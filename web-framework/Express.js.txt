What is the standard web application backend framework for Node.js these days, is it Koa? As I understand it express is quite dated because of the callback structure.I have been confused recently with the moving best practices. What is the server architecture Next.js is most often plugged into?
Who cares how old something is, if it works well, why not use it? You can easily avoid callback-hell by making the callback you pass in to expressjs async and use await inside of it, without much drawbacks. Just because the first closure into express is a callback doesn't mean you need to use callbacks everywhere, just use await/generators/whatever you want in your application code.expressjs at this point is battle-tested, minimal, easy to understand (both in usage and internals) and have a huge community still. It's very mature and does what it does well.
I haven't used Express in ten years, but imo `async (req, res, next) => ...` would mainly be attractive if failure was automatically handled and you could `await next()` to post-process the response. Though it would still help you write async code inside that route.Since iirc you send responses directly from handlers in Express, I'm not sure the latter is possible even with express-promise-router since you basically need downstream routes/middleware to return a Response object rather than send it directly.I think Express is never going to unify with Koa's direction since it's just too disruptive to Express' ecosystem (the v5.x branch is stale) which is probably for the best.
The big problem is Express code like the following will either hang the HTTP requestforever(--unhandled-rejections=warn), until the client times out and gives up, or crash your whole server, taking down any other HTTP requests in progress (--unhandled-rejections=throw):const db = {
    async getUsers() {
      throw new Error("failed to connect to database");
    },
  };

  app.get("/", async (req, res) => {
    const result = await db.getUsers();
    return result;
  });There are various monkey patches/wrappers you can use to make async errors work the same as sync errors, but it is easy to forget and hard to understand, especially for newbies. Many other frameworks handle async/sync errors in a more consistent way.
Already fixed in Express 5 (which is technically still in beta, but that just seems to be the maintainer beingveryconservative about a major release):https://expressjs.com/en/guide/error-handling.html> Starting with Express 5, route handlers and middleware that return a Promise will call next(value) automatically when they reject or throw an error. For example:> app.get('/user/:id', async (req, res, next) => { const user = await getUserById(req.params.id); res.send(user) })> If getUserById throws an error or rejects, next will be called with either the thrown error or the rejected value. If no rejected value is provided, next will be called with a default Error object provided by the Express router.
> which is technically still in beta, but that just seems to be the maintainer being very conservative about a major releaseThere hasn't been a new beta in a long time. Last release about a year ago and then the 1 before that about 3 years ago. Not a very convincing beta.
I'm not sure whether you mean "not very convincing" in the sense of "not reassuring that it works" or something else, but judging from users' comments on this issue about the release plans, it seems to work just fine:https://github.com/expressjs/express/issues/4920The maintainer said this three months ago in a comment on that issue:> Express 5 is pretty much completed at this point, and we're just finishing up the last code merges in upstream modules in order to bump the dependencies finally in the 5.0 branch.
> It's very mature and does what it does well.Is it? It performs slower than e.g. Fastify. Don't see how that's doing well.> Who cares how old something is, if it works well, why not use it?It doesn't. That's the whole point. Software is always evolving and I doubt it's even close to complete. There hasn't been meaningful updates to Express in a long time. Why do people use it and/or promote it as a standard?
> Is it? It performs slower than e.g. Fastify. Don't see how that's doing well.It's such a marginal difference when you consider real-life applications built with either express or Fastify though. Seldom is the actual bottleneck which HTTP library you use (unless you're at a really, really, really big scale), and more about how you structure your code, database and general architecture. I can count on one hand the number of times I've had to care deeply about the HTTP stack in order to optimize something, while I've probably had to optimize 100s of web products over the years, all done without touching the HTTP parts at all.> It doesn't. That's the whole point. Software is always evolving and I doubt it's even close to complete. There hasn't been meaningful updates to Express in a long time. Why do people use it and/or promote it as a standard?How to handle HTTP requests kind of doesn't. HTTP 1.1 continues to work, and will continue to be sufficient for at least 90% of all the use cases on the web for a long time.I know that the JS community generally suffers from "If it hasn't been updated in the last year, it's probably broken and not modern enough" syndrome, but some software actually end up being "finished" and good enough for the task at hand. What improvements could you actually add to express without breaking the API interface that millions of applications depend on? Sometimes stability is wanted and needed, and that's how you get mature software. Who wants to rewrite their application and architecture every time some library you happen to use decides to "improve" it?
> There hasn't been meaningful updates to Express in a long time.Because for the most part - it doesn't need them.Can you build a better express?  Maybe.  Lots of folks are trying that still, and you're welcome to use the tooling they put out.Is express dead?  Hell no.Express is well documented, well supported, getting security patches, and comes up entirely clean for a new install (including most of the optional packages you might add).Express has some sharp edges (it's been mentioned plenty above, but mainly because the framework predates the wide adoption of native promises in the JS space), but again, they're well known and relatively straight forward to work around.---Long story short, this:> It doesn't. That's the whole point. Software is always evolving and I doubt it's even close to complete. There hasn't been meaningful updates to Express in a long time. Why do people use it and/or promote it as a standard?Is an ignorant take.  People promote it because it's a good tool.Next you'll be telling me that I shouldn't use Bash because Bash 5.0 came out in 2018 and only got two minor point releases over the next 5 years.  But that sounds dumb, huh?
> Next you'll be telling me that I shouldn't use Bash because Bash 5.0 came out in 2018 and only got two minor point releases over the next 5 years. But that sounds dumb, huh?What's dumb is not being able to tell the difference. It's not about the numbers.https://git.savannah.gnu.org/cgit/bash.git/shows there are constant updates. Things are being worked on. Your example proves my whole point. There are updates every year for many years.Express? Not so. There are many gaps in its history. And for a tool like Express that has way more surface area it is in need of a lot more testing and updating e.g. if NodeJs changes something it breaks.Does Bash need to make sure it works with HTTP3, Brotli or many other things that came out? No.> Because for the most part - it doesn't need them.Right, let's go back to the Stone Age. You don't need clothes either - just a leaf. You're just so dismissive on innovation then why bother? You don't even need NodeJs. Back to assembly and punch cards...> Is an ignorant take.Yes, yours. As shown above by your example.> People promote it because it's a good tool.And how do you know that? Where are the stats? Or people just google for NodeJs server, see the top response being Express and just do that. The cycle then repeats. Have people promoting it actually benchmarked, compared and investigated all the tools before making this informed decision? I'm sure you've heard from each and everyone 1 of them to know the answer eh.
> You can easily avoid callback-hell by making the callback you pass in to expressjs async and use await inside of it, without much drawbacks.I thought this was slightly awkward due to error handling, but it looks like Express 5 (in beta) supports async callbacks natively.
I'm sorry to point out that the first 5.0 alpha came out in 2014 and still hasn't been released. When people talk about the ecosystem/battle-tested-ness/quality of express I think that unfortunately doesn't extend to anything other than the latest major on npm. It's not "modern" but it's still a good tool.
Express is still fine to use. To me it's either express or fastify. A lot of opinions in the JS world.
This. Fastify is so great. Unfortunately, the documentation became worse after v2 because Matteo was too laissez-faire in approving new doc contributions.Imo the docs need a major re-write, beginning at "getting started". New users don't know whether they should use "fastify-cli gen", "npm init fastify" or copy manually from the "getting started"-guide.And people also tried to push their fastify-plugins to the top of the plugins-site by adding a "@username" for every plugin:https://i.imgur.com/hHyI6JO.png(left are the old docs, right are the current docs where ppl try to game the system).Also, fastify-cli needs to rework the custom options in typescript projects imo.Ok, that's all. Other than that, fastify rocks!
You can get pretty far with Next API routes as a replacement for a seperate Express backend.https://nextjs.org/docs/api-routes/introduction
I’ve been using this and deploying straight to vercel (where they run as serverless functions.)  Took some obscure googling to get things like sequelize to work, not overall it seems to work pretty great.  However I would like to be able to control the resources (e.g. adding more cpu etc) and haven’t yet found a way to do so.
You can configure some knobs, like `memory` and `maxDuration`:https://vercel.com/docs/concepts/projects/project-configurat...
I've used Koa in my last few work projects but will be either switching back to Express or moving onto Fastify for the next one. Like you mentioned, Koa does indeed feel dated. It's community never really took off, either; many of it's most popular helper/companion libraries haven't been updated in years.
I still use Koa out of habit since it was the only framework for a while that had first-class promise support.One thing nice about Koa is that it's simple, so it's timeless in that way—it's not a moving target nor does it try to do something that needs a lot of core maintainers.
Yes, whole koa is like what 400 LoC?
In the past 3 years I've built 4 apps (1 mid-size, 3 small-mid) using Apollo and IMO it's currently the best possible approach. I did a research for my latest app a half year ago looking for sensible alternatives and didn't really find any.
For anything CRUD or that can be modeled as such, I use FeathersJS (https://feathersjs.com/). 
Real time updates are basically free, db integration is easy and adaptable. The service-oriented architecture with hooks just feels like a very natural way to think about an application.They recently pushed their long awaited v5 update, which adds a Koa transport alongside the historic express transport, and improves the "code reuse between client & server" story for schemas/models/types.
The standard is express. I say that with some glibness, but its the only true answer: a ton of the other higher level frameworks and pluggable middlewares still rely on the core express Request/Response types. And there are a ton of higher level frameworks, if the number of distinct replies wasn't obvious.I really like express + routing-controllers [1], if you're on typescript.[1]https://github.com/typestack/routing-controllers
Koa's great, and I use it for just about every server. It's simple, fast, supports async middleware great, and has a big middleware ecosystem.
Many actively developed backend/backend for frontend frameworks like NestJS, Apollo Server, tRPC, GraphQL Yoga, etc. offer an additional layer of abstraction that typically relies on ExpressJS (or at least offer building on top of it) when deployed against Node.js, but they allow for deployment to other targets like serverless
I think it doesn't matter that much anymore.Express was really cool and different from what was out there at the time (at least in terms of simplicity and JS support).But nowadays there's not a lot of difference between them. Sure, some are more ergonomic than others in certain areas but the patterns are almost the same in all of them.
When standing up a server I reach for fastify.The only exception is when I’m working inside an established Node shop where they already have a prolific framework, I’ll reach for what they already have in that case to avoid fragmenting their stack. Almost always, that’s express.fastify is performant, thoughtfully designed, and well architected.
Callbacks in JS aren't really  dated, just many of the patterns associated with them are. The Promise constructor itself takes two callbacks as its arguments. Async/await are just syntax sugar over that constructor. Express supports promise-based mw callbacks just fine.So I'd still say Express is the main choice. Personally I've never loved the Express API as it encourages a lot of heavy mutation (Koa does too), so I tend to be on the lookout for good alternatives - I haven't seen any that seem to be sticking (gaining significant enough community to bet on) more than Express.There's a few things like Next/SvelteKit that cover all bases in one, from your web app backend -> SSR frontend -> client states, but if you're looking at pure backend for e.g. an API, Express is still going strong.
I’m a fan of hyper-express, built on top of uWebSockets with an api similar to express -https://github.com/kartikk221/hyper-express
Express. Same as it’s  ben for a decade.
I created Server.jshttps://serverjs.io/and still use it. It is a wrapper around express:- With a bunch of middleware included and pre-configured, like body-parser, cookies, Helmet, etc. All express middleware works with Server.js- async/await routers as expected: get('/users', async (ctx) => {...});   (ctx inspired by Koa)- Websockets, where messages behave just as another route: socket('message', async ctx => { ... });
Koa works great. The nicest part is that you don't feel like you're fighting Typescript when you use it, if you use static types.
I've used this -https://adonisjs.com/- I don't think it's "standard". Is there such a thing? I guess Express was a de-facto standard. I'm a bit biased since I come from Laravel background, so adonis feels familiar.
Express (fka Connect) is standard in the sense that the "middleware" API design was/is part of the CommonJs server-side JavaScript (SSJS) initiative [1] from which Node.js originated and insofar as you can write a middleware that plugs into Node.js' core http API and express.js at the same time since these invoke your code using the same basic callback, which was deemed desirable for portability back when Node.js wasn't the only SSJS framework around. Express/connect draws inspiration from Ruby's Sinatra/Rack and Python's WSGI, and is based on JSGI/JackJs.[1]:https://wiki.commonjs.org
fastify https://www.fastify.io/
  nest.js https://nestjs.com/
  hapi.dev https://hapi.dev/All are better than express.js. It is annoying that express is still go to for many where its ecosystem is pretty dead.
You can use this small lib for expressjshttps://github.com/express-promise-router/express-promise-ro...
Adding to this, these days,  what's a complete nodejs MVC web framework that allows for easy integration of something like server-sided React for the front-end?
Lack of async support in middleware makes Express a non starter these days. Koa, Fastify, AdonisJS, Hapi, Nest are all great.
Express + typescript. Simple. Powerful. Battle-tested.
I personally hate the TS bindings.
That's one of the reasons that drove me to create Phero:https://phero.dev
I just use the Node APIs with TypeScript.
I can't tell how this has actually improved upon existing options like Koa. This reeks of object oriented programming just for the sake of object oriented programming.
The idea was to use the same paradigmes and practices as the Angular framework.It's nice to have consistency between backend and frontend, but it is indeed a bit heavy and really not necessary most of the time.
Odd. Most people I know are trying to avoid OOP, particularly in the JS community.
NestJs is for people to write Java whilst pretending to not use Java. Should have been called SpringJs.
I’m working on a moderately large-scale Nest.js project and deeply dig it, but I don't really see a lot of peopletalkingabout it, which gives me concern.Glad to hear you say that, though, maybe I’m just out of the loop.
I have also started using it pretty recently, and haven't had too much issue finding folks talking about any issues I've run into (and either found fixes for my issue, or at least workarounds while folks are currently working on fixes).However, it still by default uses Express under the hood, though you can change that to Fastify or whatever else you like.
I'm using it for my side project, a highly productive framework; I can also say it's in use in some _very_ large corporations, although I cannot give details about that.
Not sure why this is downvoted, Fastify is quite popular and the 'generator for everything' approach of Koa didn't really take off.Architect serverless (https://arc.codes) is pretty good for serverless.
