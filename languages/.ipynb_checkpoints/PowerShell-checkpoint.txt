Powershell does indeed have a baroque syntax, so I get why some folks find it clunky.
But once you glom onto everything-is-an-object, and quit trying to handle output as strings, the sheer power is a rush.
Couldn't live at work without it.
Baroque or not, its syntax has the gigantic advantage of being consistent, as it has been thought before being implemented. Where coding in Bash has always felt to me an extraordinary collection of hacks (each command has its own syntax, spacing is sometimes important, sometimes not, recursion is -r for this command and -R for that other one, etc.)
That being said, if you're used to Bash, Powershell is too heavy. If you're into Powershell, Bash is clunky. Horses for courses...
Once everything-is-an-object clicks it makes things sooo much easier. Between Powershell and Python I honestly have trouble going back and remembering how I did string parsing in bash these days.
I think a lot of the more traditional linux shell scripters have trouble flipping that switch in their heads and it leads to hating it.
Yes
I just don't like my job
Can you be more descriptive about your issues with it? I work primarily in Linux systems, I only learned Powershell from my time in Windows environments years back. Powershell blows most scripting languages out of the water imo. The two main improvements being the ability to pass entire objects down a pipe and being able to directly embed .NET code. There isn't anything native to the Linux world that provides that kind of functionality.
Perhaps you just don't like the aspects that involve working with Windows APIs?
the ability to pass entire objects down a pipe and being able to directly embed .NET code.
When I discovered that it blew my mind!  I can't remember what the exact issue was and it was probably down to bad practice on my part but I seem to remember I was having horrendous performance problems appending objects to very large arrays.  I found a solution that online that used a c# code snippet in Powershell which improved performance by orders of magnitude.
I was going to reply something in this sentiment, learned to script in Linux, although with some issues getting used to the syntax, power shell is very good and versatile.
Honestly, Powershell is one of the few tech items that I really, really do.  I love Powershell, it's enormously powerful and flexible.
Yes. Love it.
Are there things that could be improved? Sure, but I love it.
Fully agreed.  I've made software maintenance and reporting solutions, user-facing kiosk apps, integration modules for REST APIs, systems maintenance toolsets... The amount and variety of solutions I've authored that are 100% Powershell is frankly ridiculous.
Definitely don't get me wrong. It's not always the BEST solution for the job.  But it's often good enough that the startup time of learning a new technology isn't worth it.
Not only that, but with a little .NET know-how, if Powershell can't do what you want, you can probably cobble together something in, say, C#, that you can load/import that can bridge the gap.  I build pretty much everything on Windows in Powershell and (almost always) C# for this reason.
I agree. I use PowerShell about everyday to process large amounts of data (CSVs). Excel formulas work for a lot of things but sometimes it can't do exactly what you need.
My brother and I have also developed PS modules for both ServiceNow (Tickets) and Tenable (Vulnerability Management). Once you learn the command line, you never want to use a GUI again üòé
Got a link to these modules? üòÄ
Yeah I'll drop a link to the SNOW module at the bottom. Fair warning though, we started this module when we were still pretty amateur so it's not the most beautiful code ever haha
I've been working on this repo whenever I have free time and that is rare lately. I eventually want to beautify my code and add all the extra features such as Get-Help and extra comments. I also want to make it as dynamic as possible so ANYONE can use it. It's a work in progress (Just recently added username/password authentication)...we use smart cards at work.
The main reason we started this module was because we were denied access to the official ServiceNow API so we based this module on the JSONv2 Web Service which requires NO EXTRA PERMISSIONS except for the "ITIL" user role (Basically, if you can create and view tickets, it should work.)https://docs.servicenow.com/bundle/tokyo-application-development/page/integrate/inbound-other-web-services/concept/c_JSONv2WebService.html
If you're good with PowerShell and SNOW, feel free to help out with the module on GitHub!https://github.com/SleepyNinja0o/ServiceNowPS
That you can write c# types and add them directly in your scripts is amazing to me.
I'm going the other way currently (from Powershell to Bash) and while they do both provide a shell with a pipeline and scripting functionality, that's just about where the similarities end.
I will say though, Linux is an absolute assassin when it comes to sorting and manipulating text.
This weirdly is PowerShell's biggest problem, it's core text tools are really basic even compared to something ancient like awk.  PS wizards can do almost anything in it but something like search/replace in files should be a high-level cmdlet
So incredibly underrated.
So far I have:
Monitoring scripts that parse and display key metrics from log files.
Upgrade scripts.  Includes pre-staging, handling sql backups, toggling websites and services, preserves customizations, etc...
Distribution list reconciliation and updates (scan database and update a sendgrid marketing list).
Lots of API interfacing.  Powershell and REST API play very nice together.
An ETL process.
Oh and this week I'm hoping to fork lift an entire QA project (about 6,000 tests) from one location to another.
Came from a Linux background as well, by far the concept of objects was my biggest ah ha moment. The fact that what you see on the screen is only the system displaying some of the properties, and when you pipe that output, you are passing the original object and not what was displayed on the screen.
My other thing was the full parameter names, I felt that they made commands excessively long and I liked the simple one letter switches that Linux used. This grew on me slowly, I kinda just accepted it and with tab completion, it wasn't that much more typing. The moment it really hit me was when switching back to a bash script after being primarily PowerShell for several years. I had to read the manpage to interpret all of those one letter switches.
Posts that link to a product for sale are not allowed. Products that are free, such as open-source products or products with free/community licensing  are allowed.
Only post helpful or constructively critical content.
Posts need to be in English.
Title your posts with specific information, such as error messages, behaviors or questions being asked. Low effort posts and titles will be removed.
When posting scripts, asking for help, or starting a discussion, post whatever PowerShell code you have created so far.
https://www.reddit.com/wiki/markdown
Use a tab or 4 spaces on each line to post preformatted text in markdown.
Posts from either employment seekers or job recruiters are not allowed.
Links to images or URL shorteners will be automatically removed.
If you post a malicious script, ‚Äúeven if you ran it accidently,‚Äù you will be banned immediately.
This seems less about Powershell and more about your career path. If you want to branch out of Microsoft environments, then yeah, you're not gonna need Powershell as much.
However, it is still very much relevant and the best solution for anything Azure/Windows/Intune/M365 (in my opinion)
This is the sentiment I've seen in industry.
This sounds like a pipeline preference.  You gotta pick the tool for the job.  A big PowerShell script to configure servers is a better job with Ansible.  It can use parts of PowerShell for odd things.  But yah, PS in a dominant windows shop is a good step stone to other things like Puppet or Ansible to config managements. PowerShell for task work.
PowerShell is being developed to work across a ton of platforms, OP could continue to maintain the same experience if they wanted to.
Then again, there‚Äôs always Bash or Python
In your resume, list powershell under your skills section, everywhere else, replace it with ‚Äòscripted‚Äô/automated tooling‚Äô
Ie skills: windows, sql, devops, python, powershell. Experience: I deployed 1000 servers via script. I automated updates using automation tooling.
This way you can say the same things, without the MS bend.
I‚Äôll also say everyone seems to love python these days. Universities teach it early in their curriculum. Python is not necessarily better, but it‚Äôs so common that you need to know it.
PowerShell is simply almost completely unknown outside of windows-related administration jobs. I've gotten all the same reactions as you mentioned a number of times in my company.
The thing is, if you ask any team about any language or toolset they aren't aware of and that isn't hyped, they will give you a dumbfounded response. It's not just PowerShell. You could have done all your projects in Haskell and probably received a similarly lukewarm or speculative response. However, add in the Microsoft branding, and not a few people will be downright adamant about avoiding PowerShell.
Nevertheless, even without a professional application, I still use pwsh as my exclusive shell. It's the first and almost always the last stop for any interactive use cases I have. I develop modules to improve my workflow, and I offer it to teammates when they are lacking some functionality. Some of them acknowledge it's faster, but they are comfortable with their workflows and don't want to integrate new tools. I don't mind. It is time intensive for me, but it's a hobby that I enjoy; it's a language I like coding in.
So maybe the problem is tying PowerShell to your primary job. A lot of jobs simply don't have PowerShell in the job description. But in IT you need to be versatile. Explore new languages and frameworks, but it doesn't mean you need to abandon PowerShell in your personal workflow tools. I just wouldn't rely on evangelizing others or expect their approval when they know nothing about the language and have no professional requirement to familiarize themselves with it.
Ansible and Terraform have their place for OS & Infra Config. It unlocks the ability to have the infra as code. I use TF heavily on managing cloud infra. Its simpler and cleaner than making imperative code. Rarely, if at all do you see Powershell DSC in action in this space.
Powershell is in demand but you are looking at the wrong industry. DevOps leans Linux heavy. Its often based around infra for apps made for developers that are built on linux servers, containers and k8s clusters. Guess what they love and guess who they hate? So all those pipelines the code for 'massaging' betwen steps are usually bash with a community that has a distain for Microsoft.
I have a weird job where I am an engineer making pipelines but also work for the global admin teams for any automation work (that owns the identity, 365, etc). Guess what manages the rest of Azure? Powershell. I have made over 100 scripts in the last few years doing all sorts of things using powershell in this space. Alerts, Reports, Validating automations, automating random small tasks (like function apps using pwsh assigning tags at resource creation), creating identities, managing sharepoint, monitoring infra things from Defender & Sentinel, doing exchange stuff, etc.
Any resource deployment is terraform. I use bash in my the pipelines for my team since they all use it (would rather do Powershell) so we can all work on the same pipelines.
Applications are just one element of Azure, dont get stuck on what people in that space live by.
The thing that drives me nuts is the love for bash.
Ansible, terraform, pulumi are all wonderful tools. Python is incredible.
But bash? No one would argue it's capabilities but using them ispainful. It is trivial in PowerShell to glue together output from NetApp and vCenter into a preformatted Excel report. Even something as simple as parsing output from ldapsearch in bash devolves into a struggle session with awk and xargs that has me questioning my life choices.
I get the value of living off the land, but there's so much love for bash and hate for PowerShell that it looks a lot like Stockholm syndrome.
Powershell might not be as relevant, but your ability to create custom scripts and utilities totally is.  I would say don't sell yourself as a powershell expert, sell yourself as a systems integration engineer, or deployment manager (Whatever your strengths are; I'm not advocating bullshitting anyone.).  Also keep in mind that any place that hires is going to want you to learn their system before you reinvent the wheel.  How would you feel if someone came into your shop and wanted to rewrite every powershell script into Automate pro because they used it at their last shop?
The thing I love about powershell is I can spin up a utility in a few minutes flat that is useful to devops.  Either generating reports or creating templates.  Anything you write in powershell can be converted to C# .NET code with minimal effort.  If you're really worried, I'd spend some time learning Typescript.  Microsoft is moving towards that in a lot of their automation systems.
Anecdotally, personally, last job I was hired for they cared a lot more about the number of servers I managed and the uptimes, and a lot less about the tools I used to get there.  I mentioned Powershell during the interview and they saw that as a bonus, but not the reason to hire me.  A history of scaling and maintaining infrastructure is why they hired me.
Powershell is the best tool for managing windows and MS365 in bulk.
But for some specific tasks, there are better tools, in that they don't require the depth of knowledge PS often does to do some intricate things.
Is it a waste of your time?
Many of us live by this quote:
"Never spend 6 minutes doing something by hand when you can spend 6 hours failing to automate it"
This is how I live my life. Six hours of tinkering with Powershell? Sign me up.
Exactly!
Do it manually more the once!? No way I'll script it!
Ever since I saw the comic, I always askIs it worth the time?
That said, the answer is very often "yes". LOL
Yay the script works for the next time...
2 months later: I thought I had a script for this where did it go...
3 days after that: I really need to organize my repository better
2 days later: <postToReddit> Hey guys how do you keep your scripts organized?'
1 week later: ohh look there it is
If you are going to admin in windows shops then yes powershell is a critical skill
Start with "Powershell in a Month of Lunches" and go from there
There is also thePowershell Master Class on YT,  though I have not personally watched it is seems to be highly recommended
More than just windows though. You must get proficient if you want to manage exchange or 0365/azure.
Depends on what I'm doing and if it's something highly repeatable. Day to day I honestly don't need do a huge amount with powershell. But if something comes up over a weeks period where I have to do the same task repeatedly I will look at getting it into powershell.
Various widely between roles/companies in my opinion also "powershell" is a very wide topic.
"PowerShell is king" is the motto my department lives by.
If you can do something in the GUI, you can do it through PowerShell only faster and with greater reach. Need to add or remove something on 1000+ machines? Use Powershell! Need to do a lot of tedious edits to Active Directory? Use Powershell!
The downside of PowerShell is if you're not careful it increases the surface area in which you can make mistakes. Always test and verify that your script does exactly what you want so you don't get any surprises when you run it en masse.
I use Powershell constantly. Any admin who tells you Powershell is a waste of time is likely only saying that because they haven‚Äôt taken the time to actually learn how to use it properly, so every time they try to use it, it feels like a waste of time. Powershell is a godsend to Windows admins, and should be at the top of your list of things to learn.
I like PowerShell a lot more than bash, but it's got so much weird jank. String escaping gets pathological when passing arguments to cmd, or bash, or worse, both, which happens more than you'd think (looking at you, Azure CLI), and there's no good way to pipe raw bytes around (like, say, when you want to checkout a binary file from git). There's no real need to differentiate between HashTables and Objects, but it does, and it bites you at random times. IMO, they would have been better off dropping the < and > piping operators, leaving them as | Out-File and Get-Content | and then used the arrows for less than and greater than, and used == as equal to, instead of the -lt -gt -eq nonsense.
> and there's no good way to pipe raw bytes around (like, say, when you want to checkout a binary file from git).Since pwsh 7.4 it can natively pipe the raw bytes between two external binaries and also when redirecting to a file. Sucks it took until then to get it but it's now there.
Yeah this my main complaint with Powershell -- Microsoft had one opportunity to build a new shell for the ages and decided to use Bash for syntax inspiration.  It could have been so much better and now we're stuck with it forever.
Powershell feels a lot like Microsoft wanted to appeal to *nix users, especially system administrators, without really understanding them, presumably because DÃ∂aÃ∂vÃ∂eÃ∂ Ã∂CÃ∂uÃ∂tÃ∂lÃ∂eÃ∂rÃ∂ Ã∂sÃ∂hÃ∂oÃ∂tÃ∂ Ã∂tÃ∂hÃ∂eÃ∂mÃ∂ Ã∂oÃ∂nÃ∂ Ã∂sÃ∂iÃ∂gÃ∂hÃ∂tÃ∂ Microsoft's way of doing things was and is considerably different. As a result, it hadn't really occurred to them that much of bash's weirdness and flakiness is historical, not simply because *nix users prefer it that way.The end result was still a much better language than bash, of course, but that's a very low bar.
It was actually inspired by Perl as much as Bash if you read one of the asides in the O'Reilly book written by one of PS's developers lol.
I rather nushell for this purpose, it's more fun to write and easier to read.https://www.nushell.sh/
This is what I've moved to lately. I like the idea of structured data but PowerShell just feels like a shell designed by people who don't really want to use a shell.
Id posit thats exactly what they want. I started my career using 100% Linux-based tooling and slowly moved into Windows land - I have not ever liked Bash, only tolerate Fish, love Powershell. Ironically I think its biggest limitations are Windows‚Äô fault. They want to latch on to the old point and click guard.
No deb package though
I think you mean ‚Äúprefer‚Äù and not ‚Äúrather‚Äù.
.. or (s)he forgot the word "use". Maybe we'll never know.
You're right, I forgot "use". And I would change "I" to "I'd" if I could still edit.
I like the idea of PowerShell, but my constant lamentation is that it doesn't go deep enough to be considered a true shell. Many of the things that I lean specifically on bash or ksh or cmd.exe or yori.exe for ultimately lead to breaking into C#. PowerShell makes them painful.In my mind, it competes more with Python than Bourne shell: it's a scripting language that only tenuously gives you a DSL for interacting with processes and the streams between them.
PowerShell is great -- but there are some things you simply cannot do with it. For example, try to escape '$', which can be included in urls but can't be used in Invoke-RestMethod.Bash via WSL saves the day, in this regard (e.g.: $results = wsl ./myAwesomeBashScript.sh).While PowerShell is great as object-oriented scripting, it still can't handle simple tasks that can be done in the likes of bash, zsh, etc.
To escape $ you either need to use a single quoted string so the $ is treated literally or in a double quoted string use a backtick before the $ to escape itWrite-Host 'Foo$Bar'
    Write-Host "Foo`$Bar"
A lot of people's complaints in this thread are because they just haven't figured out the powershell way of doing that thing.Granted - the Powershell way of doing some things is stupidly obtuse sometimes.
In the issue I ran into, the '$' comes back from Azure in the nextLink[1] value. As soon as you try to process the string, the reserved token '$' breaks any processing - precisely because it wasn't escaped before being stored.Perhaps, it's easy enough to do some .NET manipulation, just to get PowerShell to be able to handle the string for the next Invoke-RestMethod -- but its far easier to just curl those urls, instead.[1] -https://learn.microsoft.com/en-us/rest/api/keyvault/keyvault...
I'm a huge fan of powershell, especially for build scripts and other things that get complicated sometimes. Parsing XML and JSON, calling web APIs and dealing with their responses are all about as easy as they can be.The article covers all the main (minor) bugbears.
Microsoft is driving fragmentation with Powershell. It doesn‚Äôt really matter if it‚Äôs better than bash or not. Bash is good enough for most use cases. Yet e.g. so many of their examples for using cloud apis are in powershell, which instantly alienates everyone who doesn‚Äôt want to commit learning a redundant tool.It expresses an arrogance and disregard for their users and makes a group of people just walk away from it. That‚Äôs totally unnecessary.
Either i overread it or one major quirk is totally not touched on: PowerShell is case-insensitive in as many places as possible, except file paths or the likes.You can actually call .NET methods with completely nuts casing: "asdfg".tOupPer() works.Also variable names with only different cases resolve the same, i.e. $var is the same variable as $Var.String comparison with PowerShell operators is case-insensitive and it has special operators to match case sensitivity. RegEx operators behave the same way. Using the .NET methods however conserves case-sensitivity.I enjoy using PowerShell a lot. In many of places for scripting processes (Windows server adminisitration) it has an easier entry point than Python. And handling complex objects is kind of trivial. The Windows PowerShell really shows its age by now though and I hope the new PowerShell will be included by default, too.
Powershell's fatal flaw is size.The Debian dash POSIX shell can compile under 100k on i386.This is a space where Powershell can never be.
Do you actually care about this?
Not OP, but I do. In principle it shouldn't really matter what the size of the binary is, but a large binary relative to peers in the program's category usually reflects complexity and bloat. Powershell feels sluggish and unresponsive to me relative to fish, bash or zsh (the three shells I've used most). I was so put off by the feel of powershell five or so years ago that I haven't used it since then. For that reason though, I will concede it's possible it's better now but I'd be pretty surprised given Microsoft's track record.
I care about dash because when I write for it, I write for them all.The speed and economy of size are a side effect.
I don't understand. How does the size of an application change how you write code?
And slowness, which might be related to the size. I was using PowerShell for months and loved it, until one day I needed to start fish shell and it felt amazing, the experience was just so lag-free compared to PowerShell. I didn't notice it while using PowerShell but after that I could never change back. Also shell startup speed felt quite meaningless before but after getting used to few second startup delay with PowerShell, it was so nice to just open terminal and start typing instead.
> Powershell's fatal flaw is size.I wonder how big PowerShell would be if it was reimplemented in WinRT instead of .NET
Windows is already bloated to high hell. Being concerned about powershell's size feels like rearranging deck chairs on the titanic.
PowerShell exists on other platforms
why in god's heavenly image would you use powershell anywhere but windows
I use it on other platforms so I can use the same scripts no matter where I'm developing. Also github ci
For the same reason one would use Python, Ruby, Perl on Windows, outside UNIX.Portable scripts.
powershell is a 440k executable on my machine.  functionally, it's much more capable than dash.  I don't think powershell is even remotely interested in competing in whatever space you are in.
PowerShell also needs all the other dll's located next to the executable so it's way more than 440k. Granted I agree that this isn't a space they really care about and the problem is more due to the dependency on .NET itself.
Well, I assumed the 100K dash shell also was dynamically linked (presumably to libc and the linker loader).  But yes, you're right, I wasn't including all the DLLs and all the various modules/scripts you can invoke. from my inspection, it looks like DLLs that are probably already loaded just by booting a system.
It's more for pwsh (7+) as that bundles it's own copy of the .NET runtime. The powershell.exe (5.1) is the version included in Windows and uses a shared copy of the .NET Framework included in the GAC. When looking at the size of modern PowerShell (7+) you do need to take into consideration the size of the .NET runtime which is quite sizeable. Personally it's not a problem for me and while I don't agree it's a fatal flaw it's certainly a downside compared to other shells.
I doubt anyone is using PowerShell on Arduinos.
Ever since Microsoft decided with Microsoft Graph that ‚Äúeverything is a string‚Äù and ‚ÄúEverything is a REST API call‚Äù PowerShell has honestly seemed dumber and dumber to me.  It‚Äôs great at manipulating Win32 stuff and pretty much perfect for that task sure but it‚Äôs in a weird place now since Bash and friends were always better for simple string manipulation tasks.Backticks for line continuations was also a satanic decision, even knowing of the myriad alternatives to them in PoSH.
I'm still holding out for a Tcl port to the CLR (StrongTcl? IronTcl? Tcl#?) for exactly this reason.
There is Eagle:https://eagle.to(never used it, just aware of its existence)
Oh, this looks like a real gem. Thank you for making my day today.
As someone that was in a startup built on top of Tcl during the dotcom wave, I doubt Tcl is coming back as it was back in 2000.
Why is world not in the hashset? Even gptchat4 doesn't know and thinks it could be because of out-null, and i should try without it. Anyone?
I mainly use Python to work with typical shell functions and external programs. I contend that Python and other similar languages are superior to PowerShell.
I have tried many, many times to work with posh. I was even a very senior windows engineer at some of the largest webhosts when it came out and used it heavily because the fantastic Windows Server operating system comes with literally no tools any bsd/nix engineer expects, you know, like rdp brute force detection blockers to actually manage servers, or .. my gosh, IIS URL REWRITES. BFD isn't "baked in" to linux but nobody is hiding their secret sauce so every company has to roll their own vs pulling a package from apt for bfd, etc. Here's your $expensive$ Windows Service license, now spend $20k in dev hours for someone to write a powershell script that monitors eventvwr for failed rdp event errors, extract the ingress ip into a db and block across the board.I remember being fascinated by its history because the main guy wrote it, Jeffrey Snover, I'm going to butcher this, but IIRC he was some sort of big posix/shell/bash/perl/something-very-shell-important and wanted to take the best of whatever systems he was familiar/contributed/wrote and improve them and make that powershell.Anyway, yeah I absolutely despise using it. It's syntax is atrocious. It's key words aren't memorable in the least. I know some people absolutely love it, even people who aren't using it in Windows. But it's never clicked for me.I found this thread interesting. I guess Snover left MS after 23 years there in 2022, and he was demoted at some point after creating powershell. I don't care enough about it to dig into why but if anyone is interested-https://news.ycombinator.com/item?id=31302174I did windows engineering at the biggest webhosts you know, RAX, HG, etc. Being a Windows Eng in webhosting is incredibly uncommon. Prior to that and post I'm back as a bsd/linux engineer (distsys/sre now) and the Windows Server ecosystem is absolutely abysmal if you aren't in it for Exchange, MSSQL, or whatever random Windows-Only app your company uses. I supported that trash from server 2000 - 2012 r2.Never again.
Honestly bash would be fine if the control structure syntax was a bit more sane.(... and set -euo pipefail was default). Bash scripts can be tiny for what they do, and the ssh integration is unmatched.xonsh is nice but it's been unstable for me lately.nushell is nice but not sure if it's worth switching the default for.
Cool, but it still can't properly autocomplete anything so I'll try to get that working first
Unfortunately, all the PhDs at Microsoft were moved to AI projects.
It ships with PSReadline now which gives it bash like autocomplete.
Is it something to install separately ? Or I need to upgrade  something ? I never got it to auto complete anything to be honest
It's been shipped with PowerShell since v5.1 (Windows 10/Server 2016). There have been numerous updates to PSReadLine since then to add more features but tab completion has worked for years and is IMO one of the biggest selling points.
Weird. Coming from the fish shell, I can't really get anything completed with PowerShell. Mostly, I want it to work with my git commands (detect my branches for example).
Ah if you want auto completion for native commands they need to be registered first. PSReadLine provides autocompletion support but it only works by default with things builtin to PowerShell itself. For `git` there is a fairly popular module called posh-git [1] that provides auto completion support for some of the well known commands. Git for Windows also calls it out [2]. You can also provide your own custom auto complete calls with Register-ArgumentCompleter [3]. Hope this helps![1]https://github.com/dahlbyk/posh-git[2]https://git-scm.com/book/ms/v2/Appendix-A%3A-Git-in-Other-En...[3]https://learn.microsoft.com/en-us/powershell/module/microsof...
Thanks for the help ! I will definitely set this up. But if I have to install some extension for every single command I use, it really makes the experience tedious and sub-par compared to what I'd get on Linux..
only because your linux distro is doing it for you not because bash has git completion built in.
TBH I‚Äôve despised the object oriented parts of PowerShell‚Ä¶ and it‚Äôs been my primary shell for a decade. I just mainly use it with text.
Sorta agree - I'm mostly doing string handling and parsing on windows boxes - so I often just want it to compare on a string or whatever.But sometimes the "everything is an object" is useful in ways that would be really hard to do on unix like systems.
Yeah it's pretty good! I wrote a few hundred line build script for a Windows project last month. I knew no powershell last month, and now it makes more sense to me than bash which I've used badly for 25 years.Actually on Linux I tend to use Ruby for any non-trivial scripting, and it feels much closer to that. So it's probably no coincidence that I've got on with it.
> I guess if you live in Microsoft land all day and write code in C# it's fineI write C# daily but I'm not fine with powershell syntax. It seems harder than it should be.
I always joke and PowerShell must have been created by someone who types 300 WPM ;-)
I always thought Lisp or Smalltalk might be good for a shell.
It‚Äôs weird on account of dealing with a legacy of Microsoftisms, including from cmd.exe which is why it has to use -gt as a comparison operator and not >.Batch is not nearly as flexible as PoSH although the interpreter still boots faster so I use cmd.exe all the time.
> bash syntax is similarly insaneAt least it‚Äôs terse, which is good when you‚Äôre typing commands on the fly on the command line.  PowerShell on the other hand is so unwieldy on the command line.  Even the pervasive use of case slows down typing.
With aliases, powershell can be quite terse as well, and since it's case-insensitive, you can just type everything in lowercase.
E.g. instead of the script presented in the article:(Get-ChildItem -Filter '*.txt' | ForEach-Object { $_.Length } | Measure-Object -Sum).SumYou can dols *.txt | measure -Sum Length | % Sum
> Powershell's syntax is so fucking weird and verbose.You're not wrong.  I think it's that way because of trying to increase readability.  Best practice for Powershell cmdlet development is verb-noun.Of course they throw that out the window with aliases.Examples:wget and curl both are aliases for invoke-webrequestiex is an alias for "invoke-expression" - which lets you execute a string as powershell code in your same session (note: I originally wrote scriptblock, which was incorrect - otherwise something I wrote this week wouldn't work at all, due to change of scope).  This ability gets me out of a lot of weird jams.The other thing too which makes it so weird is that it is built on top of .Net.  The overarching principle of Powershell is that it's your Windows swiss army knife.  You can access .Net classes by loading the assemblies.  I have on occasion built a small WinForms app in powershell.  You can create and invoke COM objects (new-object cmdlet).> But as a polyglot I am so sick of having to learn yet another syntax.Personally, I try to avoid "language specific sugar" when I am writing sample scripts for people (I am in a customer facing role).  But goddamn I love the shorthand way you can do a for loop in Powershell using the range operator:1..100 | % {Write-Host $_}> cmd.exe does everything I need to and batch is actually kind of flexible.OK, so you haven't really gotten to know Powershell very well if you're saying things like this.  lolScripting in batch files is like living in the dark ages.  They are "kind of flexible" whereas Powershell is "very flexible, most of the time".And that "most of the time" caveat is no longer there if you are on the latest powershell (which doesn't work with the ISE as ISE is 5.x only, and the way of the future is the universal PWSH).  My biggest gripe was fixed I think in Powershell 7, which was manipulating files with grave marks in the name.I build a lot of stuff in Powershell, as you can probably tell.  Given all the interop stuff it has, once you know how to use it all, the point where it makes sense to build it in C# is farther down the line than you might think.
I've had some great success with C# and Powershell and Copilot/ChatGPT.It writes impeccable code - but doesn't always get the question right.  I've found most of the time, even when it gets the question wrong, it turns you onto the right path forward.  Definitely has saved me a lot of time researching things.
And, presumably, I'd prompt copilot to write those things for me... from within powershell? Using what command?Generative AI can do a lot of fun things, but we're talking about a but it does not belong anywhere near an interactive shell.
on windows copilot is built into the task bar with a popout window on right side bar showing output that can work with clipboard.  You can talk to it, copy in an image or screenshot and ask for details too. if you prompt for PowerShell it gives you a code block with a copy button. (oh and also reference links to learn more... which is much nice)
I kind of see these AI tools like a superhero's toolbelt -- great, when it's on you. But one doesn't always have the luxury of internet access. It is best not to overrely on AI, or any cloud service for that matter.
if you dont have internet service and you are on a windows box, you are SOL in the first place.
This is an absolutely awful attitude. All you need to do to witness lack of internet yourself is drive a couple hours' north of San Francisco. Now imagine that a huge chunk of the world is far worse off than this.
if i was in an environment without internet, i would be using open source software.
Is there a cmdlet that will do this automatically?
> Powershell's syntax is so fucking weird and verbose.Yeah.  At a certain point it is almost impossible to internalize that complexity.As someone suggested...in the era of AI, this might not matter at all.
AI is many things, but deterministic with natural language it is not.
Windows fan here. I hate PowerShell and I'd much rather have Bash built into Windows. Things I hate about PowerShell:- You can't even run your own scripts without performing the Set-ExecutionPolicy ceremony first or signing your scripts.- It's way too verbose.- It's a strange bird that next to nobody uses, so there's zero motivation to learn it.- It's not "old reliable". You can't depend on it working due to the first point and also due to the fact that they're still working on it and even in 2016 they broke some PowerShell stuff with updates that needed to be uninstalled (KB3176934).
Literally every windows admin uses it. It's the official commandline interface for microsoft software.Every piece of microsoft software must provide a ps interface. It's an engineering directive.
It is strange to claim no one really uses powershell. It is widely used in the Windows world.The main complaint I see about powershell is that it isn't bash. The object pipeline in powershell can be so much more powerful than parsing text between commands. After all, that's why we have data types instead of storing everything in strings.
It's not widely used in the Windows world from what I can see.Walk into any office and ask an IT guy to run "ipconfig". They'll open up cmd.exe without even thinking about it.I read a lot of programming tutorials. Nobody ever reference PowerShell in them. They always instruct people to open cmd.Do you have any evidence to the contrary?
Someone else posted the evidence below.In an attempt to understand and empathize with people who do not share my opinions, I looked back through some of your post history and you said this 5 days ago:"It's never been clear to me why anyone would want to use a completely opaque and undiscoverable interface such as a commandline over a nice GUI for anything. You didn't have to read anything or search around in order to change all of those settings in the GUI."Maybe it's possible you're not familiar with people who use powershell because you tend to stick to the GUI?
That's a good point - almost everywhere I go as a consultant...their IT people use the GUI to manage things and not PowerShell.Most places that I've seen automate things with a .NET program whether it's a service, a console app run via Task Scheduler, an SSIS package and in a few cases - a desktop app.EDIT: I'm a programmer and not a sysadmin except for on my own network where I do prefer "the easy way" as opposed to the way where you have to do rote memorization to perform simple tasks. If I automate anything, it's also done with .NET or Node.js because I like the tools better and my stuff runs everywhere without performing any ceremonies. I do visit a lot of client sites though and I work with client sysadmins regularly. I'm on the East coast and I work in the NY/NJ/PA area. Also the reason I like bash better is because if I have to memorize anything (and I do, for Linux work)...I'd rather have it be something terse.
You seem to be missing the fact that powershell is just designed better. Take powershell vs bash. Bash operates primarily on strings. In powershell everything that is interacted with is an object. This wont really effect you in day to day interactions, but it is incredibly useful when you decide that you want to automate something. This combined with the fact that powershell is built on the .net framework means that there is a simple way to extend it from C#. You should give it an honest try sometime. Its not really that much more verbose in everyday practice and it has lots of tools around it that make life simpler.
https://www.powershellgallery.com/stats- 100k+ downloads of DSC resources in the last 6 weeks.https://github.com/search?l=PowerShell&q=powershell&type=Rep...- 7,600 GitHub repositories  (compared to 20,000 'shell' and 19,000 'perl')40k questions on StackOverflow tagged PowerShell, vs. 54k tagged 'Perl', 50k tagged 'shell', 76k tagged 'bash'.20k /r/powershell subscribers, 10k /r/bash subscribers on Reddit.
> Walk into any office and ask an IT guy to run "ipconfig". They'll open up cmd.exe without even thinking about it.Absolutely because of twenty years of muscle memory.But once Powershell is the default and they learn about the wonderful "gip" alias, they'll be hooked. "gip" in case people don't know is an alias for Get-NetIpConfiguration which is a more powerful version of IPConfig.PS - "gip -all" is useful. "gip -all -d" for more detailed results.
Why would I run PowerShell for ipconfig? Just do the easiest thing.Running a multi line script that does nearly anything important? Well yes I am definitely going to use PowerShell.
For simple tasks such as running a command, sure. But if that admin needs to do anything more complex, such as parsing the output of ipconfig, they're most likely going to use powershell.
Every windows admin uses it but all the admins I know don't particularly like it or fully understand it.  Theydolike what they can do with it, that they can script almost everything, and it's far better than cmd.exe but honestly the syntax and semantics are pretty baffling.There's a lot of cargo-cult copy and pasting in the powershell community.
That's all correct and it is the right way to do things (especially from Microsoft's perspective). However, the main goal of Powershell seems to be providing a scripting language that can automate Windows internals and not a shell in which you live in. Powershell is just a nice REPL, not so much a shell as you might be used from Bash.We have had Powershell for 10 years now. Has it taken off in a big way? No. The admins you mentioned use it because simple automation is the one thing GUIs cannot provide and MS had to face this after over a decade of denial.Do people get out Powershell instead of Python to do cool new projects that are unrelated to devops or admin work? Some maybe. But the real music plays somewhere else. And some of the reasons for that have been mentioned by the GP.
I wouldn't take out bash or zsh or whatever else to do a project either.   But I do use it when I want to run a bunch of cmdline tools.Right tool for the job and all...
I compared Powershell toPythonregarding projects, not Bash.It could have been
1. a shell
2. an automation tool
3. a scripting language,
yet it fails at 1., is ignored regarding 3., and only succeds at 2.
Powershell is designed for devops and admin work. I wouldn't use it for anything else.
>  Literally every windows admin uses it.And how much people with those be? Probably alot lessthat software developers in general, and non-windows admins.
I've never quite understood the concern about needing to Set-ExecutionPolicy before running scripts.In Unix, you have to chmod a+x a file before running it.
And you have to do it for every script you want to run.So to run 1 cmdlet to enable all scripts seems a bargain.
(Honestly I could be missing something and I probably am because you are not the first person to mention it.  I just can't connect the dots.)Jeffrey Snover [MSFT]
My problem with the Execution Policy is that it's useless in practice since it doesn'tactuallyprevent anything (so it annoys me every time). What was the motivation for adding it since it's not a real security feature? If it actually prevented executing stuff full stop it would be cool. The signed script concept is cool... I wish I could do that with Python.Was it just to prevent accidental script execution?
That is correct (prevent accidental script execution).It is ABSOLUTELY NOT a security mechanism.  That is why we we support this:Set-ExecutionPolicy -ExecutionPolicy BypassI wanted to make it:Set-ExecutionPolicy -ExecutionPolicy DoAnythingBecauseTExecutionPolicyIsNOTASecurityFeatureBut the team didn't like that.  (I should have overruled them on that one :-) ).Jeffrey Snover [MSFT]
I think the problem is that when you chmod a file it stays chmoded.  With the Set-ExecutionPolicy I find that I have to do it every time I start a shell.  I also run a lot of headless scripts (AWS cloud-init, services, etc.) and it's always a pain resetting everything every time.  With Unix, I know that a script is executable or not, with PS I don't.Also, I might not want every script to be executable.  With Unix I can choose which ones are executable and by whom.  With PS it's all or nothing.  :/
Yikes! - you shouldn't have to do Set-ExecutionPolicy every time you start a shell.  Something is definitely wrong there.Try doing a: Get-ExecutionPolicy -List
to see what is setting it.Then use -SCOPE on Set-ExecutionPolicy.BTW - I hear you on the "only chmod the scripts you want" - that is a nice benefit of the Unix model.Jeffrey Snover [MSFT]
I totally get where you are coming from. When having to do work on Windows, I used to go out of my way to avoid PowerShell.I finally gave it a solid chance one day and I've found that it can be surprisingly nice and powerful to work with.You can globally disable policy enforcement. Maybe not the most "secure", but it's not something I wish to bother with. There is also a really nice package management system for PowerShell modules with things like git integration and etc.You can check out my shell configuration here:https://gitlab.com/lholden/WindowsPowerShell
Java developer here, multi-OS fan. I'm using both PowerShell and bash from Windows Ubuntu subsystem. I prefer PS on Windows because I do like its object pipeline, but have to use bash for some cross-platform automation.
Powershell users don't age gracefully, that's for sure. You'll learn some arcane long-winded way of doing something in v3 and it will be relaced with something far better. Unfortunately, you'll still have to know the old way.As for longwinded, I hate using ACL in Powershell. Let's say you have to reestablish FullControl on a bunch of files as an Administrator and you don't have Write access. It's so convoluted and it can even fail silently. So much easier to just use icacls in a single line.
I'm going to address each bullet:- Set-ExecutionPolicy can be set with a single click from the "For Developer Settings." Just scroll down and hit Apply three times and your machine has sane developer defaults (inc. ExecutionPolicy).- The verbosity means that you can "guess" PS commands. Each PS command is a set layout with an action word (e.g. Add, Clear, Get, Write, etc) and then target (e.g. Set-Alias, Set-Date, Set-Service, etc).- A ton of people use PS. In particular SysAdmins are moving from VBS/Bat to PS in droves. No clue what communities you hang out with where nobody uses it?- It is definitely still a work in progress. But most of the core parts of the language hasn't changed much, if you wrote a PS file three years ago it likely still works today. All they've done is add new cmdlets, new libraries, and new functionality which doesn't hurt backwards compatibility.
> If you wrote a PS file three years ago it likely still works today.That's a really low bar.Isn't Windows supposed to have a legendary commitment to backwards compatibility? 3 years of backwards compatibility would be nice for a bleeding-edge development environment like node.js that you can tear down and replace whenever you want, but not for your operating system shell.
Guess? With  naming conventions like "Get-ChildItem"?Major functionality, probably the worst name you could come up with.
A single anecdote doesn't discount a trend.Being able to predict a PS cmdlet based on patterns works. I know, because I use it daily.
It works when it works but when it doesn't it is a pain.I recently was looking at doing some backup software in Powershell for Windows 10 and 11. My chosen method was to use a VHDX file (Windows backup does this). Now in powershell there are commands to create a VHD or VHDX file but they are tied to the Hyper-V package in Windows being installed. In Windows 11 this package has been totally removed and can no longer be downloaded or installed.So next I tried to find another way to use VHDX files in Windows 11 from Powershell. So I discovered that the diskpart command line utility can create/attach/partition etc VHDX files. Diskpart however is not integrated into powershell. In order to use it you need to create a text file with the commands to run. Execute diskpart with that text file. Then you have to search the text output for the results.At this point I felt like I should have been using a Unix shell anyway.
This is a strange rant. It has zero things to do with Powershell.
I am having to learn it to write some scripts for a customer who insists on using Windows. It‚Äôs very neat. I‚Äôm especially impressed with the ability to create GUIs. [1]Coming from bash the language is awkward. I would like to spend some time learning it more and running it on my main macOS machine.[1]https://lazyadmin.nl/powershell/powershell-gui-howto-get-sta...
I had no ideas about the GUIs. Thanks so much for the link. Makes me want to use it even more.
I use pwsh on all platforms. All automation is done with it, and in many cases web app functionality depends on it running in background all the time (for large public services).Even our GitLab runner uses pwsh.To organizse build/scripts we use Invoke-Build, a cross-platform task runner:https://github.com/nightroman/Invoke-Build
It's pretty nice. I've made my small career so far out of being pretty at home in both *nix and Windows environments, and I prefer PoSH to bash mostly because it feels more like a really terse programming language than a shell. I also find that after I run it through `Edit-DTWBeautify` or the like, and all the aliases get deanonymized, it's one of the easiest scripting languages for me to return to and understand just by reading it.There is a bit of a painful paradigm shift, though, where you have to stop thinking in terms of text streams and more in terms of shuttling objects with properties around. It's not a great idea to try to work with PowerShell exactly the same way you might construct a pipeline around `awk` and `grep`, because text streams just aren't the real primitive in this environment. For that reason I think it usually makes sense to just a stick with whichever shell environment you grew up with, unless work or something forces your hand.
Disclaimer: I'm inexperienced with bash and powershell.I just converted a bash script to a powershell script. Some things are a lot easier (like writing errors or info messages in different colors). But I had a lot of problems getting the exit codes from maven calls to determine the exit result. Checking for 0 in shell works fine all the time, in powershell checking $LASTERRORCODE works sometimes but not always. I'm using try catch now but it's a bit of a hassle (which is ironic, comic from a java developer).
$LASTERRORCODE is not the same as $?It works only on native executable errors. Some executables like git also write logs on error stream (this is a problem on linux too).
I like it for scripting shell but not for daily interactive shell.
I love it and use it almost every day.
Well, I don't, and I'm a Windows fanboy. So,why, exactly none of you ask:1. The PowerShell separation of, what on *ix* systems is stdout and stderr, doesn't really work. Want to know whether your invocation of a PowerShell command worked? Well, itmightbe that the error stream has content, otherwise check the warning stream, otherwise check the regular output stream, and see if it contains an error-message-like-ish string2. Continuing on this theme, just 'give me all the output, regardless of type/class, from this command' is just plain impossible. You want to see what this command would print on a terminal? Good luck with that!3. Serializing PowerShell output to JSON (which, naively, you would assume would be sort-of reliable) generates heaps of PS*-specific junk. Just the common '|fl XXX' expression will trigger this4. Even commands that appear to be successful, may in fact have failed. The Azure commandlets are especially guilty of this. Remove a load balancer NAT rule? Sure, we'll pretend to do that! Except, nothing happens, and you'll need a support ticket to actually modify your configuration
What do you mean with #3? A command like below runs perfectly fine with no PS* specific junk.```
> Get-Process | Select -Last 5 Name,ProcessName,Company,Path | ConvertTo-Json
[
    {
        "Name":  "winlogon",
        "ProcessName":  "winlogon",
        "Company":  null,
        "Path":  null
    },
    {
        "Name":  "WmiPrvSE",
        "ProcessName":  "WmiPrvSE",
        "Company":  null,
        "Path":  null
    },
    {
        "Name":  "WMIRegistrationService",
        "ProcessName":  "WMIRegistrationService",
        "Company":  null,
        "Path":  null
    },
    {
        "Name":  "Zoom",
        "ProcessName":  "Zoom",
        "Company":  "Zoom Video Communications, Inc.",
        "Path":  "C:\\Users\\user\\AppData\\Roaming\\Zoom\\bin\\Zoom.exe"
    },
    {
        "Name":  "Zoom",
        "ProcessName":  "Zoom",
        "Company":  "Zoom Video Communications, Inc.",
        "Path":  "C:\\Users\\user\\AppData\\Roaming\\Zoom\\bin\\Zoom.exe"
    }
]
```And when you say "Just the common '|fl XXX' expression will trigger this" does that mean you are doing this `<command> | fl X | ConvertTo-Json`? Because if so, that's why your getting all the PS specific junk.
IIRC HN really wants an indented paragraph for code blocks, your ``` did not go precisely to plan, I don't think - if you indent:```
    foo
    bar
  ```it'll be happier.
1. You check `$LastExitCode`, similar to `$?`. You can also catch exceptions when dealing with real Powershell commands.2. Try piping your output through `| Format-List -Property *`. This isn't very discoverable really.3. Try selecting the properties you want: `| select Name, ID, Etc`4. This is the fault of the module developer, not Powershell. You can also write bad software in C.
`$?` works and is more reliable. Git notoriously gives non-zero exit codes for success conditions
1. Native PS is easy. Binary commands are no harder than on any other platform, but I find $? to be reliable. Now you know.2. Pipe to Out-String. Now you know.3. Format commands generate console-host-specific markup. You would never pipe through FL to json, that's a bizarre thing to do. You're complaining that the boot doesn't fit on your head. If you want to filter properties, use select or generate new objects in foreach.4. Fair, but not a Powershell issue
The only point I would raise is that #1 isn't reliable on any system that has stdout/stderr. For most of the MS-created modules this is implemented correctly. You also have the ability to catch and throw exceptions... foreign to people who live in scripts but essential for people who have programming experience.
That's a remarkably insightful rebuttal. I sure see the errors of my way now. Except I'm not really sure whether these are in the Output, Error, Warning, Verbose or Debug stream, so...
It doesn't need insightful rebuttal :)But ...1. *> is a thing
    2. see above, I agree that Start-Transcript could be better and include all
    3. Just provide your own massaged JSON
    4. Not a pwsh problem, problem in general. For example take a look at Invoke-Builds `exec` as one way to handle thisBut really, 4 random things, and you don't like 2 decades of work. Awesome!
>    1.> is a thingSilly how you needsh to do a very basic thing in PowerShell
What? Did you think this trough? Give it another try.
> 3. Just provide your own massaged JSONor use -Depth parameter...
The author has a few good points. I want to love PS as well, but in practice it has too many gotchas and pitfalls that seem to pop up every time I write a script more than a few lines.Sure, all languages have these, but the ones in PS feel nastier and more subtle than most, compounded by the fact that it's not a language I use more than once every few months and should be easy to pick up and put down.Basic stuff like parens, commas, function calls, casting, variable interpolation and arrays are frequently surprising. Many behaviors fail silently.For example, arrays with 1 element behave differently than arrays with 2+ elements. PS is "smart" and treats the 1-element array as a scalar. Why? I've wasted hours dealing with arrays in PowerShell.See this post for a sampling of the problems:https://stackoverflow.com/a/69644807/6243352Even without the gotchas, case insensitivity, optional abbreviations, optional parens, etc, make PS scripts harder to read and debug than they need to be. PS feels like a mashup of many of the most confusing parts of PHP and Perl and adds its own fresh mess on top. Adding parameters and resolving a few of Bash's failings isn't much of an achievement given ~20 years of time to design it properly. Neither language is as easy to work with as it should be.
If I had a nickel for every time I had to debug some crazy Bashism. PowerShell can be finicky at times but is a walk in the park compared to the alternatives. For basic stuff like if/else comparisons I don‚Äôt need to lookup how many parens or square brackets to use for strings or arithmetic or recall if 0/1 is true false or reverse. Maybe I should just compare ‚Äúfalse‚Äù/‚Äútrue‚Äù strings or use true/false commands instead which have their own issues.PowerShell has real functions, not just exit codes and text streams so you can easily write maintainable scripts past 100 lines. It‚Äôs got a debugger. It‚Äôs got modules and a package gallery. It‚Äôs got autocomplete and help messages. It‚Äôs got try/catch/finally instead of traps. It‚Äôs got an optional type system so you can be as loose or strongly typed as you want. It‚Äôs cross platform so the Windows devs don‚Äôt get confused migrating to Linux. It‚Äôs got batteries included for everything between cmdlets and .net. Anything you can do in C# can be replicated. Sed/awk/Grep are nice but sometimes you just want structured data converted into an object to pass around functions instead of reinventing the wheel.Case sensitivity is a feature, $foo and $Foo should be the same and if they‚Äôre not you should call it something different or invoke it differently. ‚Äú$foo = new [foo]‚Äù separates variables from types. ‚Äú$env:foo‚Äù namespaces your env vars. In Bash is FOO a var, constant or env var?Good PowerShell is readable with little effort. Good Bash is readable with significant effort if you are familiar with Bash and the problem domain already.
Case sensitivity isn't a major deal, but it's another example of the designers trying too hard to be clever and "user friendly". A good scripting language should try to reduce friction relative to other programming languages, most of which are case sensitive.I'd like to see a native OS scripting language that has a low bar of entry, isn't silent on undefined variables and other common mistakes, imposes syntactical consistency like Go or Python, has decent basic data structures and isn't riddled with pitfalls. PS isn't that language.If Bash and PS were good, it'd be so much easier to bring non-programmers into the command line so they can automate tasks and hack on their systems. Unfortunately, these languages aren't doing that, much less passing the usability test with most programmers who'd just assume script with Py, Perl, JS, or whatever their preferred language is.
Python/Perl/JS/Ruby aren‚Äôt shells so the busy sysadmin doesn‚Äôt need to ask themselves at what point they rewrite their script in a sane language and a Windows dev won‚Äôt typically use those languages, especially as you‚Äôd have to call the Win32 api for lots of behavior or bring in many external packages for things PowerShell includes for free.In terms of ease of use PowerShell and ISE is available on every PC, is more consistent than Bash and more powerful than a user friendly shell like Fish. I don‚Äôt know how you get easier than Get-Foo, Set-Foo.Bash doesn‚Äôt really offer anything out of the box except the ability to glue external commands together and most people use it because of its availability and portability rather than its virtues as a language. Zsh, Fish, Elvish, Xonsh haven‚Äôt managed to displace it and Xonsh is even written in Python.The only thing I can think of that could make automation more friendly to nontechnical users is something like autohotkey to mimic manual interaction.
The point is, if a developer is resorting to another language just to write a 20 line script with a data structure, a loop and control flow, that's a failure of the shell. I don't want to have to use anything other than PS to script on Windows, but I'm often forced to in order to be productive.It's not saying much for the language that Windows sysadmins use PS primarily. Like Bash, the reason people use it is availability, not language virtue. See last year's Stack Overflow developer survey, where Bash was more popular than PS (29% (Bash) to 12% (PS)[1]) and loved (57% (Bash) to 43% (PS)[2]).I don't like Bash. I'm using it as a yardstick to show how disappointing PS is.[1]:https://survey.stackoverflow.co/2022/#most-popular-technolog...[2]:https://survey.stackoverflow.co/2022/#technology-most-loved-...
Python is a shell, the one you mentioned, xonshAnd PS doesn't include things for free, it brings a lot of baggage from the same company that made the win32 APIs unergonomic, though it does have a few structural advantages like typed data(the easier part to Get-/Set- could be losing the pinky-typed dashes since you already separate by Case, and for such common things you could even just use gFoo sFoo)But none of these options are anywhere close to the ergonomics needed to bring non-technical users into the fold
What I mean is Xonsh isn‚Äôt a core part of Python. If it was, I‚Äôd be very tempted to make it a daily driver as Python is a very nice language.
Look up strict mode.Array unrolling is a legitimate gripe. The design justification is that Powershell is pipeline-oriented. On occasions where you specifically need an array, either type your variable or use the array operator:[object[]]$foo = 42
    $foo = @(42)
Good point about strict mode. However, I've collected a few gotchas[1] that I don't think strict mode helps with (as seems to be the case with languages that offer strict mode, it's not enough). If you're curious and have time to take a look and let me know what I might have misunderstood, I'd appreciate it.I think I'm missing which problem your code solves. There are a few array issues in my gotcha journal. Adding types like [object[][]] doesn't seem to help with getting PS to understand nested arrays with 1 element, for example, and $foo = @(42) is the array declaration syntax I usually use.[1]:https://gist.github.com/ggorlen/1e337f211f508124321c8bc7c1d2...
An often overlooked aspect of the "vision" of PowerShell is that it is intended to be the back-end of a GUI console!An good example is the Citrix management console. It is a very thin Windows GUI wrapper around a bunch of PowerShell modules. Literally everything it does, and everything it shows comes from PowerShell, not from direct API calls. When managing a Citrix farm remotely, it uses WinRM PowerShell remoting, not traditional COM+ RPC.This is easy because:1. The PowerShell runtime can be trivially embedded into any .NET app. It's just a reference and about 3 lines of biolerplate.2. It runs "in-process", making it much faster than calling out to external shells.3. The commands are (relatively) strongly typed, so there's no concerns about escaping, shell injection, or other similar security issues.4. Outputs come back as lists of strongly typed C# objects, making them trivial to bind to grid views or other GUI user controls.5. Even tree views are easy to wire up, because PowerShell has a concept of virtual "drive" providers that can wrap anything in a file/folder structure. You just write a generic "folder and item navigator" GUI controlonceand then you can use it with any number of providers for free.The end-result looks like a traditional GUI, but basicallyguaranteesthat anything you can do in the GUI, you can also do in the shell. It's also ridiculously easy to add a "generate a script for this change" button, because it's just spitting out the internal representation!
As an ancient UNIX person, I've always loved PowerShell from the start. I remember the first time I played around with the first version that wasn't a download (2). I wanted to see how it dealt with objects, so I ran something simple:$ui = (Get-Host).UI.RawUI$ui | Get-Member (to see the methods and attributes available)$ui.WindowTitle = "Hello World Window!"After that, I was hooked. PowerShell providers and modules are incredibly useful, as is piping output to Out-GridView. Later versions have introduced more cmdlets that, quite honestly, everyone should use instead of DOS commands (e.g., Get-NetIPConfiguration instead of ipconfig). I do remember a bit of timing issues (often solved by inserting Start-Sleep) and other general flakiness like others have noted here, but the ones I've noticed were fixed in later versions.
I've been using some form of *nix since 1997? Pretty much since I had my first computer. I was very late to the party - didn't touch a computer until college! I've used Windows on and off throughout those years (gaming, mainly).Using PS is a joy, I've re-written all of my usual utility stuff from bash/zsh to PS inside a few week, and managed to improve on a bunch that I didn't want to do before because bash is painful to debug/test/etc.I rarely fire up WSL now, and it has replaced Python for my general utility scripting language.Note: if anyone is reading this - if you're still using PS5 built into W11, then you owe it to yourself to install PS7 (it can be installed alongside 5). It is invoked via pwsh rather than powershell, and can be setup to use the same startup scripts as the default PS.
I always felt that Powershell was a solid indication that the whole GUI-isation of the world that started with such a bang in the 1980s has been an impossible task to complete.For something as complicated as Windows Server, there is not enough time to build GUI screens and OLE/COM/DCOM interfaces for every little flag, function or feature.  Microsoft must have realised this quite some time ago.The evidence?  That even Windows 11 contains ancient, crufty GUI screens from Windows XP and older.  It turned out the Unix guys were right all along.  There is nothing wrong with the core of Windows as an operating system, but the baggage it carries mostly due to all those failed GUI screens makes it inferior in practice to Unix based systems.I have one powershell script I use, which is something that manipulates an Outlook mailbox.  It's unreliable (thanks to Outlook) but again demonstrates what a pointless idea the entire Powershell project was and to a certain extent what a dead end things like systemd will eventually end up being.
If you're building screens for every set of configurations that you're defining (and doing it a lot) then you're doing it wrong.If you can specify some sort of schema for configuration in general, then the screens can generally be generated.You generally don't want or need to display different instances of the same sort of configuration property in fundamentally different ways.I think that what you get from a (decent) GUI is discoverability of features, whereas what you get with the CL is specificity.The former makes computers accessible to the masses, the latter provides power to administrators.
Reading this discussion I'm wryly reminded of IBM AIX and it's smitty tool. It let you administer AIX unix from a GUI, but always emitted the equivalent CLI command, as if GUIs were just something it hoped youd eventually grow out of.
Powershell has grown on me. Over time I've worn down and started utilizing my Windows install in the Windows way. I think Powershell is a well overlooked feature of the platform, to the point where I now have moved a lot of my scripts/automations on my home server (Linux based) from bash/js/.NET 7 binaries to Powershell Core.Big asterisk, my day job is as a .NET/C# developer. So much of Powershell does feel like a .NET wrapper or C#-lite, and that's not necessarily a bad thing. It lends itself very well to feeling like a traditional programming language. Hell, it even has a debugger! My only real complaint about it and adoption thus far is the release management. Windows 11 _still_ ships with 5.1, and 7 is leagues ahead in terms of performance and features.
Nice article, and this is obviously a very specific nitpick from a single point in the article, but ...> ls --full-time | cut -d' ' -f6,7  # WRONG> If two ‚Äúfields‚Äù have different lengths, ls will add spaces to the name of the smaller one to make the two line up, which will break cut -d' '. And in fact you can‚Äôt solve this at all with ls, you have to write stat -c %w. Text streams don‚Äôt compose.I mean, ok, I get the point how he's saying Powershell has 'objects', but the example is super-contrived. All it takes to fix the offending 'padding spaces' is to remove them.ls --full-time | tr -s ' ' | cut -d' ' -f6-7Moreover, that's not even "bash" you're comparing against, but 'coreutils'. If you really wanted to grab the output of 'ls' with pure bash then you'd probably go with something like this instead:ls --full-time | while read -r FIELD{1..8}; do echo "$FIELD6 $FIELD7"; donewhich isn't exactly complicated either.Otherwise, if the gripe is about the command you're using not being field based, then go ahead and use one that is, on data that supports it. This isn't exactly a language issue.Case in point, if 'stat' is the right command to get that "field" for that "object type", then there you go. Nagging that if you don't use the right tool for the job will leave you with having to work around things, is not exactly the environment's fault.Also, text streams absolutely do compose. It's just that the underlying type will always be a text stream. But composability is 100% the reason behind this in the first place.
I would agree, but by default powershell start and interactions are so slow (a boring unacceptable slowness!), that I prefer to use windows command or tcl wish for every day usages.
Where I work, my laptop runs a bunch of agents I have no choice about, some of which are related to Windows Defender.A new PowerShell session takes anywhere from *five to thirty seconds* just to give me a prompt I can type at.Blame it on the other software if you want, but PowerShell isn't just a little slow. It'shundredsof times slower than any interactive shell should be.The part of my PowerShell profile that takes the most time to execute is removing all of the fake, useless aliases for Unix commands that PowerShell bundles and refuses to remove.
It's slow AF on multiple machines my side too so he is not alone.>learn to use your machine.https://news.ycombinator.com/newsguidelines.html
Yeah, its becoming ridiculous, but somebody needs to say it like it is. I, along with other people I am working with, used it on litterally thousands of different machines, during last decade. I think I have a pretty good experience about its speed, and while its not millisecond snappy, its not a picture you people are makig. If its slow, its a local problem, period. VM, AV, too many slow modules on autoload, slow profile, it could be a bunch of things.Now, you can keep whining for next decade, or fix your problem and stop this millenial shaneningas.
But I've fixed my problem by switching away from pwsh. You see, those "many modules" are what made pwsh usable
>learn to use your machine.I think consensus would more likely support "learn to keep your machine from using you".
Pwsh starts on my machine in 400-500ms. Far slower than I'd like. That is with no profile.I am a wizard. My profile is my power. With great care and sacrifice I've got it down to about 2s and I just have to load less-commonly-used stuff ad-hoc.I have a 3900X with 64gb of ram and a recent ssd.Powershell startup time is the number one problem with the tool, GP is correct.
That depends on the modules you use.For example, many people  keep each function in a separate file, instead of merging them into psm1 during build. That will speed it up A LOT.You can have different profiles and load them when you need them, even when you enter specific folder.There are ways around it. You complain that you want everything everything everything loaded in advance for your wizardry but are u really a wizard if you can't solve this? So if you buy a porche and then put a house on top of it, shop in cart in the back of it, tires for every season, and so on, and then complain its slow, then guess what...
Uh, let's back up.> Pwsh starts on my machine in 400-500ms. Far slower than I'd like. That is with no profile.This is already 10x slower than a reasonable shell startup time, withno profile configuration at all, on anextremelyfast desktop system. It's downright embarrassing that you are even attempting to defend this state of affairs.
Your shell is not comparable to pwsh, because pwsh contains everything under the universe already there, while in typical shell, you need to install 3rd party tools, and then load them as you use them. I don't feel embarrased at all, while you should be, by comparing apples and oranges.
PowerShell's slowness doesn't have anything to do with its feature completeness, though, nor the capabilities of the language itself. Many new shells inspired by PowerShell's structured pipelines and built-in coreutils replacements share both of those features with it, but not its abominable slowness.
I don't mind powershell as such but the windows ecosystem it is in kills any desire I have to learn powershell. The "python" command in powershell triggering an app store popup even with python installed is the one that pushed me over the edge. I'll just remote into a *nix machine...
That's actually a Windows thing, not a PowerShell-specific thing. The Microsoft Store app generates a stub executable called python.exe and puts it on your PATH. It'll get picked up whether you're in PowerShell, CMD, or MSYS2 Bash. It's basically the same kind of thing as Xcode's git stub on macOS (which I also find odious).The feature is called 'executable aliases', in case you want something to Google to find out how to disable it.
whoa! something new and makes some sense for newbies
Powershell is well...powerful and I can't say much bad about it. Bash scripting can be a pain but I like using bash scripts to chain together io from installed programs, the same task is difficult in powershell. Powershell lets you do stuff nicely if you stick to powershell modules and .net stuff. It's not very nice when wrangling output from $randomprogram.But regardless of platform I use bash or powershell usually for very small self-contained scripts and python for anything more extensive.I always say powershell is more akin to python or perl than bash except python never got around to making repl into a shell interpreter or nice things like script signing enforcement.
> You can do the default thing and write Get and press tab to cycle through things that start with Get.Except Tab is a lateral pinky key press, one of the worst key presses out there
It's also been the standard for that behaviour for shells and, well, lots of other things, for so long it won't change, and notice he also mentioned Ctrl-Space as an alternative.Though my hands don't complain so long as I don't use a mouse, so YMMV.
Powershell is incredibly powerful with | and %{} for transforming collections and SUPER simple .net integration. You can write commandlets in c#. It was one of the bright spots of my time at Microsoft.
(linux user): isn't Powershell that new slow as hell command prompt based on some .NET? No, thanks. It's just terrible as everything made of .NET.
I don‚Äôt. Reason: too wordy. Reminds me of Java.
>when amazing thing is made and people think its shit, there shoud be some name for itI would call it un-called-for criticism.But I don't want to be too critical . . .
For people who are accustomed to the *nix world, PowerShell can feel like the uncanny valley of shells.
Thats because they are hypocrites. You can't separate *nix shell from awk, less, grep, jq, insert-whatever-little-tool-with-random-argument-parser-here. Once you do that, it feels like the uncanny universe of organic horrors.Don't get me wrong. Yey for the *nix stuff, I am huge fan. We wouldn't be here if that was absent. I am not working for MS or anybody that have stakes here. Its simply no comparrison.
I just PR'd into a project that's a kludgy mess of bash.You can code-golf in Powershell. There are terse aliases. But generally the community doesn't do that. Looking at some of the bash garbage I've been subjected to, I'm glad."normally break" yeah bad devs use bash too, trust me.
I think the reason I've been avoiding Powershell is specifically the pattern of `Verb-Noun -Option argument` the author brings up.I'm not saying it's not "better" (however you measure that) but I think it's very wordy and that's always been a turn-off and barrier of entry for me.some examples:pwd --> Set-Locationls  --> Get-ChildItemcp  --> Copy-ItemI totally understand how bash's sometimes seemingly random shortcuts or acronyms can ALSO be a huge barrier of entry (just as it was for me!) and the straightforwardness of Powershell is a lot clearer, but personally now that I'm "in" on the short-hand of bash, it's been hard to start using Powershell.
The single most underused command in powershell is: Get-AliasEssentially every command you'd use has a 2 or 3 character alias that is easy to remember and quick to type.On top of it their almost programitacilly named, so if you know the powershell commands full name you can almost certainly guess the aliasTyping Get-Alias lists them all out.https://docs.microsoft.com/en-us/powershell/module/microsoft...
I now have a burning temptation to write "Get-Alias Get-Alias"
PS C:\Users\Kuinox> Get-Alias -D Get-Alias

  CommandType     Name                                               Version    Source

  -----------     ----                                               -------    ------

  Alias           gal -> Get-Alias
and I have been told by at least twenty people never to use aliases in powershell scripts so aliases are effectively useless.
I think the idea is that inscriptsyou should use the full name for maximum clarity and self-documentation; in your own terminal invocations, be as terse as you want.
That is precisely the idea.
The verbose names are self-documenting. You need documentation (names, types, comments, etc.) when code will be reused and read and altered at a later time.Interactive use is different. It is write (and tweak) then use once. You never write comments in the interactive terminal. For interactive use you have aliases, plenty of them.
One reason for that is that other people may have different aliases set up, so you cannot count on your aliases working everywhere. Yes, that also means the default aliases, which may (although very rarely) change from version to version.For PowerShell ISE there was an extension that automatically expanded all aliases, I believe for the current language server there may be similar things. If all else fails, a PowerShell script can do that as well, since PowerShell exposes its own parser in its API, so a script can easily introspect itself or another script.
If you're working on a shared project where people might care, I usually have the [PSScriptAnalyzer][1] just auto-correct any aliases dynamically for me in my IDE.If you're just doing a quick one-off or interactively, then who cares!  Crack on with your incomprehensible one-liners![1]:https://github.com/PowerShell/PSScriptAnalyzer
Powershell gives the best of both worlds: readable command names in scripts, and simple Bash-like shortcuts when you type stuff in the terminal.
Is this really the "best of both worlds" or does this just double the number of commands you have the learn?
Last I heard (and I haven't had direct visibility into this since about 7 years ago) aliases are preserved between versions for backwards compatibility, but you shouldn't use abbreviated parameter names in scripts because there's no guarantee that they won't become ambiguous if more parameters are added to a command.
That is true; but since the aliases and parameter names are discoverable with introspection, if you are writing a script you can have a tool which expands them all to their full name if you want that.That said, the PowerShell team do care about breaking backwards compatibility, so this risk is more likely in a 3rd party module than in the PS main cmdlets.
Then you just end up with bash commands again, such as "pwd" and "cat"
Yes, you do. With the advantage of the rich object model. Best of both worlds.
And you can still use the full names in scripts (rather than directly in the shell), so you don‚Äôt rely on future readers knowing the aliases.
Thanks so much for sharing this!!
Yes they do. Powershell is smart enough to find the argument as long as it's not ambiguous. For instance:Remove-Item -r -fo ./path/to/some/directoryPowershell is smart enough to know that -r means -Recurse and -fo means -Force because the Remove-Item cmdlet has no other parameter that starts with -r. For -f there are two possible arguments: -Filter and -Force which is why you need to be more specific with -fo.
oh god, fuzzy matching
No it's not fuzzy. It's long-enough-prefix-string-to-be-unambiguous.
But possibly not forward compatible for future parameter addition?
Potentially, if someone adds a new parameter which clashes so the prefix you used is not unique. PowerShell 7.x is introducing support for traditional C-style ternary expression  "a ? b : c" and there's a potential syntax clash there because PowerShell has always allowed variable names to end in a question mark, e.g. "$isConfigured?" and with that there's no way to stop "$isConfigured? a : b" parsing as a variable name and then an error. The official way forward is to mandate that variable names used with ternary expressions must use the full-brace names like ${isConfigured?}, which is annoying.People don't want that, but the PowerShell Team are not moving easily to a possible-break of backwards compatibility in how the language parses variable names. It's been discussed here:https://github.com/PowerShell/PowerShell/issues/3240for dozens of comments, and goes:"@PowerShell/powershell-committee reviewed this one today, we have a couple thoughts: No matter what we do, we're going to do some analysis of our corpus of scripts to see how often folks use ? in variable names. Some of us have a hypothesis (that others would like to validate) that the users who are using ? in their variable names may be less advanced users (as we agree in this room we'd stay away from it because of the potential problems that could arise). On the other hand, anyone using the functionality described here will be able to understand a slightly more complicated syntax (like ${foo}?.bar). Therefore, we prefer option 3 because it avoids breaking changes on these less experienced users."The committee ruled to keep the need for ${}, then the ternary expression became a gated experimental feature in PowerShell 7, you have to opt-in to enable it. One of the PowerShell developers analysed the PowerShell Corpus of 400k+ scripts collected by Lee Holmes and Daniel Bohannon for security threat research[2][3] and said "I found that about 62% of variables that have ? in them use it in the end. That made me lean towards not introducing a breaking change." - in the comments on a pull request[4]. Then someone else made another analysis of the corpus with regex and came up with 329 out of 22,000,000 of variables have a potentially clashing "?" at the end.It's been reopened as another discussion[5] and another person came up with an analysis of the Corpus with proper tokenising/parsing[6] and came up with 11 variables ending in ? out of 1,896,983 unique variables used[6] which then narrowed down to 1 that might break in backwards compatibility if this change happens. Coming up 4 years of back and forth discussion, even with that kind of evidential backing, with 2 core developers, the Team Lead and Bruce Payette one of the original developers weighing in against, being brought up in a community call, then flagged for review by the committee, then reopened as a reminder again[7] the team isstillnot won over on the risk of breaking backward compatibility by changing ? parsing at the end of a variable name.That is, yes "possible not forward compatible for future parameter addition", especially by third party modules who might not take it as seriously, but not at all casually by PowerShell's developers.[2]https://www.fireeye.com/blog/threat-research/2017/07/revoke-...[3]https://aka.ms/PowerShellCorpus(1.2GB compressed)[4]https://github.com/PowerShell/PowerShell-RFC/pull/223#discus...[5]https://github.com/PowerShell/PowerShell/issues/11379[6]https://github.com/PowerShell/PowerShell/issues/11379#issuec...[7]https://github.com/PowerShell/PowerShell/issues/14025
For deletion!
You can shorten any argument name in PowerShell, so long as it can be disambiguated:PS C:\> ls -di # same as Get-ChildItem -Directory; -d would pass the -Depth parameter instead
    

        Directory: C:\


    Mode                LastWriteTime         Length Name
    ----                -------------         ------ ----
    d-----       2020-07-24     18:09                PerfLogs
    d-r---       2020-12-14     22:45                Program Files
    d-r---       2020-12-24     22:57                Program Files (x86)
    d-----       2020-07-23     11:29                temp
    d-r---       2020-07-24     14:19                Users
    d-----       2021-01-15     21:33                Windows
> ls -di # same as Get-ChildItem -Directory; -d would pass the -Depth parameter insteadOuch, that is actually worse than I thought. So not only can you abbreviate parameters, but when the abbreviation is ambiguous Powershell just arbitrarily picks one instead of giving an error?
The aliases he‚Äôs talking about are all set by default. Most of them IIRC are just simple abbreviations- for example Get-ChildItem is gci.
I didn't realize the alias were pre-defined and not just user created.  Thanks for clearing that up in reasonable way.
Please don't post unsubstantive comments to HN. If another comment is wrong, the thing to do is respond respectfully with correct information. Then everybody can learn something. Pleasedon'trespond by fulminating about the community. HN is an internet forum and the internet is replete with people speaking confidently about things they don't know about I'm not saying that was true of the GP but it's certainly true in general‚Äîand frankly that's just human nature.The internet, including HN, is also a frustrating and activating place which triggers all sorts of untrue overgeneralizations after encountering things one dislikes:https://hn.algolia.com/?dateRange=all&page=0&prefix=true&sor...https://news.ycombinator.com/newsguidelines.html(Please seehttps://news.ycombinator.com/item?id=25862346downthread also.)
The parent comment may be incorrect (I don‚Äôt actually know, more on this in a sec), but your comment is not constructive.https://news.ycombinator.com/newsguidelines.htmlUnfortunately, while accusing the parent of being completely wrong, you have not elaborated onhow/why.Would you explain the issue(s) for the parent commenter‚Äôs future reference and for those of us who don‚Äôt have a deep knowledge of PowerShell?
Please don't post unsubstantive comments, call names, or take HN threads further into flamewar. All that is against the site guidelines:https://news.ycombinator.com/newsguidelines.html.
Please don't give up! but please also don't break the site guidelines:https://news.ycombinator.com/newsguidelines.html.Your two comments in this thread contain one fine, substantive statement: "Aliases in powershell are not turned off by default. Aliases either exist or they don't. When speaking of aliases alone, bash is no simpler nor more complex than powershell." If you had simply replied upthread with that in the fist place, it would have made a fine comment with a very high signal/noise ratio. Unfortunately the rest of both comments is just noise, tanking the ratio.As I explained upthread (https://news.ycombinator.com/item?id=25862312), the internet is crazy-making this way, but it's not some property specific to HN and it's not something that's somehow changed lately. It's intrinsic to the medium, and we all need to build our skills in coping with it‚Äîwhich includes not reacting from a provoked place. That's not easy, but it's necessary to the sort of community we're trying for here, and we need everyone to work together on that.
Don't give up don't give up. It's just that if you think about it your original comment is written in a way that it could be injected into most any discussion-thread on social media as is, and therefore I found it quite amazing in its construction :-)
How is my comment wrong?  I said `if the short version is not enabled by default..` which suggests that I do not think they are but am not 100% sure.  Ok, I was wrong and rest of my critic doesn't apply but how is this suddenly translate to `I don't want to live on this plane of existence anymore.`?  I was just wrong in assuming that aliases were user defined like on most shells.
Wordiness for some interesting reason makes it HARDER for me to remember stuff.Kind of like I struggled with PMP exam and memorization because "Integrated Change Control Management" became "Controlled Management Change Integration" or "Managed Variation Integration" or whatever in my mind,"Retrieve-Child-Item" vs "Get-ChildItem" or "Send-Command" vs "Invoke-Command" "Remove-Tiingamajiggy" vs "Delete-Whatchamacallit"... my mind is seemingly better equipped to memorize "obscure but unique" gobbledygook rather than "meaningful-but-generic" verbiage :|
Perhaps PowerShell is the new COBOL?
The rigid and obscure syntactic structure also checks. It's a couple of hours task for me to define a function, mostly spent on debugging the definition.(Probably, if I did it all the time, I'd get it right every time. Just like creating and using COBOL variables.)
I have the same problem with bash.
I have spent hours trying to write a simple function which in PS would have been 10 minutes.
You mean writing the function body? I was not talking about the function body, but about getting the declaration correct. (The bad error messages and lack of real time verification surely contribute here.)PS is more powerful than Bash, it really should be faster to write a function body in it.
Hah, Iwasthinking of that... I did have to code in COBOL for 6 months in ~2000 and I see some similarities in syntax paradigm (though superficial of course) - but I figured the reference would be too obscure for majority of HN audience :->
Indeed, I have the same reaction to Powershell syntax as I do Enterprise Java and C# --- extremely verbose and hard to actually read beyond the surface --- the fact that it contains English words is in some ways deceptive. The mixed case Reminds Me Of People Who Always Write Like This, and that's as annoying as it looks. My theory of why it is harder to read is because longer sequences of characters are harder to memorise than shorter ones.
I had the same experience, though eventually just having more practice with powershell it ends up second nature. Especially with the ides and completion that can come with it.
It also doesn't help that by default (at least in my experience), Powershell's tab completion is slow and annoying to use. I don't know if it's technically inferior, but itfeelsterrible.It does the thing where you get to cycle through various options instead of completing to the longest common prefix, which is really hard to get used to after years and years of interfaces that do the other thing.It's also difficult to form a repertoire of common shortcuts over time because so many commands share a prefix, so most often theshortestyou will be typing is 5-6 characters before you get to anything unique.
> "It does the thing where you get to cycle through various options instead of completing to the longest common prefix, which is really hard to get used to after years and years of interfaces that do the other thing."So change it:Set-PSReadLineKeyHandler -Chord Tab -Function Complete"Bash style completion (optional in Cmd mode, default in Emacs mode)" -https://docs.microsoft.com/en-us/powershell/module/psreadlin...
The defaults come out of old CMD.EXE (bad) habits, so so yes are missing like a dozen years of Linux terminal UX experimentation/improvements.One particularly common advice with Powershell is to try PSReadLine for more bash-like versions of tab completion and other line editing things:https://github.com/PowerShell/PSReadLineAs for common shortcuts, as mentioned elsewhere in this thread, Get-Alias (and Set-Alias) is a very useful tool.
PS C:\Users\Kuinox> pwd

  Path
  ----
  C:\Users\Kuinox

  PS C:\Users\Kuinox> ls


      Directory: C:\Users\Kuinox


  Mode                LastWriteTime         Length Name
  ----                -------------         ------ ----
  d-----       2020-11-30     15:39                .android
  [private info redacted]

  PS C:\Users\Kuinox> Get-Alias cp

  CommandType     Name                                        Version    Source
  -----------     ----                                               -------    ------
  Alias           cp -> Copy-ItemEvery command you listed are default alias in ps.
> "Every command you listed are default alias in ps."No, ls and cp are not aliases on Linux; the aliases which clashed too much with existing Linux commands were removed in PowerShell core, they only still exist on Windows.PS /> get-command ls,cp

    CommandType     Name    Source
    -----------     ----    ------
    Application     ls      /bin/ls
    Application     cp      /bin/cp
It's on Windows, so yes, path are displayed with backslashes.
Though I definitely agree that bash's abbreviations are a barrier to entry, I think a bigger impediment not just with bash but many languages (say, Haskell) is ungooglable operator syntax.If you didn't know what it was, how would you figure out what `$(expression)` means in bash for example?
Haskell hashttps://hoogle.haskell.org/which lets you search functions named by symbols, function signatures, etc.
Yea, in that case I just search ‚Äúbash operators‚Äù and hope to find a page that includes an example of the one I‚Äôm trying to understand.
I think this one is called a "type of quote", not "operator".At least Bash has a very complete man-page, you can just search for `$(` there and you'll find it. But the Bash symbols all have different functions, there are (very few) operators, quotes, variables, and probably more than I can remember.
Commonly used terms/functions tend to become shorter and symbolized as some notation, similar to how all the Math notation came to be.  A mathematician would be unproductive without those shorthand notations.But I guess there is a balance.  Not everyone want to write matrix multiplications as A+.√óB, though A%*%B seems acceptable to some, most nowadays write it as np.dot(A,B).
Fwiw, those aliases you mention all exist. I always do "ls" and "cd" for example. But what really annoys me is that there's no aliases for arguments. So "find . -name foo" becomes "ls -Recurse -Include foo" which makes my carpal tunnel just a little worse.It's a shame because the rest of Powershell is so good.
There are aliases for parameters, `-ea` for `-ErrorAction` comes to mind. But those are defined by cmdlets, not the user.However, you can always shorten parameter names as long as they remain unambiguous with other parameters, soGet-ChildItem -Recurse -Include foowould becomels -r -i foowhich just happens to beshorterthan your 'find' example.
there's no aliases for argumentsThere are (if implemented by the function), and moreover you can use just shrink the name to the point it becomes ambiguous. Your example is the same a "ls -r -i foo".Also tab completion. You never type those out in full, no carpal tunnel, it's just "l -r" the TAB and select what you want. Discoverability is everything in PS.
Powershell is smart enough to find the argument as long as it's not ambiguous. For instance:Remove-Item -r -fo ./path/to/some/directoryPowershell is smart enough to know that -r means -Recurse and -fo means -Force because the Remove-Item cmdlet has no other parameter that starts with -r. For -f there are two possible arguments: -Filter and -Force which is why you need to be more specific with -fo.
For commands you use frequently you can still use shortforms, positional arguments, and tab completion, though.For instance in powershell you can also do:ls -r foo
More importantly, when you have to adhere to the "Generic Verb-Generic Noun" pattern, the namespace fills up quickly and now creating a new program and sharing it is stifled by two problems:1. coming up with a name that won't clash with others in already-extremely-limited namespace2. marketing of a generically-named thing.In the Unix world, let's take top. After top came htop. How would that play out in the Powershell world? List-Processes -> SuperDuperList-Processes?
Powershell recommends a module prefixhttps://docs.microsoft.com/en-us/powershell/module/microsoft...
> "when you have to adhere to the "Generic Verb-Generic Noun" pattern"a) it's GenericVerb-SpecificNoun usually with a name at the front of the noun like Get-YakubinComments, and you don't /have/ to adhere to it.b) there isn't a single namespace, you can use the full name style Microsoft.PowerShell.Core\Get-Command if you want to disambiguate namespaces.c) You can `import-module -prefix ZZ` and then all commands in that module will get your prefix at the start of the noun part, like Get-ZZYakubinComment to avoid clashes.> "How would that play out in the Powershell world? List-Processes -> SuperDuperList-Processes?"No because List- isn't a standard verb, nor is SuperDuperList. Get-EventLog had Get-WinEvent added. Get-WmiInstance became Get-CimInstance. The third party NTFSSecurity module added a Get-Item2 to cover for Get-Item, and a Get-NTFSAccess to cover for Get-ACL.And because it's a shell and can run binaries, there's no problem with you having or running top and htop. or aliasing htop or calling your own thing htop, the Verb-Noun pattern isn't mandatory, it's recommended for companies developing modules so that administrators will have ideas how to list things, add things, remove things, without having to read the manual to find that it's mysterymgmtcli --auth-control -login-create instead of New-ToolUser.
Namespaces in a shell gives me all the bad vibes of XML namespaces.
Microsoft may contribute to open source but not all contributions are good. Powershell breaks with every significant open-source language style and is therefore a typically bad investment of time for a non-Windows developer.MS technologies have sometimes been a bad investment for Windows developers too.
That is ridiculous. Please don't spread FUD.
I'm not sure if this is relevant but I tried all three of the Linux commands in Powershell and they worked as well.
All of those are aliased to the Linux commands and also have their own abbreviations (get-childitem -> gci).
Lots of people here suggesting the main benefit of PowerShell is its object model and indeed that is very useful, but there are other great features as well. First and foremost, PowerShell basically has a command line parameter framework built in. You also have a runtime backed by one of the best standard libraries out there (.NET) - one in which you can easily reach into anywhere in your PowerShell scripts. It also has a module ecosystem supporting development in either PowerShell or C# proper. And now with PowerShell core it's cross platform. PowerShell also supports pipelines, but I mention this last because it's obviously not a distinguisher for it with bash. It's really not even a contest, PowerShell is way more... well, powerful than bash. Since I've become proficient I would never go back to bash.
This isn‚Äôt necessarily something I‚Äôm proud of, but at my old C# job I would do inline C# in Powershell as a very hackish ‚ÄúC# REPL‚Äù for prototyping and interactive testing. At the time C# Interactive in Visual Studio was unreliable and I found it easier to just copy-paste C# code into a Powershell script.It seems that C# Interactive has gotten better (and since leaving that job I have switched to 100% F# for .NET stuff). But a more useful application is using Powershell to bundle a .NET class library into a flexible, low-weight, modular command line application for internal use. For instance, a C# library which does serious analytics on large data, and then a Powershell script that deals with easier annoyances like AWS authentication or FTP access, argument parsing, and so on. Obviously a real .exe is a better long-term solution but I found Powershell worked really well for rapidly sharing compiled .NET code into a tool that data scientists on my team could use.
I don't think it's a question of it being more powerful than bash. Why does it need to be? I'm not going to use shell script to write apps. There are better scripting languages like python and node for scripting non-trivial apps.
I'm a powershell user for about 7 years now, or more. Have a lot of bindings, helpers in my powershell profile, and use it everyday for work.That being said, I'll never use it on Linux as my shell. It's just too slow to start. Fish, nushell, bash, all start instantaneously, powershell (legacy and core), all take more than a second to start, on beefy machines.I've been looking at the powershell core repo in hopes of fixing this with .net core ready to run profile, but they seemed to have something like that in place, but was disabled  at that time.Anyway, PowerShell is good, probably the best you can get on Windows(nushell also takes a bit to start, and it's still new). But, on Linux you can do much better, even if that means having to struggle with Bash/Fish scripting.For more complex scripts a full language like Lua or Python are most likely better.Also, last time I checked the docker container for PowerShell Core was easily over 100MB, if I remember correctly. Might work well for a dev machine, where you set it once, but for a CI, it's not ideal.
PowerShell 7.2.0-preview.2 starts nearly instantaneously for me on Linux, while it's significantly slower on Windows.The non-core version on Windows takesages(up to 10 seconds) to start. It's helped a bit by configuring it with -NoLogo, but still extremely slow, especially as soon as there are any modules loaded in the profile.
Pipes in powershell are just as powerful as in bash.Every curly braces pair is a lambda function with a single parameter $_.You can approach powershell very functionally and the abstractions work fine.It is however a minefield of pitfalls.Obscure error handling at the root script. Always run code at a main function that is called in the root script.Permissive undefined variables and parameters access.Unwinding nested attributes by referring to it at the root object level: what if you need a variable attribute from an object but the attribute collides with a built in method?Truthy and equality are not interchangeable. -eq and Object.Equals produces vastly different results, due to the first not being type safe.Some functions are sintactically similar to flags and parameters: -join.Case insensitivity. Seriously...All in all, if you are mindful of the pitfalls, use Set-StrictMode early on and don't run code at the script root, you are fine. Better than bash. A well written poweshell code is in my opinion way more readable and maintainable by than a well written bash code, despite its shortcomings.However both of them don't come close to what python is in terms of type safety, error handling, legibility, flexibility and maintainability, even for system scripting.
My favorite is that functions don't actually have return statements.A return is just an exit for the function. If you try to assign the output of a function to a variable, it will essentially be a string containing whatever is printed to the console throughout the function's duration.
No, that's misleading. The result is not typecast to string, it's not combined into a single string, many outputs become an array. And it's not whatever is printed to the console, it's whatever was sent to the pipeline output. Printing to the console is separate in PowerShell. Unlike in Linux world where the main way appears to be abuse of stderr for things which are informational and not errors, PowerShell has many output streams, and only one of them is the output of a function. e.g.function test {
      "hello"
      5
      write-host "world"
    }
    $result = test$result contains "hello",5  the output of the function and 5 is still typed as an integer - not string and not a single string - and the console prints "world".And it does this to make it work like a Unix shell, because if you write a command and get some output, then want to batch some commands together in a function and get no output except what you explicitly "return", that would be annoying.> "functions don't actually have return statements"They do actually have return statements (for control flow).(And if you make classes with methods, they have traditional programming language features - called with parens, lexical scope, return statement controls the return value).
Oh Man, that can also cause a lot of issues. If you call a function that has a return value but you don't actually need it, like invoke-webrequest, but you use an explicit return statement right thereafter things go haywire. I have yet to produce a proof of concept to illustrate this issue, but I came across this and it actually overwrites my return statement with the orphaned return value from the invoke method. Took me ages to figure out what was wrong, because debugging the application I could see inside the function that the variable I was returning had the expected value, but what was being bound to the outside was something completely different
Makes me wonder if there might ever be support for standardizing a json input/output schema for all the typical Linux userland stuff, /proc structures, and so on.  Then a "jq" like utility would have more value. Having it co-exist with the current "just a bunch of text" isn't ideal though, as you'd be stuck with something clunky like adding a switch to every command.  Or an environment variable that changes everything. Or a "j-" version of each.
The best approach I've heard is to "standardize" on doing it with IO descriptors, so we'd have stdin, stdout, stderr, stdjsin, stdjsout. Individual programs could check which file descriptors are open and read/write the format automatically. This may also be the best way to leverage the benefits of plain text and structured data and move between them quite naturally as the situation demands. It's also really not that hard to write a few basic utils or fork old ones to the new scheme as a proof of concept, but AFAIK no one ever has.While we're here I'd also like to see more experimentation on using file desciprtors with GUI/TUI tools. I've had good like using things like vim in the middle of a pipe for data that needs a human touch before being passed through. The suckless world uses dmenu quite a bit.
A piped array of "octets" (C style character bytes, like void*) of nil or more length is probably the most basic interface possible for relevant hardware.A structured interface introduces much more complexity.  Rather than standardize on any specific 'wire' format a better approach might be to have a bi-directional connection and a standard for negotiating across it.This might allow different forms of communication (E.G. a shared ringbuffer), negotiation of protocols, signaling when ready / blocked / needing more to proceed, what format(s) to use and if multiple streams should be used (as well as how to multiplex them)... etc.  Programs might even be added to the middle to setup the preferences between two applications and then tell the OS that they're done and to just connect the input and output directly.
JFTR, stumbled over this recently:https://github.com/kellyjonbrazil/jc"CLI tool and python library that converts the output of popular command-line tools and file-types to JSON or Dictionaries. This allows piping of output to tools like jq and simplifying automation scripts."
There was an endeavor sometime around 1998-2002 to reimplement a lot of coreutils, textutils, and other GNU-ish *utils in perl with regular, structured output formats (I believe XML at the time).  Unfortunately, I don't remember the exact name and I don't think it was ever completed enough to be a contender.
libxo on FreeBSD tries to do this to some extent but a way to turn json back into neat tables is somehow missing (jq isn't great in that regard).
Shameless plug - I created a cli tool called jtbl[0] that converts json output to tables in the terminal.[0]https://github.com/kellyjonbrazil/jtbl
Ah, that's interesting, thanks for sharing.  Their github README does a nice job of showing how it doesn't add a lot of work:https://github.com/Juniper/libxo
I know there's a project started a few years ago, building something like this for bash called Relational pipes[1].It's perennially in my "to check out" list and I haven't actually played around with it, mainly because I'm lazy and it's not in AUR.So can't comment how ready it is to use to today. But it looks interesting.[1]https://relational-pipes.globalcode.info/v_0/index.xhtml
Maybe a better idea would be something like the HTTP Accept header for the shell, where the user can set it once and any supporting application will respond in that format.
Helge Klein, a long time Windows dev, summed up my complaints about using PowerShell as anything other than a nice shell that sorta feels like *nix:https://helgeklein.com/blog/2014/11/hate-powershell/I still use CMD.exe, so please get off my lawn ;-)When I need the power of Powershell, I use C# (or even Python + Py2Exe if I'm deploying).
All of those things are bad, but the worst is the variable scoping.Did PowerShell devs learn nothing from what was horrid about PHP?
I think for the devops person or someone doing server administration (sysadmins etc) powershell everywhere must make things easier even with the trade offs (as some have mentioned, it does have a bigger memory foot print, which may or may not matter depending on a host of factors)As a developer? I haven't found PowerShell more useful than zsh/bash or fish (if you haven't, try fish, it has a lot of benefits of PowerShell (fish has its own scripting language that is more "language like", like some of the more simple constructs of Python, syntax wise) but via a simple plugin[0] you get bash compatibility too, and its madeforUnix like environments). I do like that it has a rich object data model, I just don't do that kind of thing in my shell. I mostly use aliases, shortcuts, and maybe some grepping. I don't do heavy duty tasks from the command line where I'm not writing the logic in the first place, and I just find it easier to use the standard that my team does (currently, this is JavaScript, with the shebang it executes just like a binary. We can reliably say everyone has the same version of node)Maybe in the future this will change, but I don't see the win to divide my attention economy to it deeply, personally.[0]:https://github.com/edc/bass
I agree its more for a devops person, not developers so much. Specifically Windows techs who maybe don't use Linux very often.  I've steered a couple of the new IT guys towards it when they ask about how to automate something.  Its much easier to learn new, than to learn shell scripts, batchfiles or C#.The only place where I use PowerShell as a developer is in Visual Studio, in NuGet Package Manager. Update-Package, Generate-Migration, Create-Database, etc..
I tried Powershell for cross platform usage. While I didn't put it through the paces, I didn't have any issues on linux. In the end, I ditched it- Powershell is too verbose. I might as well use Python or node. Hard to beat lodash and node.js for processing objects.- Powershell starts slow, almost 2 sec. I use i3 and it's noticeable when I start a terminal with Powershell. Sure it's a one time cost but I'm nerdy like that.- If I work on Windows I use virtual machines or WSL2 obviating the need for a cross platform shell.
It's funny how the article claims that treating everything like a string is a drawback, when it's often touted as a strength of bash.The author of this piece claims: "Powershell [...] offers a series of commands useful for developing tools and automatisms that are very difficult to implement with simple strings." but as far as I can tell, they don't go on to actually explain any of these cases where Powershell is a more appropriate tool than traditional string-based shells.
Let me channel Snover really quick:Imagine you need to get the MAC address of a network adapter in Bash.  One way to do it would be...ifconfig eth0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'...another...ifconfig eth0 | awk '/^[a-z]/ { iface=$1; mac=$NF; next } /inet addr:/ { print iface, mac }'Both of these are tied to the way the MAC address is printed in the output of the ifconfig command, and there's no contract that says that can't change.  In fact, there are probably versions of it out there where these won't work.  In PowerShell you would do this...Get-NetAdapter -Name Wi-Fi | select -ExpandProperty MacAddressThis is far more readable if you pass this script on to someone else, it won't break if the way it Get-NetAdapter gets rendered to the screen changes, and best of all, since I know the discoverability tricks in PowerShell, even though I've never done this before, I didn't have to go to stack overflow to find it.
Right, but the fact that you can parse out something that didn't have a contract is a strength.Someone had to write the Get-NetAdapter cmdlet to give you a contract, and Linux has those too, so a fairer comparison would be something like:addr=$(</sys/class/net/ens33/address)I think that's just as readable as your example.The question is how does powershell handle extracting somethingwithouta contract, and is that more readable than bash? I'm skeptical :)
> "Someone had to write the Get-NetAdapter cmdlet"Amusingly no, nobody wrote it. There's a part of PowerShell which can wrap WMI/CIM classes into auto-generated cmdlets, and Get-NetAdapter is one of those. (Which is why it's not available on Linux installs of PowerShell).Take a look at the XML in C:\Windows\System32\WindowsPowerShell\v1.0\Modules\NetAdapter\ and there's no C# code or .Net DLL for it, just "MSFT_NetAdapter.cmdletDefinition.cdxml" and "MSFT_NetAdapter.Format.ps1xml". Presumably auto-generated, human checked, though I can't prove that.[1]https://docs.microsoft.com/en-us/previous-versions/windows/d...
Its not like pwsh can't do strings ffs. It just can do objects on top of that. You can totally go bash-like-crazy in it and parse strings if you like that.
Sure, I'm saying that would be a fairer comparison - getting output from something that has no defined interface.So why not compare apples to apples, how would powershell extract the MAC from ifconfig output? If that's more flexible or powerful than bash with standard UNIX tools, then that might be impressive!
> how would powershell extract the MAC from ifconfig output?It could go identically crazy as in bash, as it has its own grep (sls), can use grep itself etc.> (ipconfig /all | sls Physical) -replace ".+: "
    00-FF-84-14-66-D7
    00-FF-B7-06-19-0F
    00-15-5D-00-1F-3C
    ...
Right, that's a fairer comparison. So the question is, why is that better?
Its not. Everything else is.Although, on more thought, it is better even as parsing engine as you have system design rules enforced across tools and OSes. Even single tool may work differently depending on *nix flavor.
Here's what I got:ifconfig | ?{$_ -like "eth0 *"} | %{($_ -Split " ")[-1]}In other words, find the line that starts with "eth0 ", then return the last column using " " as a delimiter.
But Get-NetAdapter just works. Your command, I don't have a /sys/class/net/ens33 on this Ubuntu virtual server. I do have a /sys/class/net/venet0 but /sys/class/net/venet0/address is blank, even though the VM does have an IP address.Grepping everything under /sys/class/net/* can't find the IP in there. It shows up in `ip addr` as venet0:0 and as a P-t-P link, so I assume that's related; doesn't work unless you know the adapter name and still might not work then? What kind of "contract" is that?
Here's the output of the command the parent told me to run on my Windows workstation:> Get-NetAdapter -Name Wi-Fi | select -ExpandProperty MacAddress
    Get-NetAdapter : No MSFT_NetAdapter objects found with property 'Name' equal to 'Wi-Fi'.  Verify the value of the property and retry.                                                          
    At line:1 char:1                                                                              
    + Get-NetAdapter -Name Wi-Fi | select -ExpandProperty MacAddress                              
    + ~~~~~~~~~~~~~~~~~~~~~~~~~~                                                                  
        + CategoryInfo          : ObjectNotFound: (Wi-Fi:String) [Get-NetAdapter], CimJobException
        + FullyQualifiedErrorId : CmdletizationQuery_NotFound_Name,Get-NetAdapterI know the problem, I don't have a wireless card on this machine, but how is this different from you complaining that your network interface isn't called ens33?
Even better than the ip | jq in my sibling comment.
Your example is relevant to show how powershell can handle some tasks better, but this task is better performed with ip than ifconfig, as it has an option for json output which jq can parse:ip --json link show eth0 | jq '.[0].address'I'll admit that the discovery of this is probably not very great. I wouldn't be surprised if a number of people learned about the json output, and possibly jq, from this post.
PowerShell is simply inverting the defaults: Linux/Bash scripts output formatted text by default, but sometimes have options to return objects (often as JSON text strings). PowerShell cmdlets by default return objects (in a custom binary/in-memory format, but convertible to/from JSON, among other options like CSV and XML), but might optionally return formatted strings. (PowerShell also offers tools out of the box similar to but different from jq for exploring/converting/navigating objects.)In general when working in PowerShell you don't have to look up if there is a command with a --json flag (or equivalent) that does what you need to do, you can assume that objects are the default response and move on to working with them with PowerShell's jq equivalents. (Obviously, that makes discovery generally easy.)
Now parse the IP address
ip --json address show eth0 | jq '.[0].addr_info [].local'
I'm not on a Linux box at the moment but isn't there an eth0 entry in /sys (or maybe /proc) which can give you mac address in easier to parse way (I think you could just use cat).I don't know if they are still in vogue but /sys and /proc interfaces were originally intended to return clean output which is easy to parse in programs and scripts. I guess usage never really caught on.
Over the past month I did an experiment of using only powershell, including on my macbook and Linux boxes. I‚Äôve gone back to zsh now though.The benefit of powershell - the rich object data model - isn‚Äôt actually that useful in practice day to day.The memory usage is ridiculous for a shell.The killer though is a disregard for economy of expression. The example in the article can be expressed as just ‚Äúfind /path -mtime -3‚Äù.I have kept ps on Windows, i didn‚Äôt go back to cmd.exe there but WSL2 is still my default when opening Microsoft Terminal.
I love powershell because I have a basic working knowledge of Linux commands. In bash this means I have to google a bit for even slightly complex things like 'change the extension of all .swp files under this directory'.In powershell the short syntax tends to be noisy but I usually can start with the linux commands and muddle through with tab completion:ls -r *.swp | % { mv $_ ($_.FullName -replace ".swp$", ".swap") }
Almost always when I see PowerShell critiqued by people used to Linux and Bash, the criticisms leveled against if often add up to: "I am used to the workarounds for the limitations of my system. Sure, your system does not have these limitations, but what if I need the workarounds, like with my current system?"This is like... AutoCAD before the year 2000. It wasdigital paper, and acted exactly like a drafting board with pens, rulers, and protractors. It was better than paper, but not by much! SolidWorks came out and blew it away. It was proper 3D, with constructive solid modelling. It could generate drawings of arbitrary projections or cross sections in under a second, saving months of time. Yet... people complained thesame way. What if I need drafting tools? What if I want to draw lines manually? How do I draw "just" a circle? Why do I need to define what I'm doing in 3D? Just give me digital paper! That's what I want!I made a comment on YC News nearly a year ago that I'm going to partially repeat below:https://news.ycombinator.com/item?id=23257776PowerShell is more UNIX than UNIX.Seriously. In UNIX, if you want to sort the output of "ps"...sss... that's hard. Sure, it has some built-in sorting capabilities, but they're not a "sort" command, this is a random addon it has accumulated over time. It can order its output by some fields, but not others. It can't do complex sorts, such as "sort by A ascending, then by B descending". To do that, you'd have to resort to parsing its text output and feeding that into an external tool. Ugh.Heaven help you if you want to sort the output of several different tools by matching parameters. Some may not have built-in sort capability. Some may. They might have different notions of collations or internationalisation.In PowerShell, no command has built in sort, except for "Sort-Object". There are practically none that do built in grouping, except for "Group-Object". Formatting is external too, with "Format-Table", "Format-List", etc...So in PowerShell, sorting processes by name is simply:ps | sort ProcessNameAnd never some one-character parameter like it is in UNIX, where every command hasdifferent characters for the same concept, depending on who wrote it, when, what order they added features, what conflicting letters they came across, etc...UNIX commands are more an accident of history than a cohesive, coherent, composable design. PowerShell was designed. It was designed by one person, in one go, and it is beautiful.The acid test I give UNIX people to see if they really understand how weak the classic bash tools they use is this:Write me a script that takes a CSV file as an input, finds processes being executed by users given their account names and process names from the input file, and then terminates those processes. Export a report of what processes were terminated, with ISO format dates of when the processes were started and how much memory they used into a CSV sorted by memory usage.Oh, there's a user called "bash", and some of the CSV input fields may contain multiple lines and the comma character. (correctly stored in a quoted string, of course!)This kind of thing is trivial in PowerShell. See if you can implement this, correctly in bash, such that you never kill a process that isn't in the input list.Give it a go....After I posted the above, "JoshuaDavid" provided acorrectBash solution, which blew my mind because I just assumed it was borderline impossible:https://news.ycombinator.com/item?id=23267901Note how complex his solution is, and that he had to resort to using "jq" to convert the output of "ps" to JSON for the processing!Compare to the solution in PowerShell, of which nearly half is just sample data:https://news.ycombinator.com/item?id=23270291Clear, readable, and easy to modify even for a junior tech.What I didn't say in that thread was this: I didn't actually bother to work out the solution to my toy problem in PowerShellbeforeJoshuaDavid posted his solution.I made up the problem simply assuming that it's ludicriously difficult in bash -- without checking -- and I similarly assumed that it's trivial in PowerShell -- without bothering to check.I was that confident.Are you still that confident that Bash is superior to PowerShell? Or have you internalised its constraints, and are too used to drawing fiddly little lines on digital paper to realise that your tooling is hopelessly outmatched by solid modelling?
I like powershell, but missbash set -e.(really really miss this)Find it hard to set a script to abort with a stack trace.Find it hard to deal with relative imports(this script imports a file in the same folder)explaining the scoping rulesDisklike explains how your array is now a single object when you returned it from a functionAbsolutely love powershell JSON support, miss native yaml support.Love parameter globingLove integration of parameters with a script, dislike that auto generated help can‚Äôt be done via single line comment to function
> bash set -e.(really really miss this)Set-PSBreakpoint -Command Write-Error -Action { break; }similarly:trap { <# IDE breakpoint here #> }> Find it hard to set a script to abort with a stack trace.$script:ErrorActionPreference = 'Stop'
    # or
    throw "Oops!"> Find it hard to deal with relative importsThat's a very unfortunate limitation that I've never understood myself, to be honest. The typical "best practice" is tonotuse relative imports, but to use "installed" modules or scripts instead.> explaining the scoping ruleshttps://docs.microsoft.com/en-us/powershell/module/microsoft...> Disklike explains how your array is now a single object when you returned it from a functionThis is also "one of those irritations" that tends to bite people when dealing with search results, e.g.: "Get-ADUser". If you always want an array (even an empty or single-valued array) then wrap functions in @(...), e.g.:$users = @( Get-ADUser -Filter ... )This is also the syntax to create an empty array, or an array of one item:$empty = @()
    $listOfOne = @( 'foo' )> miss native yaml supportBut this would betrivialto add. Writing a module to provide commandlets such as "ConvertFrom-Yaml" and "ConvertTo-Yaml" is about aday of effortin PowerShell. Good luck doing the same thing in Bash and producing something useful, let alone full-featured!In fact, someone has done it:https://github.com/cloudbase/powershell-yaml> auto generated help can‚Äôt be done via single line comment to functionTwo lines forautomaticallygenerated help is one too many?# .SYNOPSIS
    # This works...
    echo 'foo'
`bash set -e`. Your examples don't work (if you have an answer please paste it inhttps://github.com/PowerShell/PowerShell/issues/3415)Set-PSBreakpoint -Command Write-Error -Action { break; }
    cmd.exe /c "exit 1"
    echo "if this->($LASTEXITCODE) is 1 I shouldn't be here"Your stack trace code is wrong. What your code is doing is essentially saying throw an exception when you encounter an error. All I am asking is when exception hits the top, dump the stack trace.$script:ErrorActionPreference = 'Stop'
    function bar() {
        throw "oops"
    }
    function foo() {
        $a = 123
        bar
    }

    foo

    PS C:\tmp> .\a.ps1

    Exception: C:\tmp\a.ps1:6:5
    Line |
    6 |      throw "oops"
        |      ~~~~~~~~~~~~
        | oopsI use `trap{$_.ScriptStackTrace; break}` but unfortunately I cannot hide this code into a helper script that I can dot source... because of scoping rules! Even though I am dot sourcing a file which I would think would load it into my current scope according to dot sourcing link you sent.Why this is not the default behavior when leaking an exception and aborting I have no clueenforcing things are arraysyes you can wrap stuff in arrays, but that is making the callsite look ugly for a function definition problem. The solution "return ,$array" is just weirdHonestly I prefer the bash way of $yaml | yaml2json(.exe) | convert-fromjson. Easier to find cross platform converters which your example is not. Takes me like 5 seconds to write, however then I have to teach others to do it as well, I want it in the platform. Also why they are at it, add toml support as well.for documentation# .SYNOPSIS
  # Why do I need to type .SYNOPSIS above here, and yes that extra line is too many
  function foo(
      # but here its just obviously a comment for a parameter
      [string] $param=""
  ) {
      $param
  }Also didn't mention this before I wish there was a version of powershell that was static checked like typescript for javascript.
> Honestly I prefer the bash way of $yaml | yaml2json(.exe) | convert-fromjsonI always prefer native support, but that's just me. I recently even wrote a converter for DNS bind zone files because they're such a pain to deal with as "text" files.> Why do I need to type .SYNOPSIS above here, and yes that extra line is too manyBecause there are other sections as well.Consider yourself lucky! If you're writing binary modules in C#, the automatic help generation is missing. Instead, you have to use a hideous legacy XML-based help system nobody asked for. There are thankfully generators available now that plug into the Visual Studio build system, but in the past you literally had to author these by hand.> I wish there was a version of powershell that was static checked like typescript for javascript.Don't we all?Set-StrictMode adds some static checks (not enough IMHO), and there are also linters available. If using VS Code, you get a bunch by default.Fundamentally, once I start getting too frustrated by the weak typing, I realise that I'm writingsoftware, notscripts. I simply crack open Visual Studio and start writing C#...> Why this is not the default behaviorPowerShell conceptually is nearly perfect at a high level. It was originally called the "monad shell", and that design pedigree still shines through.Unfortunately the implementation has many gaps that are as yet unresolved.I was hoping PowerShell Core would fix everything, but it only fixed a few things (parallel foreach finally!) while leaving simple things like break-on-exception on the table.Nonetheless, having worked with both Bash and PowerShell, I hugely prefer the latter because of that purity of vision.
Well... if it's about complex scripting, you have Python or Perl whose are standard, well integrated, lightweight, powerfull and preinstalled on Linux.If it's for a day to day usage as a shell, bash / fish / zsh... are more concise and faster.The example given on the article :# Get all file modified in the last 3 daysGet-ChildItem -Path path -Recurse | Where-Object {$_.LastWriteTime -gt (Get-Date).AddDays(-3)}Is just:find path -mtime 3in bash ...The object thing is nice, but using strings as output is universal.
I wish there was a sane way to bootstrap powershell without having to use an existing binary release. It is not surprising thought, you can't bootstrap bash using .net core either.
Telemetry in dotnet is opt out.
