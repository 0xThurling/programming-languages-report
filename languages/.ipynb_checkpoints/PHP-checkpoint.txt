PHP is honestly fine. I’m not a fan of PHP, and much prefer NodeJS, but objectively speaking PHP is in a decent place. Many of the complaints and criticisms people have are based on the state the language was in 10+ years ago but the core team has made massive strides in improving the language and there’s a really good ecosystem for stuff like Laravel.
With that being said, pick the language you think you would enjoy the most. Try both, if you start with one language you’re not married to it for life. You can switch at any point.
The thing that constantly gets to me with node, I like the extensive ecosystem, I like the vulnerability reports... I dont like the vulnerabilities a lot of packages and dependencies introduce. On the Clojurescript side, I found it even worse; almost any changing was a breaking change before even touching some code...
As you've said, php has matured a long way. The core libraries are pretty solid. Again, like you said, the tools need to work for you. It's about finding what's right.
Addendum: even the market doesn't necessarily reflect what is best. It's mostly a popularity contest, though, Stack Overflow and git get pretty good with their surveys. I guess I'm trying to say, the best language for the product might not be the most popular/widely adopted one. This is fine, if you can understand it - great. But if the community around it is weak, or the documentation is poor, you may find yourself struggling and with little support.
The best language to learn is the language that is in demand where you want a job.
You can always learn another language later. Meanwhile, you will have learned programming.
it's an ok choice. it's still popular and the language improved a ton over the last decade. it has solid frameworks like laravel and symfony too. the only thing i personally don't like about it is that it's not async and projects like reactphp are not popular at all compared to node. since php is significantly faster now though you probably won't run into scaling issues for a while.
this is a good resource for learning modern php:https://phptherightway.com/
PHP started as a "hobby project" that was never meant to become a programming language. For the first few years it was implemented by someone that knew (according to themselves) nothing about programming language design and implementation. And at least some of that design (or lack thereof) stuck and was at the core of the language for a long time. It was an internally inconsistent mess and objectively badly designed. Couple that with a less than beautiful syntax and it's ubiquity (because it was still easier and more pleasant to use than the alternatives) and that's where you get all the hate.
But the language has evolved a lot over time: it's seen multiple rewrites and large updates and is still being actively developed. There's plenty of big projects running on it and a lot of jobs around it that aren't going anywhere in the near future. So if you like it: go for it.
If you're just getting started and deciding on what to spend more time on I'd definitely recommend looking at some alternatives as well though.
yam desert impossible offbeat retire lavish fear abounding office literate
This post was mass deleted and anonymized withRedact
Php laravel has come a long way as far as I know. It's used in some really large scale projects.
Express is decent enough, I can't speak for javascript as much as I can php but in express, you're handling a lot more of what something like Apache would handle for you, or nginx. It's similar to Flask, processing URIs etc.
Personally I hate the unpredictability and lack of clarity in JS. I much prefer the php as part of a backend solution. The clarity of the code, the simple config, scaling workers etc. Logging is so much simpler, especially on a Linux system.
I dont much care for the accessor operator though. A simple "dot" would do just fine, like every other language lol
You need to also weigh:
what it will teach you and how it is transferable to other systems. Try transferring your learning in parallel if you can (if you can do it in php, do it in js...).
job market and prevalence in currently running tech (granted COBOL and Fortran are still in use).
you need freedom to express your ideas in code with little impedance (javascript). You need a simple tools and decent debugging (php).
Ultimately, you need to consider various stacks on the whole, and decide at each level, what db, what server, what architecture, etc.
I recently came across thisnaoris protocol. The future requires innovation and stagnation means death.
Subscribing to your post. I'm also interested! Thanks for asking haha :)
If there is a chance that you work with Wordpress, decently, you will need PHP.
PHP these days is fine for your own projects
Just don't read any tutorials or lessons written more than, say, 10 years ago.  They will teach some BAD habits that will make you write extremely vulnerable code.
But, I will say this...PHP is definitely not a common language these days.  I would not learn PHP if you want to learn how to program so you can get a career in programming.  NodeJS is basically king these days, with Django and Ruby on Rails as second and third place, though you'll still see some Java.
Personally my issues with PHP have nothing to do with the language. It's the jobs.
It seems weird to criticize a language for having successful projects built with it, but as a developer who has to work on these projects; that is the problem with PHP.
Most PHP jobs involve very old open source business software. Projects like WordPress, Drupal, OpenCart, or Magento. The thing almost all these have in common is being terrible to work on. They're super old codebases with all sorts of janky work arounds and hacks.
It's rare for there to be any sort of automated testing. You typically have less than ideal ops (these are often hosted on shared hosting and have no sort of CI / CD pipeline). Most of the custom business logic you will work on will involve hacking apart some plugin that does most of what you need to get the last 5% a client is requesting. These jobs also tend to be on the lower paying side as far as dev jobs go.
If you can find a job working on custom software in something like laravel or symfony, that has good test coverage, good CI / CD, and a great local dev environment; then PHP is great. But thats maybe 1 out of every 1000 PHP jobs.
On the flip side in something like ruby on rails almost every job will be like that.
Because they formed their opinion based on PHP 4 and think it isn't approaching version 8 already.
PHP has a low barrier to entry, is easy to learn, and very easy to write badly.  PHP before version 5, the language itself, was rather badly designed.
Back in the day, tons of shitty PHP code was flying around.  The only (but biggest) turd left from that era is WordPress, which is probably the single biggest factor in PHP's reputation at this point.
Here'sa good explanationof how PHP got its bad rep. Of course, that text is 8 years old, and many of the worst things have been progressively improved, but some of the original bad design decisions are baked in the language.
I learned PHP by myself for web development as a teenager. It really was a bad introduction to programming. It was before JavaScript became somewhat mainstream, so I stuck with it. Later I learned another bad language (Matlab) before finally landing on something logical: Python. I now hate PHP because it was a bad experience, but it taught me so much. Also, PHP has become much better.
I think it is based on the poorly done things they have seen by random people learning to code.  PHP was the next step after HTML for a lot of hobbyists. I guess that is a testament to the language’s learning curve and widespread adoption.
Some of it is elitism by developers who think their language of choice is better.
You can check outr/lolphpfor some fun examples.
But essentially:
A long history ofserious security vulnerabilities
Associated with ancient code & security issues from the WordPress ecosystem
I honestly believe this is where most stigma comes from.
Slower than many other languages, prior to PHP7
Those things picked up a stigma that was and still is hard to shake.
Today, PHP is a solid choice but there are a rather few cases where its the "best tool for the job" for a new project.
Thought this was a pretty good argument against WordPress from a PHP developer.
If you're somebody like me, who skipped the entire WP phase of learning PHP and went straight into PSR based OOP, using more matured frameworks like Symfony and Laravel, and learning advanced coding patterns to build entire frameworks from scratch (in more languages than just PHP too), then yes, WP is absolutely a pile of hot, steaming, procedural spaghetti code, and I dread every time I have to work within it. I don't hate it because I'm a half-assed developer, I hate it because it's built and maintained by half-assed developers, and it's ecosystem births even worse half-assed developers. I understand the codebase is very old and comes from a very different time, but if anything, that reinforces exactly why its so bad. Let me expand further on this:
https://www.reddit.com/r/PHP/comments/j17k50/w3c_wont_use_wordpress_for_their_next_website/g71cual?utm_source=share&utm_medium=web2x&context=3
Given how easy PHP is to learn, I've thought about this a lot.
Young developers tend to adopt whatever paradigm is being parroted by the loudest voices, which right now involves highly abstract JavaScript libraries and installing the whole internet via npm.
Beginning developers don't know how to set up a simple LAMP server, but NodeJS tutorials on YouTube install a light web server for you.
Talking points from 20 years ago
More recent talking points before PHP 7 and FPM
Maybe this is too harsh, but I think that's kind of how it is.
Can someone who actually has PHP experience please enlighten me about the unforgivable sins that PHP committed in the past ?
I can, yes. It's true there is 'blind' hate for PHP from people who haven't done it, hate more about the low barrier of entry and WordPress, and also people that still hate it for outdated reasons that have since been fixed at times. That said: I think a lot of the most pro-PHP people unfairly think of all the PHP hate as coming from those places.
I've also seen a lot of PHP 'defence' in the form of pointing out javascript suffers the same problems in some area yet it's not nearly as hated on, and to be honest: I agree. The difference is I hear that and think javascript is overrated, not that PHP is underrated.
So what am I talking about? PHP has a history that, although in some ways since cleaned up, still very very much leaks through. PHP was essentially made to be a C wrapper for writing web pages - emphasis on "C wrapper". C has a lot of janky shit, but C also has the excuse of being an intentionally minimal language where the jank is sometimes actually a feature, and the language is decades older than PHP. I'm talking things like not having namespaces, having 'return arguments', relying on "there was an error" magic values that some functions return (like returning -1 or null or false to indicate an error occurred) which have to be followed up withget_xyz_last_error()type calls to actually see the error that occurred, a flag argument to functions which is just an integer filled in by globally-scoped constants, and special "resource" values.
Now PHPhaslong since gotten namespaces, gotten exceptions, gotten an object model that can represent a "resource" much better, and just in general has quality of life stuff to make the above argumentssoundlike I'm just complaining about old PHP... except my real complaint here is you can't escape that historical baggage of PHP. PHP added all these things but never updated the standard library, and now there's just a grab bag of different ways to do things that are obnoxious to juggle. To say nothing of UTF-8 or other unicode encodings support being quite possible, but error-prone.
Want to decode json? Cool.json_decode. If it returnsnullthere was an error and you need to calljson_last_error()to get the error... Unless thenullreturn was because the json being decoded genuinely represented the value ofnullin which case no error occurred. Or unless you passed the flagJSON_THROW_ON_ERRin which case the decode will actually throw an exception if an error occurs.
There's a lot of situations where the standard library or the language itself is janky in that way - the language theoretically has a good base now in terms of features to let you make good software, but a bunch of stuff out there - even the built-in stuff- is a mess of all sorts of different ways of doing things. This gets compounded by the fact it's a programming language with a configuration file... and also the ability to override the configuration file withini_setcalls. So much of PHP's behaviour isn't obvious or even possible to interpret without carefully reading not only the code you're looking at and either remembering or looking up the flags or other caveats, but also knowing the context it's running in.
You also have a lot of times PHP is "helpful" and does magical things for you that can be a) not helpful at all and b) are easy to not even be aware of. PHP having the stat cache has fucked me for sure, and it's really easy for people to not be aware you may need to callclearstatcache()before all file check calls you're trying to do if you actually want to know what's true. PHP was "helpful" and auto-cached shit that's not implicitly cached in any other systems and it's not at all obvious it would do that.
I think a lot of people that like PHP like it because a lot of these issues can seem really minor when writing 'normal' PHP in a reasonable, controlled environment. Which many people do to be fair. When people like me complain about things like this they call it nitpicking about shit that rarely if ever comes up in my experience.
But here the real core of why at least I don't like PHP: even if this is an infrequent problem to hit things like unexpected ini settings or the stat cache causing issues and it's not overly difficult to adapt to the weird stuff like how json_decode has 2 totally distinct error reporting mechanisms the fact is these issues exist still, whereas there are plenty of languages where the issues don't exist at all.
This isn't even all of my thoughts on the matter - I had way too much time to think about in the years where I was either writing PHP, or writing python3 right after which, despite hardly being perfect either, is a much more ergonomic tool IMO.
Howdy there. 10+ year web dev here.
In my experience it's dangerous to get too absolute in your opinions about anything in programming.
Phrases like "literally every thing else is better" and "no one should be using X" are usually not helpful.
Languages are tools we use to do our job. Our job is solving problems and building solutions for people, we just happen to use programming to do it. We can argue about the brand of a hammer, or a hammer vs a nailgun all day long but in the end we just need to get our project built.
I used PHP for 8+ years. It helped start my career and you never know what your next job will be, so don't be too quick to villify any one language/framework/approach - you might get stuck with it regardless.
PHP has an enormous community and that alone is worth a ton. The things the Laravel folks have been doing the past few years are incredible and the fact that many many many things have been accomplished in PHP means you'll find a lot of precedence out there on how to make something.
It's a language. Getting too bent out of shape over one language or another is really counter-productive to what we all do. Have fun, find what you like, and keep an open mind.
Edit: clarified who I am.
I know very little of PHP. When I was getting started in web dev, I believe the issue with it was that it did everything in the view. So mixing in database calls, etc., in with templates. Which causes an unmaintainable mess. I don’t know if that’s still the case, or if it ever really was, but that was the perception.
I have absolutely no evidence to back it up, but I have a theory PHP gets abuse for the same reason a lot of devs have hated JavaScript in the past - because it's been successful in having a low barrier to entry and getting picked up by a lot of new developers that have had successful starts to their companies.
I've never hated PHP, but I have hated the awfully written, insecure, highly coupled, tangled morasses of garbage that have been some of the PHP code bases I've worked on, which massively outnumber the well structured, well written PHP code bases I've worked on.
Its reputation is not entirely undeserved. It has absolutely improved in more recent versions, but it's had a history of generally janky and inconsistent design. This is quite common in languages which have evolved over many years, and isn't helped by the old stuff which hangs around in future versions for backwards compatibility reasons, but ends up cluttering the language.
Some examples:
Weirdness with type conversions and equality."hello" == TRUE, and"hello" == 0, butTRUE != 0
Inconsistent naming and usage conventions in core language features / functions.strposvsstr_rot13andbase64_encodevsurlencode.array_filter($input, $callback)vsarray_map($callback, $input)
Historical hacks and patches which remain in the language.mysql_escape_stringvsmysql_real_escape_string. This feels like "My resume (final) v2 (final).doc". And they had to introduce the "real" version because the original had a pretty bad security flaw
Not super clean-looking syntax e.g. due to the kinda funky way variables work.foreach ($foo as &$bar)
There's not one clean place to configure stuff. e.g.error_reportingvsdisplay_errorsvs ini-file settings
General redundancy and duplication -intandintegerare both valid
Confusing / misleading naming. e.g.E_ALLdidn't actually coverallerrors (at least not in earlier versions)
More info here:https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
I hate PHP because my PHP professor was a neurotic tool who forced us to use a textbook he wrote himself to learn PHP, a book which ignored all programming conventions and was essentially just him hacking spaghetti websites together that were impossible to replicate. Never again
There are a lot of bad apps written in php. But otherwise it's also peer pressure. And when you start digging into why people who know it don't like it you'll find a lot of reasons. And also when you discover other languages for comparison.
Yes, it's a meme at this point. But it's a meme with a foot in reality.
PHP and JS actually have a super similar original concept. PHP: wouldn't it be nice if I could have some code in my html that I run right before I send it to the client? Then I could show today's date without editing my webpage every day! (JS is the same thing but the it runs after getting to the client).
Some decisions made lots of sense for this very limited concept, but then they're not good when you're making a full blown application. Loose typing, for example. Of course1 == '1'since everything comes in from the request as a string anyway. Might as well make it easy.
I know I haven't listed many flaws, but maybe this will help you understand the root of the flaws other people mention.
There's a cycle with programing languages, and the tech economy.
Then, someone will figure out a good framework or pattern for getting people going in some language, where you can standup a basically functional system pretty fast.Unrelated, there will be a rising growth of job opportunities in the tech sector.  Businesses and startups will start using the "easy and quick tool" to get projects started fast, and hire people who know that tool.Because the barrier to entry is low, you get a lot of newer, less experienced programmers churning out a lot of code really fast.Because it's easy to learn, the code works, but the thing that they lack is "experience writing and maintaining code long term".  So the code gets kinda messy, and a lot of people are touching it, and pretty quickly it becomes hard to understand.
The business either thrives, putters along, or goes under.  If it goes under code quality doesn't matter.If it putters along, then you get people making incremental changes to the code base over time, and they either already have, or develop, some sense of the qualities that lend themselves to long term maintainability, and grow frustrated that it's absent from the system they need to maintain.  A new generation of people withopinionson how to properly do$languageare born, because they see what didn't work, and what did work when the were able to fix up parts of the system.If it thrives, then you can keep throwing money at the mess until it grows untenable, and then throw money at fixing it in a variety of different ways.  This churns out different frameworks for doing things that don't suffer the growth problems they ran into, or sometimes different programing languages entirely.  And so you get people with stories of how moving away for the language fixed their problems, and the old way isbad.
But in all three cases, you get a lot of people who see the language and framework used in the worst possible circumstances.  Obviously, it's the language that's to blame, and not the circumstances.
You see the attitude with basically any language that was widely popular at the start of a tech boom.Perl has a reputation for being unreadable, even though maturely written perl is basically fine.Php is a garbled mess, even though if you follow best practices it's fine.Javascript is the worst, even though you can use it totally fine.Python is... Easy to learn, with many flexible frameworks and great applications to web development and data science that can lead to a very profitable career!  This 90 day bootcamp will help you get a job fast and teach you the skills you need to start developing applicationsnow!
The lesson is that every system has bad parts, and the potential to be used to make a really, truely difficult to maintain and understand system.  It's got nothing to do with the language, really, and more to do with making maintainable systems beinghard, and a skill that's not easily taught to people without maintenance and incremental development experience.
Modern php is in its best shape ever
This is an age old question, but I think it makes perfect sense to learn PHP. A decent chunk of all web services are written in PHP and companies need skilled devs to maintain them. I'd say it's a good language to help you get started, but there's no reason for you to stop at PHP once you feel you're knowledgeable enough. JS and TS are probably next on the list because you can do both backend and frontend (including mobile) apps with them.
I feel people are a bit too opinionated on languages in general. To be honest, for probably 90% of apps, it won't really matter what language they're written in as long as they work from a business perspective and businesses won't need to spend a fortune on developers just to handle basic maintenance.
As someone who learned PHP post 8.1 I did find it very much worth learning
Things I like:
Lots of packages available via Composer, and lots of extensions available via PECL. You can pretty much do anything web related you want. Symfony components are amazing.
Good suite of developer tools available. I do PHP in VScode, with Intelephense, PHPstan, Xdebug, and php-cs-fixer. Using these tools I've been able to cut down on time spent debugging by a lot. A lot of people here also love PHPstorm.
Nice syntax. Match statements, autoloading, constructor property promotion, traits, interfaces, enums. Lately I've been experimenting with Fibers for concurrent scripting, they are great.
Overall I think learning PHP was a good choice for my career. I work in IT and it helped me really stand out and get hired at a great new job recently. I'm able to automate and script things really fast and get rid of a lot of tedious busywork. I hope to go into software development in the future. While I do think the language has a little baggage, overall I think it's heading in the right direction.
As someone who learned PHP post 8.1 I did find it very much worth learning
Nice to see what you outlined, it's IMO a good path of learning PHP as most new comers typically goes through CMSs and magical frameworks right off the bat.
What kind of answers do you expect is this sub?
Learning PHP gives you a fundamental understanding for other languages IMO. I started in PHP and found JavaScript / React easy to pickup. Then I learned typescript typing was  bit of a learning curve but now I love it. As a result I was able to pick up Java pretty easy.
Learning any modern language is valuable. I'm currently learning Python. This should lead the way for rails.
I have worked with PHP my entire life and i love it!!! The current state is the best one. The Laravel framework have levereged PHP the last years.
Laravel have the bigger community and the best ecossistem.
Symfony is huge too!!
Some considerations:
PHP is the most used for websites, blogs and monolithitic systems.
PHP is not usual in microservices.
javascript wins php in numbers because it is used in the frontend.
Javascript is more usual than PHP in microservices
Python is more usual in infrastructure automation(DevOps) and DataScience.
Most of linkedin opportunities comming to me are related with javascript, Java and python. Just a few PHP opportunities even having a strong background with PHP.
Most of linkedin opportunities are related with microservices.
In conclusion you should pick between PHP, Javascript and Python. They are both good choices.
It's pretty fun if you are making websites. It's loosey goosey and kind of a wild west with so many different ways to do things. But if you have an issue there's probably a PHP function already built to help you out. How can you argue with a  language that has an Elvis Operator ?: AND a Spaceship Operator <=> ?
No cool name for it but ?-> in PHP 8 makes me so so so so happy
Just to expand on this, PHP started off as a templating language for html, grew into a functional language and then introduced OO.
Compared to Ruby or Python; both have been around for at least twice as long as full blown languages, they come from the opposite direction where web based libraries were introduced to them (rails, django etc).
Further adding to PHP's misery was the development of WordPress, drupal, joomla, silver stripe etc when it was just learning about objects - and around this it was the easiest free / open language to use.
What this meant was PHP gave the world some of the easiest free web apps to deploy and manage, working on coding principles that were incredibly archaic, during a time of the dot com boom and bust where demand for easy, free software was high. This also meant your average Joe with a bit of reading and tinkering could put up a site with minimal fuss.
So now a huge chunk of our web is running some really old PHP code, which is difficult to deal with; more in the sense it doesn't follow established patterns laid by more complete languages which many don't want to sort through vs any technical difficulties.
Web 2.0 movement really took off roughly 5 years ago, CS graduates found web apps could work with languages and principles they know and now we're in a place where smart educated people can use familiar, tried and tested methods to build applications on the web, after having to deal with legacy PHP for the ten years before that.
So yes, there's a bit of a reputation with php that it's slowly shaking off. It's still incredibly popular, making huge strides (laravel, symfony) and hell, Facebook used it for its first couple of years (and still do, kind of).
What it needs is people to use it like the OO language is aiming to become, not WordPress or some other legacy code based framework / cms.
P.s. I haven't double checked any of my statements regarding timelines etc, someone with a better understanding of the history can probably correct me, but the above is a general gist as I understand and remember it, and why PHP is where it is.
I work at a company that's a MS House. My last developers meeting was nothing but badmouthing PHP and I felt cornered. I code in C#.NET/VB.NET, but have always found PHP as my fallback when something is either too costly (licensing) or overly complicated (I started webdev with PHP). PHP gets the job done, but as I've said, given I work with other .NET programmers, keeping us all on the same language/framework becomes a necessity. I feel that if I worked in a purely PHP environment, the badmouthing would be very much the same for .NET/Ruby/Python or other popular languages.
Another reason I see very little support for the language, in my environment, is the fear of supporting code no one has any knowledge of. Of course, I do, though you won't see me speaking up when a large PHP project loses its key developers. I've got enough on my plate as it is. :S
It'sabsolutelya viable choice for web development, and it's entirely possible to code consistent, well-tested & documented projects using modern programming concepts and methodologies in PHP. As well as one bad reason that it's derided by many (bandwagon hatred), here are four good reasons why it's derided by many:
It's a goddamn mess, and refuses to break compatibility in order to reform. The global namespace is a rat's nest, unicode support is strange and inconsistent, function names and arguments aren't consistent, sometimes you get errors and other times you get exceptions… in many places it's just plain ugly.
Most people who hate PHP formed that opinion years ago when it was much worse than it is now (which isn't to say it's any less of a goddamn mess, but now there are namespaces, lambdas, stronger OO, reflection, good testing/documentation/development frameworks, two large libraries of good code, etc etc).
Many (most?) popular open source PHP projects are coded spectacularly, unrelentingly badly; either poorly written or poorly designed. It's hard to defend PHP when there's stuff like Wordpress out there. Supporting or dealing with these projects forms the bulk of most non-PHP coders' experience of PHP, so no wonder they hate it.
Unlike some newer, more fashionable languages, or languages that are led by a strong authority, there's little cohesiveness among PHP coders; instead, there are hundreds of minor communities usually organised around specific projects. They're largely siloed and don't present a strong voice, share code, or even think similarly. There's no "Zen of PHP". It seems to me that this is less true that it has been in the past; there's more sharing of ideas and code, and more interoperability between projects and libraries. But we've got a long way to go before we can present a united front.
personallyILove_it();
I thought the function name was i_personally_love_it(). Same function, but the parameters are a completely different order.
People hate PHP, because they see a language that is arguably worse designed than their language of choice, but is still orders of magnitude more popular.
It's a very popular language therefore the % of bad programmers goes up.
People always complain about how PHP is insecure, but the truth is bad programming = bad programming.
Some people mistake their tools for what they can do with their tools. They think that the tool must be perfect. And in it's perfection they too will be perfect.
It's the poor craftsman who blames their tools when something goes wrong.
And some people just have to have something to hate.
Sometimes, though,tools can be crap.
I was never able to move from PHP to something else. I tried nodejs for a few months but it always seemed much more complicated. Especially the dependency and build system.With PHP to move my code to a production system I just need to run `git pull` and the new codebase is instantly live. No builds, no server updates.The Markup system of PHP is also very very handy. No more messing with handlebars or external libraries.Realistically you can start a small site with PHP and HTMX and no external PHP package dependencies in an evening.
I'm in the same boat! PHP is so insanely functional. There are a lot of powerful frameworks but I personally like to keep my projects very simple with minimal dependencies andnothingcomes close in terms of how fast I can go from idea → prototype → production. PHP + SQLite is a beast.
In case it wasn't obvious from the context of the rest of my comment, I was using this dictionary definition of 'functional':>designed to be practical and useful, rather than attractive.It gets the job done. Really well.
Functionalhere means that it functions well. Not that it's a functional language.
all he said is that he can get his work done.definition of "functional" is "designed to be practical and useful, rather than attractive"
And all I said is, that most people understand something different under that term, when talking about programming languages ...But thanks everyone, for the dictionary definition lookup.
I spent years making money off of PHP. I was doing PHP when shitting on PHP was cool.I spend most of my time writing GO now.Go + htmx + tmpl is all you need for a basic site. The go runtime produces binaries... While you're still installing php and a web server, my binary is already running and in systemd.Need validation, grab validator. Need a DB, grab sqlc and write sql and then have the code for your API calls generated for you!!! (This bit of code generation feels like magic candidly)Need a command line tool? GO.Have to build a Key Value store? GOWant to build a database? GODo you need a container deploy system ... well Kubernetes is already in GO...There was a magic to LAMP and PHP 4... it was the right stack at the right time. When I work in go now I feel all that magic again.
Why? Like, besides some basic cli tool, and some “system” network programming (what google meant in their marketing, as go is definitely not a system language), I fail to see any benefit of that thoroughly uninteresting language.It’s basically Java 1.2, sold in “Unix-flavor”, somehow making it acceptable to the people that otherwise hate to touch anything non-C (and in extension, never having used anything more modern)
Why go:I like Rust, and zig. Both end up with better performance than go. All three will output portable binary.I like Ruby and Django. I can get a V1 site out faster than I can with go.Java is java. Its great if its huge, but hard to do "simple" in java... and the specter of "is this the year oracle fucks every one" looms large in the java ecosystem.The compile/test loop for GO is stupid fast. How go deals with dependency is fist class. Go nailed concurrency model has found a sweet spot between safety, ease of use and developer performance that is unmatched.Go is the "brutalist architecture" of programing. Most people look at it and go "why" but if you embrace it, and adopt it, there is an effective sensibility that you're not really getting elsewhere.
If third party libraries are important to you, it's hard to recommend Go over PHP. Everything is available in PHP. Go is still very new. Maybe you can code all that you need by yourself, but that's a pill some companies won't swallow.On another note, whether or not I can make a database in Go is irrelevant. We're talking about replacing PHP, a web language. Why would I need my web language and database language to be the same?
>> Go is still very new.Well over a decade old.>> If third party libraries are important to you, it's hard to recommend Go over PHP.There are plenty of third party libraries for go. This is where most of Go departs from PHP/java/ruby. Php/ruby you might look to something like larval or rails. Java had spring/hybernate/struts/grails (there's a lot there).  Is there A framework you're going to jump on in Go? No, Go isnt Rails, it isnt omakase. Go has a ton of parts that "just work" and work well together.You can pick an ORM (gorm) or use code generation like SQLC (magic!). There is a clean validation implementation that covers 99 percent of your use cases and is easy to extend. If you hate that there are 3 solid alternatives. Do you want a custom router, there are lots of choices but the standard library is good enough. How about logging? Works fine out of the box but plenty of choices here too. Auth, Identity and Access control what do you need there is a middle ware for it already or you can build one in 10 minutes. Are you parsing massive JSON files? hey if the standard lib is too slow there's 4 other choices depending on your use case.Want to recycle all your code for CLI tools or service workers ... go is a hell of a lot more elegant than ruby or PHP for this (better concurrency primitives).> On another note, whether or not I can make a database in Go is irrelevant.I have a little project: the web server, the DB the, images, everything. One simple binary, one config file. Im not installing web servers, run times, databases. It's clean simple and out the door. Im playing with a search engine in go that looks like it could be mixed into that same binary and be 75 or 80 percent of what a solr/open search server would be.Would rails or larval be faster to launch. Sure. Are they going to keep getting features out ahead of go after 6 months or a year. No things are gonna be really even. And when ruby or PHP hits the wall (and they have a point where scaling them stops making sense) then what do you do? Port to java... or go? You could just pick go from the start and scale it all the way out. Binary blob monolith to scaled services you can just stick with go....
I think you're underestimating how big the PHP ecosystem is compared to Go. Auth, Routing, and Sql code generation are basic things that every ecosystem offers. Even obscure languages have these things. Furthermore, Golang is a famous pain in the ass to parse other people's Json, but is fine for known data structures. It's a great example of where the simplicity of the language falls short as well.As a side note, golang doesn't seem to offer anything even close to what other ecosystems offer for Auth without using a third party service. They have some pretty basic libraries from what I've seen, but I could be wrong. These are not things that you're gonna roll in 10 minutes.When working for clients, and they need to connect to an obscure payment processing service, you could roll your own. But I don't want to be the one to tell them why we can't connect to these services without writing these things ourselves when their competitors can because they chose a language like PHP
>> As a side note, golang doesn't seem to offer anything even close to what other ecosystems offer for Auth without using a third party service.https://awesome-go.com/authentication-and-oauth/Theres ORY if you want your own in house auth zero...There are piles of other things out there.>>> They have some pretty basic libraries from what I've seen, but I could be wrongBasic, maybe... Minimal closer. I like to think of go as brutalist architecture its so drab and functional that it feels ugly, void, and lacking.Look at go's standard library. It's complete, but there isnt a lot of flash there. Good go packages maintain that stance. They give you enough to finish the job. Your not gonna find a package with a lot of "utility" functions in it, your not gonna find a lot of "left pad" like micro libraries.And when you adopt this sort of thinking you dont really need as many choices. When every thing is boiled down to "this is functional/working" it doesn't leave a lot of room for implementation details or interfaces as distinguishing features.
I like Go. But how come they have not fix the issue with implicit nulls? Null guards everywhere... I cannot believe that a company as mighty as Google did not choose to use decades old insights on how to fix this.Now it's really hard to fix. The std lib already does implicit nulls all over the place.Kotlin kind of fixed it for Java, and it really helps us.PHP is old, and makes it easier to forgive it's mistakes. But Go?
> I like Go. But how come they have not fix the issue with implicit nulls? Null guards everywhere... I cannot believe that a company as mighty as Google did not choose to use decades old insights on how to fix thisThey relied on decades old insights of persons who worked on C and Unix. That said, I'm honestly still on the fence about if nil checking is really braindead, or just what it boils down to in the end and the rest like exceptions and Options/Result is just theatrical.What I don't get is that they are not more pedantic about checking nil errs in the compiler. They error hard during compilation on unused variables, but err checking is simply not done.
I also use PHP this way and the speed I'm able to get something from a database to the page and iterate is still unmatched.
And that's why people look down on it - it's the same as how movie reviewers don't like regular movies, or book reviewers only like complex barely-readable books.The simple stuff is just too boring once you are an expert in the subject.
Personally I never shat on php because of simplicity but because of lack of expressiveness, limited language constructs and bugs. Combined with the massive new crowd going into programming with it, it gave rise to immense walls of pain (I remember wordpress sociable code source 12 screens long loops visually..).Later they started to move away from all that with PSR, typed object layer and more es6/py3 set of features.
I would argue it's not the same at all.If you're very much into art, you've probably seen the simple stuff already, and you would prefer to see something that surprises you or makes you think instead of the nth iteration of the same tropes.But PHP is a tool, and youwantyour tools to be boring and reliable. (Whether PHP fits the description is a different discussion.)
You'd be surprised. A lot of programmers want complex tools because they are more interesting. They also tend to write unnecessarily complex code.For example instead of just doing something there are multiple levels of indirection and instead of simply operating on a variable they tend to setup overly complex types that get passed around. Obviously sometimes you need that, but I'm talking about adding this complexity when it's not necessary.
Of course those people exist, and they also exist in PHP land because as soon as you start using its more advanced features itisas complex as the other mainstream languages.But I would guess that a majority of developers that are not CS researchers value simplicity over complexity, at least in theory. After all they’re just trying to get shit done.
Similar to how Stephen King will never win the Literature Nobel but he is such an incredible writer.
I suspect it's actually you that doesn't have exposure to PHP. I have exposure to about half of those, and I like PHP.> are better at judging the merits of moviesTheir definition of "merit" is "surprises me and brings something new to the table", while a regular person wants "is entertaining". i.e. they are better at judging the merit of something not actually wanted.
Maybe upgrade to a recent version of PHP from the last five years. It has strong typing, not just hints in comments.If you like strong typing, great, but many popular languages have weak types and dynamic types by design. It’s not some horrendous oversight.
interesting that it finally landed.But just because PHP apparently added reasonable typing in >7.2 still makes it a ranchy languages for most of its lifetime.Anyway ranting about it doesn't imply that i hate it or that i haven't used it. Its one of my first languages, but from my personal view, php is a shitty language in comparision to most others
You would have to compare PHP to the alternatives available at the time. Originally PHP replaced Perl and ASP, which have their own problems and no static types (back then). Ruby/Rails came out and got traction but was slow, buggy, and still no types. Python also slow, no types, and not great for web development.Then we got Javascript and Node, with even less sensible types (no integers!) so you have to use Typescript and lots of tooling to get what PHP offers.In enterprise environments Java and then C#/.Net dominated and did have strong typing, but that’s not the world of PHP.Comparing PHP from a decade or longer in the past to Go et al. hardly seems apples to apples.So if you want to dismiss PHP as “shitty” compared to “most others” define shitty and identify the others.
PHP without types / types in comments existed in parallel to spring boot for years.And im pretty sure that the history of PHP is still everywere inside PHP, like php function inconsistencies across the board.Or whats the current situation on unicode support?When i started with PHP4 and Lamp, what a great time. JavaEE was bloated, not a lot of good free webservers available, granted.But while PHP5 was great and had a loooong shelflife, JEE became much cooler and had fundamental critical things like CDI and really good CDI Frameworks.Eclipse Java IDE was always really good, something PHP hadn't had for ages.And if you look at the fundamental difference between lets say java and php: In Java you have specs and reference implementations (partially also thanks to oracle, you now have mulitply companies having their JVMs) which made the JVM very robust and fast.When Facebook did the hhvm/hack stuff, that was great and pushed enough nerves to rethink the performance of PHP but the performance gains were stupid crazy. Thats a very good indication when a language with so little money and support has such a huge performance gain after such a long time existing.The fact that Facebook than threw the PHP community under the bus with hhvm/hack didn't make it better.
I don't think PHP and Java really compete for mindshare. Java has mainly thrived for larger enterprise projects, whereas PHP appealed to individual developers and smaller businesses, and applications like WordPress. Of course there's overlap and companies may use both, but writing a web application in Java requires significantly more investment than choosing PHP.Eclipse supported PHP from 2007, and the PHPStorm IDE from JetBrains dates to 2010 or 2011. Java has always had better tooling because of the enterprise focus. PHP IDEs are very good today.PHP 7.x and 8.x have seen big performance improvements. I haven't seen hack/hhvm get much traction outside of Facebook but maybe it did.
I don't wish to put words in your mouth, but it certainlysoundslike your argument is essentially, "PHPwasbad, therefore PHPis and will always bebad, no matter what improvements it makes."This...doesn't seem particularly reasonable?You're not required to like PHP, and you don't need a reason why things you dislike are objectively bad in order to be allowed to dislike them.
Its just a discussion and my personal opinion i'm sharing.Its hn, i think its reasonable to discuss asthetics of langauges?But yes the history of PHP is murky and i do believe, that a few small changes could have big advantages for PHP and because PHP was one of my first languages and i also developed for it for a few years, i do have some type of connection to it.Just imagine having a more community / sig driven approach defining a spec first, than having a reference implementation and opening it up to others.And a PHP base rework would also help. Rethinking the architecture and code, cleaning it up and fixing issues which are still there because of it like unicode support.
> It has strong typing, not just hints in commentsEven for arrays?
PHP arrays areordered maps, not arrays of a homogenous type as in Go or Java. Array is a type in PHP, but all arrays have the same type, regardless of what they contain.You can describe the expected value or key/value types of an array in PHP doc comments for IDEs and static analyzers, but PHP won't enforce those.
I write go so... types.Types are great and they have downsides. Perl, PHP, Python, Ruby, JS, Lua, lisp, objective c are proof that you dont NEED them to have working code.
there are many loosely typed languages that are used professional (in addition to PHP). dynamic typing it has its pros and cons but that doesn't stop it from being used professionally.
My point was that the professional side of PHP developers at that time, decided that they want to have a strong type system.
What did you have to build? `node index.js` and it works, without build.And what did you mean with "no server updates"? PHP has to be updated and the server processes has to be restarted.The markup of PHP is a mess, OK js is not much better :DSure you can start PHP without any dependency, cause it has a "million" dependencies included.And yes, i use both. The right tool for the right job.
> Sure you can start PHP without any dependency, cause it has a "million" dependencies included.This is exactly what good/great languages are doing: providing a standard large standard library.
I do not agree, that this is the only way of great languages. Great languages in my opinion are those, that implement concepts in a way, that they compose well and enable you to do anything you want elegantly. With the concepts they implement, they give you an answer to any situation might come across, without forcing you to write tedious ugly code as a workaround for lacking facilities.Perhaps what you refer to are great ecosystems of programming languages?
> And what did you mean with "no server updates"? PHP has to be updated and the server processes has to be restarted.This is not true. You can update a PHP file without restarting your server, and it will run your updated code.
> With PHP to move my code to a production system I just need to run `git pull` and the new codebase is instantly live. No builds, no server updates.Make sure your .git folder is not "instantly live" as well...
low-skill sounds much more negative than "not complicated enough to constantly fail" :P After so many sightings of bespoke build tooling I kinda miss this part the most.
I mean, if I had been doing PHP-only professionally for years and then as an alternative merely checked out NodeJS, I wouldn't budge either, I think. But NodeJS is not known to be an elegant, fascinating or even horizon expanding language. None of that. So I am not surprised. Additionally it is kind of in the same language family as PHP is (while there are differences). Add to that all the overhead you have with minifiers, bundlers and whatnot, and I can understand easily, how one would not want to switch to NodeJS coming from PHP.However, it might be a good idea to try languages, that are encouraging different paradigms, belong to another family of programming languages, or are often used for other things than PHP usually is. Try a Haskell, try an Erlang, an Elixir, a Scheme/Racket, a Rust. Languages so significantly different, that they add value for your learning experience as well as enabling you to do new things and get to know elegance in programming language design.
PHP has a special place in the story of the web-dev.The whole "no build step" was the most underrated factor for its success, because it was such a low-skill tool to pick up.The tightness of that edit-test-move loop was why I used it, even if the "edit" included "sftp it to a vhost".That bit is what made it successful & I can't think of anything I've used in the last decade which felt as easy as PHP for that particular style of self-taught programmer.
Back in the day when VS Code didn't exist and even sftp was rare and the world ran on port 21 classic FTP, we had code editors with built in FTP like PHPEdit, we would literally hit Ctrl+S and save and upload the file on production in one stroke. Refresh the page in browser on the live site and there it is. Those were the insane days before terms like agile and CI/CD were even invented.
Yes insane and after upload "bang error", sh...t, fast fix the error and upload it quick again, befor anybody register the error :D :D
Ctrl-Z, Ctrl-Z, Ctrl-Z, Ctrl-S!
I still do this! Often still over FTP, sometimes over folder mounted over SSH.
Scrum is older than Linux.
I didn’t touch PHP for a long time but it have a nice place in my heart especially for the reasons you gave.I have a hard time with people joking about PHP because while it wasn’t perfect back in the day, it’s probably the culminating point of the non elitist computing. PHP was accessible to anyone who had the basics of creating an HTML website (which was a skill any random person could acquire in a day or two).Also, the people making those jokes are most of the time working on projects with micro services and SPAs everywhere for a boring business app with CRUD and forms. Which I find pretty ironic since a single PHP monolith solved this exact use case 20 years ago.
Also, it had dirt-cheap hosting, as a single process could host multiple sites (though it did come with some security implications).Nowadays we tend to bring up a whole virtual OS.An interesting direction in this area might be GraalOS, which might allow running multiple applications in a single OS process, doing the necessary isolation itself. (Not affiliated)
I'm taking the "no build step" thing to the extreme in one of my projects.PHP has libraries for compiling SCSS and minifying JS, and filemtime() is very fast. So if you wire them together in just the right way, you can edit any script or stylesheet under the project hierarchy and have them compiled, minified, and bundled together on the fly. Cache the bundle until you edit one of them files again, and automatically bust the cache once you do.No need to build anything whatsoever, both on the frontend and on the backend. It's like REPL over HTTP.
I can confirm, this approach works great!I use this in production for a system with 3k requests per second that runs in a single Apache+PHP web server and a single 80GB MySQL database. Never needed to optimize anything.You have no idea how happy it makes me to see someone else was bold enough to try this and it worked for them too.Simple, maintainable, instant SCSS and JS build pipelines with all the benefits and no drawbacks! Plus any junior can understand and change it in minutes.
> PHP has libraries for compiling SCSS and minifying JS, and filemtime() is very fastIf you do compiling and minifying, that's a build step.
Every human-readable programming language must be compiled into some sort of bytecode (opcode in PHP) and/or machine language in order to work. The question is whether a human ever needs to be aware of that step. In PHP, you generally don't. In the aforementioned setup, you don't need to be aware of SCSS compilation and minification, either. Not even if you use devtools, because the map file will point to the correct line in the original source.
The usage of the term 'step' here is in the pre-deployment development process sense. I think what this person is doing is converting SCSS to CSS on request, at runtime.
Regardless of which steo, compilation process is typically done as part of a build step, where the SCSS files are transformed into the final CSS that will be served as a bundle to the end users' application.Web browsers can't understand SCSS natively.To be truly extreme (performance), devs should consider tree-shaking unused CSS and JavaScript. This may require using Vite (Rolldown is in the works/Rollup) if there are no other options or it makes no sense to serve bloated resources. That's the reason, I chose Astro as I care about users, not prioritse the developers' minimalistic workflows.I prefer Tailwind because it allows me to avoid duplicating classes (mine and vendors), which is an advantage over other approaches.I did dogfooding in Go development.
Hot Module Replacement and Live Reload in Node-based web dev servers bring some of that magic feeling back, although you will quickly need to learn about module resolution and other intricacies.
The criticism is that those things comes with mountains of complexity.
That is the problem of the tool developers not of the app developers. For us, it is easy to use.
It also breaks easily. Npm is a very unstable platform.
I liked the documentation. The old documentation, in a .chm file.
This also lead to shitty tool integration.While it was always easy to debug java based apps and the debug support is great (remote connection, drop frames, all types of breakpoints etc.) people struggled with this in php.I showed a professional a few years back how to debug with php, after 2 weeks he stoped using it...
Why on earth would you need to build PHP or its extensions from source to build a useful web project?
> It's only easy to start up to hello world kind of projects.Sure but the important part here is it’s also easy to deploy to the internet for free or a few bucks.All you said is right but still, I don’t think there is anything comparable nowadays and if I had to explain to my son how to create a basic non static website without using proprietary PaaS, I’d have a hard time (without PHP).Was it the best option when you were a company building a product ? idk but at least it was a viable option. Was it the best option for any kiddo wanting to learn creating things on the internet ? Totally and we never got anything better for this since PHP.
How would you describe something useful?Can you give examples of counterintuitive idiosyncrasies you must deal with to be productive?
PHP and the ecosystem around it, especially Laravel, makes developers incredibly productive: everything is so damn easy.Nothing comes close to it in Go, Ruby, JS (Node), Python; from what I've seen. Laravel is one step ahead.
I worked with Laravel and trust me, it's a pain in the ass when you have a medium/big project. The "documentation" (more a how-to) is full of bad practices, the facade pattern makes it hard to refactor or change the underline logic, you can break the contract easily (it's just php annotations, not real type-hints), the ORM is a pain to test and has too much magic, you use strings to set the validation makes it hard to understand when it's not trivial, the request->input() takes query/body so you end up mixing everything and some clients use the API in various way, there is helpers to get the config/service anywhere (even in static methods) which makes it painful to test and refactor, etc. I strongly recommend to use Symfony instead, the documentation is great, the profiler is built-in, the cache is better (faster), it's type-hinted and strict, there is interfaces, it scales well because it's flexible and well thought.
> I worked with Laravel and trust me, it's a pain in the ass when you have a medium/big projectEvery language is...
My thought on NodeJS is I've experienced incredible productivity with Astro web framework, as everything is written in TypeScript.I'm familiar with Livewire and have used AlpineJS, but I plan to adopt Qwik (Resumability) as a component in Astro, which addresses frontend performance. One step ahead of others now that I don't have to maintain Go language as a backend which took me months to migrate to TypeScript for a medium size platform.
I'd love to see something like laravel/symfony in go/rust. If anyone is willing to give it a shot I would've switched yesterday
I've thought about doing a Laravel-like framework in Go, but one of the superpower of PHP/Laravel _is_ the possibility to have very loose / no types, which gives a great DX when used correctly, but in Go, you'd have to interface{} so many things that the resulting code would be non idiomatic / not as performant as go can be.And then, you'd need to have an ecosystem as strong as Laravel which... wow... would take a _lot_ of investments.
Honestly it’s pretty hard. We are talking about frameworks with decades of development. It’s not something that can be done by one developer, you need corporate levels of investments at least to bootstrap it.
Well, no, that's not really a fair assessment. Someone is quite literally doing "rails but for Rust" with loco:https://loco.rsAs far as I know, the bulk of this effort has been one developer pushing it along. I wouldn't personally use it but it _does_ exist.It's also worth noting that these older frameworks all come from a different era of development - nowadays most newer devs seem to want to build microservice-after-microservice, where these don't quite fit into the picture.
They are doing it and I hope they succeed and prove me wrong but last time I checked Loco was still far from Rails.
> Nothing comes close to it in Go, Ruby, JS (Node), Python; from what I've seen. Laravel is one step ahead.I can't really agree with that when Express and Django exists in this world. But Laravel is indeed amazing piece of software
Express from Node? That's not even comparable. Express is a simple routing solution, Laravel is a framework packed with features.
Express is not in the same category as Laravel, what gets closer to Laravel in the NodeJS world would be Adonis (that I know of). Express is essentially a modular router (for people that think that server-side JS is a good idea)If you run `laravel new my-app`, you got an application with caching, database, queue, views, translations, whatever else you can think of, ready to use with things like Oauth / Payments / E2E Testing / Feature flags / Search... a command away.You don't get that with Express, you don't get that with Django, from what I've seen (but I'd be very happy to be wrong!)
Express is simple but it’s pretty barebones, nothing comparable to Django or Laravel.But yeah Django is nearly perfect, my dream framework is Django officially typed in a world where the python community get its shit together with type checking.We are not far but I miss having good IDE auto completion and not having errors in my IDE as a reliable source of confidence.
PHP is slowly gaining ground on strict typings and every update brings new features. It’s really fun to see losely typed methods over time being refactored to typed methods, giving you that slight peace of mind in every step. Big kudos to the PHP and Laravel community.
Django is comparable. A little harder to deploy (well we have docker now so who cares) but still incredibly productive.I mean, with Django, literally just defining your database models in models.py and not touching anything else is enough to have a working application with a full featured admin backend with authentication already built in.If you define your models correctly with the good constraints you are literally left with writing your HTML views and/or API endpoints, adding permissions and call it a production app.I’ve never touched Ruby but it also sounds like we shouldn’t discard RoR in terms of productivity.
> I’ve never touched Ruby but it also sounds like we shouldn’t discard RoR in terms of productivity.I'm doing some Ruby for work and I hate it with passion every time i have to touch it.Official tutorial-style documentation for Ruby is largely non-existstant (except for a book from 2002 that teaches outdated stuff from ruby 1.3). Learning ruby is 99% monkey learning, as in reading some random tutorial off the web and then doing some monkey-see-monkey-do. It's awful and it's frustrating.Python on the other hand is extremely well documented:* Tutorial:https://docs.python.org/3/tutorial/index.html* Standard library reference:https://docs.python.org/3/library/index.html* Language reference:https://docs.python.org/3/reference/index.htmlGuess which language is thriving and which is slowly losing relevance?
I've worked with both, Laravel and Django, for many many years.Laravel is miles ahead of Django, in every single aspect. The template system is incredible while the django one is stuck in the 90s. The integrated job queues, scheduling, asset bundling, etc, etc. And yes, you also have Admin interfaces for Laravel, both paid and free, and they're as good or even better depending how you look at them. Community is also a lot bigger which means more packages and better maintained.
> I’ve never touched Ruby but it also sounds like we shouldn’t discard RoR in terms of productivity.RoR is insanely productive.
Python has been doing web frameworks for quite a while now - starting late 1990s with Zope & Plone.
Laravel is Rails clone afaik
java/kotlin with either spring boot or quarkus.
PHP is a great language to learn OOP, classes, interfaces, abstract classes, traits, managing dependencies and unit tests. I'm not using it anymore but I learned basically everything with it a decade ago. Thanks PHP!
A good language to learn OOP is Pharo or Smalltalk.
I thought the blog post would introduce me to how PHP in 2024 somehow got rid of all the cruft from ages ago, but instead it merely talks about some frameworks. Probably high level frameworks are what saves PHP from dying, because they mean, that people don't have to deal with as gnarly PHP all the time, but going so far as being excited about them? Sounds more like a justification to still keep using this language, despite all the other often better language options out there. Heck, I would even prefer writing Java these days, than going back to PHP.
PHP these days is pretty much fine, it is nothing like PHP 5, IMO. I started working on something a year ago and it was way better than using any frameworks. Initially I did start with a framework (Laravel), but it had its own limitations (and bloat) so I decided to do it from scratch. The code was much more manageable, understandable, etc.
Could you share a project you did? I would like to compare to my past PHP writing.I also found, that doing my own plain PHP imports/requires worked better than what WordPress by default wants you to do for example, so I can well imagine, that something similar can happen with Laravel.
I am by no means an exceptional dev, but some PHP code I've written can be found on my GitHub. None of it uses frameworks, and a bunch of it is small libraries ('components') that make up my own personal functional 'framework'/toolkit:https://github.com/aaviator42/Edit: Link that shows only PHP repos:https://github.com/aaviator42?tab=repositories&q=&type=&lang...
I took a look athttps://github.com/aaviator42/izi/blob/main/izi.php. Basically the first repository that was listed. It looks a lot like what I wrote years ago, which unfortunately, in my book is not a positive. What I take issue with are the following things.iniSettings();
    enforceHTTPS();
    session_start();Global state things directly exposed to the user (programmer in this case). The problem here is, that this kind of thing immediately fails, when things start to use concurrency of any kind, because suddenly one has multiple processes concurrently setting global settings, without any kind of mutex in between. But this seems firmly part of the language??? That is worse! Because it encourages people to use global state just like this.if(isset($_GET["m"]))Apparently it is still common practice to have such "if bla is set, when do blub" everywhere in ones code? No functions with decorators or a similar or alternative concept? I would think there should be some kind of easy to use mechanism in place, that tends to avoid forgetting these ifs.There are ... 60 lines of global logic, that is not encapsulated in any function or so?Some of the functions are quite long. But I think mostly because they render out HTML.At line 107 with the procedure printHeader starting, what I call PHP nightmare starts:Switching back and forth between PHP, HTML and HTML with integrated JS (!!!) and CSS. All of course without syntax highlighting, but that is a minor issue. The major issue is treating HTML and JS and CSS as mere strings, instead of structured data, and the very bad readability of having procedures suddenly "end" and spit out some wild HTML, then suddenly continuing again, because some server side logic/decision is required at some place in that stream of unstructured data, whether some part is to be included or not, then the stream continues and then at some point one needs to actually check, that one did not forget to truly end the procedure. This has some of the worst readability. Maybe C code with bit magic is worse.One can find this kind of approach in many, if not most, Wordpress plugins. What's more is, that this is also terrible for writing tests. The procedures do not return a value to check against. All is a side effect. Perhaps there is some PHP library that manipulates the PHP system, so that one can at least do string comparisons on the side effects. Like mocking, basically. But still terrible for testing.For a comparison of how it should be done instead, check any templating engine, that at least separates template files from PHP code. Better, checkout SXML libraries, that treat HTML as structured data, a tree that can be traversed and pattern matched against, without pulling out arcane string manipulations or regular expressions. And then consider how one could write tests based on such structured data.If this "HTML is a string, even on the server side before sending it" kind of approach is how a language treats HTML, then the language is not suitable to be directly used for HTML templating, without any additional library. This alone has caused uncountable security issues in so many projects.I realize, that this is probably kind of a "one off script" and may not reflect other kinds of PHP code.I did all of those things myself, years ago. And when I already had moved away from such an approach, I had to maintain a project, that was written this way. It had no tests of course. No fun. It has not that much to do with you personally being a good dev or not. I think it has to do with the ecosystem encouraging you to do these things. Outputting HTML like that should be declared illegal and should be impossible.https://github.com/aaviator42/StorX/blob/main/StorX.phpin comparison looks much better. It seems it does not output things directly. Everything seems wrapped nicely into methods. One obvious footgun seems to be another global state thing, that I really hope is not a thing in PHP itself:const THROW_EXCEPTIONS = TRUE;Please, please tell me, that this is not an official part of PHP itself.
> iniSettings();> enforceHTTPS();> session_start();> Global state things directly exposed to the user (programmer in this case). The problem here is, that this kind of thing immediately fails, when things start to use concurrency of any kind, because suddenly one has multiple processes concurrently setting global settings, without any kind of mutex in between.No offense but I take it you don't have much experience with PHP (and that's fine).Because your complain is exactly one of the beautiful things in PHP.It's all per request.It doesn't break.You don't have to think about mutexes.
The project is private, but I hope I will be able to make it open source in the foreseeable future.That said, I do have some book recommendations and some useful links.Books:* PHP & MySQL: Novice to Ninja by Tom Butler* PHP 8 - Quick Scripting Reference by Mikael Olsson* PHP 8 Objects, Patterns, and Practice by Matt Zandstra* Programming PHP (2020) by Kevin Tatroe and Peter MacIntyreLinks:*https://phptherightway.com*https://www.php-fig.org/psr/*https://web.archive.org/web/20230110234256/https://www.cases...
I read a bit ofhttps://phptherightway.com/#errors_and_exceptionsand it makes me doubt whether the author has ever worked with a big PHP project:> The only real difference is that Python will freak out over any small thing, so that developers can be super sure any potential issue or edge-case is caught, whereas PHP will keep on processing unless something extreme happens, at which point it will throw an error and report it.Wtf. The real difference is, that in the real world people will ignore notices, because they are "merely notices" and because "it works right now", when there surely is a code path, that will rely on the variable being defined and that will catastrophically fail at a later stage or point in time, when the issue is much bigger than right when the undefined variable usage was introduced. How the F is this not an exception. If it can lead to errors and wrong results, which it both very realistically can, it should prevent people from continuing to run it. What happens instead is, that people will obliviously go on with broken code, possibly getting wrong results for years, before someone fixes it. Do not forget the manager people breathing down ones necks when things "work" but one still wants to "improve" things.The statement is so disconnected from reality, it really makes me doubt the quality of rest of the content. Like a thinly veiled justification saying: "Oh but this is not actually an issue, believe me, all is fine!" when the house is on fire.PHP is used by so many beginners, but actually due to all the foot guns is more suitable for mature developers, who are very vigilant and strict with themselves, to avoid these foot guns. Basically you cannot let a beginner anywhere near PHP, without a tonne of project setup to safeguard against all of this stuff.
Yeah, to begin with, the default php.ini is pretty bad, too.> it really makes me doubt the quality of rest of the content.I have not read all of it, all I know is that I have found some parts informative, but I have not used this website as my major source. It was mostly the books I have mentioned, especially the first one.
> nothing like PHP 5Nor PHP 4 for that matter.IMO what PHP has going for it is: (1) no build step, and (2) built in templating.  Ease-of-use very high in terms of web development.
Posts related to PHP usually become discussion if the language sucks or not here on HN. I am co-founder of a PHP PaaS and I can confirm that almost all clients are using frameworks or even CMS systems on top of PHP to build stuff. Why not?I am interested how PHP and frontend tooling will work out in the future. Nobody is compiling JS/CSS with PHP (as far as I see). That is usually done with Node.js. Livewire (and Inertia.js) are bridges. Sometimes PHP becomes a backend to provide an API for an SPA frontend.
Will 2024 be the year that PHP users finally feel they no longer have to tell everyone else that PHP doesn’t suck?
I've been being productive by solving real business problems with PHP since 2007. Hope to continue doing so in the future.
Have been using PHP since 2008 and will continue to do so. The community, ease of development and ecosystem around Laravel is unbeatable.
Laravel rocks though I am more of a Symfony man myself, been working with it since 2.1. API Platform has no equal. At $job I built a fully DDD system on top of it and its been a breeze.
In April 2024 PHP reached its lowest position ever in the TIOBE index. It's not even in the top 10 anymore.https://www.tiobe.com/tiobe-index/
Tiobe also has Visual Basic at number 8. I would not rely too much on their rankings.
It's true there are some odd things when I compare it to my own anecdotal bubble but for the most part it does reflect what I see.Python, C#, C++, and JavaScript are super popular. Ruby, Go, and Kotlin have been getting more popular. Etc.I know people who are just now getting into Laravel and I'm sure it will remain a valid framework for years. That said PHP's popularity has only been going down since it peaked around 2010. This is reflected in all metrics you can think of.https://www.tiobe.com/tiobe-index/php/https://trends.google.com/trends/explore?date=all&q=php&hl=e...https://insights.stackoverflow.com/trends?tags=phpIronically, PHP is a pretty awesome language now compared to the days of v4 or v5.
Using PHP with docker the default way would require several docker images to run in parallel, i.e., php-fpm, webserver, etc... I use nginx unit to have a standalone docker image with php, webserver and application, similar as you would have it for a node or spring boot application. nginx unit has no support for http 2/3 and you would require a proxy to support that, FrankenPHP seems to be an interesting alternative for my setups, will definitely check it out!
Second this, FrankenPHP is on my list to check out someday and linda already forgot about it. Seems like a pretty decent option. I did however end up using a Docker image to run a small local project (using Caddy instead of nginx)
Can anyone help me as a newbie? I see many comments saying php is so simple to use, but I'm getting bogged down with Docker / Composer etc etc. There seems to be a lot to learn, am I going about it the wrong way? What's the simplest setup that I can use for production as well as dev (otherwise I'd just use laragon). Thanks.
For me the journey kinda started by checking which was the most common way of installing PHP on the OS I'm using. If you're on MacOS then nothing beats homebrew. 
The main thing is to try and use the latest stable version and then go from there. This should make life easier when it's time to update or when you start to deal with having to install/enable certain extensions.
I've tried setting up Docker but finally just set everything up in Debian so I can use VSCodium without issues.
In production (for a newbie) I would just go with something like a small 5-10$ VPS running Ubuntu with Plesk control panel which will help you setup and keep things updated (you'll have the option/warning of changing PHP version for each website in the control panel)
One (hacky) way to learn is to just install WordPress (apparently not fashionable these days, but I love it) and start messing around with the PHP in theme files. Turn on error reporting and just start breaking things.
Just install Apache and PHP. There are plenty of LAMP stacks prebuilt out there. Amazon Lightsail has a prebuilt LAMP VPS.
LOL
If you are thinking about building a web application, take a look at Laravel. I not a huge PHP user, but Laravel is always on the top of my list for building web applications. It's the greatest web framework to ever exists, even better than Rails IMHO.The ecosystem around Laravel is really incredible and unlike any other framework. They have libraries for every stage of a web application from taking payments all the way down to server management and hosting.They even have awesome libraries like Inertia which are built for Laravel but can be used with other frameworks.It's the only reason I still stay fresh on my PHP.
+1 for laravel as well. I joined a php project for a fresh rebuild in laravel and had mostly .net experience. Laravel was great.The documentation is an almost perfect blend of examples and nitty gritty detail. The documentation is almostengagingif you’re coming from other frameworks.I found myself thinking “wow that’s almost no code, what about this feature or that” and the next section would be the exact topic I was wondering about. Had a blast and could learn more php details as I went
This is exactly what I told my friends the other day. The writers of the documentation do a terrific job placing themselves in your shoes.
Laravel is great if you just want to get something simple done as fast as possible with the simplest, most elegant (at a glance) code possible and don't care at all about understanding how it works, what's going on under the hood, performance, doing anything the devs didn't expect, etc.Everything in Laravel is as obscured, "magical" and opinionated as possible for the sake of making the code "beautiful" (again, at a glance) to the detriment of basically everything else. I really have no idea how any experienced programmer can look at it and think it's usable for anything beyond the most simple project.The mere fact that models are PHP classes but none of their properties that exist in the database are actually declared as properties in the class because the ORM just "magically" puts them there at runtime should be enough to drive away any sane person. And let's not forget the amazing "Facades" a.k.a. glorified global variables filled with magic methods that you're expected to make extensive use of.
Can you give me a few real life examples where you got bit by the "magic" conventions or ran into any serious issue from not explicitly setting properties on your models?Facades are not global glorified variables with magic methods. Usually they're just a way to instantiate and access a class with less code. People complain that facades limit testability. In fact, they're easily mocked. Etc.The docs do a very good job of explaining how things work and how you can override any "magic" you may not like. If something is doing something you didn't expect, you probably didn't read the docs. In fact, a delight of working with Laravel is it's so intuitive that you can often guess how to achieve something and be right.Have you worked with Laravel in practice?
You can look at a Laravel (Eloquent) model and easily see what methods it has. Nothing is hidden -- at least no more than any ORM that inherits from another class which gives it functionality.As for properties -- yes, they're not explicitly described but mapped to the database schema. Other ORMs, like that in Ruby on Rails, also do not explicitly set model properties and just map to database columns. People have been upset about this forever, but everyone else has happily used Active Record and had no major issues, all while enjoying not having to add a dozen lines of code to annotate props.In both Rails and Laravel you can define accessors and setters, either overwriting the magic property for the column or defining new properties.If not seeing the properties on the model is a huge problem, there are plugins to generate them and put them in the model. My IDE gives me direct insight by inspecting the table.I'm happy not to have to write out all the props twice when there's no tangible performance issue and I've never had any other problems with dynamically getting the model attributes from the schema.You're taking a matter of taste and context-based tradeoffs and acting like those reflect unchallengeable principles.Symfony is a great piece of software. So is Laravel. Github numbers alone will show you how compelling so many developers find Laravel. Of course, there will be haters who think they're all stupid, uneducated, bad, idiotic, lazy, etc.Everyone makes trade-offs based upon taste or prior decisions. Consider Django. There, you explicitly define properties, but link them to the type of database column they'll use. Then, you can generate a migration based upon the model, and then run that migration. I really like that pattern. Removes tedium of writing migrations, preserves ability to modify the migrations, and makes things explicit.When I used SQL Alchemy in Python, it completely allowed me to not write migrations, only models. That was very nice, until it wasn't. But then I just had to do a few things manually -- a reasonable price to pay for saving a bunch of time in the other 19/20 of cases.These are all just different ways of getting to the same place. Each has benefits, each has drawbacks, the extent of each which will depend on the project and the developers' tastes.
The only benefit you've mentioned is writing less code. Which just proves my original point about Laravel being for people who want to get things done as fast as possible with the minimum effort possible, regardless of how much sense it makes.>Consider Django. There, you explicitly define properties, but link them to the type of database column they'll use. Then, you can generate a migration based upon the model, and then run that migration. I really like that pattern. Removes tedium of writing migrations, preserves ability to modify the migrations, and makes things explicit.This is exactly what Symfony with Doctrine does, and it's the correct way to do it. The benefits vastly outweigh the "drawback" of having to write slightly more code.
When I work in Django, instead of other frameworks I use, I think "I like this more, I like this less; this works better for me in these circumstances, this does not." But I've never felt it made any sense at all to pronounce one as objectively better than another.In most cases, it is a matter of taste and tradeoffs that vary based upon circumstance.You can keep saying "this is the correct way" with all the conviction in the world, but it won't turn matters of opinion and circumstance into universal fact.
It's not a matter of personal opinion, it's a fact that the data mapper pattern (like doctrine) allows for a better and more maintainable architecture than active record.Separating the data access layer, the models and the business logic (basically a 3-tier architecture) is a widely used and proven industry standard to keep a sane, maintainable and testable codebase.Active record ORMs like Eloquent mixes everything in a single layer (business logic in the model events, data accesses are done by the models), but as soon as you reach a significant level of complexity, it is unmaintainable.Even Laravel codebases that grow in complexity often ends-up wrapping Eloquent in a repository layer.
> Symfony is a great piece of software. So is Laravel.And to be clear, Laravel is a piece ofSymfony software, and a good example of what you can do with Symfony packages and a bit of opinion.There are 13 Symfony dependencies inhttps://github.com/laravel/framework/blob/9.x/composer.jsonalone, and many of the Laravel packages listed in there also depend on them; the Laravel Request class extends Symfony\Component\HttpFoundation\Request, the Response class extends Symfony\Component\HttpFoundation\Response, etc.
Technology companies routinely use/license technology from other companies in their products. If, for example, Apple relies upon Samsung for displays and memory in their laptops, it does not follow that you're actually buying a Samsung laptop.In any event, Laravel has never been shy about its debt to Symfony.
It'sa lotmore than "a bit of opinion". It's a huge framework with tons of unique and original features. You're being very reductive. Yes it does use Symfony components for some core functionality, but that's just a small part of what Laravel offers.
I think we largely agree; I just think "Laravel or Symfony" is somewhat a false dilemma because of this. You can build your own system on Symfony libraries... or you can use Laravel's system that's heavily built on Symfony libraries, with a lot of the plumbing done for you.
> And let's not forget the amazing "Facades" a.k.a. glorified global variables filled with magic methods that you're expected to make extensive use of.Each of the facades comes with a corresponding dependency injection if you prefer. You can write an entire Laravel app without ever touching a facade.
Laravel is a decent web framework, that comes with batteries included and _often_ has sensible ways to override and avoid things if you don't want them.For example, you don't need to use the ORM at all and can just use their query builder (which is pretty good). It's there if you want it, but the framework works happily without it and doesn't get in your way in that regard.I inherited a Laravel codebase from a previous contractor and it was reasonably ergonomic to navigate and extend, because I was able to lean on the framework documentation to understand how it all worked. But there were several points where it was _not_ reasonable, because of Laravel/PHP magic and those were pretty painful to figure out and debug.The reason I wouldn't choose it myself anymore is the magic, the little surprises and hard to debug idiosyncrasies that it provides in order to look pretty. Also generally Laravel, PHP and related ecosystems are moving too fast and are difficult to keep up to date without breaking and/or misunderstanding things. It's not quite JS/npm level of churn, but unnecessary regardless. A more minor point is the baseline performance tends to be on the lower end of what I need.There are ecosystems out there that value stability and clarity more and provide better tools to test and debug the code if necessary, and I've come to appreciate those things much more with experience than other factors such as reducing the initial development time.
What other ecosystems and frameworks are you talking about? I've tried many things across many ecosystems in the last 20+ years and so far, despite any drawbacks it could have Laravel is the best one by a long shot. So I'm curious what those other better solutions you mention are and what are its trade offs.
What are your preferred alternatives to Laravel?
Symfony is more explicit, configurable and has way less magic.
> [Laravel]'s the greatest web framework to ever existsBack when I worked with PHP, we used Symfony and several coworkers very much looked down on Laravel. Symfony was modular and you could easily switch whichever component for your own by just implementing the interface and overriding the dependency injection thing. Word was that Laravel hardcoded many things and was less customisable.What is your take on this? In what way is Laravel superior to Symfony?
This is the big reason I use Symfony for most of my projects.I do lots of refactoring and modernizing of legacy or non-scalable codebases as a freelancer; with Symfony you can replace it module by module and slowly implement the Symfony framework structure.Through some configs, it can do dependency injection, event listener stuff, etc, but the framework is mostly glue around components.With Laravel, you need to go "all-in", and you had to do things the Laravel way. If I strayed from that path, it would make things really difficult.I still work on projects with either of the frameworks, but if I had a choice, it would almost always be Symfony.
Laravel is great for prototyping and fast building. If you want to make a big application with Laravel, it's better to use Symfony-like approach with interfaces and DI (you can do it by using Laravel). 
What I personally do not like in Laravel is their ORM, too much magic calls involved.
Yes, the magic involved in Eloquent ORM, also the central use of Facades or that the models are based on migrations (which uses code comments as a crutch for auto-completion), instead of the migrations being based on the models (how Symfony uses simple PHP objects, from which then Doctrine generates the "missing" migrations).I can live with both frameworks, but Symfony just feels cleaner and more transparent in its workings without using magic to make things look simpler.
I think that people believe they'll switch out components more than they really end up doing, but in Laravel, you can override things within Service Providers, and then use the built-in dependency injection to get the thing you want.
> even better than Rails IMHO.I don't know about that. I have been looking at Rails 7 and there's a lot things in Rails now I like better than Laravel.Symfony did most of the heavy lifting with getting PHP relevant again, Laravel was just better at marketing. Laravel is good, don't get me wrong but everyone seems to think Laravel is the only good thing in PHP and a lot of Laravel is built with Symfony libraries.
Also inertia.js just reached 1.0 and has been really fantastic to work with.
I'm rebuilding an old online community / forum in the TALL stack. It's awesome. I do have to do a lot of raw sql query building to keep it performant though.
So do you just not use Laravel’s ORM?
I do use it, but for some of the more complex queries I use the Raw SQL part of it.
OK, good to know that you can do both.
It has a full-fledged query builder:https://laravel.com/docs/9.x/queries
It's possible to combine query builder, orm and raw sql any way you want
+1 Laravel. Built-in queues is a killer feature that makes your Web App scale with little pain.
- Laravel has many "admin libraries" (Voyager, Orchid, Filament, Twill, Backpack, ...), some of them open core, each with their own idiosyncrasies. Symfony has EasyAdmin.- Laravel uses Inertia for Vue.js or React integration while Symfony has an integrated solution with Symfony UX- Symfony has become more modular with Symfony Flex- Symfony has put a lot of effort into improving "developer experience" in the Symfony DX initiative- Symfony has brillant docs in many languages including a new open book by Fabien Potencier and other Symfony collaborators
> If you are thinking about building a web application, take a look at Laravel.Take a look at Symfony before Laravel. It will be very similar to Java developers who are familiar with Spring.
Looking at the Laravel site, I’m concerned about Laravel’s reliance on an ORM. Not only because ORMs are widely derided, but because I have a legacy MySQL DB and PHP 5 project I want to resurrect. I’m down to rewrite the server, but how do I restore a database full of user data with Laravel?
I work on a project like this and you'll run into some papercuts, but it's not hard.You can take a model for anything in your legacy code, and just set properties on the model to teach Laravel how to deal with things that don't follow conventions.For example, you can override the table name. Suppose you had a legacy table called "postdata". In Laravel, this table would be called posts, and a model would be Post.So you'd just tell Post to query postdata rather than posts.Likewise, you can tell it which fields to cast as dates, booleans, etc. You can tell it which fields represent timestamps for updating, creating, deleting and so forth.You can setup relations that don't follow naming conventions the same way.Theonlyissue I've run into is doing things like setting up relationships across databases. You can do it, it's just not super straightforward.I think you'll find it's a breath of fresh air to have a modern wrapper around your legacy code, and that your legacy stuff will then fit in quite nicely with your new work.
Great, thanks! I’m pretty psyched to get started, after reading these comments.
Laravel is “linked” together via a combination of Composer dependency manager and Dependency Injection. You can easily customize your setup to remove the dependency on Eloquent ORM and use something else.
Thanks!
What I'm doing is recreate everything the Laravel way and worry about importing the data (millions of pictures, videos and comments) later. I figured that once I'm proficient at Laravel that writing some import jobs would be relatively easy.
Thanks! That’s happens to be just what I need to do: import pictures and related data.
Does your DB have a classic design? You can very easily map an existing DB with a fresh Laravel install, just write a couple Models, their relationships and you're almost set.I have been working with Laravel on a daily basis since 6 years and have never felt more efficient with code.
Not sure what you mean by classic, but I designed it manually to be queried with plain SQL. So I suspect the answer to your question is yes.Thanks for the info!
By classic I mean something somewhat standardized like user table: id, name, email ; post table: id, user_id, content etc.
Pretty much, then, yes.
Were building some internal tools for customer service on Laravel's Orchid package and its the first truly RAD I've had in php that doesn't hold me back.  Building interfaces is a pain and I lost touch with Javascript a decade ago, but it handles all of that for you.Highly recommend
Next.js is great but can't compare to Laravel, they are not for the same use case. Laravel comes with an ORM, a job queue, a mail framework... And it can also scaffold a complete auth system for you
You can just add Bull/Temporal, Prisma/Knex and Braze and you can swap stuff when needed but I understand that for new people it's nice to have everything integrated when starting out.Still seems like most people write separate backend and Nest.js is most popular. I am not a biggest fan yet personally.
How so? Nextjs only offers ssr and routing. Nothing else. Not even close to the full stack functionality you find in a default laravel or rails project.
It also has API routes and Middleware. But yeah, Laravel includes more by default. With Next.js, you need to pick a few more tools to go along with your stack. E.g. Next.js, NextAuth, Prisma, SQL database. You end up in a similar place, it's just not all part of the same package. That may or may not be beneficial for your team.
And the advantage of Next is that you can leverage React components server side and client side, and share code between them.Laravel Livewire is pretty nice for basic interactivity, which is all many sites need, but React becomes useful as soon as you start needing app-like features. At that point, using Next, which is already plugged in to that ecosystem, is a very nice experience.Next is great for static sites, too, so nowadays I prefer putting my time into that vs. fragmenting between a more purely server-side framework like Laravel.
Inertiajs is the right solution if you need more interactivity than livewire. It can be used with react or vuejs out of the box (probably svelte too but haven't looked it up).
Next.js is great as long as what you're building is not much more than a landing page, or you're proxying to a real backend system (by another team, etc).Trying to build a "full stack" application with just Next.js is suiciding everyone that comes to the project after you leave.
PHP was my first language back when I was a teenager in highschool - it all started because I wanted to get some data from users and store it (I just knew basic HTML and CSS back then), when a friend mentioned he used a PHP snippet to send an email from a website. That sounded like magic to me so I bought a book on PHP and my mind was blown by the possibilities.Several websites and years later I had a pretty good understanding of backend/frontend concerns, web security, SQL and databases... although I didn't really bother setting up a local environment so I just tested new stuff "in prod" by dropping the new files directly via FPT!After University I then started working as a software developer doing full stack work (mostly Java & Python backends) and Angular, then React for frontend.In many ways I prefer TypeScript + React in the frontend with a Java/Nodejs + TS GraphQl backend, but I remember the speed with which you could get a website up and running, self contained, with no CI/build/deploy issues and it was the best thing ever to learn reallyI'm almost curious to see what it'd be like to build a website super professionally now with PHP, but I'm pretty sure it'd feel very similar to typed python or Java
Hey, I'm the author of the post. A while ago I made a video where I built a small but serious hobby project in PHP with Laravel. It was a five hour recording, but I condensed it into a commentated 20-minutes timelapse:https://www.youtube.com/watch?v=mmtVkDh9RGwIf you don't have the time to watch it, you can also check out the open source code of that project:https://github.com/brendt/aggregate.stitcher.ioI still work on it, and I'd say i's a pretty accurate representation of a standard Laravel application.
Which leads me to start to think if there is a way to make timelapse videos that filter out some of the too quick movements, like windows and dialogs opening ... to make you mostly see how the code grows. App idea perhaps? :)
You could probably use GIT commit history as a data source?
> with no CI/build/deploy issuesI miss those days.I think the amount of front end building we do for the web nowadays is absurd. We transpile everything - JS, CSS HTML, and then we bundle them in odd ways to circumvent all kinds of issues. The way we make webpages is so disconnected from the technologies that browsers offer us.Makes you wonder when people are going to realize that we're way past serving static pages and don't need the next big front end tool, we just need a better way to run actual applications in the browser.
> we just need a better way to run actual applications in the browser.That's not going to happen. It's been tried, and it's almost always proprietary.So it isn't really adopted.WASM might be "it", but in that case, you're still compiling/building stuff :-)
> The way we make webpages is so disconnected from the technologies that browsers offer us.Can you say more about this? I don't really see how "actual applications" differ from a React app in a meaningful way; React apps almost always leverage the capabilities of of course HTML/CSS/JS, history, AJAX/HTTP, cookies, and so on. As the JS distributions evolve, the build systems do too in terms of output.Maybe I misunderstand something, but in general the idea that just writing vanillaJS or some analogue would be sufficient to deliver the quality of apps enabled by frameworks (and talented devs) seems a bit naive to me.
> Can you say more about this? I don't really see how "actual applications" differ from a React app in a meaningful way;React is everything the web (in its initial conception) was never meant to be.HTML was meant to be used for static documents. CSS (single file, linked to by all documents) was meant to add styling to all those documents. JS was meant to addsimpleinteractivity to documents. Navigating between documents reloads everything and no state is kept (other than user sessions of course). We broke every single one of those concepts and the way they were meant to be used.Now, our HTML consists of a single index.html with a div#app and primarily content in the <head>. Elements are entirely generated by JS. Most of the time you just load a single big JS file that contains everything and navigating just replaces elements, state-wise you're still on the same document. We want all kinds of fancy CSS features that won't be implemented for another 25 years so instead we use transpilers. That is, if we don't include our CSS in the JS. Did I say JS? I meant JSX, because we don't even write HTML directly anymore. The point is, we don't use any of the 3 the way they were meant to be used.We've built layers on top of layers of abstraction to be able to add a level of interactivity that was never meant to exist on the web. Instead of coming up with a new way of building actual applications that meet all our needs, we keep (poorly) patching old technology to get it to play nicely with our modern needs. It's a constant fight and a gigantic waste of everyone's time. We can do better.
Sometimes the best platform is the one you have though. It’s not conceptually good, but its ubiquity is good. Slowly we creep towards HTML/CSS/JS as solely a compile target haha.Also, just because of tone-death in text, I’ll say I agree with you! The web as an application platform is a bodge. Humanity loves bodging though!
> HTML was meant to be used for static documentsSo? What does that have to do with "technologies the browser offers us"? The browser now offers a thorough set of DOM bindings in JS, which is definitely not meant to be used for static documents. Quite the opposite.> CSS (single file, linked to by all documents) was meant to add styling to all those documents.That's still how it works?> JS was meant to add simple interactivity to documentsBefore the DOM, sure> Navigating between documents reloads everything and no state is kept (other than user sessions of course)Which was horrible UXEverything you go on to say seems to be some puritanical bend on never evolving software. The platform and its usage have co-evolved, and now we have a complete app distribution platform where a 1MB bundle can deliver equivalent functionality to an app taking hundreds of megabytes on the phone platform, except this 1MB bundle can support screen sizes from the smallest phones to the largest desktops.I genuinely don't understand what kind of complaint this is:> We've built layers on top of layers of abstractionShould we go back to writing Assembly? Wait, isn't this a higher level than machine code? Wait, isn't that still interpreted by the CPU into microcode? ...> Instead of coming up with a new way of building actual applicationsHonestly, I don't get it. We did come up with a way of building actual applications, it's called the browser, using HTML/CSS/JS. I don't care that some people write it in a file called .jsx or .tsx - is using TypeScript also offensive to you? - I still deliver a static HTML/CSS/JS bundle to users. That seems like the ultimate validation of the original concepts in those technologies, they are so expressive that we're able to circumvent the need to start from scratch yet again, instead evolving themselves to be a performant, compact app delivery platform.> It's a constant fight and a gigantic waste of everyone's timeThe gigantic waste of everyone's time is thinking that starting from scratch will solve more issues than it will introduce. Good luck writing a new platform that supports not only many classes of devices and small packages, but also doesn't kill accessibility features, screen readers, and billions of man-hours of development that still works today.This is better than it was. Not sure what kind of person simultaneously argues "we can do better" and then rails against the evolution of usage of technologies that... made them better
> > HTML was meant to be used for static documents> So? What does that have to do with "technologies the browser offers us"? The browser now offers a thorough set of DOM bindings in JS, which is definitely not meant to be used for static documents. Quite the opposite.I think they mean that syntactically, HTML is best suited to static documents, since that was the original design consideration. While the DOM has had things added to it to make it work as a declaritive UI language, that doesn't change the fact that the HTML spec at it's core is very focused on information hierarchy, typography and print-style layouts.--> > CSS (single file, linked to by all documents) was meant to add styling to all those documents.> That's still how it works?Yep! <link rel="stylesheet" href="./style.css" /> on every document, and you just keep adding to that file. (Not advisable but possible)--I could totally see us building a BETTER target platform; imagine a declaritive UI language that allows binding nativly? No "JS Main Thread" blocking weirdness, and frameworks would all use it making views/templates/components intercompatible. HTML is a weak solution to the problems modern web development faces...BUT it's also a globally available solution making the annoynaces that come along with it just acceptable enough that we'll take the extra step to emulate a better platform with frameworks. It's available everywhere, and global change is hard or even impossible. It's working with what we have and I think that's good. But pushing for something better is also good. :)
Haha we had the exact same experience. My mind was blown by PHP as a teen and I even made decent money in high school making websites - all without ever setting up a local environment.I didn’t keep doing dev work and had a different career but changed back to development a few years ago (also mostly TS). I’ve also been curious for a while about what it’d feel like to start a new project in Lavarel instead of Next.js or Sveltekit like usual.
I started my career with PHP. Created my own apps, created client websites etc. Full of footguns, but I didn't know any better. Once I learned more languages, I never used PHP again. I actually started to feel like I'd been fooled into using PHP.Now the small PHP community keeps trying to justify their language choice with articles like these and comments like the ones on this submission. They claim it's a no brainer to use Laravel for new apps, because it has a big ecosystem and good ergonomics, and pretend that this description somehow does not apply to hundreds of other frameworks. They claim that the article A Fractal of Bad Design (which was really cathartic to me when it came out) is out of date, but when I look, all the old footguns are still there, all the problems with the standard library are still there and stdout still writes directly to the browser. The foundations are rotten.Go ahead and use it, I don't care, but stop trying to convince me to use it.And now the downvotes begin. PHP devs hate dissent it seems.
I don't wish to be the bearer of bad news, but nobody is trying to convince you to use it: nobody cares what you're using for software development... and you're working with out of date information if you think that A Fractal of Bad Design is relevant any more. PHP has evolved a great deal over the last decade, as have the people using it and as has the ecosystem.Personally, as my username might hint, I've been using PHP for a long time, and, as I've commented on HN before, I would not choose PHP if I was building an engineering organisation from the ground up, and I do not use PHP professionally at the moment, but I absolutely choose to use PHP for my own projects and can enthusiastically say it's agreat languagein 2023.If you're not willing to try out modern PHP, that's fine, but ranting and raving about PHP based on your experience more than a decade ago is not relevant any more, given this is a post about theimprovements made in the last decade. Many people with experience beyond PHP think PHP is a great language today.
Quoting myself:> They claim that the article A Fractal of Bad Design (which was really cathartic to me when it came out) is out of date, but when I look, all the old footguns are still there, all the problems with the standard library are still there and stdout still writes directly to the browser.
You can quote yourself ad nauseam but that does not turn your incorrect statement into a correct statement. If you spent any amount of time looking at a modern PHP codebase, you'd discover that the type of code people write today is radically different to the type of code you'd have seen at the time A Fractal of Bad Design was written. There are still aspects of modern PHP that stand to be improved, absolutely, but that's true of all languages.
Your argument is basically:"Yes, yes, the footguns are still there front and center, but we added more guns that don't shoot you on the foot."If I was using PHP, I'd be livid that the cruft is never removed. Just deprecate and remove it
A lot of stuff is deprecated and not removed.Can you give an example of the footguns you so fear?
No, my argument is that most of the footguns described in A Fractal of Bad Design have been long since fixed and those that remain are being removed as and when it's feasibleandthe PHP community has matured a great deal to the point where the remaining footguns don't really apply in modern codebases because of libraries, static analysis and testing.Spend any amount of time actually using PHP and you'd discover that it is meaningfully different to what it once was. It's far from perfect, and still has a long way to go, but if you reflect onwhere it wasand what had to change to get where it is today, the improvement and progress has been excellent.
http://maettig.com/2020-09-16-revisiting-a-fractal-of-bad-de...Nearly every point in the original blog shown to be solved here.
So dramatic. No one cares what you use, and I suspect you could just not read articles about PHP and voila your problems would go away. Choose your own destiny!You have to ask yourself why such a large proportion of work gets done in two objectively bad languages, PHP and Javascript. They dominate the space. I think it tells us that it's not actually that important to have a 100% perfect language, when it comes to building stuff.
tbf, TypeScript has taken over a huge part of the JS ecosystem, and while doing so has fixed lots of common "meme" gripes with the language. It has also introduced new issues, but alas, the web is typesafe.Learning PHP though is exactly as the article describes. I had to do it in college and even using a modern version of PHP, the language felt as if it had been written by 3 first semester students under pressure to meet a deadline.> You have to ask yourself why such a large proportion of work gets done in two objectively bad languagesI did ask myself that, and I came to the same conclusion as the author of "Fractals of bad design": The majority of work gets done by amateurs and amateurs, per definition, don't know any better.
> And now the downvotes begin. PHP devs hate dissent it seems.I mean, write stupid comments win stupid prizes?> Now the small PHP community keeps trying to justify their language choice with articles like theseHow would you expect people to react when you frame it like that. I assume you're one of those people that think you have good opinions, but wonder why others don't want to hang around and hear them.
Small PHP community, now I've heard everything.
It feels large to you because you are in it. Other language communities feel small to you because you are not in them.
PHP is still above Go, Rust, Ruby, and Perl in at least the TIOBE index:https://www.tiobe.com/tiobe-index/Are those all small communities too?
> The ratings are based on the number of skilled engineers world-wide, courses and third party vendorshttps://i.stack.imgur.com/Jteqd.pngI'm sure theres also still tons of skilled engineers for Perl around. Or Fortran. Definetely Java. But the TIOBE index looks more like taking inventory of existing skill throughout the industry and less like it tracks disruptive trends.
PHP is far from my primary language, but in no universe is the language that powers so so much of the internet "small".
Website traffic to servers running the language is not necessarily correlated with the size of the community
whats your metric for a large community? internet traffic? github projects? number public repos? number of packages? by every metric i can think of php is has a large community, not as large as java or python but still large.how twisted does your dislike of a language have to be for you to not even acknowledge that a lot of people use it
github stars and volume of left-pad clone repos
PHP devs hate to admit that the only reason PHP is still relevant at all today is because of WordPress.If WordPress moved to a modern language tomorrow, PHP would cease to exist afterwards.
I've worked professionally with PHP as freelancer the last 10 years. I almost only use Symfony and Laravel.But there's also Typo3, Spryker, Magento, Drupal, Shopware, Sylius.I won't touch Wordpress. I worked with it about 15 years ago for a few years, but didn't touch it afterwards.
I don't get how people can say that. WP is almost ~50% of all websites. PHP is ~80% of the websites. There is a whopping 30% in between.And moving WP to a 'modern' language (whatever that modern means) is not something possible. ~60,000 plugins, similar number of themes, 30% of all ecommerce websites, billions of dollars of businesses with dependencies ride on it.
WP is way behind modern PHP. From the article> Right now, WordPress only has beta support for PHP 8.0. Now, to be clear: PHP 8.0 was released in 2020, and is now end of life, three years later — and WordPress doesn't yet support it…
WordPress would cease as well I think.There are dozens of alternatives better than WordPress, if upgrading it meant a complete tooling change I think many would take the opportunity to replatform to something else. The only thing WP really has over them is it's expansive plugin library, and buy in from clients.But it's not really up to devs. I don't think many devs believe it's the best system, but it is desired by clients very often.
> The only thing WP really has over them is it's expansive plugin librarThe expansive plugin library that WP has is due to its ease of use, stability and the extent it goes to acommodate users, developers and businesses at the same time. Its no small factor, its no small feat.
I do agree, which is why I think WordPress would go away pretty quickly of they ever invalidate their legacy of plugins through a major change.
Yep. That's why WP has always prioritized backwards compatibility.
You probably dont make content sites. The reason PHP is still relevant today is because no other language has CMSes as good as those from PHP. And i dont mean WP or Drupal.Craft, Kirby, Twill, October, Grav, Statamic, Bolt, Processwire…
All of those projects have big active ecosystems around them and are used for serious projects. Most other languages dont have a single CMS. There is no CMS in Go or Elixir. Javascript have some but they are super immature and mostly hype. Python has some super ugly ones based around Django.Now people may look down on these PHP cmses but many web projects like ecommerce grow as extensions of CMS. And most of these CMSes are suited to this because they are nice web framework with customizable admin area. So it often doesnt make sense not use PHP.
So don’t use it? Literally nobody wants you anywhere near the PHP community.
Out of curiosity, what language are you using for backend now?
Not a fan of PHP like most of professional PHP devs, I guess but the utility of Laravel for example is unbeatable IMO.
"the small PHP community" .... what?
> PHP devs hate dissent it seems.Perhaps, but do they hate dissent as much as non-PHP devs hate PHP?Language wars are silly.
Found the haskell programmer
It's been 10 years since "PHP: a fractal of bad design" [1] was written.It's remarkable how the language evolved, and how many of the issues mentioned have been fixed and improved over the last ten years.1.https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
It’s funny because when I think of “fractal of bad design”, Javascript is the first thing that comes to mind. I love Javascript but it makes me ask “why?” a lot.
PHP is kind of the same league, a lot of hate comes because some senior employee told a bunch of juniors after years of working in Wordpress that PHP is a garbage language and you should not touch it. "It's cool to hate PHP!"PHP can make absolute garbage, and it can make a elegant product. Just like Javascript can. And same with Python and Ruby and what ever else everyone recommends.It may be a lot harder to make garbage in Rust, but it's possible. PHP has a problem where it gets out of your way, gives you the entire toolbox to build a house. But the problem is which one of the 17 types of hammers do I use to hammer in one of the 104 different types of nails. Where as Ruby, gives you 3 hammers and 4 different nails, and 7 magic nails that appear after you're done hammering.
Php's inconsistencies in regards to needle vs haystack make me weep. Javascript doesn't have anything remotely like that.
I hope you realize that "fixing" these types of early mistakes is almost impossible for PHP, a language which tries hard not to break things, especially something that's going to be used everywhere. But if this is such a deal-breaker and your IDE is dumb as a stump and can't remind you nothing prevents you from wrapping the stdlib or using something like psl to do it for you.
> I hope you realize that "fixing" these types of early mistakes is almost impossible for PHPI do, yes; which means early mistakes stay in the language forever; same as in javascript. More's the pity.
If its powering 80% of the internet, 30% of all ecommerce websites, its not a mistake.
I think fixing as in "removing and replacing" is indeed impossible, but defining a new convention and making alternative names for the same function would work fine.Let's say the new convention is that functions are named str_*(), then keep strpos(), but create a new one called str_pos() that is the same, and mark the old one as deprecated (but don't remove it).I am sure there are edge cases where both str_* and str* exist already and do different things, but we can figure something out.
I think you actually could fix this forward by using named arguments instead of positional ones?
JavaScript absolutely has things like that. Very famously so.https://www.youtube.com/watch?v=et8xNAc2ic8
Notice that lots of (probably most of; maybe even all) examples in the linked talk are due to unreasonable inputs. `true + true` doesn't make sense; `{}.toString().call(new Date())` or `+[] === +![]` don't make much sense either. This is just not what developers do. Meanwhile, iterating over arrays is absolutely what developers do, on an hourly basis. Which is why I said that javascript doesn't have things like that — the papercuts  it inflicts on you hour after hour after hour.
Laravel's Collection class means I don't ever touch a raw array, and I've never had a "left-pad" scenario happen to me with PHP. Both languages have their warts; neither's tends to be an issue inactualpractice with an IDE and experience.
Just use typescript
No.
Many of the statements in that article were misleading or outdated already in 2012, though. E.g. the part about PHP being tied to Apache… At that time I had been using php-fpm behind nginx for years.
I didn’t go back to all the points, but I get the feeling the configuration and security parts are mostly fixed, while the functions related issues and type looseness stayed mostly the same.Am I missing other important parts ?
Which ones have been fixed?
What really struck me was the statement: "In total, $580,000 was raised in 2022
The Foundation pays 6 developers to work on PHP" which made me realise how easy it is to take for granted the development and maintenance of these open-source languages and ecosystem as a whole.Say what you will about PHP, but we all rest on the shoulders of the incalculable effort that goes into the software we use everyday without thinking twice, and is something I'm very grateful for.
Similarly, cURL has been maintained by Daniel Stenberg for nearly 30 years. Billions of installs, every major tech company probably uses it... labor of love.
I used to describe PHP as the spac filler of the web, holding all the good stuff together.Then I had to pick up a Laravel project and - for me - Laravel alone has resuscitated PHP's reputation.
Absolutely, writing modern PHP with Laravel as a framework makes the whole language feel totally different compared to just even a few years ago. I do also really like the statelessness of how PHP is ran.
At the day job we are using it to serve tens of millions of API's a day, without having any issues concerning stability and/or scalability.
> Laravel alone has resuscitated PHP's reputationI honestly don't know if this is supposed to be a good or bad thing.
The video from that site (alsohttps://youtu.be/x9bSUo6TGgYat youtube) is really quite well done.  I wish more language comparisons were done in this way, with two speedy minutes in an editor accompanied by taut voiceover.  Very impresssive!
Thanks! I'm the author of the post and creator of the video :) Appreciate the kind words.
It is tidy and efficient. One question: Are you saying “docblocks?” I’ve never heard of this.Thanks!
Yeah, doc blocks. It's a name that originated within PHP a long time ago:https://docs.phpdoc.org/guide/guides/docblocks.html
Thanks. I haven’t used PHP since 2011 or so.
I used to work way back in the day on PHP too, but even though I'm sure this will be downvoted, it's really sad people still take it seriously as a language in 2023. There's nothing remotely elegant about it. It's not expressive or programmatically succinct in the way Ruby is. It's not beautifully well thought-out the way Python is. It's not fast and modern in the way Rust is. It's not elegant or composable or client-side renderable in the way React.*script is. It just brings nothing to the table. It's an ugly hodgepodge borne out of an over-engineered homepage from 28 years ago. Various business interests have kept it afloat, and people who don't know any better keep championing it. I think people do eventually catch up with what's going on though as soon as they personally experience writing anything remotely serious (5-10,000+ LOC) that isn't a simplistic web-app.
> I used to work way back in the day on PHP too,This is your issue - PHP < 5.3 is very different to PHP 7+. Not just at the language level - but the community, frameworks and best practices too. No more random scattering of SQL statements in HTML files!Modern PHP (with a framework like Laravel or Symfony) is probably one of the most productive ways to build web applications.> It's not beautifully well thought-out the way Python is.This is definitely an interesting take... Python hasn't even solved package management yet. And the 2.7 => 3 migration is probably the most famous example of making a mess of an ecosystem with backwards incompatible changes. In contrast PHP has Composer and 5.3 code is pretty much compatible with 8.0 (although ideally all code from the 5.3 era should be burned at the stake).> and people who don't know any better keep championing it. I think people do eventually catch up with what's going on though as soon as they personally experience writing anything remotely serious (5-10,000+ LOC) that isn't a simplistic web-app.You've basically just said that PHP devs are too inexperienced to be able to scale a codebase past 10k LOC? Pretty much every serious web dev using Symfony/Laravel would disagree with you.
I'm on PHP 8 and I feel the same as parent.Sure, there's been a lot of progress since the PHP 5 days, but the core of the language has been left mostly untouched by design, and we haven't seen the kind of drastic moves like JS moving to ES6 syntax.It's a matter of taste, so there's no absolutr truth. I hate PHP's function and property access syntax differenciation and wildly prefer ruby's approach or instance. And there's so much more nice things coming in languages that have been designed from the ground up to be nice to use.I understand PHP's pragmatism, but can't find it pleasant to use TBH.PS: we got arrow functions, but they stay limited to anonymous functions for instance...
Maybe PHP can add a "stricter" mode that gets rid of all the cruft? Enable it per-file, allow it to simmer for 10 years, remove legacy support in PHP 12.
This would really help in a lot of way IMHO. PHP has good aspects, getting rid of the weirder one, even if compatibility gets sacrificed, would be a boon for building new applications.
It already has one
I called it "stricter", not "strict" for a reason.
Uhm, how about PHP attributes, getting rid of comments / annotations? Named arguments? Constructor property promotion? Readonly properties (8.1) / classes (8.2)? Arrow functions or typed properties (both 7.4)?I'd say those are really cool things. Especially as a web developer, there's just so much boilerplate I can get rid of since using 8.0+.
I’m in agreement with you that it came a very long way.Now, most of those have been present in many other languages [0], often with less limitations.And as usual the old ways haven’t all been deprecated either, so it stays weird. For instance typed properties were a chance to reset the clock on type handling, but no, declaring a type will force cast parameters to that type instead of throwing an error (i.e. passing 0 for a string argument will convert it silently)[0] Constructor property promotion isn’t, but TBH I’m of mixed feelings about it. We get conciseness in exchange for weirdness as the properties aren’t declared outside of the constructor, where they would be otherwise. I wished it was done the other way round.
> declaring a type will force cast parameters to that type instead of throwing an errorThere is `declare(strict_types=1)`[0][0]:https://www.php.net/manual/en/language.types.declarations.ph...
Yes, except it has to be set on the _caller_ side.I kinda see why, after all it’s the caller who will deal with the TypeError. But assuming we’re not setting types for all our functions, when I do for a specific one, I want to enforce that strictness on the _callee_ side (“for this function, it really matters that the parameters are correct”), and not have to go check if every single caller files properly has the strictness set. [0]So in the end, the best option is to _not_ type scalar parameters, and do the strict check manually and throw your own TypeError, inside your function instead.[0] Auto setting strictness for every file in your project and checking for it in CI clears the issue, but that becomes another boilerplate you’re adding to your system. And it still doesn’t work for native functions.It’s so close. Really, so close to be good.
> Auto setting strictness for every file in your project and checking for it in CI clears the issue, but that becomes another boilerplate you’re adding to your systemThere was this RFC[0] but it seems to have fizzled.> And it still doesn’t work for native functions.The page states: 'Function calls fromwithininternal functions will not be affected by the strict_types declaration' (emphasis mine). Outside of array_map I don't think this happens all that much.> So in the end, the best option is to _not_ type scalar parameters, and do the strict check manually and throw your own TypeError, inside your function instead.That sounds awful. Why not install a nice static analyzer like phpstan or psalm and never think about it again?[0]:https://wiki.php.net/rfc/namespace_scoped_declares
> native functionsThanks> That sounds awful. Why not install a nice static analyzer like phpstan or psalm and never think about it again?It is completely unelegant, but works decently in practice (fits the subject perfectly…). We’re extensively using phpstan, especially as it’s the best way to expose in array types.Phpstan still has blind spots, including the ability to disable it on the caller side (in particular, as far as I  know you can’t disable specific errors inline, so if you have to do it for one parameter for instance, it applies to all parameters), and the option to overwrite a variable type just for phpstan. Those comes from developer error, but that’s exactly what we want to protect the system from.Actually checking at runtime that a value is of the right type is more secure.
Yes, the backward compatibility is a crux on the one hand, on the other hand it has made upgrading PHP versions a breeze. In the past 6 months I updated several code bases from PHP 7 / 8.0 to PHP 8.1 / 8.2, the PHP part was easy (just the deprecated dynamic properties in 8.2 caused a wall of text in our loggers), the framework was a bit more difficult. The most problematic were the exotic packages that the clients had installed ages ago and that are not properly maintained anymore, so I have to figure out a replacement for those code modules.Constructor property promotion is fine, I think. I think it ties in well with the readonly property.public function __construct(
        public readonly Company $company,
    )
    {
    }There's just so much info & functionality + type safety crammed into there that wouldn't have been possible previously; it's really nice.
The one feature on PHP that I wish was more commonplace is the `use` keyword in function expressions as it is one of the few ways to limit what names are in scope at a given point in the codeIIRC Rust's `mod` declarations can behave similarly.
"Can't find it pleasant" is a personal preference and not why no one should use PHP which the GP is suggesting.
GP’s take was way too salty, but to be honest I understand where he comes from.Yes, it’s a matter of personal preference, but I also never worked with people that thought PHP was beautiful. Not that we look down on it, but it’s probably the same feeling construction people have towards their white vans. We value the good parts, hate the jagged parts, and if tomorrow it made more sense to ride Miata for whatever crazy reason, we wouldn’t look back. But I’m not holding my breath to have any decent reason to get out of PHP at my current job, and I appreciate the reasons why.
Sorry to be dismissive, but elegance, expressiveness or succinctness are not mandatory for "making things". Gatekeeping a programming language on esthetics is quite shallow in my opinion.Ease of use and deployment, breadth, availability, low cost of maintaining, are sometimes more important, and PHP offers plenty of value in these respects.I don't want to work with it, but I will never presume to look down on people that do. PHP has been a cornerstone for a whole generation of programmers and I think the current web-development ecosystem would not be where it is without it.
Yeah I do agree it was a stepping-stone in many ways.
It doesn't matter what happens, anytime something good PHP is mentioned the thread always turns into a fight. Why can't we just stop gate keeping programming languages and let people enjoy them. PHP gets tore apart all year long, and 1 nice article comes out and everyone jumps on it like it's preaching Delphi or VBA.PHP has continued to done wonders for me, I continue to write huge apps in it, I continue to love it. I've used every other language you wrote, and continue to this day to write in PHP. Not because I'm not able to grasp how good another language is. But because it works. If I need something I go to packagist and search, it's always there. If I need to deploy something, there is tons of ways, and even basic ones. I don't need no fancy deployment setup, but I can have a fancy deployment setup if I want.But people are more then welcome to hate it, and every time a positive post comes out about PHP I will continue to post my statement and then carry on building stuff. As there is ALWAYS a negative comment.
Everyone's at a different step in their journey. But I do agree if you're building stuff then exactly, who cares? End of the day it's definitely about what's built, not how.
HN does a lot of stuff well, but there is a ton of gate keeping here and PHP is one part of it. It does not deserve the hate it gets, it's popular to hate PHP here. It's actually less popular to like PHP. So articles like the above always get torn up.It's rather sad to see, we should be encouraging people to build however they want. Point students in the direction of best practices and discuss ways to improve. Rather than talk about how much we hate the fact that PHP continues to be in the top 10 and pretty much the entire web is built with it.But people do love to hate.
> Everyone's at a different step in their journey.Text book example of being condescending.
I’ve made a few “serious” projects with PHP and has been great, I never feel like I’m fighting against it to do what I need to do, the code can be very concise, its very fast and has a lot of batteries builtin.Python is not beautifully well thought out, the syntax is awful and the version conflicts make it a mess.You’re comparing to React which is not a language or in the same domain is confusing and makes me doubt your credibility.
React isn't a language, it's an elegant pattern layered on top of (Java|Type)script which are languages. Not sure what versioning conflicts there are with Python but there are a lot of community solutions in the form of pyenv, virtualenv, etc. Python is well thought-out, imho, but I think it can take a certain type of person time to realize it. I used to hate it but the way I ultimately came around to understanding it was someone explained to me it's essentially extremely close to pseudo-code, which I think is ultimately why it can seem very natural and why so many universities and the larger STEM/ML community have all adopted it.
React with JSX can be pretty close to being a new language+runtime (just like Svelte).
That's such a strange statement, you can compare PHP and React because they both can return a HTML string? Even though one is built entirely within another language, and it isn't is not a "language". More of a toolkit. Same as say Symfony html framework is.
This is why I stopped posting on the internet people will twist and turn stuff for reasons beyond me. It’s like pulling teeth.
A "React vs PHP" Google search turns up tons of articles and forum questions with that exact same comparison.So either it's logical to compare the two, or the internet is just full of idiots like me and the parent poster :D.
Many of those questions have answers that point out you are comparing two very different things. Some of them are explicitly comparing Laravel and React, which makes a bit more sense. The rest seem to be AI generated trash.The easiest way to explain it is that you could reasonably use react within a PHP project.I wouldn't use the term "idiot" but rather "ignorant". A good article that answers the PHP vs React question would be mostly explaining the differences in the function and usage of both tools.
For reference, I'm working with both React and PHP. And yes, for example WordPress uses React components. 
I'm a 42 year old software architect. But hey, maybe I've been ignorant all this time.React vs PHPisa decision you can make, because... the intention of both is to output HTML.edit:> The easiest way to explain it is that you could reasonably use react within a PHP project.I can use C within a Python project. Does that mean I can't compare the two? One is compiled while the other is interpreted, so maybe you can't compare those?
> React vs PHP is a decision you can make, because... the intention of both is to output HTML.Often PHP is used when no HTML rendering happens at all (Apis, scheduled jobs etc.)> I can use C within a Python project. Does that mean I can't compare the two? One is compiled while the other is interpreted, so maybe you can't compare those?Those are at least both programming languages. Several major python libraries are written in C (or other compiled language) so a pure python project is probably fairly rare. Someone asking for "Python vs C" is probably more in need of an explanation of what the broad categories mean and tend to be used for than a point by point breakdown of specific language features and ergonomics.In this specific instance, the complaint was that PHP, a server side language, doesn't offer client side rendering built in. This a point that should be brought up comparing JavaScript to PHP, not React.
> Often PHP is used when no HTML rendering happens at all (Apis, scheduled jobs etc.)When comparing to React those things are irrelevant.> the complaint was that PHP, a server side language, doesn't offer client side rendering built in.So am I allowed to compare server side rendering to client side rendering? Or are those 2 different things and I'm ignorant if I try to compare them?
If you complain your tesla doesn't float very well, then you might be a little ignorant of what cars are used for (and that you probably should have used a ferry.)
React can be used both on the server and client side. That is a benefit over something that can be only used on the server side.React can even be both on server and client using 1 codebase (see Next.js). But it seems the PHP police here on HN does not allow me to compare that solution to a solution in PHP.
It's funny how we both think of each others statement how strange it is.For me, not being able to compare the two is like saying: You cannot compare a horse with a car as a means of transportation because a car is not an animal.For me, I don't care one is a programming language and the other is a framework. For me they are both ways to generate HTML. PHP was/is mainly intended to generate HTML. It started as "Personal Home Page" and now is "Hypertext Preprocessor".
Yes, but that doesn't make it a programming language. A lot of things can render HTML. I am pretty fluent in Javascript, HTML, CSS, jQuery, React, Nodejs, Nextjs, PHP, Python, and a beginner in Java and a few others. React is not a programming language.
Right, that's why it was React.*script. Regex.
Someone who worked with Python / Django and JAVA / Spring for years professionally, I see PHP / Laravel as absolute superior way to build web apps, especially if you are in a team and people might come and go.
> and people who don't know any better keep championing itExperienced developers understand that there are different tools for different jobs.  They also understand that languages are not successful for 30 years without providing some legitimate value.
I think that PHP isn't that bad for some use cases. What I really disliked about PHP as a developer was how much control the host has over tweaking the runtime; this can be"problematic" in some shared hosting setups.However, I'm also a bit of a hypocrite here because I worked for a hosting company, and also loved that feature.So, I think in the context of something like a container (or vps/dedicated) it can work well.I think PHP gets a lot of hate because itusedto be a nightmare. I know friends who still use it, and they claim it's a day and night experience from the olden days. It probably wouldn't be my first choice for a project, but I probably wouldn't groan either, if I had to reach for it now
I agree with all of those points, except that it does have one thing going for it - it is easy for end-users to deploy PHP apps: FTP your files onto any random cheapo shared web-host, done.I’m amazed that it’s been so long and no other language comes close to that :(
Compared to moat languages, if you have no visitors, php takes up 0 system resources from your system to just sit there and wait.So you could have hundreds of small sites on the same machine for an extremely low resource cost. That is something it brings to the table and its very beneficial for hosting solutions where there are a lot of small webaites sharing on the same resource.
Along this line, I like how memory leaks just can't be a thing because the page only exists so long as it's being rendered.
I might be misinterpreting "taken seriously" with utility, but to me it is very valuable that a PHP script can just be dropped on almost any web server and it can start doing stuff, and that alone is reason enough not to not dismiss it.
I used to agree with this and think of it as a main benefit, but setting up a server to use Nodejs is easy and a lot of servers come prepped with node, npm, etc, so it's just as easy ad starting up a PHP project, if not easier because package.json can easily install dependencies.
Kinda, you have to make sure all the extensions you need are installed, then fix php.ini so it's not doing anything wrong, and then it usually works if you haven't missed anything, until something becomes deprecated.
> It's not beautifully well thought-out the way Python isSlagging PHP and then saying this just means you are trolling which is not exactly welcomed on HN.
It's more productive as Ruby and Python and much faster than either? Is that not reason enough for some to choose it? I'd argue that of the PHP, Python, and Ruby it is Ruby that should die. It's the same use case as Python, but harder to read and just as slow.
we should show this comment to facebook that uses hack (php originated lang) in millions of files to run their little website and infrastructure.php isn't bad. just got a bad rep.
many langs got quirks. some more than others. but php has more web production success story and usage than most.
PHP had design flaws (many of which have been addressed since the 5.x days), but what language doesn’t?A significant cause of it’s bad rap is touched on briefly in this article, Wordpress.Even back in 5.3 days, you could write elegant and scaleable code, it just took work to do. At a former employer using PHP 5.3 on 2005 era hardware, we could do 500+ req/sec per machine with an average response time under 100ms and a P99 response time of under 250ms, with a zero downtime SLA and hundreds of millions of requests per day. Yeah, it wasn’t easy, but it worked.As a dear friend used to say, PHP is a ball of nails. You throw it and it sticks. Just exercise care when picking it up and all is well.
>  we should show this comment to facebook that uses hack (php originated lang) in millions of files to run their little website and infrastructure.Appeal to authority isn't a valid strategy.Facebook used PHP because they wanted to build something really quickly and afterwards it became too costly to switch, as it always does, so they built an entire engineering department to work around PHP issues.Your average PHP dev team can't do that.Plus, what are you comparing it to? Reasonable people don't compare it to Vlang, they compare it to Python, Ruby, Java, C#/.NET, Javascript/Typescript, Golang, and PHP ranks at best averagely against those regarding language, standard library and ecosystem consistency.
appealing to authority? lol.
no. read my comment again.
it shows real production example of a juge, complex, website that serves billions.
average php devs can't do that? maybe. but the php lang doesn't block them.
You mean the slow, bloated website that rarely adds features useful for users?
nope, i mean a website that serves billions
The language is valuable and a good choice because it’s easy to read and your codebase   Be(when used with a framework) are very maintainable.  We have Java Perl and python and php has been the easiest to get people working on existing code.The documentation is also excellent.
$For $me, $all $the $dollar $signs $make $the $code $hard $to $read.
I loved the straightforwardness of just having a nice simple HTML page with some <?PHP ?> sprinkled in. Now everything has to be done through a million layers of indirection. Which is fine when it's necessary, but I still like to write my own pages as simple unstructured PHP.
I was waiting for a comment like this. If I had a penny for.... I would be a gazillinaire :)
I agree with the author about the superset, this is how it should be done. The current PHP type system has many weaknesses (e.g. generics, typed collections, etc.) that aren't easily solved, and I don't want to use some static analysis tool that relies on comments to type my code properly.
PHP has always been and will always be my goto language when it comes to personal projects.I don't use it professionally, but it's such a breeze coming back to it whenever I work on my own stuff.And the ecosystem (especially Laravel) is light-years ahead of ANY competition in ANY language in terms of ease of use while still having all the necessary features.It's the only language for which I always read the release notes because it's so exciting to see it become even better as the years go.
I learned programming with PHP back in the mid-2000s, and worked professionally with it until about two years ago. I haven't touched it since 7.4 or so, except to help some friends with WordPress sites and such.It might be me getting old and grumpy, but PHP seemed to peak in terms of usability and syntax around 7.2. Lots of the new type syntax in the article is... inscrutable to me. I'm all for strong typing in general, and I don't miss the type coercion and weirdness of PHP, and I'm glad to see it continue to move forward. It's just the syntax.Back when PHP 7 was being discussed, I followed the arguments on the mailing lists closely and was rooting so hard for those advocating adding much more explicit and strict typing, and I remember me and a coworker getting rather upset at the old timers like Zeev who were adamantly opposed (and who mostly lost the fight). I'm only 33, but I've got nearly 20 years history with PHP, and I suppose now I'm the old timer.My last project in PHP was forced by business concerns to support PHP 5.4 through (at the time I left) 7.4. The massive pain required to make that work might have colored my perceptions of the whole situation.
Maintaining a legacy project might as well be a different language entirely than building a fresh project with modern PHP. I've been doing both, maintaining and modernizing a 17 year old PHP codebase, while building fresh apps with Laravel. And I would say the language is certainly not the limiting factor, but rather prior decisions causing debt.
I used PHP in my university days, 20 years ago, and went on to build a few websites with it that I still run today e.g.https://caption.meIt was a fantastic student language - the docs were great, the code was simple and imperative, there was loads of prior art online. It was empowering to tweak code and see immediate results in the browser.These days I prefer the strictness and ecosystem of Scala on the back-end, and the developer-friendliness of ReactJS on the front-end. And I think the separation of concerns (model-view-controller) is helpful.So I am gradually migrating caption.me PHP code to Scala/ReactJS. A migration like this can be done piece by piece. After implementing the back-end for a feature in Scala, I write the ReactJS component, then alter the PHP code to render the ReactJS component tag in place of the former PHP implementation, then use some simple javascript plumbing for the React DOM binding.I have a Grafana chart that shows the number of lines of PHP code remaining, so I can track my progress over time. It's quite satisfying.
If you are the sole developer working on migrating the project and you want to have the frontend in React.js why not use Node.js/TypeScript instead of Scala for the backend? This would save you from context switching between two languages and consequently increase the development speed.Also why the rewrite? If it works (in PHP) it works. Perhaps instead you could maybe add some frontend JS for better caption UI/UX?Does everything have to be done in React nowadays, as opposed to plain static HTML? (Speaking as a React/Node dev myself)
I tried Node.js on the backend but it didn't have the expressiveness and ecosystem of Scala.I run a few simple Node and Python apps behind the scenes of caption.me,  but for the core code, I want the power of Scala, its functional style, rich type system, monadic composition, immutability-by-default, avoidance of nulls etc. As well as great libraries like http4s, Doobie etc, Scala also gives me access to the entire Java ecosystem.The PHP->Scala/ReactJS rewrite is partly a learning and experimentation project for me. I use Scala in my day job, and when I make technical/architectural decisions, I benefit a lot from the stuff I've learnt in my side projects, particularly on the front end side.PHP has had its day in the sun (as shown in the job market trends onhttps://www.itjobswatch.co.uk/jobs/uk/php.do), so I think it's more valuable to get exposure to modern languages as I still have a few years of professional coding ahead of me :-)
The shade cast on Wordpress at the end is the article is a little disappointing. Ok, they’re behind on versions but for many years there was not much progress in PHP. Now PHP is flying and dependent projects are not keeping up. What can the PHP team do to help facilitate?
The fact that WordPress doesn't run on PHP 8.x is honestly the least of WordPress' problems.There are MANY reasons to cast shade on WordPress, it's an absolute pile of garbage from top to bottom.I recently developed a WordPress plugin as a personal project for my blog and it just puts in light how bad this software is, from non-existant documentation (on 10 years old functions?) to practices that were already not recommended in PHP 5.WordPress as a product is great, but WordPress as a technological piece is absolute garbage, made by grossly incompetent developers.
It's not the PHP internals team's responsibility to prop up a private company (Automattic, who owns WordPress) who are lagging behind on maintaining their product and ecosystem. They're already strapped for resources as it is.
Maybe not, but Wordpress is arguably one of the main applications that has kept PHP relevant over the years. They could reach out a hand.
Why would a new project in 2023 choose PHP over anything else (modern Java, Kotlin, C#, etc.)?
Because people can make whatever decisions they want based on their own list of tradeoffs. I can tell you from experience laravel is far easier to get going than any c# or Java framework. You can SPRINT through a project in laravel and then break it into pieces after the fact.I would pick it if I wanted to launch something new without getting stuck in premature optimization hell. Bigger org I probably would not unless I was building an isolated POC.
Personally I'd reach for PHP because I think Eloquent is a great ORM. I've built applications with Eloquent, Doctrine, Entity Framework, and Prisma and although I'd prefer to write my own SQL queries when working with a team that has little to no SQL knowledge Eloquent has been one of the best ORMs I've used.
The rich ecosystem, the amount of developers experienced with it, ease of deployment and maintenance
Kinda applies to anything (Ruby, Python, Rust, Java, Javascript, ...)
Why would anyone in 2023 use Java or choose to be locked into Microsoft?
Why "locked into"? When choosing JavaScript, you're locked into JavaScript (and Ecma International), when choosing Kotlin, you're locked into Kotlin (and Jetbrains). You're always "locked into" the language and its ecosystem, no matter what you choose. I don't find that to be a real argument.
Speaking of which, how good is .NET on Linux nowadays?I know it was possible for a long time (with the release .NET Core), but heard it was kind of broken/cumbersome on Linux. Maybe now it's easier to just develop an ASP.NET app, host it on Linux and use Posgres/Mysql instead of SQL Server?
Nothing cumbersome about it, on the contrary. Just give it a try!
In the front end you have no choice but in the backend you have all the choice into the world. No you’re not always locked in the backend if you have a decentralized system where each service can be based on a different language but yea, I don’t like Java or Java like languages so I will never use especially one maintained by microsoft.
because PHP kicks ass :)
PHP is a whole server system. The other things you mentioned are just languages.
This is delusional
What are you on about?
Judging from the tone of his comments, he appears to be a troll.
PHP runs a lot of my projects. 
Always grateful for the effort that goes into it.
Deploying is very easy using git. Composer makes it easy to install libraries.For the makers: with these packages you can easily make a nice blog/site with minimal amount of code and files.https://phprouter.com(one file router!)https://github.com/EFTEC/BladeOne(Laravel Style Blade Templates, but much less files)https://parsedown.org(markdown library)
seems like 2023 is finally the year to pick up PHP and get that limbo.just kidding, I am getting paid multiple times the salary of PHP devs by shipping JS blobs to Lambda functions that render HTML and have DB calls in between them. Totally different from how PHP works, last but not least because I can have a fancy AWS certification for configuring things instead of FTPing a .htaccess file!sarcasm aside, I really think with cutting edge serverless we are ending up where PHP has been like forever, just with _much_ better tooling and processes compared with FTP-deployments.
These days - I use swoole/openswoole with any PHP project.    
it brings connection pooling, async, concurrency, event loop, io parallelization and much much more.
What is, in your opinion, the benefit of that over the "traditional" model of having a web server in front for static assets and fCGI/fpm as the link?
Just getting into openswoole myself. Are you using any db pooling with laravel? At the moment I’m solving this with proxysql and MySQL sockets.
Started my career as a PHP dev, I dislike it so much I migrated to JavaME and Blackberry development. Then to Android. Best decision ever to ditch PHP.
I love PHP - although it probably only account for about 1/3 of my workload/project.Would love to see a loose-goosey-functional-lisp-like lang of php :)
Yeah now that you mention it I'm surprised there aren't more languages that compile to php. The runtime is actually pretty good.
My main issue with this report is that it gives all figures without any context:- $500K in the foundation. Is this a lot or not, compared to other foundations?  Is this more or less than the previous year/last decade?- 6 developers. Again, what does this figure mean?- "many users still use old versions" -- again, at which % should the community be worried?The only meaningful info I found was the chart showing that after 7.0, its popularity stopped falling (though, the chart should have been rendered as stacked to see the full sum of downloads).Regarding the language, I guess people get their job done with it, but the code in the presentation makes an impression that it's the same hassle as back in 2010 (v 5.3) when I quit using it. (Used it since 1999.)
What are authoritative documentation sources for php these days? For javascript and browser apis, that would probably be mdn.io, and possibly web.dev. Any equivalents for php? php.net/manual looks like it might be it; but it contains numerous comments from years if not decades ago.
The English version of php.net/manual is the authoritative source. It covers all the features found in the latest version. Just because it contains comments from decades ago doesn't mean that the content itself hasn't been updated for decades.
I work in PHP each day. I prefer the Yii2 framework and sometimes use Symfony. For some reason I just can't get into Laravel. I tried but the rapid development speed of Yii2 really is the best for my workflow.
I don't really keep up with all the new features as it suits me fine. In combination with vue it is so powerfull.
Oh and for everything else in the normal PHP world, I tell people to use a framework, and for that framework I tell them to use Laravel. Period. To me it's the jQuery for modern PHP (note: I don't even code using it myself, but I tell people to have their dev team start with it)
Hi, curious to try new version of PHP. Do you know some good tutorial to setup development environment?
Symfony ships with a local web server. Or use some Docker Compose if you want more advanced stuff.https://symfony.com/doc/current/setup/symfony_server.html
You can just install PHP and use the built in dev server:php -S localhost:8000 -t ~/my-php-fileshttps://www.php.net/manual/en/features.commandline.webserver...
If on macOS then Laravel Valet is great -https://laravel.com/docs/9.x/valet
Just hit up laravel and get building something quick and easy. I’m sure a lot of the laravel core contributors actually have some good advice for general env setup outside laravel as well.
Laravel comes with Sail, which is a ready-to-go Docker install. Up and running in a couple of minutes if you've got Docker installed already.
I used PHP in mid-2000s, and then again in ~2017. By 2017, with the power of IDEA/WebStorm at my hands, it felt pretty much like developing a Java or a C# application: the stuff you needed was there, at your fingertips.And I still prefer PHP docs over pretty much any other language doc.
How has PHP lost its way?It grew up from a poorly thought out hacky scripting language to a major programming language. All the nasty code you could write in PHP 4 or 5 is still possible, but everyone will look at your code and laugh.
There are many other possible directions the language could have evolved in since then. For example, an emphasis on its dynamism and statelessness rather than introducing a static Java-like OO model for building hierarchies of classes. Or a modular system that encourages the user to put “complex” code in C modules, making application development as simple as calling a few functions.
Maybe because there are already major programming languages at that level already, which arguably do things better: if you are going to have a Java-like OO model, then just use Java (and leverage its ecosystem, tooling etc). Whereas there is a niche for a quick-and-dirty scripting language for just getting something up and running.
... You can still hacky script in it, my dude. I have to do that several times a year for stuff like one-off ETL's for customer data, or to verify an idea before rewriting it properly..Absolutely nothing about modern PHP stops you from writing like the crayon-muncher you were back in the early 2000's...You just also have the option, to, you know, use battle tested libraries and work with cohesive community driven standards now as well.
If you honestly think Java is the solution to replace PHP you clearly know very little about the language and its usage.
Poorly thought out?Only the language that runs most of the internet and invented the term tight development loop.All the modern crap has just moved us further away from this.
Those functions are all still there. You can still do <?php echo “Hello world!” ?> if you like.
<? mysql_connect(...) ?> isn't doing too well
It's a pretty dumb argument to make on the basis that no functionality was lost (There is both the MySQLi extension, and the more general PDO one), and if you really, really can't get the budget to refactor it, you can drop a single shim file in to "get those functions back" while using either of the mentioned extensions to do the actual work.
If you wanna hang your hat on that, go for it. The hacky approach the parent poster yearns for is still entirely possible, even if you have to update a half-dozen lines of mysql_connect to mysqli_connect.
mysql_connect has been heavily discouraged for at least 15 years now.
PHP 4.1 came out with mysqli in 2001. So you could argue that mysql_ functions have been bad practice for over 20.
This made me realize how ild I am :)Weren't the 90s just 10 years ago?
Both of those are currently hobbyist projects. They may develop further and become useful to the average PHP dev, but they're definitely not there yet.
Yeah, Matt is absolutely right. I'm working on PXP as a passion project, something that I've been trying to do over the last year or so and only started to invest serious time into the last couple of months.The goal isn't to completely replace PHP but to complement it. You can think of it like a playground for future PHP syntax. Something could be added to PXP and released in a week, PHP on the other hand has 1 big release a year. If something is successful and widely used in PXP, then it could be a contender for PHP core.
Not sure he 'forgot'. People dont tend to do that kind of thing in PHP as honestly it's totally unnecessary.
What's the point? You can use types in the vast majority of places in PHP and it works well, so I don't really see the point of that instead of contributing to the native typing system.
Javascript already set the precedent. If you don't like the way a language works, it's preferable to have a proxy language thatdoeswork the way you want that compiles to it, rather than accept the language for what it is and learn to work with it.
Javascript can't be compared with PHP, javascript is the only scripting language that all browsers understand except wasm.
And there are multiple interpreters that may work different or have not all features avail.PHP is used on servers that can run many different languages.
Additional there is only one php interpreter that is widely used (yes there was hhvm and some others ), that means you can rely on all features of this version.
You missed my point: PHP is adding types to the core language, so instead of developing a superset, contribute to the type system of PHP.The comparison just isn't relevant.
just a downvote then. helpful.
The only gripe I have with PHP is that the standard library while extensive is a total inconsistent mess. Would rather see that addressed first.
It's unlikely to happen. 10-20 years of use for many of those community generated functions is a lot to break. It may happen eventually, but I wouldn't count on it.
If you're inherited a legacy project thats a mess then the chances are it was written by some ass who's not following the languages generally accepted PSR standards. Proper PHP code is extremely easy to dive into and maintain.The benefit and downside of the PSR standards is they are optional. Sadly some think they know better and opt to roll their own convoluted 'standards' that just end up creating hell for the next person to come along and have to maintain their mess.
PSR isn't generally accepted. It's a bunch of nobody know-it-alls that decided everyone needs to write java in PHP.No thank you.
You're just wrong. PSRs are widely accepted and all serious frameworks and PHP libraries implement them as needed. I haven't seen a PHP package in quite a long time that didn't implement PSR-4.
Except the largest framework doesn't. And the majority of libraries don't.
What statistics source are you using to determine the 'largest framework' here?Even if we go back to the 2021 Jetbrains developer survey (https://www.jetbrains.com/lp/devecosystem-2021/php/) out of the 11 named frameworks/platforms people are using all but 2 of them use PSR and composer.You keep making these assertations which frankly are coming across as absolute bollocks from someone who's stuck in the early 2000s.
If you actually think that you dont know the language very well. It's baked into Composer, all the major frameworks fully use it as to almost every major opensource project that isn't prevented from doing so by legacy code.And honestly if you're a PHP dev intentionally avoiding the widely adopted standards and know someone else is going to have to maintain your code then shame on you.
Composer is trash, semver sucks and I'd tell PSR to go jump but it'd get stuck in a class file somewhere.
You must be a joy to work with. I feel sorry for the rest of your team, having to deal with that kind of view on everything.
if its a legacy project then of course it would be the same php from 7-8 years ago, what exactly were you expecting?if you want to try modern php then start fresh or put in the work updating the legacy.  its no different than being given a jquery project from 7-8 years ago and expecting a modern experience
"what exactly were you expecting?"Exactly my thoughts. In the end it gets up to the developers are to blame by not taking time to upgrade their projects and end up with a legacy project.PHP does the deprecation and backward compatibility better than many languages (hello Python!) but still some effort is needed as a developer to ensure your codebase is updated. I'm not even talking about the architecture here, which of course is harder to change, but language features.And there is Rector to automate most of that!
It is and it isn't. PHP 8.0 and 8.1 are a different beast altogether in my opinion and way better.
PHP 7 is actually pretty good and was the version I stopped at. Upgrading to 8 shouldn't be all that bad and mostly you can just install the new version side by side with the old one. As with any interpreted language, you have to hit every page and what not in order to see if there are any issues that will arise. I don't know if at this point if PHP has a compiler as that would save a HUGE amount of time upgrading to new versions of the language.
There are breaking changes from 7 to 8.
As a fullstack developer who has worked many, many years in the javascript hellhole, I mean ecosystem, as well as the python ecosystem and .NET; coming back to PHP the last 2 years, working essentially in Laravel and the like - I couldn't approve more of this message.Seriously, PHP is the grand father that will drive you to class and you'll never be late, the car will never smell and everything will always just be fine.It's fast, it's typed (now), it's reliable.Laravel is pretty darn rock solid. I've used a LOT of frameworks. Most of them fall on their ass in either the documentation or performance scope. Laravel is beasty, reasonably well documented, handles hundreds of thousands of users without a scratch. Plays well with Redis and MariaDB or anything really.Just ignore the fugly standard library inconsistencies of (old) PHP, every language has their toilet corner...Oh and it's free. All of it. PHP, Laravel. And its hosting has always been the cheapest. You don't need a particular OS or certain cloud providers.When I consider the solutions of flask and microservices I've left behind, the many node processes running with pm2, the complexity of .NET solutions... PHP just works, and it's easy to make reliable... And if it's slow, it's because I'm doing dumb stuff, not because of dark corner edge case I happened to be tripping into.It's single threaded first, queue jobs for anything slower. That simple facts make it so much easier to reason about things, and keeps the fullstack linear, transactional and easy to reason about, 2 years into it.PHP is not the best language in the world. I prefer Swift and even Go for many reasons, but it's an easy, simple, straightforward language. It's the BMX of the languages.
This 100%. It's actually a bit of a red flag to me these days if a developer turns up their nose at PHP. The language has matured a lot and building stuff with it is simple, cheap, straightforward and fast. If someone's still hating on PHP in 2023 it makes me wonder if they've been focused on more exotic technology because they were looking to pad their resume with more expensive skills, build science projects for their own amusement vs. what the business needed, etc. etc. Red flag. I've had these guys like this on my team and guess what, they built fancy over-engineered solutions to problems that no one had and then job hopped and left it for us to deal with. I can't speak for anyone else but I go into work every day for one purpose, and it's to ship shit which users use. I don't have room on my team for people who have other priorities. The amount of stuff you can get done with basically just PHP and Linux is amazing.
Don't you dare to tell me that my isomorphic Node trpc graphql with redux and sagas on top of next.js with SSG and SSR and parts in server components with my home grown validation and ORM framework and still no translations because they don't work together with everything else and deployed on serverless docker lambdas to a kubernetes cluster is over engineering a landing page with a contact form. So fast!That's a state of the art WebApp. You old PHP developer!
Don’t forget to deploy all that code to the edge. Your $5 VPS in NY running both nginx and MySQL is going to be a huge bottle neck when somebody in Texas tries to view your simple website and it takes .10 seconds longer to load. You’re going to want that contact form code on at least 1,000 servers worldwide for maximum benefits and conversions.
Also, now that you are on the edge and your form submissions are web scale you likely need to model eventually consistency for the processing so you will need a highly available queue running somewhere.
Joking aside, as someone who runs their entire saas off a single bare metal server in Las Vegas, I have been toying with the idea of pushing some stuff to the edge. The reason being, sometimes those average load times are not giving you the real picture. If my average load time is 560ms per request because 90% of requests are 400ms and 10% are 2 full seconds, that might be a problem. Fixing those 10% requests and bringing them down in line with the rest would equate to an average speed up of only around 100ms.However, I'm not yet sure a complicated edge deployment would actually fix the 10% problem.
I like the idea of a "Progressively Enhanced Monolith". Start by building the core of the application in something like Laravel that can do anything and be developed quickly, then stick it behind a proxy/CDN like Cloudflare. Then if you find endpoints or pages that are accessed frequently and would be better as their own microservice then use a small serverless worker to either respond directly from the edge or forward the request onto a microservice.
I'm jumping on the conversation , actually my portfolio website is on cloudflare pages with astrojs , it costs me nothing to host it , has a quick way to develop . I higly recomend it
10 seconds? Slight exaggeration, surely.
0.10 seconds
This made me giggle because I've heard stuff like this in serious situations.
Of course, it's based of my personal experience too. I'm not claiming I invented this at all.
Yeh, JS-land is wild. In a way, it's amazing that this ecosystem is so lively and fertile, but my gosh it's draining.
You're not using Temporal workflows? So outdated!Though to be fair, devs lose employability when they don't get to use (in their work) technologies that are gaining wide popularity. It's a balance to be struck by the CTO/architect (assuming the devs want or are able to demand that skills development in the first place).
Wait you're not using islands architecture!? Hahahaha how quaint!  Get a load of this site, it's not using islands!!
You described the marketing website of my previous employer.
And the marketing website of many others. It’s not a joke. Pure real life.
> If someone's still hating on PHP in 2023 it makes me wonder if they've been focused on more exotic technology because they were looking to pad their resume with more expensive skills, build science projects for their own amusement vs. what the business needed, etc. etc. Red flag.I get that you are arguing from personal experiences, people you met and worked with. But this statement lacks context and nuance.There are developers who don't like PHP because of outdated reasons and possibly because they are snobs. Sure, that's a red flag.But there are many who have so many battle scars and war stories with the language and its ecosystem that they decided it's just not worth the pain anymore. Even though PHP has evolved (with regular breaking changes...) and tries its best to put something useful on top of a shaky foundation: The effort required to make PHP work with you, in comparison to other languages, becomes too large and painful. I'm not talking about superficial things here, nor do I have the tendency to overengineer stuff, quite the contrary. I'm talking about writing simple, robust and efficient code.However I would say there are three very good reasons why you should use or at least consider the language:- You want to quickly hack together something useful with minimal fuss, AKA its original purpose.- Buy-in of the OO, code generation, IoC/DI, magic framework stuff that Laravel/Symphony provide.- You have to.
This comes across exactly what the previous poster was saying as someone who turns their nose up to PHP.  Especially the "you have to" gibe.> But there are many who have so many battle scars and war stories with the language and its ecosystem that they decided it's just not worth the pain anymore.I could say the same thing about javascript from the early days, through Jquery, and beyond.  Should I turn my nose up to modern javascript because of the past 2+ decades I've been working with it?  No because they are "outdated reasons" as you say> The effort required to make PHP work with you, in comparison to other languages, becomes too large and painful. I'm not talking about superficial things here, nor do I have the tendency to overengineer stuff, quite the contrary. I'm talking about writing simple, robust and efficient code.Do you have an example of this?
> I could say the same thing about javascript from the early days, through Jquery, and beyond. Should I turn my nose up to modern javascript because of the past 2+ decades I've been working with it?Yes. And I say that as someone who has been developing "modern" Typescript web apps full-stack for the last few years.My issue with JavaScript are fundamental to language design decisions that can't be removed due to major breaking changes. Things like having to deal with `undefined` AND `null`. `==` vs `===` (more specifically, type coercion), prototypal inheritance in addition to ES classes in addition to TypeScript classes. Array.push causing mutations. Having `for of` in addition to `Array.forEach` etc. etc. etc.And then  you have the fact that it is neither OOP nor Functional. So you get people from both backgrounds, and ideologues from both backgrounds, trying to squeeze JavaScript into their preferred paradigm, within the same code-base ... and JavaScript obliges. Because it is neither.Every single JavaScript application looks radically different from each other and, worse, in a large organization with many teams working on a common code-base, consistency becomes damned near impossible to enforce.And so you start adding lint rule after lint rule after lint rule until you have an entire team dedicated to maintain your custom linting bullshit.JavaScript is a complete shit show to this day even if it does have nice features and even if you can get up and running with it quickly.If it weren't so popular, and if it weren't the "language of the browser", I wouldn't recommend it for anything other than small teams who can decide on which "version" of a JavaScript adventure they want to strictly adhere to.
Same experience. JS is shitshow and dumpster fire. I’m picking up Vue 3 and every time I have a new question I need to ignore Vue 2 documentation written 1-2 years ago because the paradigm has shifted away from the “option” API to “composition”.  The same jarring change experienced in the React community when it shifted to hooks. It is no wonder I can find a cascade of defects in just about every modern website made written within the last 3 years.It is not only bad for the developer, but for the users, too. The overall confusion and frustrations are abundant.
I don’t turn up my nose though. I don’t judge anyone for choosing tech, especially if they have good reasons.I’m also very loyal and pragmatic. I really tried.I don’t want to start a language war here either. What I said above was a counterattack on the idea avoiding tech that doesn’t agree with you is somehow a red flag.My general point is: consider that there are people who have earned their opinion the hard way. Even if you disagree.
> magic framework stuff that Laravel/Symphony provideThe magic in these frameworks is evil, and likely a big part in ruining PHP's reputation. Laravel in particular hides way too much stuff behind magic, and when it goes wrong you find yourself sifting through OOP-obfuscated layers of framework and libraries just to find out how exactly your controller is called.
> The magic in these frameworks is evil, and likely a big part in ruining PHP's reputation.Have you actually used Symfony?It's an absolute pleasure in its domain and includes rich debugging abilities through its dev toolbar.
You're really doing a disservice to others with opinions that are so out of date.
https://symfony.com/doc/current/page_creation.htmlApparently there's now something called annotation routes. Which appear to be inferring functionality from comments.You made me look though. I suppose I had it coming.
They are not comments they are php8 attributes
# is a PHP comment syntax. #[foo] is as much of a comment as #foo is.
Not since PHP8 it's not [0], it's a real part of the language that you can read and view using reflection[0]https://www.php.net/manual/en/language.attributes.overview.p...
It's still using a subset of the comment syntax, and will still be ignored as comments rather than hard-fail in earlier versions.Unknown attributes are also ignored silently, which isn't really a good sign.
This is one of the reasons I like PHP, in newer PHP versions it is an attribute but in older versions it is just a comment. Clever and backwards compatible.
It isn't backwards compatible (`#[foo` used to be legal PHP 7, but is illegal in PHP 8).It may technically be forwards compatible syntactically (`#[foo]` will, as you say, just be ignored by PHP 7), but that's an anti-feature (assuming that the attribute isn't a no-op, it'll presumably break something else).
Okay, forward compatible. It makes it easier for framework and library maintainers to support multiple versions of PHP, which is nice.> `#[foo` used to be legal PHP 7, but is illegal in PHP 8).So it is not a comment in PHP8 then.
PHP8 attributesarecomments with a special format.
They are not. Attributes are metadata that can reflected/accessed at runtime:https://php.watch/versions/8.0/attributes
Comments can also be accessed at runtime :)
And a program can generally read its source code and make fancy adhoc interpretation, sure. That’s nowhere close to specified facilities that you are guarantied to be able to use with a fair amount of trust in the resulting outcome with the regular toolbox.
I honestly prefer community supported battle proven production ready "magic" than what most product developer under a deadline cobble together. In my experience the problem you describe happened like... 2 times in my 20 years career. And I literally spend my entire days fighting my own colleagues very explicit smartnesses
Sure, but it does exist frameworks that uses minimal amount of magic.It is the magic part that is the problem,  regardless if it is the framework or your own code that it is doing it.
There are really different topics here.One is that the framework can do all the magic under the wood, or not, and in (almost) no case leak any clue about that.Or, the framework can provide a lot of facilitation through conventions and there no real benefit to use this framework if you don’t leverage on these facilities. Having conventions doesn’t mean you have to be acculturated to all of them upfront though, as with proper modern IDE the learning curve can be very smooth and funny.
> when it goes wrong you find yourself sifting through OOP-obfuscated layers of framework and libraries just to find out how exactly your controller is called.debug_backtrace() has always been my friend in situations like this
Indeed so. But there's value in an ability to find out such things without running the code, just by looking at it.
What ruined PHP's reputation is people believing the language itself was a sufficient framework and unsafe SQL and escaping practices being the norm, due to naive developers (which PHP has plenty of) thinking the simplest solution (eg concatenating strings and variables into SQL queries vs prepared statements) is always the most correct.I mean, with PHP you either use a framework or you necessarily end up writing your own ad-hoc, informally specified, bug ridden implementation of one. At least frameworks like Laravel are battle-tested and should at minimum cover the most obvious issues.
It's like that with every framework: Laravel, Rails, Django, you name it.If you build a class of thing which the framework creators had in mind, and do not have a need to deviate from the prescribed ways, it's a force multiplier.Once you try to build something that does not fit the confines of the framework, it's of course possible, but the framework stops helping you, and after some time becomes more of an impediment instead.
"...Once you try to build something that does not fit the confines of the framework..."Can you provide an example of that? In my experience people think too quikcly they're smarter than the community behind the framework and that it doesn't fit their use case, and the real cause is just that they don't "like" the recommendations and think they can do better. Plot twist: They don't, and usually end up creating a terrible mess. What would be the alternative? Building your own in-house undocumented, untested, unproven framework and/or tying together 100s of libraries? Are you convinced that's going to lead to a better result for all use cases of your application? And that once you leave the company, the next developer will think "Oh, this custom framework is great... I'm glad they didn't use Rails/Django/Laravel"... not my experience... at all.I think that these frameworks are the best choice for most project, and if they're not (Like.. you're building Google Earth or Figma or something really different) then the problem is that you picked the wrong tool from the get go.I don't think that "this one special case" is special enough like to not use a batteries included framework and go wild with your imagination. Unless you're a FAANG, otherwise you're wasting your employers money.As an anecdote, I once worked for a shop that used Django. One of the developers before I was there "decided" the Django ORM was bad and promoted bad practices, etc, etc... so he wrote his own "better" ORM on top of a postgresql library. You can imagine how that went, specially after he left and the second gen of devs arrived to deal with the monstrosity.This happens a lot more frequently than you think.We should stop thinking we're "so special". We must focus more on providing business value by writing product code, tests and documentation and less rewriting the world because it's cool.
Out of curiosity, what foundation would you consider solid currently?
I've been building on Laravel for some years now and I'm always delighted how you can just ctrl+click and see the internals (and the magic). They're pretty modular and extensible/overridable.
OOP, codegen, vendorlock, and bloat-magic...Those resonate with me reminding menof some of the worst development experiences in my career. Different language, different domain, but I recognize it. The simplicity is alluring, and even enticed me at first. It just doesn't scale for problems that are complicated vs the ones you are shown as marketing. The managers and architects like it because it hides the confusing or non-elegant details from view, but that just makes it hard for the devs to work on it.
> But there are many who have so many battle scars and war stories with the language and its ecosystem that they decided it's just not worth the pain anymoreThis applies to absolutely every language or stack. You switch to Ruby because the grass is greener, and 5 years down the road you feel the same. Then you switch to Kotlin or Erlang or JavaScript and you'll end up hating it anyways if that's how you roll.
I love PHP, but a red flag?! If they’re busy in the Ruby/Java/C#/Go worlds (all get-it-done environments) then I’d just assume they don’t read many Hacker News praises for PHP. It’s easy to have not encountered it since the bad old days unless you work on a team that uses Laravel for some things.I do understand hiring someone who has that tradesman programming ethic and is comfortable with Linux, but that’s more requiring certain positive traits.
Yeah, that's fair. Now that you mention it, 90% of these guys where I get that red flag instinct I described are Javascript devs or wannabe Javascript devs. It's as if the JS ecosystem has driven an entire generation of developers insane
I'm in complete agreement there; I've seen a number of those. I like to ask simple questions about what they like about programming to catch some of those issues and look for a certain amount of self-understanding.
Exactly how I feel reading this thread, I had no idea PHP has changed so much.
I think it's a case that unfortunately many people don't understand how simple a solution can be. They've been fed the typical books and articles and firmly believe that if it's just PHP it just can't be good. Right? I mean going through all this pain and requiring that many developers, means that this solution has to be much better? Right?On the one end of the scale you've got the PHP Laravel monolith, and on the other you've got the completely serverless bits of JS over lambdas, with 12 different technologies, buckets up the wazoo, to store 300mb worth of data.Then you're told 'yeah, but this is distributed'! Okay cool, so you save 50ms of latency. Super... How long does your javascript takes to start returning content? Right, much longer. What the hell is even a cold start? How is that a thing in 2023?PHP is unsexy. And people don't like unsexy. I, on the other hand, I like my vacations uninterrupted.
One does not need PHP for that. Most well known traditional web framework with server side template rendering will do.But yeah, before you jump through the whole ecosystem of JS and require 3 different third party services, only to make a website, that does not work with JS turned off and cannot be build and run any longer 3 month later, due to dependency fup, you are much better off with unsexy PHP.
PHP has matured and has been a nice language for a decade now. But PHP developers havent. Cargo culting “good practice” and lack of creativity plagues the community. Frameworks have become so heavy that you spend more time configuring them than actually adding value. Oh and some still argue over setters and getters.
My experience is that if I join a team of PHP developers, there is a 40% chance of the team being professionals and writing good maintainable code. With Java, .NET and Python I would say 80%. C and C++ around 90%.This also reflects in their salaries.
That is my experience as well. A competent PHP developer can earn as much as developers for the languages you listed, but they are less frequent.
> PHP has matured and has been a nice language for a decade now.And how did it manage that? Python forced people to deal with encodings properly and the result wasa lotof pain. You're claiming PHP somehow invisibly fixed the numerous problems of the language without anybody noticing? That "fractal of bad design" blog post, everything described in it has been fixed?If so I want to learn how they did it. That's some heavy duty language evolution work.
There are breaking changes from 4->5->7->(less so)8This is why so many basic php web hosts continue to offer older php versions because the old code will not work and why paid projects like cloudlinux hardened php still exists. Just in the last 2 years they finally ended security support for php4 on the hardened php project.So to explain how it worked, it wasn’t as sudden as python, but the problem areas have been depreciated and removed as php has evolved.
> everything described in it has been fixed?Everything? No.Much of it? Absolutely (and the more widely a particular point is agreed upon, the more likely it's fixed). The article iseleven years old.
Encodings are a non issue in PHP and the availability of web tools is much wider in php than for python. PHP matured in the sense that it from a wordpress type of hacky language to an almost decent language. It can be used properly if you know what you are doing (ie can scale really well for the web, can be secure, allows for good oop design, can be fast _for the web_, and has a wide range of supported packages, separation of concerns and so on).
> and the availability of web tools is much wider in php than for python.If that was a metric for language quality, then Javascript would be undeniably the most perfect language ever designed by any intelligent species in the universe, judging by the number of frameworks.> to an almost decent languageAnd now I would like to hear a good reason why I should use an "almost decent language", when I can use a decent one instead.> It can be used properly if you know what you are doingIt doesn't matter what I do, the language still insists of having multiple modes of error handling, a massive amount of builtins all of which sit in my global namespace, it's configuration is still seperated between compiler flags, a system wide ini, and local config. The base deployment mode is still "dump files into folder and let CGI do the rest".
I am not saying that’s a metric of the language’s quality, nor am i saying that python is worse than php.What i am saying is that the offering of tools has matured in php - instead of a basic template engine like smarty you now have “advanced” templating engines, packages and so on. Python has less packages but that can also he because python packages work better and there is no need for an overwhelming number of packages.Regarding error handling that’s precisely one of the many issues with php. There are so many ways of doing the same thing that it becomes exhausting. And what many php devs do is they work around these issues either by endless hair splitting debates or a dubious amount of made up design patterns.You shouldn't use php, i am totally against it. I think it’s as bad as it can affect your mental health. Just saying that by comparison to it’s previous versions it has come a long way.However it does handle character encoding quite well and you can scale as much as you want to literally. Probably because thats too complex for the average php developer and it was left to core language developers which are pretty competent and experienced.
That hasn't been my experience at all. Although, I do spend more time interacting with the Laravel community (a subset of the PHP community) than the PHP community itself.I found the (Laravel) community to be more about object-level discussions ("how to do x feature the best way possible") rather than meta-level discussions.
> Oh and some still argue over setters and getters.Serious question, what does that argument consist of ?
Whether to use them or not. Petty endless debates over their benefits and drawbacks. Literarily for as long as i worked with php devs in all teams there was someone debating this pattern. As php is not strongly typed these can help with data type validation, can perform some logic when setting values, while others say it’s inefficient as thats an unnecessary method call, or that no logic should be performed in them. Some prefer to use magic functions instead of setters and getters others are against it because it makes the code difficult to maintain, some say they should only be used for data entities, others want to use them for every property, some prefer them because you can rename properties while maintaining external accessors, others against then because of consistency, some argue over what naming convention is best, some want to persist data in some type of storage when making updates, some attach observers to them and so on.Bottom line is that the language being so flexible, unassuming, and swamped by needless features almost everything can be debated the point of exhaustion.Python, being more straight to the point and not overkilling oop allows for more focus on doing what matters: business logic.
class variables can be typed now though, so the data type validation argument doesn't hold at least for basic type system validation
Then use lumen, it comes with laravel.
https://lumen.laravel.com/docs/10.x> Note: In the years since releasing Lumen, PHP has made a variety of wonderful performance improvements. For this reason, along with the availability of Laravel Octane, we no longer recommend that you begin new projects with Lumen. Instead, we recommend always beginning new projects with Laravel.
>  Nah, I’ll use python or other proper languages, thanks.Python is no more "proper" than PHP as a language.In fact, they're both identical as far as footguns go.
There's plenty of stacks that I'd say qualify as "simple, cheap, straightforward, and fast" (modern Java, for instance - huge red flag to me if people still turn up their nose at Java), including some that you'd probably consider exotic (honourable mention: Elixir+Phoenix).I personally never liked PHP, so I haven't kept up with how it has developed and I don't expect to start, to be honest. Of course, if you've got an otherwise interesting project that happens to be PHP and want to pay me to help you with it, I'll be professional about it, but there are too many alternatives that appeal to me more than PHP for anything where I have a say.
> It's actually a bit of a red flag to me these days if a developer turns up their nose at PHP.Depends on the reasons. One good reason for preferring another language is .NET/Java business app developers can earn a lot more here than PHP developers ;)
Oppositely: not being able to articulate the problems with PHP/Laravel compared to a stack of say Kotlin/Ktor or C#/MVC or Java/SpringBoot is a red flag too in my book.
Have worked at a few places where PHP was dumped on because “it doesn’t have threads”.  The dumper-folks were also noted to be for spending most of their time trying to fix threading issues (Java, usually).  Saw this in person twice, have heard similarly from other colleagues over the years.
I agree “it doesn’t have threads” is a bullshit reason. Especially since it took JS's threadlessness to make evented (aka async, aka promise-based, aka callback-based, aka eventloop-based) mainstream, and for good reasons! It allows many to maximize the compute resources better than possible with the threaded approach.There are good reasons to avoid/switch-away-from PHP... Like weak compile time quality guarantees, messy std lib, low quality of available libraries, many security issues; all WHILE great alternatives exist for free! (e.g. Kotlin, Rust, C#, Java)
Just 6 years ago you still were writing type hints in comments as suse annotations which was not PHP standard.So PHP was and might still be a shitty language.And PHP was my first language I'm fine with scripting with it but it was ugly as hell to write big code
And don't get me started with all the points where the syntax pretends to consume an expression but it's actually just the parser looking for a very specific pattern that will be read as if it was an expression, but other forms won't be accepted.Sure, it's perfectly possible to grow numb to those pains and some will even pat themselves on the back, claiming pragmatism over principles, but wow, if you're not used to that level of make-believe in computer languages you'll be paralyzed by disbelief. An endless series of "this can't be true!"
Ditto for any language. I think it is a good sign for someone to recognize the trade-offs a language makes, or even accept that they can complain about it while acknowledging they don’t understand the trade-offs.But when a dev says X is objectively bad, that is not a good sign. Languages are tools, not a way of life.
What about people who get their stuff done with mature, well established, and high performant Java and C# frameworks? The benefits of static languages is already established, particularly for longer maintained and larger code bases where multiple people work on them.
PHP8. You think it's a red flag when people don't believe that PHP8finally got their shit together.What's that George W Bush line, Fool me once, shame on...shame on you. Fool me—you can't get fooled again. But we're not talking about getting fooled just once, or twice, we're talking abouteight times.
First off, this comment reveals some ignorance about the language. PHP 6 never existed. Trying to inferanythingoff version numbers like this is goofy; in a much shorter time period Node is up to v20. Does 20 versus 8 mean anything? No.No one got “fooled”. The got a useful tool that got better over time.
Anybody who believes thatthistime PHP isn't awful can expect the same disappointment as the last few times. I'm an old man, I remember all the pain ofupgradingto PHP3 and for my sins my current work includes trying to cajole somebody's PHP7.x code into running even though it appears their employer disowned the project we know if we don't make it work the "replacement" will never actually materialise.This is a language built by people who didn't really know any better, so I don't blame them, but it's ludicrous to pretend that it's a "red flag" to have noticed that this keeps happening and learned from that experience.
These “as a super important hiring manager” brags are quite boring to read
I guess it depends on how it's communicated. If someone tells me he doesn't like PHP because of this and that reason, that's fine. Getting wound up about some specific programming language (feature) or any tech still raises a red flag for me. But then I might be terrible as well :)
I can be pretty confident that if a language is not from the ML family I’m not going to like it for all of the reasons it’s not a ML language.
Whatever happened to passionate programmers?
One of the reasons why I love working on PHP jobs is that I get to avoid "passionate" programmers.It's fine to be excited about programming but those that build their whole identity around it are just super obnoxious and not fun to work with.
Thousands at Railsconf or Clojure Conj would disagree, I'm sure but these languages are kinda special.
I am totally passionate about removing complexity from apps and stacks.
> Laravel is [...] reasonably well documentedHard disagree. Sorry, I don't have a computer science degree, why does their documentation make that assumption. I find their docs very hard to grok.PHP.net docs are no-frills no-fuss, straight to the point. Other frameworks are documented very well too, CakePHP comes to mind (at least, when I was using it last in v2 and v3).I can't say I've read the absolute latest version of their v10 docs, but when I was neck deep in 5.8 I found I had to switch to older versions of the documentation to read up on some of the most basic of Laravel features. eg. What's the syntax of using Form in Blade templates? I had to go back to v4.x docs to read up on it, Blade templating hardly got a mention in v5.x documentation, despite it being critical component in a Laravel application.If there was a bug in a project and I had management breathing a fire down at me because it's breaking the site / losing sales / stopping monthly reports from going out, I shouldn't need to decode computer science terms, or look through previous versions of documentation to find the solution.This is why, in my opinion, Laravel documentation sucks hard.
The documentation reads like a tutorial, which is fine the first time you read it, and really annoying the next 99 times when you're just trying to find something. My biggest gripe though is that the majority of classes / methods aren't locally documented with comments, or only minimally. If I don't understand how a certain parameter behaves (or even what a function does), I have to go online and search for examples, or look through the docs hoping that it's explained. And don't get me started on Facades, which are a code discovery dead end...All that being said, my overall experience of working with PHP / Laravel is quite pleasant, probably more so than other technologies I've worked with in recent years. Everything has its issues I suppose.
Yep, the tutorials/guides are really good, but as you say, the details aren't really covered. There are so many examples like "relationsToArray(): Get the model's relationships in array form."[1] Just an expanded version of the method name with no context or detail.[1]:https://laravel.com/api/10.x/Illuminate/Database/Eloquent/Mo...
The good ol' "you thought docs, but actually generated no information gain and no docs, ha tricked you! but look at how fancy our docs website looks" kind of documentation style.
> The documentation reads like a tutorial, which is fine the first time you read it, and really annoying the next 99 times when you're just trying to find something.Ah yes, the Ansible approach. I've used it for a decade, and I routinely get lost in its utterly terrible by-example documentation.They are the golden standard on how not to write documentation.God, I hate the Ansible docs so much, they are the reason I burned 30% of my Kagi search quota this month.
I think more documentation teams need to know of the concept of Diataxis [1] so they can invest in the 4 different kinds of documentation developers turn to for help when picking up a new technology:- tutorials;- how-to guides;- technical reference and;- explanation.1:https://diataxis.fr
Thanks for this.  This is something I kind of knew but would have been hard pressed to articulate, especially on the spot.  Seeing it laid out like this is very useful.
This looks very nice and is something I have been searching for but didn't know existed.
Thank you!
See also the C4 model "for visualising software architecture".https://c4model.com/
Outside of modules documentation, the rest of Ansible docs are examples. For instance, there is no page where all ways of accessing inventory variables are listed. Or supported jinja filters. They are all scattered in a myriad of examples, which you have to read, carefully, to find what you need.https://docs.ansible.com/ansible/latest/playbook_guide/playb...On this page there is no quick index of all the functions available, their argument and a short summary of how they work. You need to synthesize this information yourself by reading through ALL the examples, and hoping your niche use case is listed.There are more than one type of documentation, with different use cases. There's the tutorial/list of examples, which Ansible excels at, and is ideal for a first timer reading the docs from cover to cover. Then there's the API reference with quick index, for intermediate to advanced users, where they know roughly what they need, they just need to find it. In this, Ansible's docs fail dramatically.
I am certainly not one to defend the new ansible docs, but part of the woes that you're describing are due to the fact they just doubled down on `ansible-galaxy install` based setups, meaning there isn't "an answer" to what filters are available in ansibleThe authoritative answer to what filters arecurrentlyavailable inyourdistribution is by running `ansible-doc -t filter --list` which does include a summary line, although for some of them it's "geez, thanks" just like any open source collection of disparate modules glued togetherI used to actually build the ansible docs locally with singlehtml because I despised that chopped-up view, but now that they're all "galaxy all the things" it's practically useless again (although I will also say that building it locally and eliding all their tracking bullshit makes the pages load like a bazillion times faster, so ... still valuable in that way)
For stuff like Ansible (and other lacking software) docs i find that ChatGPT can provide the missing pieces.
The documentation for Laravel is still unreadable.Guess that is why selling Laravel tutorials seems to be a fruitful business.
The documentation for Laravelisreadable, in the sense that if you read it from beginning to end, like a book or tutorial, you will get a pretty good understanding of what Laravel does. But [supreme being of your choice] help you if you just want to find out what the possible values for a specific parameter of a specific method can be...
Nah. It's pretty bad. They only document like 5% of the features. What they do document is good but other than that you have to read the source on GitHub or Google for code snippets and I say this as an expert that studied the docs for help in documenting my own orm. They just straight up don't document most of Eloquent's features and class methods in the docs at all and it's super frustrating to me.
But why? I‘m working with it daily and what I learned is to read the docs properly. Usually it‘s me not reading correctly. There is some advanced stuff that‘s not covered in the docs, but not necessary to build an app.
That's exactly the point: a documentation should becomprehensive, i.e. it for each class and each method it should describe exactly what the method does, including all parameters etc. The Laravel "documentation" is atutorial, i.e. it describes what you should do for the most common use cases in a style designed to be read from beginning to end. Which has its uses too, but asdocumentation, it's pretty lacking...
What are the “computer science terms”? I went looking in the docs briefly but didn’t find anything like that. Maybe the v10 docs do better?https://laravel.com/docs/10.x/blade
Agree. Last time I tried Laravel the documentation was lacking a bit. E.g. there are lot of "automagic" things that aren't explained. And then you are left wondering with things like "Must the names of those 2 things really match for it to work?".
Really? I don't have a comp sci degree either, and yet I find the Laravel docs incredibly easy to grok. Do you have any specific examples of things you've struggled to understand?
What "computer science terms" did you encounter, that you did not understand? I also do not have a CS degree, but every term that I've encountered in the Laravel docs I found easy to search for. Just don't rely on Wikipedia for explanations, for CS (and mathematics) subjects Wikipedia seems to be useful only to those already versed in the field.
I struggled with sorting out Contracts vs Facades vs Traits. I graduated from university 20 years ago with a software engineering degree, where it was drummed into me that simpler often is better, and much more robust. Reading the Laravel docs however, leaves more questions than I started off with.eg.https://laravel.com/docs/5.8/contracts– talks a lot about how Contracts are powerful additions (like all the other features of Laravel, the docs are good at telling you they're powerful) and the examples show just some barebones code that doesn't really do much without a lot more work. The examples in the documentation seem to be more on the side of being some code snippets that don't convey much context.Additionally, there's lots of "congratulatory" text in the documentation ("Laravel has a powerful feature called <x>", "in Laravel adding <feature y> is actually really simple", "some developers enjoy using <feature z>". You simply don't see this in PHP.net's docs, it just tells you what the function / feature is, gives you examples that work straight out of the box, lets you know of any pitfalls or differences in PHP versions to watch out for, and there's a whole list of comments contributed by other PHP devs spanning years, that are up/downvoted.Another example of powerful documentation was that I learnt what MPTT is, and how to implement it effectively, purely from CakePHP docs back in the day (I'm talking v2 here). I can't see how anything as remotely useful would be able to be taught from Laravel docs alone; for someone who doesn't have a computer science degree, there would be a LOT of tabs open, full of rabbit holes that need to be explored. This is not effective documentation in my eyes.The difference between these sets of documentation is like night and day to me. The Laravel docs needs to stop patting itself on the back, and be more like other software projects' documentation.Don't get me wrong, I love working with Laravel, itispowerful. My issue is with the documentation, which leaves a lot to be desired.
Laravel focus a lot on branding & communication to create a hype by overselling their functionality, you are a "Web artisan" when using it, the ORM is not like other ORMs, it is an Eloquent ORM etc.
A facade cuts out the boilerplate  to achieve the same ends as a contract, which is to provide a dependency of some kind.I agree with the documentation sentiment. The documentation is enough to get one started, but not nearly enough to get the job done well. The community is overran with beginners, and you are left to your own devices once you really want to get your hands dirty.
The 5.8 docs are like from like 7 or 8 years ago. I’d say the 10.x docs have improved a lot, but I do share some of your opinions on the docs in general. Anyone can contribute to them, though.https://laravel.com/docs/10.x/contracts
The project is in a constant state of flux. So for example the Contracts you cited are in version 5.8 but they are no longer in the current versions.EDIT: I just noticed that Contracts are still in the current version just got moved in the docs, so I your point still stands.
Right, but this is a discussion about their documentation, not whether Feature X in a version of Laravel is still around in the latest version. I'm not attacking the framework, as I said I love using Laravel. I just have criticism about their documentation.
there are many documentations tells you the detail in their code.... even with the most basic usage
> it's typed (now)To note, you'll need strict mode for type hints to be useful.https://www.php.net/manual/en/language.types.declarations.ph...The fun part is, instead of going for a generic strict mode system we would have expected, PHP went pragmatic: as most application won't be 100% strict typed, you need to declare it file by file, the icing on the cake being that the restriction applies on the caller of the functions, not the function itself.It makes for complicated situations, where for instance you can make an utility class that is 100% typed and follows strict typing, but if the caller of your class isn't, none of it will matter and types will be fuzzily coerced anyway.
> To note, you'll need strict mode for type hints to be usefulThis is not really true — those type hints can be read by static analysis tools, preventing you from many of the issues that would also be caught in strict mode at runtime.
You’re right. Psalm has been a god send on the project I’m working on.Unfortunately, it’s taking far too long for Laravel to catch up so parts of its API are a black hole for types.Especially things like request input, which returns a union of string and array as opposed to using a conditional return type.You end up with assertion soup every time you touch Laravel so over time the project uses less and less of it.A well-typed framework and set of libraries would be very nice.
> Psalm has been a god send on the project I’m working on.Thanks!
The type system isn’t expressive enough for these tools to catch anything but the most basic errors.In PHP, typing is for function signature documentation.
> you'll need strict mode for type hints to be useful.false.Utterly false, I don't know where you came up with all of that nonsense. All type hints work as expected, just you can't typehint variables. Only parameters/class properties/return types.And the `strict mode` is a failed experiment no longer recommended in new code (no side effects but no benefits either).
> Oh and it's free. All of it. PHP, Laravel. And its hosting has always been the cheapest. You don't need a particular OS or certain cloud providers.Unless you’re getting shared hosting, then it’s true for most things now. You don’t need a specific OS or cloud provider for .NET, Java, Go, Rust… etc> When I consider the solutions of flask and microservices I've left behind, the many node processes running with pm2, the complexity of .NET solutions... PHP just works, and it's easy to make reliable... And if it's slow, it's because I'm doing dumb stuff, not because of dark corner edge case I happened to be tripping into..NET isn’t anymore complex than a PHP app. Unless you write many layers of abstractions. And nothing stops you from doing the same thing in PHP.
PHP has been a great language for a while, essentially since the world of enterprise became web based instead of application based. I suspect it’s not seeing too much adoption because it wasn’t always great, partly because a lot of enterprise is married to Java (which is frankly also in a decent state) and because JavaScript (with types) and Python lets your teams do a single language while also doing a react client or a lot of BI/ML.Most mature programming languages are nice to work with these days though. At least in my opinion. About the only one I dislike is C#, and that is mostly because whenever I need to use C# I need to use it with a combination of libraries (Odata, Entity Framework, Asp.versioning) as an example which simply don’t work together unless you overwrite/extend half of them. Because for most use cases C# is as excellent as all the rest.But PHP was essentially build for the modern use case of everything being web-based and it’s weird to see the reputation it still has. Then again, django is also an excellent tool for most modern work that doesn’t see the adoption it should. I’m so sick and tired of having to deal with things like umbraco failing at things that have been a fundamental part of django for longer than some of the people reading this post have been alive. :pBut I guess its all those things that keep me well paid. So maybe I shouldn’t be too angry about it.
The NPM/JS/TS hellhole is real. Moved on from it a couple of years ago, and today I switch between Go and PHP (WP custom stuff).Obviously Go and PHP are two very different languages but they bring me peace in ways JS never did. Especially when reopening older projects.
It's goofy to me how many devs think the art of writing software necessitates continually updating dependencies to have things not break. You're running in place! You could be working on something new that generates value, or adding features to what you have in that time.
To me, dependency management is a part of software maintenance and it's not always just 'running in place'. Updates bring security patches (sometimes not publicly explained or disclosed), performance improvements, and new features that could enhance the value generated by the said software.
you only point out positives, but the negatives are usually felt a lot more intensively
> Just ignore the fugly standard library inconsistencies of (old) PHP, every language has their toilet corner...Personally, I do like the way the standard library is - almost all cases of where people whine about it being inconsistent, it is a consequence of the PHP standard library andmanyof its extensions being extremely thin wrappers around libc and C/C++ libraries in general.That, in turn, makes it often possible to just take straight C library example code, copy it into a PHP file, add a $ in front of all variables, and have it magically work.(IMHO, it's no surprise that the whiners tend to be younger programmers who have grown up with Java in their university education - us older "neckbeards" are so used to the C world that its conventions are second nature for us)
>> That, in turn, makes it often possible to just take straight C library example code, copy it into a PHP file, add a $ in front of all variables, and have it magically work.* head explodes awesomeI know what I'm doing this afternoon!
Writing PHP bindings is pretty easy as well (once you manage to sort out build tooling, but that's a mess anywhere in C). Have fun :)
I've used maybe a couple of dozen programming languages over the years (yes, I'm that old). I see programming languages as tools—you want to pick the right tool for the right purpose. Whether a tool is right depends not just on the language itself, but also the ecosystem of libraries.Thanks to Laravel (along with Livewire and Alpine.js), and an ecosystem of libraries enabled by Composer, PHP is a great choice for web development. I'd not use it for, say, coding machine learning stuff though!
Absolutely. The developer experience with PHP is so far ahead of the Javascript "ecosystem" that it is ridiculous!
For those who are not familiar with the PHP ecosystem, any currently maintained framework is also fine. I myself use F3 for small personal projects.Totally agree about the single thread thinking is enough for most things. It of course depends on what you build. For example, I would use some language that runs on Beam for a chat platform.
> It's the BMX of the languages.How should I interpret this? The language is cool? Can perform cool tricks?
If you want to ride a bike, you can ride the bike. If you want to do tricks, you can do tricks.PHP makes simple stuff easy and difficult stuff possible. (But you're not going to win the Tour de France on a BMX bike.)Nowadays, a lot of other things also do this, but PHP was the first to really "get" this. I understand it's not for everybody, and for certain things, other languages are certainly better. But there's precious little that youcan'tdo with PHP, since it's been around for so long and has been growing with the Web from pretty much the very beginning.
And...the language can be taken to a high school prom - like any BMX bike can be:https://www.youtube.com/watch?v=VPVJzi7Ta9wSorry, could not resist! lol :-D
I know NodeJS well but have never used PHP, but I can attest that using PM2 is a pain and node_modules deps issues can be a hair-pulling event. But the package.json scripts provide a simple and built-in way to run basic build tasks. There's always an ~~app~~package for that, no matter what "that" is. There are also tons of tutorials, examples, and snippets for everything you want to do to get up and running quickly. TBH I really enjoy working with Typescript, it really brings sanity to JS (as long as you are consistent with it) and Express is dead simple and just makes sense.Would you mind sharing your insights into why one should go with modern PHP+Laravel instead of NodeJS+Express+Typescript? what does the PHP equivalent of pm2 load-balancing look like and how does it compare?
Have a look at quarkus.Thanks to JVM you have really good out of the box debugging features including hot code replacement and profiling.You can use kotlin which is a really really good language in comparison to PHP.There is no need in my opinion to write real applications with PHP.
In my experience Laravel teams are WAY more productive than Quarkus teams though.
I hold a center position on this. I think PHP is great for a lot of things (especially these days). I even agree about Swift. Love that lang.But for web, I personally prefer Typescript frontend and backend combos. It's amazing to be able to write everything in one language. I largely tune out the arguments and new flashy frameworks, but I get why people call the JS ecosystem a hellhole. There are a lot of options out there. That being said, when your team is competent and balances functionality with new shiny stuff, it can be a real treat to have access to npm for frontend and backend.
I've always told my coworkers and friends that the programming language doesn't matter at all (despite I don't think there's anything wrong or worse than alternatives in modern PHP). What matters is the frameworks, libraries, ecosystem, editor support, available talent, culture around it, etc. And PHP (and the Laravel ecosystem) is rock solid in that area, the best by far. I'm a frontend dev at a pretty big company, but before this I worked on a Laravel + TurboLaravel (Hotwire, etc) and it's just incredible how easy and quick it was to build and maintain things.
Symfony is better for scaling apps, I have found. I know Laravel is built on top of Symfony, but Symfonyscalesout of the box much better, Laravel is still the framework of bespoke one off projects in my experience (used it for years). It does not excel at maintainability of large apps.API Platform is really good for scaling CRUD endpoints too (its a Symfony project, or at least tightly Symfony adjacent)Of course, this is my experience (albeit over many years) however I wanted to just throw out a worthy alternative people really should look at.
Is C#/.NET overly complex? I'm used to Laravel and have been exploring C#/.NET, which while a bit complicated is nice for the static typing. I've been hearing that for web apps the Laravel ecosystem is still simpler and more batteries-included than the equivalent ASP.NET.IME, Laravel's "easy deployment" story is heavily linked to the paid service Forge, and installing dependencies during deployment is a bit slow plus takes a /lot/ of memory (we're using old Composer and Laravel versions though). What's your take?
Agree, though I would put Java in the same category as well (and actually prefer that). Great ecosystem, great frameworks for every conceivable business case, excellent performance, tooling.
There's javascript in the back. And there's javascript in the front. Curious what you use for application development on the frontend and if you have some recommendations for that?Thanks in advance!
Most of the stuff we do now we do with "Laravel Livewire".It's quite brilliant really, even for modals etc. "look ma, no javascript!". Of course it does JS for you, you just don't see it. That's my favourite kind of Javascript - someone else's problem. Livewire is a mid-way between front-end backend, it's a progressive back-end with long polling like NextJS I suppose. From your end though, it takes care of all the security of running your own API, and correctness. You basically have dynamic front-end from the backend.If you want a full SPA or you need an application that is very responsive without network requests, I recommend VueJS - Livewire recommends AlpineJS, but of course you might be a React guy, that's fine, and use Laravel as a regular API.You can even use GraphQL if you want to die of a young age, have some weird kinky thing going or you have something to prove... Unless you're Facebook of course you probably don't need GraphQL.
> it's a progressive back-end with long polling like NextJS I supposeIt’s kind of funny that this is the new best thing, when this is almost the same model JSF did decades ago.
It just had so many other issues with its ergonomics that this nice innovation was lost in the weeds a bit.
That I agree with, though I found that for internal admin pages with many forms, there was nothing more productive.
I actually used a product that built on top of it, so my experience is probably worse than yours!
All those arguments would apply to Python and Django in my opinion.
For a framework that is radically different but also PHP-native (since PHP 5), would you like to spend an hour playing withhttps://github.com/Qbix/Platform?If you do, please share your experience in a comment. I’d love to hear it. I architected this framework over the last decade :)
The way your landing page is laid out isn't doing you any favors. If you are going to build a rapid application development platform, look at Retool for inspiration in terms of designs and copywriting. Cut the token stuff, otherwise you will lose customers or self select for crypto bros. The license you chose will turn off most professional development shops and the ones using the platform would be based in places like eastern Europe where the license will be ignored entirely. Your landing page design is fifteen years out of date, this is the sort of design used to bamboozle small trades shops and non tech companies in places like the midwest and the US south, you will have a hard time attracting the sort of web engineers that will help make it go viral. Again, it depends what sort of customers you are trying to sell to, but if you intend to make a profit, the usually advice would be to offer a cloud offering like WordPress. Selling web frameworks rarely work out unless your product is a specialized database.Your copywriting gives off strong old school enterprise sales vibes with a dash cryptomania. You are not going to get much organic product led growth among the US under 40 crowd here. I suggest taking a look athttps://payloadcms.com/and study their design, execution, and copywriting.
You seem to know what you’re talking about.I checked out payloadcms though, that site is pretty terrible…
I mean no disrespect, but imo you need to get a modern UX designer involved in rethinking and redesigning your site. Message-wise, your site has too many angles, sells too many use cases, and has too many general marketing statements and not enough concrete examples. This only confuses readers.In terms of design, the site design (1) doesn't promote a linear flow of reading, (2) doesn't space out information with enough padding, (3) doesn't make good use of text sizing to create an information hierarchy, (4) has too many disparate and messy screenshots, and (5) has distracting cursor animations and alignment shifts when hovering over the top navbar. Overall, it makes for a messy, cluttered reading experience and imo likely turns many people away. Here's the page I'm talking about:https://qbix.com/platform/welcomeThe important thing is to present a very clear "how this is used" right away, targeted at a narrow set of use cases, in an easy-to-follow, nice design. Not too many examples; one key feature at a time. For the audience of devs, they need to see how the platform is used at the most basic level (the code and UI screenshots on that Payload CMS site are good examples). If you find that Payload site's layout confusing, you're probably out of sync with modern design. In any case, I hope this feedback helps.
While some of what you say is correct (e.g. about the scrolling text and the messiness in parts of the Payload site), overall your criticisms show that your view of what's easy to follow is pretty out of sync with developers here. What you perceive as "bad" isn't really taken as bad by most others here, and I'd guess they're more likely to have positive impressions of Payload than Qbix.The Qbix Communities page is definitely cleaner and more linear than the Developers/Platform page, no doubt. But it still looks very basic and again doesn't give enough focus to specific features. Instead it presents two videos (which aren't necessarily a good way to get people interested, since they may not even click on them). And at the bottom, it has two dense columns of smaller text packed together, which doesn't really invite people to really think about the features. Would be better if the text points were spaced out, given larger header text sizes, and accompanied by representative icons or even screenshots.I also watched the first video, and the example Yang 2020 app you demonstrated also looks cluttered and squeezed due to the similar text sizing and lack of spacing things out. To me it looks like it's from 10+ years ago, before flat, material design really took hold of the mainstream and became consistent across many web apps and SPA. (Pity about Yang 2020!)Sometimes it's best to question why others are having such a contrasting response to you. It does mean something. Letting go of your own opinions and preferences can be helpful for finding greater success in a wider community. Seriously, think about getting opinions from a few UX professionals, and give them some weight when you evaluate them, even if you disagree with them.
I do question it. I am happy to have substantive conversations, and improve things. You may not realize it but the current site(s) other than the Development page are the result of years and hundreds of iterations with people who expressed criticism just like yours. Including professionals. And thus what you say at this point is one data point — but you can’t please everyone.People often point out problems in design aesthetics,  and imagine that the opposite solution somehow can be realized in a consistent way that makes everyone love the result and will make the difference in platform usaage, but no. That’s not how it works at all. It’s like the people who say “your app doesn’t work” to a developer (with no details on a solution should be), and imagine that somehow this will lead to a much better app with no bugs that everyone will use.At the end of the day, adoption matters far more. Facebook is cluttered and ugly compared to many other clean beautiful apps, but people are super used to it. Discord is totally bewildering, with tiny gifs for flair and many controls are extremely hard to discover and operate, but people are used to where things are. Craigslist is ugly but at least it’s straightforward. Many more beautiful sites fell by the wayside as they tried to take it on (remember kajiji? others?)As for Yang 2020… your criticisms are fine but you should realize the design wasn’t ours. It was, in fact, following the design guide here since each community designs their own portal:https://cdn.hackaday.io/files/1665227124477248/Yang%20Gang%2...You see, when you are designing a tool can be reused in many different environments with hundreds of variations that could go either way, and still has to work, then you realize that the design decisions aren’t so simple and that these may be the least bad after having gone throughexactlythe process you described.Look, if Payload’s GIANT SCROLLING TEXT and white text in black over white text on black was the unavoidable result of hundreds of iterations, then I’d accept it. I personally think there are good reasons for what we have done, having tried tons of other variations. But I don’t think the GIANT SCROLLING TEXT, or making all links look exactly like the text, is necessary or the inevitable result of iterating. We HAVE been listening to criticism and THIS is the result.
Hi, I made the Payload siteApparently it triggers you. I don't claim that it's perfect by any means (actually I think some of what you're saying is right).
Sorry if my criticism sounded harsh. I was not triggered by it, but simply going into depth why I do not think I should spend time making my site look like that.My response was simply a reaction to the scope of criticism and the claim that this is the new best practices. Because the other site was held up as an example of what I should spend days emulating and making my site look like, the sheer time investment and “well, if you think it isn’t good, then you can’t be helped” made me believe that this is some canonical example of best practices and design. So I naturally critiqued it and said exactly why I thought the latest design standard was crap. That’s why it came out like that.If I knew the author would be reading it, I would have been a lot more tactful in my criticism. But I do stand behind what I am saying. (For what it’s worth, the developer section of Qbix also needs a lot of work, but the OTHER sections + overall design of the site I think are good — but happy to take specific and constructive criticism in the same vein I gave it.)
Don't worry, I've been a designer for 15 years and I know intimately that I can't please everyone.It's hard to get under my skin. That's actually I think what your takeaway should be here - - you can't please everyone, but you should take all feedback as valid and try and deliver something that solves for your problem the most widely.If someone feels something, then they felt it. Including your reaction to my site, and the others' reactions to your site.
Could do with some improvements, a template, maybe a CSS framework if you're not using one yethttps://i.imgur.com/RYEo7Gv.png
I agree about the developer portal. Have you seen the other sections of the site? Start at the welcome page
I am afraid that if you think that then there is no help.
Umm... are you serious? I could believe you perhaps with your criticism but then you say this is the future of web design?The site you held up as the example I should emulate feels like some kind of terminal from the 80s movie "Hackers"... are we "hacking the gibson"?It features white text on a black background, overlaid on animated white text on a black background...Then you scroll down, and it has TEXT IN A GIANT SIZE going slowly across the screen..Then it turns to white and has a video that doesn't fitThen it has text of all different sizes, and code examples, which is irrelevant to most customers.I am not making this up. It's literally here, I would invite anyone to look at these images and tell me whether this is unironically what I should make the Qbix site look like:https://imgur.com/a/IMT6pgBAre you affiliated with that site or project?
You cant take this stuff personally. I think people just try to help. 
I dont think payloadCMS site is some kind of incredible achievment but its very well done site in line what developers are used to.
Qbix website in my opinio has so many issues it is hard to point out which one to fix and how. Sorry but i think is simply a mess. There is too much information crammed together, to many various elements that dont really fit together and it makes is for anyone that visits the site really harder than it needs to be.But what i meant is that with that defensive approach you have… it is going to be tough to make it better.
Quick scan.. I'm going to be 100% honest. Screenshots looks like it's a hobby project. While scanning the code I came across folders named "files", "classes", "includes" and "scripts" are big warning signs.
Very interesting. I am shocked that this is the first time I am hearing of your framework. Any chance you can make the app setup work using composure instead of cloning from the git repo? It may increase visibility to your project.But in any case, great job with the platform!
Will look into it. You likely meant composer?
I agree that PHP is a fine language these days, if using modern features and techniques. I've seen plenty of recently written PHP that looks like it was written in 1997.That said, PHP does have complexity to running like node does with pm2, Apache or Nginx in front. Is it as bad, depends on the person, but it does suck IMO.
> It's fast, it's typed (now), it's reliable.Fast, the most overrated feature that we developers endlessly look for. How fast?
How much are you winning, milliseconds, nanoseconds, picoseconds? It's extremely likely that if something
is slow is because you're doing something wrong regardless the language and/or framework.It's reliable PHP? Well, so are Python, Ruby, Go and other friends, right?> Laravel is pretty darn rock solid.Again, so are: Rails, Flask, Django and many other matured frameworks out there that have been baked
for years now. Unless you pick some toy framework project written in a weekend I'd say there
are plenty of rock solid options out there.> Just ignore the fugly standard library inconsistencies of (old) PHP...I'll just prefer to pick a language that narrows/discards that dark side as much as possible.
Very long time ago I couldn't finish reading a page whose author painstakingly
detailed every single inconsistent feature of PHP (literally it could have taken a whole
day to read). After that horrifying testament I said myself to ever get my feet wet with PHP.
Now in a team with PHP you will need to agree which "inconsistencies" should be left out either
by adding some tool to automatically watch for that or educating onboarding members of your team.> Oh and it's free. All of it. PHP, Laravel.Aren't the other friends out there also free? All of them?> When I consider the solutions of flask and microservices...Flask AND microservices are two completely different things. You can have a full fledged
monolithic Flask application or go with the microservices rabbit hole with ANY technology 
and/or programming language that you want.So PHP, well... Nah. At least not for me. There are plenty of interesting languages and technologies
out there to be learnt and PHP for me is definitely not one of them.One question aside out of ignorance. How do people debug in PHP? Many many many years ago I worked for an extremely short time
for a company that were heavily using Laravel. I didn't know how to debug a PHP program at a time. People told me to simply do "prints" to the rendered template. If I remember correctly I also tried to find some tutorial or howto on debugging with PHP only to be unsuccessful. I'd be interested to know because with Python is just a joke to do that. Install ipython and ipdb. Then set `import ipdb;ipdb.set_trace()` and you are done, you get the full fledged mighty console where you can see everything you need to track down an issue. Up today I haven't got the opportunity to testify someone using a similar capability with PHP but hey I might be wrong and something of the like is out there.
> How do people debug in PHP?Mostly xdebug. There is also ZRay on IBM if you use Zend, but I've never used it.
> It's single threadedYou could make it single threaded. But the standard is multi threaded, and if you have more then 100 users will be have to deal with locks.That said, locks/threads are still easier to manage then async code.
Most things wrong with PHP that I really care about are currently being resolved in Psalm which undoubtedly will eventually (might be 10-15 years who knows) be rolled into the language.
PHP has types now??
Yes. Since 2015.
I'm in the group described halfway down: was on the Internet during PHP  5, lost interest in it, and moved on [to Go]. I haven't written anything in PHP newer than version 5. Even transitioning from 4 to 5 was quite a big deal, I definitely noticed improvements.But it wasn't enough.I couldn't fit the data set in memory with PHP. But I could do it with Go.I couldn't do parallel computations in PHP in order to respond to an HTTP request quickly enough. But I could do it with Go.I couldn't reliably and easily deploy to different systems with PHP. But I could do it with Go.Eventually, I couldn't write a web server with PHP. But I could do it with Go.A lot of my early websites were written in PHP and I was able to build them quickly and routinely. I didn't really have a problem with PHP as a paradigm, or even its security and consistency posture. I'm glad they've since made an actual language spec and fixed a lot of issues with it. And I don't judge or look down on PHP programmers. I just don't think it was the right tool for my jobs.
I agree, the main problem with PHP in my experience so far has been that it's very memory-hungry and slow (even PHP7/8), especially when coupled with frameworks/ORM magic.I remember after spending some time with Go, I got used to being able to process tens of thousands objects in memory in milliseconds. When I proposed to do the same in PHP, during architecture review, PHP devs thought I'm out of my mind because that would take like a gig of RAM (which would compete with other PHP processes on the server) and considerable amount of time. You have to use a lot of hacks to make it all fit in memory and be fast.Our Symfony framework also initializes in like 300 ms on each request, while in Go it's below 10 ms. As every PHP process dies after serving a request, you have to reinitialize the whole dependency container on each request from scratch, and in large enterprise applications, that's a lot of dependencies.
FWIW: There are a bunch of ways to "do" php execution, and a lot of them are wrong. That's not exactly PHP's fault, just that there's been a lot of blind-leading-the-blind.Assuming that you're not spinning up and tearing down a container for every request, you want to be sure you're running php with a php-fpm configuration (preferably talking over a unix socket) -- this is the fastcgi process manager, which maintains a pool of "hot" php interpreters for you that are immediately ready to execute code for an inbound request. This is usually good enough for most applications without going into the weeds on things like opcode caching, but that's all available as options too.I'd be happy to help troubleshoot this with you if you're interested. I've also got a fully automated build script that works pretty well. You can find my contact info via the link in my profile. Ipromiseit doesn't have to take anywhere near 300ms for php to reply to a request.
My experience is that Symfony, in its fat, batteries-included form, does take quite long time to initialize on cold caches. The first request can take hundreds of milliseconds but usually the very next request is in the normal 10ms range. This is especially noticeable on (cheap) shared hosting which has always been a common place to run PHP.I've never found it to be a problem on a VPS but if you're developing on something slow like a Raspberry Pi I can see this happening regularly. If you're used to deploying stuff in containers and constantly throw out the cache the initialisation problem can happen very easily as well.
IIRC back in symfony 1 part of it was becasue symfony used the first request to write optimized versions of the code into a folder that I cannot remember the name of.I think there was a way to do this up front in Symfony 1 and there might be some way to do this as part of a build and deploy step. Of course on applications with less traffic and less strict requirements just hooking something up to run a request immediately after deploy might work just as well, but if it runs across n  small pods it might be a much better idea to do it on a beefy build machine instead of on n resource constrained pods causing slow loading for n customers.
That 300ms initialization time sounds like a cache-free execution (aka dev mode). I have symfony projects light on ORM usage (I dislike Doctrine from the bottom of my hearth, but what can you do it's the blessed symfony ORM) and after a cache warmup it handles requests under 100ms.Yes, the frameworks have obscene (java-like) class dependencies that build up during initialization (I'd prefer if there'd be a lighter function based framework nowadays), however for someone that knows how to manage PHP on the server there are OPCache tweaks, preloading facilities which help improve the request initialization performane (these steps are also expanded on in the symfony docs).The share-nothing arhitecture of each request is either a benefit or a downside, depending who you ask.
It does run with caches enabled, my memory is murky but I remember Go processing requests on an order of magnitude faster (10x). Maybe it's about dependencies reconnecting on each request, or the large amount of classes in the monolith? I remember marking dependencies as "lazy load"  helps.>there are OPCache tweaks, preloading facilities which help improve the request initialization performanceI remember we disabled some of the settings for preload because we hit a bug which manifested as a segfault due to PHP's shared memory space for preload getting corrupted under a high load.In any case, everything is fast and usually doesn't require a lot of tuning in Go out of the box.However, I do love PHP's shared nothing architecture for the reasons of memory isolation: we have thousands of B2B tenants and with PHP, I'm confident we won't accidentally spill one company's data into another company's account. Things like when ChatGPT exposed your conversations to random people because a bug in the Redis connection pool inside Python's shared memory space returned a connection for a different user, due to a race condition.
Well, that's the problem with all PHP frameworks: they're written in PHP! Yes, PHP has gotten faster thanks to OPCache and other tricks, but still, the less time your application spends executing PHP code, the faster it will be. And frameworks like Laravel just pile on additional PHP code to execute like there's no tomorrow. I mean, just look at the callstack when an exception happens...
I was running tens of thousands of jobs an hour with an asynchronous AWS SQS job dispatcher written in php that would launch php sub processes on the CLI. Super fast. Was able to get by with a very modest ec2 instance ($20/month) handling jobs for 300k users. Was auto scaling too.PHP 8.x has a ton of performance improvements that make what you're saying sort of not relevant anymore. I prefer PHP over Python these days on the Linux CLI. The code is cleaner.
We do a lot of work with large datasets.  PHP 7&8 are so much better than 5 in terms of memory usage for large datasets.Its not magic though, and I'm not surprised a compiled executable is many times faster, especially for math heavy stuff.  Slow is often "good enough" though and deploying is quite straight forward.
I’ve written PHP apps that process millions of entities without issue at my old job. We didn’t use an ORM or anything magic. At my current job, using an ORM, my code has twice as much memory yet I can only load a few thousand entities before OOMing.If you’re willing to give up magic, it’s worth it.
What you are describing only happens in dev environmentThe Symfony container does not rebuild in production and requests should easily be served within 5-10ms as well so you might want to check your deployment pipeline and that you correctly composer dump-env prod
PHPs language peers are things like Python and Ruby, both of which are slower.
The way developers are encouraged to structure PHP projects (mainly due to autoloader semantics) always felt more like Java or .NET to me than it did like python. The resource consumption comparison between a Symfony web app vs the same thing written in ASP.NET or Spring Boot has a pretty clear winner, and it's not PHP.
Well that depends. There are like a dozen python interpreters and JIT compilers. PyPy is fast, albiet memory hungry.
If symphony takes 300ms in prod. Then you have a serious problem!Probably a configuration missing.
All i see is that the php fpm based frameworks (e.g. laravel) are 100x - 300x slower. And this is the best case scenario. When projects grow, php-fpm gets slower and slower. Which is not the case for go. Im not a go-fanboy, my entire carreer has been in PHP. Im just saying, PHP is one of the most terrible languages for web servers. And it's all php-fpm's fault. On top of that, the PHP community seems to promote OOP and SOLID which are the last design patterns you want to combine with php-fpm. There's a reason why facebook created their own PHP transpiler.
Isn't that synthetic benchmarks for toy projects? The amount of code which is run on every request grows with the size of the project in PHP/Symfony (which can take quite some time in a huge monolith), while in Go, everything is usually initialized once at startup.
This benchmark means nothing.
In terms of parallelization and reinterpreting every request, there is Swoole (implemented in Laravel as Optane) that fixes both of those issues. Most Laravel projects can handle 2x as many requests with a simple modification.
I agree with every checkmark except for Go.PHP was the right tool at the time especially when everything on the web was somewhat Wordpress first. PHP felt like a blast with WAMP/LAMP.Since then I have moved on and honestly it never occurred to me, that PHP still could be an option in my tech stacks, neither one of my devs recommended it.No one hates or disliked PHP, there are simply other options.Looking back, recommending PHP today feels like "You can do this with jQuery, too" in the Frontend domain. Yes, you can, but maybe you shouldn't or only if you have the right people. And PHP is a rare skill now.
I’m not defending PHP necessarily, but yes, obviously a language that’s more performance oriented will be better at performance-oriented tasks.
I'd say PHP is great to get started, Go is for when you need more control, more mechanical sympathy.I did write a REST/JSON API in PHP 5.2 (two years ago, I'm aware there's newer versions out there but they aren't easily available in RHEL 6/7 used at our customers at the time - it was a slow moving industry); it's doable, and using best practices learned from other languages makes it look maintainable at least.Did run into some issue with large datasets though, but that was an implementation problem; the original author would read a CSV, convert it to XML using concatenation, then parse the XML to convert it into JSON because at some point a decade ago he found out that the X in XHR was no longer (and never was) the norm, all in memory. That broke when there were more than a few thousand rows in the CSV.
Yikes, you can't attack others like this on HN. We ban accounts that do that, regardless of how wrong someone else is or you feel they are.If you'd please reviewhttps://news.ycombinator.com/newsguidelines.htmland stick to the rules when posting here, we'd appreciate it.
If you had stuck to facts rather than being insulting and inflammatory, I don't think your comment would be downvoted.You make some interesting counterpoints but people aren't going to see them because of the  counterproductive language surrounding them.You should take a look at the HN guidelines.
Your response here feels unkind and combative
In almost any scenario?>I couldn't fit the data set in memory with PHP. But I could do it with Go.I guess this on is self-explanatory.>I couldn't do parallel computations in PHP in order to respond to an HTTP request quickly enough. But I could do it with Go.Consider the following (covers both statements above): you need to get some data from a few sources (databases etc) do some computation on each set and then do some sort of mapping to get the resulting set. You may want those computations to run in parallel and idealy you'd like to start mapping as soon as each computation function starts producing results.>I couldn't reliably and easily deploy to different systems with PHP. But I could do it with Go.I haven't been using PHP since 5 but I assume it's still much easier to just push you Go binary to a destination.Though with Docker and company deploying PHP code is not a big issue these days I assume.
> >I couldn't fit the data set in memory with PHP. But I could do it with Go.when would you ever have a website serve a request, and have to use gigabytes of memory to do so?> Consider the following (covers both statements above): you need to get some data from a few sources (databases etc) do some computation on each set and then do some sort of mapping to get the resulting set. You may want those computations to run in parallel and idealy you'd like to start mapping as soon as each computation function starts producing results.Again, why would you ever have an HTTP server do so much work in order to serve a request?
>when would you ever have a website serve a request, and have to use gigabytes of memory to do so?I'm pretty sure that PHP is not only used for web sites otherwise comparing to Go is simply meaningless. There is little to no point in using Go to build something with a relatevely low load.>Again, why would you ever have an HTTP server do so much work in order to serve a request?http server != website. You can have two services somewhere down infrastructer that communicate via http(s).
> I'm pretty sure that PHP is not only used for web sitesPHP is explicitly designed to serve web content. It's usage may vary, but it is unfair to expect it to optimize towards anything but as a web backend.
>you need to get some data from a few sources (databases etc) do some computation on each set and then do some sort of mapping to get the resulting set. You may want those computations to run in parallel and idealy you'd like to start mapping as soon as each computation function starts producing results.This definitely sounds like a typical situation for handling the job in a queue (plus with an async library like spatie/async to retrieve data in parallel), though I see the advantages and convenience of using a natively-async language here.
An example (not the best one maybe but I'm not the right guy to come up with good examples immediately) from a year ago:We have to integrate company M and W (one is a marketplace the other one is a big store, think Walmart or something).Company W mostly uses software similar to SAP-whatever and have a small team resposible for building 'helper' services in place where SAP can't do the job.Company W can't communicate with M in any other way except through your generic http API they provide.So every now and then M has to send a request to W and W has to prepare a pretty large XML response. (obviously the data is split in some way and we are not talking about tens of GBs but even so W has has to fetch the data from  more than one data source, process it and send it)In some cases you can simply have a cache\a view\whatever for this (so you only have to fetch prepared data) but in some cases you can not.PS: this is if we are talking about HTTP communication. Or maybe some real-time communication where you can't really respond with "hey, we are getting your data prepared so just wait for a bit and re-request it with this nice jobID at a later time"
Well, for that use case, it would be typical in my industry for party A to send a callback URL to party B, so that B can POST the required information back to A after doing the multi-step processing. It's not really a done thing to make a synchronous HTTP request and wait say a minute or more for the response. Maybe that's just different expectations in different industries, though.
Developer advocacy is such a weird thing, do it right and people will line up for you to mentor them and pay you for it, do it wrong and you will people scratching their heads asking "so you can do with this thing what you could do with Perl + CGI 15-20 years ago and still not get more performance out of it?".Sadly this article is the latter.I'm working on both sides of the fence -- dynamic strongly typed language (Elixir) and static strongly typed languages (Golang, Rust) -- so I am already sold on the advantages of dynamic languages. That page is doing a poor job selling PHP to me though, f.ex. it's not clear when you do `$request->user->orders`, does that automatically go to the DB? Does it first fetch the user and then all their orders, or does it do it in one go? Is the whole thing prone to N+1 queries like Rails is (was? no clue about it nowadays)?Posting cute little coding snippets is skipping 99% of the story. The code mustremainsmall and simple and understandable and easy to dissect / troubleshoot, long-term, and allow for adding metrics / telemetry, analytics and such.So OK, we get it, you're so hyped about PHP that you made a website about it. Alright. Now do a cookbook. Next show us a 5-year old project and tell us how long does it take to add a feature or fix a bug exactly. Tell us of the issue that took you the longest to troubleshoot -- and why did it take so long.Before that this is basically a surface-level marketing page that says almost nothing and is not even accentuating the strong sides of your loved technology because what I am seeing here I can clearly remember 5 other languages I've done it successfully with: JS, Golang, Elixir, Rust and Ruby.
> Is the whole thing prone to N+1 queries like Rails is (was? no clue about it nowadays)?Rails has had the ‘include’ method which solves n+1 since version 3.0 around 2010. Before that it also had preload which worked similar.
Planet php has a strange and probably unique geography. It has its large continent of modern generic web frameworks but it also has these countless small but thriving islands of specialized platforms that solved specific problems.But islanders and continentals dont talk or help each other.You can obviously build from scratch a blog, a wiki, lms, forum, analytics, e-commerce, survey etc. etc. site in Laravel. The funny thing is that it is quite likely that theleadingopen source solution for what you want to do is already in php (wordpress, mediawiki, etc) yet you cannot benefit much from it. You definitely cannot import it, but you cant even learn easily from it unless you dig deep into a complicated codebase.Because php is so old and so adapted to web development people went on and built wonderful things with it, capturing complex domains with all their peculiarities. But that valuable knowledge base remains fragmented and locked within each one of these monoliths.Going forward there is ever more intense competition between open source language ecosystems. A lot of improvement efforts look inward (making languages faster, safer).The php community might also be able to draw unique advantage looking more "externally", taping the enormous domain knowledge of all these projects. How that could be done in practice is an open question, but it could become the USP for php, the way data science has become for Python.
Why do most PHP related posts on HN read like repentance ? If you want to promote the language -to the point of buying a domain and making a webpage-, please show interesting stuff, not something that is equally trivial to solve in gazillions of web frameworks written in gazillions of languages.
I don’t get that feeling. And I like that people are doing their best to try to improve the reputation of the language. The reality is that modern php is very decent, but a lot of people that have never used it or have used a very old version mock or look down upon it for no apparent reason.It’s important to try to improve the reputation so that it gets new developers interested in it in order for the language to keep being relevant.If you want a concrete reason why I think php is great and has many things that are very useful compared to its competition:Extensive native support for classes and types.Php does class-based OO better than its competition (JavaScript, python).Designing a traditional object oriented system using classes and interfaces is better in PHP than in JavaScript and python, if we limit ourselves to the native features of the language.For example, you cannot define a native interface or an abstract class in python or JavaScript. JavaScript classes, since they’re just syntactic sugar, havea lotof unexpected behavior.In python you have to accept the this/self object in every method definition.Here are a couple of links about php classes, interfaces and types for anyone interested:https://www.php.net/manual/en/language.oop5.variance.phphttps://www.php.net/manual/en/language.oop5.interfaces.php
You just prove my point... you start your post with something that reads like "it's decent now, please look at PHP again". But:- you make bold claims about PHP OO
    - you make downright false points about other languages
    - you nitpick things that are non-issues in other languagesAll in all, nothing in your post really seals the deal about PHP. It's not about mocking or looking down on PHP for no apparent reason. I'm pretty sure most of us on HN have used it already and most of us have followed its development. I sure did. And every time a new version comes out, I welcome the improvements although it's just mostly catching up with the competition. So what compelling reason do I have to use it again in 2023 for greenfield projects ? None. It used to be "the web specialist", but now all platforms have great web frameworks along their distinctive features.
PHP sucks though.
I wouldn't say it sucks, or rather at this point it has its warts like any other platform. It's definitely not a pretty thing, and it was never meant to be. It's something that borrows from the competition rather than innovate.
Name something better to build web sites.
HTML
Yes, I agree. But if you want to do some form of dynamic rendering and not static rendering HTML only is not an option. PHP matches HTML pretty well.
I've been using PHP for about 19 years and what I can tell is that both the language and its community have evolved the right way. Writing modern PHP is a joy, IDE support is great and we have tools for everything.Modern PHP is about community standards, not about any particular framework and exposing Laravel as the best way to get started with PHP is questionable. I wouldn't recommend it to anyone wanting to learn (real) PHP.The article praises PHP but it is sad that doesn't link to any other resource or project which ditches the value of PHP community.Laravel is great for RAD which is attractive for small projects. The kind of stuff "business with 500K orders runs on a $6 VPS" thing. For clients wanting a robust software system you can use a better tool.
Yeah, I think phptherightway.com does a much better job introducing people to modern PHP.
The only bad part of the PHP community is the people that have never done anything else other than WordPress. The shittiest more careless horrible and bad practices riddled codebases I’ve seen in my life come from WordPress developers. It has nothing to do with the language though, it’s just that part of the ecosystem which I think is what drives all the negativity and looking down towards PHP.
So Laravel is not robust?Honestly asking. Haven't written PHP in over 20 years.
Laravel only seems to be for small stuff like
- the backends of Apples Webapps
- spiegel.de, the biggest German news site
- the New York Times website
- backend services at Disney
- About You (large online retailer)Seriously, though, I myself work for an enterprise that runs big parts of the European energy grid and we use Laravel for all sorts of stuff. At a previous job Laravel powered a whole ISP.Notice when people say Laravel is good for small stuff and early prototypes, they never explain why.
> Your website is automatically protected against XSS, session hijacking, CSRF, SQL injection, host header attacks, and other vulnerabilities.That's quite misleading however
Just made the same comment and deleted it seeing that you already stated it. Protecting against all of these is hard and no tech is going to automatically protect for all of this on its own. Such a weird statement to make that takes away from the message of the site entirely.
I worked for a company and we used the PHP ORM Propel. So in theory no SQL injections you would think, WRONG.We used a function like findOne() (I don't recall exactly). It looked like this:$resetTokens->findOne($GET['password-reset-token']);The issue was that findOne would accept wildcards, so one could use ?password-reset-token=% in the URL and reset the password of any random users.
I think the webpage is talking specifically about Laravel. It ambiguously doesn't mention Laravel till later, but the code snippet looks like Laravel code. Laravel's ORM does sanitise strings.The snippet also validates request inputs, so clearly it doesn't assume that inputs are safe.
I totally agree with everyone before me here on the issue of security.If an app stands the stress test against say for example this comprehensive list(1), it can consider itself somewhat safe or at least benchmarked.
Otherwise, only vague and unsubstantiated claims, which does not help PHP nor any other programming language or framework.[1]https://github.com/payloadbox/xss-payload-list
In both Symfony and Laravel these days they have their own request objects to help you get information on the request. You shouldn’t be reaching into the get or post variables directly like that.i.e.
$request->query(‘password-reset-token’);
That’s a parametrized API that’s supposed to be safe against injection, at least to anyone who’s ever used parametrized APIs and hasn’t read the documentation of this particular library in detail. That it supports wildcard makes as much sense as log4j executing code in textual messages.If an ORM/builder casually puts =/IS and LIKE in the same method, don’t touch it.
The code snippet is very Laravel, and it does a lot to stop all those attacks with that API.
Rails does a pretty good job.
PHP has come a long way and I have since changed my mind about Laravel but I love Ruby, and Rails does an awesome job. Laravel actually seems to try to mimick Rails in PHP
I've tried Laravel, it's a beautiful framework.
But I see no reason to switch from Rails, it's a beast.
Hi!I'm looking for advice on how Rails vs Laravel compare (as I'll have to pick one of them soon for a project). Assuming the same knowledge and familiarity on both of them, why would you prefer Rails over Laravel? Thanks!
Ruby is a beautifully-designed, concise language. PHP is the opposite. If you like Java-style verbosity you may like PHP. I don't.
Yea, I think what makes me enjoy Ruby a lot is the ability to meta-program a lot. I can mold the language to what I want to express.Of course, this can be a double edged sword if you aren't comfortable in the language yet.
The reason why I stuck with Rails is because I am already a Ruby user. I like PHP and all but I am way more comfortable with Ruby.I don’t think there is anything Rails can do that Laravel cannot and wise versa.It’s about taste.I think Rails + hotwire hit the sweetspot for me!
In general I think there’s something to be said for sticking with languages that match your model of approaching a problem. DHH gave a good, albeit a bit rambly, keynote on this topic once. He compared some of the tools selection conversations to the equivalent of people comparing gaming consoles purely by specs when in reality, picking a console mostly boiled down to what you subjectively enjoyed more. I like that idea as a rule of thumb and encourage people to start there and go with what feels right for them before making deeper choices. (Lots of nuance here, don’t want to delve too deep so please view from that context :) )
Thanks!
I think the easier way to do things is mostly always the secure way in Laravel, so unless you go out of your way to do something weird, you're mostly safe from those attacks once you know how it works under the hood (to some extent) and what Laravel does and does not do for you.
You don't get XSS protection out the box from any language's standard library, nor CSRF.
You do get XSS protection out of the box in most templating languages, though, and PHP is also a templating language.Take this template:<h1>{{ title }}</h1>In most templating languages, for a title of "<script>alert();</script>", the result will end up being:<h1>&lt;script&gt;alert();&lt;/script&gt;</h1>In PHP, which is a templating language, the equivalent seems to be:<h1><?php echo $title; ?></h1>But this will print the title unescaped, which is a security vulnerability, and incorrect. In reality, the equivalent is:<h1><?php echo htmlspecialchars($title); ?></h1>Now, you could say, don't use PHP as a templating language! But if you're not supposed to use PHP as a templating language, why does it behave as one? This is one of PHP's footguns to be avoided. Personally, I recommend a linter like PHPCS to catch issues like this one.
Templating languages are abstractions on top of other technologies. I don't see how PHP is a templating language. I could write that exact same code above in NodeJS and I'd need to use mustache to escape the output. So you can make the same mistakes in Node, Python.Nobody writes PHP mixing HTML and PHP anymore, and if you do you should run. Shit code is not unique to PHP and I've seen more than my life's share in JS and Python codebases.
>I don't see how PHP is a templating language [...] Nobody writes PHP mixing HTML and PHP anymorePHP is designed to be a template language, but it's a terrible template language, so nobody (it is claimed) uses it as it was originally designed to be used anymore.So "use PHP" is not good advice if what you mean is "use a web framework and a separate third-party template language", which works just as well in any language and doesn't give PHP any particular advantage.
Tangential, but I've always found Mustache's tagline "logic-less templates" confusing - what they mean is that the template language doesn't have control flow. Logic is not a synonym of control flow in my mind.
Well, of course not from any lang that treats HTML as a string, but there are langs, which treat HTML as structured data, in their standard libraries. Take a look at SXML libraries for example. Whatever script you stored as a username for example, it would still get treated as text, not tag, when put into lets say a span or p. SXML is aware of the boundary between tags, their attributes and their content.
I googled SXML and it appears to be have implementation libraries in lots of languages. This is not the core language's standard library.
What do you put as the distinguishing feature between "core language standard library" and "comes with the language at installation"?Some example:https://www.gnu.org/software/guile/manual/html_node/Reading-...(no installation of anything third party required)
Alright, let's go with widely-used programming languages for now - I've been programming for over 20 years and never heard of Guile.I am not against the idea of having native protections built into stdlib, we can agree there, but it's disingenuous to suggest that this problem is unique to PHP as the parent comment suggested. It's the same in all of the major programming languages used to spit out HTML as far as I can tell.
Oh, very much so. I don't doubt it. Most of them are doing it wrong, fiddling with strings, instead of structured data, which HTML would lend itself really nicely to. Especially PHP, with its "output HTML" in-built mentality should have gotten it right, but did not. Many others did not do any better.
> There is no need to compile anything.But I really like compilers, they catch a whole class of bugs, before I run things.
While you don't have a proper compilation step, you can run some very good static analysis on PHP.I can't imagine not having Psalm or PHPStan in our build pipelines.
The compilation step, and the resulting binary, is also very useful if you need to distribute your software. As opposed to creating a ZIP file.There are tools for creating stand-alone executables from PHP source code, but they're not as nice to use, compared to languages that were designed for this. By distributing software I also mean making your latest code live in prod.I suppose the benefit of using PHP (or other interpreted languages) is that it's easier to create "plugins", just copy the new source files to the server.
Correct. I had a use case where I needed to run an app on 30,000+ servers and the app would be updated regularly with new features. I wasn't going to use PHP for that because it would involve not only copying the PHP binary around (and maintaining that version), but also my own app code. golang ended up being a perfect solution because I could cut the binary down to about 3-4 megs with compression and build flags. More importantly, it was just one thing to install and maintain.
PHP has a way to compile entire applications into single files, for what it's worth. You can compile it all in your CI/CD and then push the PHAR file to all the servers (instead of the thousands of regular files). I don't know if it accomplishes everything you're after, but it's been a PHP feature for over a decade.https://www.php.net/manual/en/intro.phar.php
As the op said: "There are tools for creating stand-alone executables from PHP source code, but they're not as nice to use, compared to languages that were designed for this."
Unit testing is a poor mans compiler. Our medium size rails app has 40,000 unit tests and constantly we have issues where an updated library changed the name or parameters of a method without warning causing breakages.
Yikes. Is there a static analysis tool for Ruby (along the lines of MyPy or PHP Stan) that could have caught this?Also, out of curiosity, are all of those tests hand written, or is there some generation in there?
All hand written over 10 years. They catch a lot of stuff, but stuff still slips through. Generally the area of the breakage even has tests over it but didn’t manage to catch the particular issue or they had mocked out parts which ended up being the issue.I can’t see how static analysts could solve it really.
imho, this is a huge reason why ruby fell off the popularity charts over time. i predicted this pretty early on and got a lot of flack from the ruby community as a result.nobody wanted to write tests to ensure that something would compile... let alone tell you what 'type' an object was. i can't tell you how many hours i wasted watching my pair trying to figure out what 'type' an object was, by using `print`. luckily i was working as a very expensive consultant.of course these things could be bolted onto ruby, but it never felt natural. running 40k tests to see if something compiles is absurd, takes forever and results in super brittle tests that have to be reworked when code changes. often people would use meta programming in the tests, which only made figuring out the errors even harder since the line numbers would be all wonky in traces.sorry you're saddled with that legacy of well intention and poor execution.
Not enough.
It’s cool to see PHP getting its second heyday once again. It’s currently a perfect storm of two communities starting to notice PHP. From the JavaScript side, people are comparing React with PHP, and on the bootstrapped start up side, people are talking about just using a single index.php file for your entire product without dealing with a complex tech stack as inspired by Pieter Levels.
> It’s cool to see PHP getting its second heyday once again. It’s currently a perfect storm of two communities starting to notice PHP.Really? I see no evidence that this is happening
The Frontend / server less / JS ecosystem craziness and high rate of change has left a lot of devs disenchanted.High profile posts over bundlers, tailwind,  and microservices set the scene.A few popular people on Twitter have been talking about Laravel which has influenced other devs.Wind is in Laravel's sails, not php's
PHP has never been replaced as the dominant scripting language for the web.
Almost every PHP site also uses JavaScript so I'd say not
awestroke asked for evidence, but your long comment provided none
"500,000 orders per month"That's like, what, 12 orders per minute? Is this meant to be impressive or something? I bet any language run on a modern laptop can handle that.
"when hosted on a $6/month server"Dropping half a sentence will often make it sound goofy, yes.The point being made is "you don't need a massive K8s infrastructure to handle hundreds of thousands of orders a month". Most people don't;https://www.joelonsoftware.com/2001/04/21/dont-let-architect...is an oldie but a goodie on the subject.
>"you don't need a massive K8s infrastructure to handle hundreds of thousands of orders a month"This is true of many languages that are slower and faster than PHP. It's not useful as evidence of PHP being a better choice for anyone.
It's not an argument of "this is the absolute best possible choice".It's an argument that raw language performance in this sort of context isn't going to be the problem for 99.9% of people developing code. If you have 500k orders a month,you can afford more than $6/month in hosting.I sometimes see folks post on StackOverflow trying to micro-optimize things like string concatenation or single versus double quotes that make perhaps a second of CPU difference in a million executions. The point is directed at those folks; the ones who are thinking "language X is faster, and for that reason alone I should use that instead".
Boasting about 0.2 requests per second, even on a minimally spec'd VPS, is damning with faint praise.
An "order" would involve far more requests than just one however...
That was a bad way to make the point, because you could serve five orders of magnitude higher with PHP, or node or go or python or pretty much any language right now.On top of that, You don't need massive k8s infra for any other framework either, so it isn't really a selling point for PHP itself.
>"when hosted on a $6/month server"So with hardware specs better than the Chinese laptop I bought second-hand for 150 EUR (which has a Celeron J CPU), the very same one that can serve 2000 req/s on Elixir and 5000 req/s with Rust, then?Sure, waiting on the DB is often 95% or more of the request, I get it, but 0.2 requests per second (which is the 500K orders per month when you do the math) is nothing to brag about regardless of which language or DB are being used.It's even below the level of having a bash script doing the heavy lifting.
I thought the same thing. PHP is a fine tool but that is not a value add statement. The code can "handle" anything, it's the underlying OS and related systems that limit the load.
For every request that generates an order, there are probably a dozen or more requests that doesn't generate any order. Also, OS these days are so bloated a $6 vps will barely has any memory left on startup before you actually run any workload on it.
A $5 linode with debian 11 has like 950mb usable on boot?
try a nanode from linode. $5/mo and as bare-bones as they come. no bloat there.
Or smartphone.
I am an erstwhile PHP apologist. Having come back to PHP after a long time away (not really by choice), I can confirm that the language has improved significantly since PHP5. PSR was a huge success in a lot of ways. However there are still a few things that prevent it from being my language of choice.First off, there is a surprising number of core behaviors you'd expect from a modern web application that there isn't a clear go-to for in the PHP world. Does anyone know of a well maintained library for publishing and consuming AMQP messages asynchronously?PHP is still limited by living inside of the context of the request. This has an effect on certain types of application-layer caching, and makes for a poor model for backend scripting.You also still need to interact with multiple layers of dependency management -- from os packages to pear packages to composer libraries. Configuration can be messy, and many projects still aren't containerized.Finally, while the language has evolved, many of the projects that use it have not. The longer lived the PHP project, the more likely you are to encounter the exact paradigms that make it so hard to work with. Other languages have benefitted from a much greater percentage of their lifespan being supported by ecosystems that encouraged keeping your dependencies and the parts of your code that exercise them up to date.That being said, it's great to see that there is a path for starting new projects with a modern framework. But I would have said the same thing about Zend or Symfony, and those seem to have fallen off for reasons I don't know.
Async Messaging:https://symfony.com/doc/current/messenger.html#transports-as...Some of your complaints are a little weird.  
* The OS package/pear package thing is highly dependent on what language features you want to add to the base language.  If you want, you can install all those features with pear.  It's just easier to install with OS packages.
* Composer used to add libraries to your code base
* The fact that "many projects still aren't containerized" has nothing to do with PHP.  I doubt there are many languages where that statement isn't true.
* No idea why you think Symfony has fallen off.   Laravel has large chunks of Symfony code inside it and the project is going strong with regular releases.
> It can handle more than 500,000 orders per monthHow many seconds in a month? 60 * 60 * 24 * 28 = 2,419,200.So basically, its performance is at least 0.2 requests a second...
Realistically, and speaking from professional experience of over a decade, "creating an order" can be one of the most complex tasks your frontend part (as opposed to admin/cronjobs parts) of the web app is going to do. It is not a rare thing to see dozens of records in a dozen of tables being created/updated at order creation time. All of these "order creation" examples are super naive. Once you develop for a shop that operates in $10M+/year range (i.e. there was probably time and money to bloat all the user/cart/stock/warehouse/sales/dispatch/marketing operations and metadata), god forbid a shop that has lots of legacy code and data structures, you will be fine with anything around 1s at order creation.(Not that I want to defend Laravel's speed, it's not really anything to brag about, and the typical "cache everyhing everywhere all the time" aswer is not that useful.)
While 500k order does not sound as much - you have to remember an order != a request.Not to mention that as long as you have a direct sync query to a database - your code will have to wait, lol.
Yeah...OTOH it makes a point that it solves a real problem. A business processing 500k orders a month is not trivial.
I know it's just meaningless numbers, but our php backend handles 10 orders per second peak. And obviously a order requires many more requests than just 1.
I have a client that handle peaks of 7k requests/s using php-fpm + nginx + MySQL. Using their own custom framework in PHP.It all sits in a single 5 year old machine with 8 cores and 16GB RAM. Their bottleneck is actually MySQL but they have room to spare so no need for upgrades right now.
I help with an open studio event.  We maxed out last weekend at about 350 visitors per minute (about 30%Wordpress and 70%custom php symfony pages) on shared hosting.  We have a cdn helping with images and such.
They’re not wrong… PHP7+ is blazing fast, has a huge library, gradual typing support, etc.If starting a new project in the space where they all “compete”, I would choose PHP7 or PHP8 with Laravel or Symfony (or maybe even WordPress) over Rails, Django and probably over NodeJS.
You lost me at WordPress haha...Ive a lot of love for WP, but I don't really get the appeal of extending it past blogging... if you're doing anything more complicated it's pretty trivial to implement blogging functions in your site.
The days of WordPress being used for only blogging are long gone. I have many, many multimillion dollar clients using it as the hub for their whole company (none of which have blogs). It's crazy how it just...works. A little PHP-FPM tweaks here, a couple NGINX tweaks there, and you're off to the races. Very little maintenance, almost no downtime ever.
You are probably the cleanest WP + PHP developer in history, who contrary to the messed up ecosystem of WP plugins has clean coding style that puts everyone else in the WP ecosystem to shame then, or those multimillion dollar companies don't actually need that much functionality on their sites.Even the data structures in a default WP setup, making everything as post types is silly for anything not a blog and I wouldn't build anything on top of that ever again. Most of the examples (all I ever saw?) for themes are silly, because they use concattenation for HTML templating, instead of composition. Not long and a theme will become messy, unless one is very vigilant, but then code reuse inside the same theme obviously suffers.Basically the whole ecosystem is full of anti patterns that one would avoid usually, but that somehow have become the tutorial samctified way to do things in WP.
> You are probably the cleanest WP + PHP developer in history, who contrary to the messed up ecosystem of WP plugins has clean coding style that puts everyone else in the WP ecosystem to shame thenWhen you give people the power to do anything and dozens, or even hundreds of millions of people start doing anything and everything they can think of, many will create major messes. That happens with anything that becomes extremely widely used.> or those multimillion dollar companies don't actually need that much functionality on their sites.The WP world is so big that it has its own specializations and their subspecializations. You cant imagine what kind of complexity is involved in such systems and the variety of the problems that are being solved.What WP does is to solve the problem of launching, running and maintaining A LOT of things right out of the bat, allowing you to build even more complex things. There are widely used plugins for many things ranging from using replicated databases to launching full fledged software/app store websites. The enterprise WP world builds on it instead of rejecting what others already built and are maintaining.WP runs 50% of all the websites at the moment. 30% of all ecommerce websites. And 'website' means anything ranging from the sites of CNN, Reuters to the $5 florist shop site a flower shop owner in Oregon just launched without knowing anything about programming...It works. That's whats important.
No doubt you're right, but the "just works" part kinda just seems like it's to be attributed to the LEMP stack no?I just wonder if a lot of these shops would be better off starting from something like OctoberCMS or all the Laravel add-ons like Nova or Spark which give you Admin and Billing UIs pretty instantly?
there is something to be said about the huge installed base of WP. one radical new plugin that is not deterred by the "blogging" typecasting can change the world.
wp's appeal is the admin/cms backend which can be used by nearly anyone. it can also be deployed nearly anywhere, easily.
Not gonna bash PHP, but WP... never again.
My experience with WordPress has been broadly positive under certain use cases. What were the negatives you saw/issues you ran into?
I've had enough problems with WP installs that I won't ever touch it again and I don't even want to list specific issues, but it's all about quality. So for a while it has been the same story, over and over:- non technical someone wants a CMS
    - I tell them I'll build them what they need, then give them a quote
    - non technical someone doesn't like my quote and installs Wordpress and a gazillion shiny plugins, because "it's easy with the shiny admin panel and I can install it anywhere for cheap and all the functionality is already covered in plugins"
    - things break, because plugins are meh
    - things go real bad, security issues, loss of data, shitty performance, the whole piñata
    - non technical someone cries over the phone "can you fix my website ???"
    - I won't fix their website because I like to build things, not clean up someone else's mess. Feel free to fill that business opportunity but I want to do something else.
Laravel is probably the top reason why I moved away from PHP to Go. I find it frustrating to have to learn custom DSL and custom syntax to do basic stuff. Which then of course if you learn is going to be useful until the next major version of the framework, at which point you will have to re-learn everything over again. I like how I can just know the Go standard library go into dozens of different projects and still being able to contribute because there are no custom frameworks and DSLs.
I think its a great reminder to code with whatever you feel comfortable. For example, my last project I did in Centos/Apache/PHP5/Code Igniter 3.1 with some WASP for protection I did for 12 years and sold few months ago. It checks out against Qualys Server test and ImmuniWeb very well. I sold it for close to $10MM with annual revenues of $1.6MM. The last question the new owner asked me was "what did you program it with?". They mostly want bunch of boring excel spreadsheets seeing where I am, how the sales are sustained, and how do I believe it can grow. On the final day, their IT guy showed up. He looked in silence through 45 minutes of my code's presentation, which is very much mix of OO and not OO, and his only words were "I don't like frameworks if that was me I would start the whole thing from scratch".So you never know what or whom you gonna get, but the bottom line is if you have sales and revenues and keep tabs on spending, they will come, and they will not care less about your fancy framework or newest code implementations.TLDR: code in whatever you feel comfortable but always consider security as top priority (not speed) because in production your code's/setup security mistakes can cost you serious legal troubles.
Gotta love engineers. 45 minutes of reading 12 years of someone’s work and the first thing they say is “yeah I’d rewrite it”.Every. Dang. Engineer. It’s crazy.I try to work in a codebase for 3-6 months before coming to any wild conclusions. Usually you find that there’s some warts but it does the job and there’s complexity that was solved that you hadn’t originally noticed, and it’s not worth rewriting it just needs some love in some areas.People hate reading other peoples code.
A clean rewrite is almost always going to produce better code than what already exists in a project that has grown organically.The current project has had numerous iterations on requirements over the years, changes in project leadership, paradigm fads come and go, and all that time accumulating cruft and layers. Looking at it at a single moment in time, you have a fixed set of current requirements where all the discovery has already been done, plus whatever your current knowledge of future requirements is, possibly none of which may have existed when the original code was written.That doesn't mean that everyone is going to sit around on their thumbs patiently waiting for you to rewrite it to be perfect. The more lines of code there are, the more time it will take, and the more hidden features that nobody really remembers exist but are still crucial will crop up.Few situations areactuallybest served by a full rewrite, but almost every project would be better off if the world could stand still long enough for it to happen.
Ideally, you want people deeply familiar with the original codebase doing the rewrite.What usually happens instead is that the rewrite happens because the original code has been handed off to a new set of people. They're not deeply familiar with the code. It's confusing to them. It's not obvious why things have been done in a specific way. And so they decide rewriting it from scratch is the better option.Unfortunately, they're not in the best position to come up with a solution that incorporates the right lessons from the original design.
a rewrite from scratch is a pipe dream for almost everything bigger than "hello world".just ask WordPerfect.any kind of home grown business app will have corner cases and requirements spaghetti that would take much more time to figure out than to write actual code.and if the person asking you to do a rewrite just shrugs when you ask "where is the test suite?" walk away asap.
I was expecting something about Go.
Me too. Some kind of weird Frankenstein of Go mixed with PHP.
You mean FrankenPHP? The Modern Php App Server, written in Go.https://frankenphp.dev/
Also Roadrunnerhttps://roadrunner.dev/
Same, didn't see anything that was remotely Go other than a generic http handler written in PHP. The other part about handling 500,000 orders a month on a $6/host isn't very impressive. You can do orders of magnitude more with just PHP. You can do that in a minute with Go.
turns out "go" is also a verb.
Thus is why I wish titles quoted names, at least where is there is any possibility of confusion
Not sure how quotes would help?If referring to the go programming language, the title should say "golang with PHP"There is no other way to disambiguate one of the most commonly used English verb from the obscure (in relative terms) programming language.
Those of us who program in Go are always looking at the word “go” in that lens. Our mistake.
> Go with "PHP"And articles referring to Golang could read> Go with "Go"
That's why I say "golang".
I built and maintained open source frameworks in both. I left PHP for Go.1. withhttp://sqlc.devI don't have to write ORM or model code anymore. Define all your SQL in an easy to audit file and all your models and interfaces are generated for you.2. withhttp://goa.designI can have well-documented OpenAPI API's that any team can generate a client for in any language. It also generates the HTTP JSON and gRPC clients/servers for me so I can focus on my logic.3. withhttps://github.com/99designs/gqlgenI can define GraphQL revolvers that play well with sqlc (any RDBMS) or I can use a key-value store.4. speaking of key-value stores, Go allows them to be embedded! Even SQLite now has thehttps://litestream.io/project to make it super simple to use a durable, always backed-up SQLite database even in a serverless context.Go is faster, uses less memory, uses types, has built-in formatting, package management, benchmarking and testing. Go supports multiple cores in the same process, and has really-well designed stdlib without all the bugs I used to face trying to use the PHP stdlib.After writing millions of lines of PHP for years, there is nothing I miss anymore. Laravel still wants me to write models, controllers and views by hand and make all the client changes as by-hand code refactors.Go lets me focus on the actual logic instead of waste my time in PHP writing all the implementation details like controller requests handlers, db fetching logic, and input validation.
It sounds like you haven't touched PHP in a very long time. Your comment reads like a 2015 forum complaint - which, to your credit, certainly would have been all valid points 8 years ago.The language has evolved since. The ecosystem has evolved since. Most of the things you're complaining about are solved paradigms that no one does manually anymore unless they're trying to drastically improve on ecosystem tooling.Even your complaints about Laravel are solved by open source tooling in its own ecosystem.Nothing about your preferences are really unique to go - most, if not all of these tools exist in many popular languages.The one solid point you have is that go lets you do many of these things by default without adding anything. To which I say: Duh. Go doesn't have a massive ecosystem of backwards compatible projects to continue supporting. It was barely used outside of niche cases until 2-3 years ago. In 10-15 years time, I'm sure people will say the same things comparing Go to a newer language.
You've made a lot of claims here without providing evidence. Care to post some links like I did?
Sure.1. SQLC is little more than a template generator for Prepared Statements wrapped in a class. [https://www.php.net/manual/en/mysqli.quickstart.prepared-sta...]. It's not exactly a mind bending or time saving tool.2. There are multiple OpenAPI generators for PHP, in fact, they existed from nearly the start of the OpenAPI protocol (formerly Swagger) when Go was barely a year old. Here's a current popular one:https://openapi-generator.tech/docs/generators/php/]3. PHP also, (unsurprisingly given the origination point of the spec) has many GraphQL implementations that support any database driver over ODBC, key-value stores, or even flat files. Here's one that plugs into Laravel [https://lighthouse-php.com/]4. PHP has many mature, modern embedded KV store options... but it's also had one in the standard lib since years before Go even existed, or the concept of KV stores was even popular. [https://www.php.net/manual/en/class.splobjectstorage.php].On your non-numbered points...Go and PHP are fairly similar in raw processing speed since the JIT was added to PHP. However raw number crunching is rarely realistic when most applications are going to be using databases, stores, etc. So why not look at a benchmark of popular frameworks in both languages - which shows, again that the two are fairly similar in performance. [https://www.techempower.com/benchmarks/#section=data-r21&l=z...]PHP has also had types for about 4 years now. It's not statically typed, but that's a preference, not a pro/con situation.Built-in formatting is also a preference, not a pro/con situation. Many developers strongly dislike languages like Go and Python for this.PHP has had one of the most powerful and useful package management ecosystems in the entire open source world since composer mostly replaced PEAR nearly a decade ago. It also has mature and well loved testing tooling. Neither of which are built in, because why would you need to build in tools that the community already creates and maintains for free?I don't know what "bugs" you faced in the PHP stdlib, but I will concede that it is painful to use. Most of the stdlib is little more than a wrapper around C functions of the same name, and they inherit the frustration of using those C functions.Laravel does allow you to write things by hand. You can also just define them ahead of time and have the Migrations, Models, Controllers, Views, Transformers and more generated for you automatically. [https://blueprint.laravelshift.com/]There you go, there's your links. But frankly, you didn't need them. There's little you mentioned that's unique to Go at all, you just named a bunch of things that have become popular tools for most modern languages still being actively developed. I'm not sure why you think any of these things are Go-specific - some of them are maintained by the Go core team, like other newer languages have started doing, but that's it.
Also: lets not forget one very important and under-rated side-effect of PHP -- it lets you write server-side code that can leverage a 'public' address. You might think 'well, doesn't everything let me do that?' Not quite. On 'free' VPS servers they usually have 'ephemeral' IPs or IPs that change. So while you get free bandwidth and compute -- it's hard to actually do anything useful with it like run a service if you don't have a public address. With PHP it's assumed it will be accessed from the web so if you run it on free shared hosting you get that accessibility built in.PHP is very good for writing services that cost literally nothing because you can run it on free hosts like 000webhost that give you everything you need to host complex services (upload, database, sub-domains, and more.) It's perfect for budget devs or maybe devs that want to make their infrastructure more resilient to ah... financial upsets...
Being able to host for free on dodgy free hosting is hardly a benefit anyone should care about.
You can throw it into lambda or vercel for that matter too. Yes you can use sketchy hosts but still can use legit ones too to host for free or very little money.
You can throw basically anything on lambda. That’s hardly a feature of php
Might be useful for teenagers  / people with no disposable income to start trying web related stuff from a public library.
Maybe? That’s still not a super great selling point for a language.When I was a teenager I used to host sites on an old android tablet. These days if you have a credit card, you can make use of the free plans most platforms have and free credit, especially if you have an .edu email.
PHP 8+ is filling-in a lot of the missing features -- type hints, attributes, named parameters, etc.Nowadays instead of using 'string_you_have_to_remember_and_might_mistype' or abusing associative arrays as in the given code sample, you can usually get full code completion luxury with PHP without magic comments or other workarounds.PHP 8 is still missing a few critical features such as generics and typed resource handles, and nikic left the project, but I'm still hopeful PHP 9 will deliver on those key additions.
Learned Python a few years back; after being a long time php dev. The named parameters and the *parameter expansion felt so nice in Python and it irked me that we didn't have that in php. Feels good that it is finally coming ^^
If you're looking for a great CMS and were bitten by WordPress back in the day, you should take a look at Statamic (https://statamic.com)It's a Laravel package and it's the best CMS I've ever used (from a dev perspective). v4 just dropped the other day
PHP has a lot of top tier CMSes. IMHO bunch of them are even better than Statamic. Craft CMS (https://craftcms.com/) is a lot more mature database based CMS. Kirby (https://getkirby.com/) is better at flat-file and has a lot better admin interface. Twill (https://twillcms.com/) is better integrated in Laravel and is fully open-source. Statamic mostly feels like it's sitting besides Laravel and they call themselves Laravel based for marketing.
You're absolutely right! PHP is blessed (or maybe cursed, depeding on your perspective) for that.I believe Craft and Statamic share a root in ExpressionEngine, which I loved also. I've only used Craft a little bit, for me the biggest issue is that it is (or was when I last looked) built on Yii, which isn't my go-to framework in PHP.This is in no way a showstopper.I haven't used Kirby, but it looks like a completely stand-alone application so I'm going to miss being able to co-locate the rest of my application there with the full toolset of the framework behind, which for small sites I really appreciate about Laravel+Statamic having right out of the gate.I've also not used Twill, but it looks to be similar to Statamic (as it's also a package). Not sure how this can be more open source than Statamic tho... if you mean free as in price, I'm all for paying for great products to make sure the teams behind them can keep on churning out great work. I'm sure AREA 17 will keep supporting Twill for a long time to come, but it doesn't look to be the focus of their business.I'm also intrigued to know what you mean by "better at flat-file".UX of the admin interfaces is kinda subjective and less of a concern from a dev perspective (though it's still an important consideration if you're trying to pick the right tool for a client or another team!)> they call themselves Laravel based for marketingSame goes for Twill :) nothing wrong with hanging onto the coattails of a popular piece of techAFAIK Statamic wasn't built on Laravel at all in the beginning. I believe Jack adopted it because it was clearly a great stack to build on top of. I think he made a great choice and I'm glad of it.
Statamic, Kirby, Craft are all commercial products and not free licensed (as in freedom). Twill is only one that's Apache License 2.0. I agree this is both blessing and curse and for products like this is much safer to get the commercial product that has safer future. But for example if you wanted to start  small CRUD SAAS based around CMS it would be feasible to do only with Twill.I don't think it's a good idea to have your product and your presentation website in one app so for me it's not a feature. They should really be separate concerns.I haven't used Statamic 4 yet but last time i've used it they didn't seem to use much from the Laravel. It basically publishes routes to Laravel from their own system and that's it. It even recommended it's own templating language Antlers. It just feels they want to really ride the Laravel wagon while still being just separate system. Thats OK but Twill for example really depends on Laravel and feels more deeply integrated with it.Craft is good simply because it leverages database powers well and it's super mature. Things like relations and search are a lot harder in flat-file systems. Twill does this OK. Flat-file systems generally have ways to use database but it's more work. I would pick Craft for sites where having DB is more advantageous than flat-file.Kirby is kinda it's own thing. It's oldest and mature, simple, steady but modern. It tries to have as little abstraction as possible. Opposite philosophy to all Laravel magic. It's kinda edgy and zen because of that. The advantage of less code and dependencies - it's super fast and easy to read source code. Not that it would matter in a CMS. 
Kirby embraces flat-file as kind of nosql database. For example every page has unique identifier that is indexed an can be referenced anywhere. I don't know about CMS that does that out of the box. And Kirby admin interface is also pretty different because it has no preset ways. When you install it it's empty - you have to completely define it. This can be huge advantage or more work for developer depending on what you do. It's more like build your own CMS package than CMS.Statamic has inspired lots of their features/implementation on Kirby and for years played catch up. Nowdays they are all very feature rich so it's more matter of taste (and price). Statamic has one really nice advantage and that's GUI blueprint builder. If you hate writing YAML to define admin area (which both Kirby and Statamic need) with Statamic you don't have to.
That PHP code right there at the very top of the page that is supposed to be representative of how great it is has multiple TOCTOU authorization and validation bugs.  In fact, nearly every piece of code on that entire page is riddled with transactional bugs
Do you mind elaborating? I can see how the user's ability to 'place-order' might be rejected between the access check and the order creation but that would be an extraordinary edge-case that does not need to be accounted for in 99% of applications.If you're developing an application that needs to account for such an edge case you could easily do so with an insert w/ join method on the Order model.  The author isn't trying to show that the code is bulletproof for every scenario.
That's really the point.  The code is deceptively simple for a whiz-bang "look how easy this is!" kinda presentation but the reality is that it's not useful for anything but a toy web store.  Maybe it's fine that it only works 99% of the time if you're just trading Pokemon points, but not when you're dealing with people's money.
I'd argue that a vast majority of web applications are not "dealing with people's money" so there's not a need to code for such cases.The right tool for the right job, etc. etc.
I'd argue being able to stop worrying about your code after writing it and not making decisions like these is a good enough reason to just do it right. Especially when it's not much more additional work
https://jacobian.org/2022/sep/9/quality-is-systemic/
If you may, could you point out what are the TOCTOU bugs you have mentioned?
Everything between checking if the user can "place-order", and then validating the inputs, and then finally creating the order.
I don't think the request object can be modified by the end user or that it is modified by the server at that point. If my belief is correct, does this code still contain TOCTOU bugs?
It's the underlying state of the database that will change between these different checks.  Not the end-user modifying the request object, which is in PHP memory
Thanks for explaining it.
Why would you go with PHP+whateverframework instead of Ruby on Rails or Django?I haven't touched PHP since 5th version and I'm kind of sceptical it can offer anything RoR can't.
Use the right tool for the right job. I always use plain PHP for all those things I want to keep running forever without having to spend time and brain space to maintain. You can't beat putting a file on a LAMP server and forget it's running. I have tons of public endpoint that do all sort of stuff , aren't core to my business and don't want to deal with the operation hassle that would come to keep such framework working and running in the long run.Just a few examples of such PHP script:1. an endpoint that is being called by my CI to send messages on IRC and telegram when a new build is ready2. the analytics bit of my project so I know who does what without relying on google analytics but by storing all that stuff in a mysql db. It's under 25 lines of PHP code and has worked a lot better for me than any analytics tools I've tried:https://gist.githubusercontent.com/mickael-kerjean/289d3d0be...3. the target of the contact me form of my project4. all the webhooks and other simple marketing automation stuff I need to process one way or another5. all sort of online tools relevant to my niche to boost the SEO side of my OSS project6. my status page which is an array of url I look after that is being curl around7. crud cloud instance of my OSS projectand many many more examples, got about a hundred random stuff running from a single cheapo VPS I don't have to maintain.
Sounds like a scripted and slower (not trying to diminish) version of Go.
But when he wants to add a feature he doesn't have to create a new microservice and a systemd file and a watchdog and setup the reverse proxy, all things needed for a go endpoint.He just drops a PHP file in a folder and be done with it, it just works.
You don't have to create a new (micro-)service, you can just add new functions to an existing one.> it just works.Are you trying to tell me that modern PHP is so cool it does not require LAMP or whatever? I highly doubt it.You still need and use all the same stack, except you don't have to install thigs separately I guess.
I don't know why you are being downvoted, this is a very legitimate question. These server-side frameworks are all alive and kicking and very competitive. When some other smaller ecosystem comes up with a good idea (like elixir/phoenix) there is a rush to replicate which happens rather fast.I think in the end the competition will lead to specialization. Python will almost certainly capitalize on its data science / ML links but its not clear (to me at least) how php and ruby will differentiate themselves.
Rails console, metaprogramming, elegant blocks, procs & lambdas, Turbo/Hotwire. Concise Ruby language vs PHP framework code with hideous inlined fully-qualified method paths.
all of that pretty much is available and arguably much better in Elixir/Phoenix
OP was comparing Ruby and PHP.
PHP 8 is a vast improvement over PHP 5. Also, the frameworks have become much better - I especially love the Yii framework as well as the Codeigniter framework if you are looking at a Rails replacement.
I'm a Go dev these days and rather looking into TS and Rust.I was just curious to be honest. With RoR being what it is PHP frameworks has to offer something on the same level (at least) to be of any interest (as a I see it). Not to mention ecosystem\packages\gems\etc.
It is ridiculously easy to setup a full CRUD environment in frameworks such as Yii. It is as simple and selecting some options on a screen and then clicking on a button. The example below is from 7 years ago!https://www.youtube.com/watch?v=Xi0gH2izUy0
A great many good things that I still use on a daily basis are written in php. Roundcube and Nextcloud for starters.Some of the most fun I ever had writing basic CRUD apps and simple interactive websites was in PHP and Codeigniter back in the day. I'm pretty much Team Python now just because of the huge ecosystem but maybe it's time to give PHP another chance...
I see no argument at all for using Laravel over Django or Rails.PHP was always a mess. Why would I want to come back to it now on the off chance they don't screw things up again?
Exactly.array_filter and array_map, have different order of arguments.($array, $callback) vs ($callback, $array)A small example of how inconsistent the language is from the ground up.Most people can explain their respective web servers, but I've never heard anyone even come close to what PHP/Laravel is actually "doing".Side Complaint: If you are working with Laravel Queue, it is such a hassle to reload your code changes when developing.
So what's the programming language that's 100% consistent? For example Python isn't.
I doubt any language is at 100% but from my work with them Elixir, Golang and Rust are predictable and a joy to use. I don't remember the last time their API has surprised me.
Perfect is the enemy of good. There are many languages much more consistent than PHP.
Ruby, Clojure, Go, Kotlin, Rust.
Yeah, but these things exist across languages. Laravel has collection methods that fix that and they can be used in any php project too.https://laravel.com/docs/10.x/collections#available-methods
I used to refresh nettuts.com obsessively in high-school and Jeffrey Way's PHP content was the highlight.Sadly the site got a refresh ages ago and is nothing like it used to be.Anyway, if you're reading this thread, thanks Jeff!
I too learnt webdev with Jeffrey back in the jQuery days of 2011 - I subscribed to laracasts at the start of the year (primarly to evaluate Laravael for work) and was delighted to see that he runs the site - he's like the Bob Ross of webdev.
> It can handle more than 500,000 orders per month when hosted on a $6/month serverIs this a statement from the real world? What business sells 500,000 orders in a month from a $6 server? I mean, if you sell that much, you would probably want a high-availability solution and they don't sell for 6 bucks.
The message seems to be targeted at the „webscale“ folks. Something like: Look, one 6$/month server can do more than you ever need. You don‘t need {complicated stack}.Just use two 6$/month servers.
> It can handle more than 500,000 orders per monthHilarious because other languages are capable of that per minute not per month
What stack can handle 500,000 orders per minute - 22.3 billion a month - on a $6/month server?
Most of them? 500k per minute is around 8k reqs/sec. $6 will get you 2 vCPU, so each CPU only needs to handle 4k requests per second.I'd at least expect that to be possible in Node, and would be somewhat surprised if a Go or Rust framework didn't hit that mark.
I think 4k requests per second is quite ambitious even for native languages or garbage collected languages like Go.Hello world will work, but once parsing, validation, and database queries get involved, you'll need some beefier hardware to get those numbers.I can't get the cloud benchmarks for 2022 to work (a dedicated PowerEdge is the standard physical benchmark and that's not very realistic here), but according to these benchmarks:https://www.techempower.com/benchmarks/#section=data-r20&hw=...you're going to need some very optimized code to get close to 8k reqs/s.
OK, 10 minutes then ;)My point was that the article quotes orders per month, while other systems are quoting requests per second. I found it funny that they tried to mask the low speed by using big numbers.
500,000 orders per minute on a $6/month server? Which language is able to achieve that?
Go
If you're going to pull numbers out of a hat at least provide some evidence, especially evidence based on a comparable workload.
I actually wrote a whole article about this myself:https://alicegg.tech/2023/02/06/4dollar-vps.htmlTL;DR: go can handle 1000+ RPS on a ridiculously small server
But creating an order isn't just a request. PHP will also handle 1000 RPS of hello world just fine on a 4 dollars VPS.Maybe (probably) Go is still faster than PHP, but the hyperbole is being pushed a bit too far here.
And what about the database?
I think the point was the $6/month server here.
There's 2 things to separate here:1. PHP the language and developer experience (frameworks, tools, community, docs, etc)2. PHP performance at scaleIn my experience, PHP is much improved for 1. and fine to work with. Laravel and composer are great.For 2. I would never use PHP on anything above a few hundred requests a second. It's slow on its own, but more importantly it's blocking IO model will grind things to a halt at any level of concurrency when talking out to database, caches, or other services. You are also vulnerable to issues like saturating your database with connections due the programming model in php-fpm. I know async php exists but my impression is the mainstream frameworks dont support it (I could be wrong?) so why not just switch language at that point. I speak from experience of scaling a Laravel php app up 5k RPS+ and needing a LOT of EC2 instances to do it. Using Go was a revelation and delivered a 10x improvement in terms of resources required to serve the same number of requests.So yes, if your rps < 500, why not, PHP is fine. For anything above that, it's a not a great choice.(And defining your scale in terms of orders per month is a bit silly)
Weird that you get down-voted but I lose more and more respect for HN these days so I can only say I am not surprised that a common-sense post was given the gray treatment.I have the same experience as you, I've participated in migrating from PHP to JS, to Elixir, and to Golang. The transition to JS was mostly a performance disaster (not much performance was gained) but at least more devs could help so it was still a big win organization-wise, whereas the transitions to Elixir and Golang were a screaming success on every front: we immediately gained anywhere from 7x to 25x more req/s and the DB load was stable and the request timeout errors dropped by 97.9% on the first day (and were completely eliminated a week later), not to mention the cost of our hosting also dropped by at least 70%.I am past my phase of "hating" languages but honestly, saying "PHP is not the right tool for jobs X and Y" is a "hate" in the eyes of many anyway. And yeah it's not good enough for big scale. I mean, if you make $1M a month then you likely don't care much if you pay $50K in hosting, sure, but why do you have to spend 5% of your revenue on hosting? There are a lot of modern technologies with which you'd be hard-pressed to justify having more than 2 application servers and 1 DB server (with read-only backups and replicas if sh_t hits the fan).
Thanks, I was confused with the downvotes as I was just relaying the facts of my experience!Good to hear someone else has had a similar experience. Nothing against PHP at all, but it's definitely not suited for scale.
I think I'll stick with rails if I want cute DSLs and lots of magic ("… broadcast an event to update the frontend in real time …"). But sure, it's great that php has come a long way since php3.That aside:> It can handle more than 500,000 orders per month when hosted on a $6/month server.Surely it can do more than 700 orders per hour, 1 order every 5 seconds?> The only additional fees are for a CDN (if you want your assets to be served faster) and a domain nameUh, so no managed database, but you recommend paying for a CDN before slapping Varnish in front of your static assets?I get that php might be eminently usable at this point - but this seems like an odd pitch.
I've been using Laravel for the past year at work, not a hater type but still find it meh even with all the improvements.
I too was a junior that was plagued by wordpress and php custom plugins, never again will I touch this language if I can.
I agree with the message, but the example has:- hidden global state- arbitrary string literalsIs that Laravel?
It's been a long time since I had to deal with Laravel, but that code snippet looks very similar to the Laravel version I had to work with ~6 years ago.I hated it (Laravel) for those reasons, along with the madness that was the DI container. Guess I'm just not "web artisan" enough.
The other day I finished a side gig I was doing - a Wordpress site recreated using the Wayback Machine - the site went down a while ago and the admin stopped answering phone calls, not to mention emails.It was a largely pleasant experience, taking me back to my early years as a "web developer". I had to modify some PHP files because the theme used didn't offer slots for widgets in places I wanted it to.That being said uncached the site takes over 20 seconds to render. CPU load wasn't high so I can't help but wonder what was it doing all this time.
I’d had a site in a similar state, and I did figure out what it was doing.Client had launched a product that was a bit more successful than typical. Nobody could access the site though. I dig around a little, come to find a neat little snippet of template looking for a featured user for some markup.The genius who set this up iterated through each record trying to find the featured item. One query at a time, testing each record in the application for the flag.Php is fine, some very inexperienced “developers” use it though so you find a lot of gems like that in the space.
Any programmers here who've used PHP to build command line tools in PHP? What is the experience like compared to, let's say Python or node.js? How good are the facilities? What are the limitations?
It's really good. Using the Symfony Console component you get sane argument and option parsing and validation (optional/required, single or array values), output styling, interactive inputs, tables etc.If you're wanting to build a TUI I haven't seen any libraries as advanced as the Python or JS ones.
Symfony command is great for thishttps://symfony.com/doc/current/console.htmlBut it really depends on what you need the command for.I use Symfony command for general things, Node.js for eg PDF generation, Python for ML, Rust for calculating Ranks/ScoresDevelopment time is the same for all of them.For whatever reason Node.js scripts always feel dirty to me. I can not even pinpoint why.
I have rewritten more-or-less the same tool, 100KLOC, in Rust and PHP. I can't tell you about Python or Node.jsUse PHP if- you're in a hurry and you already either know PHP, or the script is going to call other PHP code you've written- execution speed is not important (ditto for Python and Node)If neither of the above is true, give Rust a whirl.
I tried to write a CLI tool for orchestration by wrapping some sub-processes. I found PHP very limited in its ability to handle subprocesses (streams, error handling, signal forwarding). I tried to avoid using frameworks, but eventually used Symfony's "Process" lib. It helped with Linux but Windows support is very limited.This experience was pretty disappointing, but also pretty niche. Overall I agree with the general sentiment that PHP is very nice to use nowadays, especially for web development.
Very easy to do. Check out the getOpt function for argument parsing etc.
here's a nice goodiehttps://github.com/nunomaduro/termwind
Performance is always a good argument, but, be realistic and be honest, most applications did not need ultra fast performance and most applications did not have hundreds of parallel users.
The problem is this page advertises Laravel, not PHP. Ruby on Rails has many similar "demo worthy" snippets that make complex tasks seem readable and intuitive to the layman. Laravel and Ruby on Rails have something else in common: due to the focus on these "natural" interfaces, they compromise in every other way. Architecture, performance, testability and so on and so on.For those who know PHP, this code is full of singletons masquerading as static classes (which Laravel incorrectly calls "Facades") which mean no isolation and clear flow of dependencies in your code. In a nutshell, every line of code you write this way comes loaded with a pound of irreducible, unfixable tech debt. Enjoy.
> In a nutshell, every line of code you write this way comes loaded with a pound of irreducible, unfixable tech debt.And worst of all, you are stuck with a shitload of churn every time a new Laravel version comes out. But this is true for Rails and CakePHP and probably many others as well. At least Django seems to be moving a bit slower and not deprecating loads of features on every release.
Making "complex tasks seem readable and intuitive to the layman" is no bad thing - besides other engineers,future youcould become a 'layman' easily. Readable, expressive code is something I've come to value highly after almost 20 yearsAnd from first-hand experience, while the specific code sample shown on this page shouldn't be treated as a practical example of how to architect a larger application, there's nothing compromised here in terms of performance or testability.All tech is tech debt at some level or at some time - what has happened to pragmatism? Laravel has actually helped me write the most performant, tested and least-refactored code I've ever written.Like any tool, used properly it will do its job well; simply grumbling and shooing it away does not stop it being a perfectly fine tool in the right hands.
I guess I wasn't clear enough? I said "it makes complex tasks SEEM". My point being, they SEEM SIMPLE in a DEMO. But in real application it quickly turns into a quagmire, due to the problems I already listed.Oh look, you even say so in your own comment: "the specific code sample shown on this page shouldn't be treated as a practical example".So... you're saying the page makes it SEEM simpler than IT IS, hmm? Is this what you were asking me about "why is it bad"? You don't think parlor tricks in demo code is a bad thing?So what are you even objecting to here? I said something bad about Laravel, and you use Laravel, so you have to go on the offensive out of loyalty? I don't know why people need to identify so religiously with their tools. If we start picking apart this demo code, you'll probably admit that every line contains an anti-pattern you'd avoid in a real project of more than a modest size.So what is this demo demoing then? It's essentially misleading people about what it takes to write a good app. If we'll go by simple demos alone, PHP needs no framework at all for a good demo:<?php
    echo "5 + 5 is: " . (5 + 5);Boom, everyone understands this, now you can write your own Google!This is why RoR declined and it's why PHP with Laravel and WordPress as their poster boys is declining.PHP itself is no longer as terrible as it used to be, although all the good people seem to have left the internals. But the frameworks people use on it are terrible, incompetent and aggressively misleading people into bad practices for the sole purpose of marketing to newcomers.
I have one name for you: SymfonyMore or less directly opposite of what Laravel is preaching. It's the popular choice for anything that is being build long term. It is very popular in Europe and we have a far bigger community around it than Laravel does.
Symfony made many architectural mistakes early on, including with the way they used to do injection and so on, but to their credit, the community seems curious and strives for quality, so over time it has become a very interesting project. I stay away from frameworks, in general, but the Symfony components are excellent.
5 + 5 = <?= 5 + 5 ?>why use echo?  php _is_ html :D
Absolutely, having worked with Laravel I can only recommend not to use it, Symfony does a much better job.
If you use facades there's no fixing that unless you reconstruct and reweave every component in your application to pass relevant context in and out, instead of lazily reaching into globals for it.What you call "full DI" in Laravel is still globals in disguise, because there's a single global container.Most defense of Laravel comes from people who have no idea how to write a good app. And unfortunately, due to bad frameworks, the number of those people is multiplying. I blame Spring and RoR. So much pain came from them. Laravel is just a pale copy.
There is also Phel (Lisp-like language that compiles to PHP).https://phel-lang.org/
Use pretty much any language. It mostly doesn’t matter.
We are pretty much at that point. Choose the language that works best with the tools or libraries you want to use… and if there aren’t any specific requirements, use any language you want then.
The last time I used PHP was in 2004 or 2005, PHP was at version 4.something, and I did not like it. That kind of formed my opinion on the language, even though I know it's come a long way since. OTOH, I have no reason currently to take another look.But it's nice to be reminded, I guess, PHP isn't the dumpster fire it was 18 years ago.
5 seconds per request isn't anything to shout about in 2023.
Laravel gets over 2000 requests per second in PHP 8.1https://kinsta.com/blog/php-benchmarks/
Unless you specify the hardware and compare with the OP your claims are meaningless.
Where does this 5s/request come from? Are you misreading the word "requests" instead of the word "orders" that is in the article?
I hosted a phpBB forum as a kid in the early 2000s.15 years later I joined a marketplace startup that was doing 10,000 transactions a day.Built as a PHP monolith.I was sooooo confused at first. “PHP??? That strange language I used to host a forum is powering this app??”Turns out the founding engineer was self-taught and PHP had the most tutorials or something lol
And come check out NativePHP[1] where you can build native desktop apps using Electron or Tauri + PHPStarting with Laravel support and launching soon[1]:https://twitter.com/search?q=nativephp&src=typed_query
Even if you write modern strongly typed PHP and make sure to handle all your exceptions you will still encounter null (and other) errors at runtime. The language is ok these days and far faster than Python & Ruby etc but still I would not choose a new project to use it.
I don't like that in the code validation rules are applied to a "request" (and written in a controller) but not to a model. This means that if you want to create a model somewhere else, you cannot reuse  validation code.
$request->user()->orders->create($request->validated());This looks so wrong from an architectural point of view! A request has a user (which in the context of HTTP should be more or less only an authenticated principal), which has orders, which are created from the same request, where the journey started. There is no separation of technical and business concerns.See:https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-a...
It's terrible indeed but Laravel pushes for this kind of "fluent" apis
I actually think this article undersells PHP, as it doesn't mention the incredible additions that PHP 8 introduces, nor does it mention excellent static analysis tools like PHPStan.I recently rewrote a PHP web app in Rust (https://soapstone.mradford.com/riir/) and although it was interesting, I think it would have been better staying a PHP app. As nice as the Rust compiler was, I felt PHPStan would have automatically caught a similar number of bugs, all the while feeling less combative.
The problem with PHP is not that you can't write great maintainable codebases in it -- you certainly can.The problem is how easy it makes it to write obscenely unmaintainable anti-architected code bases in it.The average PHP production code base is deeply offensive. I'm knee deep in one right now.You can still have awful code bases in Rails or Django or Go, but the opinionated nature of those ecosystems makes the average much better than PHP.If "PHP" were synonymous with "Laravel", that would be different. But it's not.
For me the best platform is one that's easy to debug and the debugging story for php is one of the worst. Otherwise it would still be quite hard to read. But at least it's cheap to host.
xdebug is pretty okay. PHP is single threaded, the entry point well defined, var_dump/die/echo works wonders, debugable by curl and simple php -S nowadays.it has orders of magnitude less complexity than the JVM, or even the various Python server runtimes (gunicorn, uwsgi, etc)at least in my experience. can you elaborate on what you see as the debug support deficiencies of PHP?
I'm mostly interested if this is a tiny hobby project by someone who wanted a nice example to use in arguments.Or an advert by someone involved with Laravel/Laracasts.As the former it's quite effective.The latter would be funny.
There's a lot of reasons to both use or not use PHP, but of all the ecosystems I've developed in, PHP has the most lovely dev tooling.Every popular piece of dev tooling in the PHP ecosystem feels like it was made to solve a problem, do so as simply as possible and let you know all the information as cleanly as possible.There's contemporaries to most of those tools in every other major language, and all of them have problems or annoyances that I feel simply don't exist in PHP's tools.
I just don't get why people in php use lazy comparison  when you know that "0e4"=="0e5" in php.and yes, Laravel use lazy comparison (hundreds of times). And yes at least three bugs where caused by this use.see:https://github.com/laravel/ideas/issues/698for why I'm a bit grumpy with php ecosystem
Can anyone with experience in both compare modern PHP and Laravel vs modern Ruby and Rails? Which one would you choose and why, assuming you have the same experience in both?I’m asking because I keep hearing Ruby on Rails is the best for starting a SaaS, etc but from my little experience on it, it seems to me Laravel is way better. Is it just a “language” thing? That most people prefer Ruby to PHP?
(sits quietly in the corner wishing Hack had taken off, or at least that one of the things PHP took from it was native XHP.)
Nice. I needed this today.  I teach "Advanced" Web Programming and my classes start next week. I've been generally ignorant of most of the kazillion fancy Javascript frameworks and have more or less kept PHP as the base of the course. This is what more-or-less has felt right most of the time.
For "Advanced" Web Programming, I don't really feel like you're hitting the mark by sticking with PHP. Sure, it works, and will probably get the job done for most web projects any of your students will ever work on, but if you want to get people excited while making them employable, it's important to teach new tools and frameworks. Unless the "Advanced" part is more about the techniques and patterns and less about the language, I think you're doing them a disservice by not branching out. And, of course, you can teach patterns and techniques in any modern language.I'd expect to see some discussion of async job processing and front-end web frameworks in any advanced web programming course, high-school or college level. Honestly, just teaching the usual react stack with a typical node backend would probably be ideal since JS is approachable, react is still "cool", and you still only need to use one language.
Coming from Rails, how does Laravel compares? If you know both languages, which one would you pick? I've this hunch that there's no reason to lick Laravel over Rails, since that latter is the bees and knees for web development.Alternatively: what would you suggest someone getting into web development to learn? PHP or Ruby?
> If you know both languages, which one would you pick?The one with the best density of good developers in your hiring region if the application ends up scaling.> Alternatively: what would you suggest someone getting into web development to learn? PHP or Ruby?Neither. I would tell them to get into the Javascript ecosystem - not because I think it's necessarily good, but because that's where most of the work is. I'd also reccomend picking up at least one other general purpose language to be a bit more rounded such as Golang, Java, C#, Python.
I have worked with both Laravel and Rails. I would still pick Ruby on Rails for my projects because I feel the Ruby's ecosystem is more mature than Laravel's.Don't get me wrong –– Laravel (the framework) has some polished first party packages however, as soon as you step out to third party packages the quality drops significantly.
Personally Rails. From a business perspective both are fine.
I would use the PHP Yii framework - it has generation of CRUD, controllers, models etc.. and excellent customisability.
what this page means is: go with laravel.wordpress is also php. dont go with php.
I thought this is a workaround showing off how they use Go lang and PHP together, fell for it!
PHP is pretty nice these days but salaries for PHP roles are terrible. I can get paid 50% more being half as productive writing Go (for no reason bc 90% of people using it don't actually need any of it's features or performance)
The fact that you can build a whole app inside just one index.php file is highly underrated and I understand how newbies finding this out are getting excited.I remember when Rails first launched and I wanted to try it but it was so complicated to get started.
You can do that with any language using CGI.
I always dislike the "requests per month" metric because it seems like a transparent attempt to impress with a larger absolute number: 500k requests/month is 5sec per request, which feels pretty underwhelming
We are talking about 500k orders/month, not requests/month.Placing an order from the Web will almost always involve multiple requests.
You are touting the language's ecosystem or tooling but the language itself is horrid. PHP is carried by Laravel.Another language carried by tooling is Go. The language itself doesn't even have sum types, lmao.
No thanks. Those code examples are full of indirection and the bottom example reminds me of the object nested spaghetti  mess of large PHP frameworks.Just because code reads well doesn’t mean you can understand easily what it actually does.
There's joke amongst PHP companies that modern PHP has finally, completely become Java.
Replacing PHP/Laveral with JAVA/SpringBoot is not different at all.
Yes because PHP5+ is pseudo-Java.
We're now at Laravel 10. Take a look at the Laravel Bootcamp for a quick introhttps://bootcamp.laravel.com/
> Read the following code as if it were a documentation page:If I read this as a documentation page, this makes me scared:`Order::create($validated + ['status' => 'pending']);`What does it mean to add an array to something?
This could be rewritten as:Order::create([...$validated, 'status' => 'pending']);
Ah, makes sense. Thank you.
It would be shorthand for:`$validated = ['key' => 'value'];
$validated['status'] = 'pending';
Order::create($validated);`
As someone who likes PHP that stumped me as well, I *really enjoy working with PHP 8.1, but I could not really grok the code either.
> the exact same syntax in PythonNo, because the example is showing concatenation of associative arrays. In Python, you'd use a dict, and you can't do `validated + {'status': 'pending'}`:```
>>> validated = {}
>>> validated + {'status': 'pending'}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'dict' and 'dict'
```You can do `validated | {'status': 'pending'}` since 3.9, though. I think using union or the * operator (e.g. `{*validated, 'status': 'pending'}`) looks less weird, but if you're a PHP programmer, you already know what + does here. In the end, it becomes bikeshedding.
No complaints about the spread operator :-) But the plus in javascript produces this:[1,2,3] + [1,2,3]
    // '1,2,31,2,3'(never tried this in js before; so was amused by the result)
I mean yeah as a php dev for 12 years since i've started picking up python , i find myself nowdays coding stuff in python :)
PHP has 99 problems, but shipping code ain't one
A major downside of phps model is that there is no continuously running service, so you can’t run timers or background cleanups.
Isn't it too much "string oriented"?
I see couple singletons calls in those examples. Is it considered a good practice in PHP now, or was it made to simplify the demoed code?
Maybe you mean 'static' calls?Depends on the context but in most cases these are a convenience, syntactic sugar.Take SendOrderToVendor::dispatch($order)->onQueue('orders'), for example.This could also be written as:$job = new SendOrderToVendor($order);$job->dispatchOn('orders');(Exact function calls may not be correct, I'm on my phone)Functionally identical - same code path. The main gain is ergonomics, but it's entirely your choice how you prefer to write this code.
The issue isn't the exact syntax that's used to access the service object. It's the fact that any random chunk of code anywhere in the codebase can reach out to any other random piece of code. Syntactic sugar or not, that's considered to be an antipattern in pretty much any community outside of Laravel's.
Laravel calls them "Facades". And no, they're not considered good practice outside the Laravel community.
As someone more familiar with js/react, is there an equivalently mature reactive frontend framework?
Laravel has inertia, livewire or alpine to get reactive/snappy frontends if you want to have an SPA. Inertia lets you use your react while not needing to write an api. Livewire drops the js completely and does the SPA-esque frontend with php, alpine is just a smol lib to make parts of the website interactive.Generally speaking, if you use PHP to build an API, you can use react still as is.
It's one of those posts again. I have no clue what compels people to write things like this.
I have a soft spot for PHP. I love code I can write, then just refresh the page.
Okay, but you didn't mention Go at all in the article.Jeffrey Wayisa really good teacher, btw.
of course php is best, but how do u do in app(web app/browser) notification with 6$/month apache & php?
for example if there are 2000 users who need to push a message to when a queue job finishes in php backend?
Laravel lets you run tasks in the background. You just queue up those notifications and then some other task you wrote will come along and start sending them. Apache isn't involved.
Thanks.
My queue is done and working, but how can i make php to have websocket for thousands of devices ? I know it's javascript in the frontend and i could do some kind of timeout loop to check job status, but that's not good..
From the title, I thought someone implemented PHP in go.facepalm
Sounds like a threat TBH
PHP malware on windows is a thing now too lol
sorry to break it to you, but symfony is much more superior and flexible than laravel.
Go where exactly?
I would say that the thing that gives web devs a bad name is an attitude like yours.
I hope you're nobody's boss. Talent doesn't come from mild mannered yes men and doesn't look like plastering over decrepit slop.
I hope you will mature one day and that you will see that whatever bad experience you had with PHP (probably many years ago if not decades) is not universal.
> The fundamental flaw is still with the community preferring server-side rendering of pagesServer side rendering is a flaw?
I finally had a chance to write some PHP that (a) wasn't WordPress and (b) actually did something useful a few weeks ago at $DAYJOB.Going from zero to functional web backend in less than 3 hours for a language I'm almost totally unfamiliar with made me understand just why this got so gosh darn popular. I thought building out a Flask application was fast, but PHP's initial experimentation loop is just on another level, criticisms be what they may.
I've been writing PHP for a quarter century, but I've never become a "whiz" at it.But I regularly write fast, robust, secure backends, in a day or less (less, if possible. I don't actuallylikeworking in PHP).Despite the torrents of hate from this community, it is still pretty much the backend king.Here's the "Fishtank Graph."[0] It kind of puts things in perspective.[0]https://w3techs.com/technologies/history_overview/programmin...
I agree that it still owns a massive chunk of the backend market. 20-something years in, and it's still difficult to shake.However, I would take the numbers on the site you linked with a big grain of salt. Detecting which backend technology powers a site without direct evidence is nearly impossible. PHP may be high up the list since it and its associated stack leak the most metadata.
I've totally copied php http headers into non-php backends just to see what happens. It costs nothing and gets a trifle more security.(Not really but it makes me giggle at least)
I've always found those statistics to be a bit odd, given how popular other languages are, especially the likes of Python.Not only that, but since .NET Core and the new versions of .NET running just fine on Linux distros, I'd expect their usage to go up, not down.Curious. Actually, their disclaimer page seems to suggest that setups with a decoupled SPA/API might not be detected correctly:https://w3techs.com/disclaimer
> the likes of PythonI've spent 15 years writing serious code and never ran into Python all that much until I went back to engineering school. I don't think a lot of people use it for their backend code, at least in my experience. But wow are there lots of stats and science people using it exclusively--it's completely ubiquitous in academia and research (though R is making headway).
I'm pretty sure that Python is the language of choice for AI stuff. I think even Apple's ML stuff is based on Python.
yeah you're right, I guess I lump that into "academia and research" as opposed to "software engineering" where PHP... exists
>  I've always found those statistics to be a bit odd, given how popular other languages are, especially the likes of Python.Think about how many Wordpress installs there are, not to mention Wiki's and forums.
Second that, PHP is still default for hosting providers. I get basic hosting for free on OVH with domain that has PHP by default. So even if I am .net dev on my job I still have some personal stuff in PHP because it is default and I cannot change it for that managed hosting env.
At my previous job, we had micro services in Java that did most of the work. The frontend was a thin layer of PHP that focused on SSR, but PHP is the only detectable tech from the outside
Surprised to see Scala running almost as many website backends as JavaScript.  In my mind, it faded in popularity long ago.
The survey methodology is biased toward old technologies, from the era where you sent HTTP headers that advertised the stack you were using. Modern stacks often hide that info. (It's also biased toward techs used in blogs, since when it detects a tech used on blog.example.com, that tech is counted for example.com)
Also it biases towards smaller organizations which don’t follow security guidelines saying that you should disable those banners. There’s a real breadth versus depth discrepancy here.
Perhaps the Scala ecosystem is where Haskell nerds all decided to settle into?
I upvoted you and vouched u/rizky05 because I think they raised an important point.> It is powerful indeed. But PHP syntax feels unelegant and making me write unnecessary ceremony. It feels different when I write typescript code, every character I type fits like lego.> Especially when my codebase grows so much. Navigating PHP project is like thrown in forest without a map, you can always look up the sun to find your way.“Elegance” is something that gives people warm fuzzies, I think this is why there are so many Rust advocates (I am one), when pieces fit together nice or can be refactored cleanly and tests are first-party it isnice.However there have always been “hacky” and “proper” languages, because doing something hacky that worksalsofeels great.Python is a hacky language, it’s easy to go to 0-100 very quickly. C++ however requires time and precision to make things proper, so people avoid it and few things are made comparatively in C++ unless it's infrastructure software that people spent a lot of time writing.Maintainability be damned, sometimes you really just need to throw something together.The curse of things that work is that they will be expanded upon and kept around for too long.Unfortunately: PHPworks, and is anexcellenthack-language for the web. Which means there’s a lot of code that becomes “production grade” that should really have never been intended to live forever in the first place.
PHP can be super hacky and super structured, within the same file, and it's your choice. You can have tests, static analysis, etc etc, or not. Or you can start without and then adding it as the project mature, without having to necessarily switch to another language.I'm working on my own startup that started as a side project and it was super hacky at the beginning, but by sticking to PHP (and thanks to PHP continuous improvements) I was able to refactor little by little and make the codebase way more structured and easier to maintain.
As a vaguely-related anecdote, I wrote a super-hacky PHP script in highschool 20 years ago, it gained some popularity based on being open-source and easy-to-install (PHP’s #1 strength for sure) - and to this day I am still spending a significant chunk of development time refactoring based on ideas that eg Typescript and Rust have out of the box (eg using PHPStan to emulate a language with typed arrays)(I keep wishing that I could rewrite it in a “better” language, but there is no other language that is even in the same ballpark when it comes to “any random user can upload this .php file to any random web host and expect it to work”)
Youcanwrite any kind of code in any language, but going against the grain of that language tends to go badly. Even if your style works for you, if it's not what the ecosystem expects you'll have trouble using libraries, you'll have trouble onboarding new hires, ....
Zuck wrote a super hacky PHP script 20+ years ago and now he's a gazillionaire.
My first job was actually rewriting old code from python to php for zuck. Hack is a surprisingly cool language.
And they still use ~~php~~ hack.
> when pieces fit together nice or can be refactored cleanlyThis is a trade-off that makes sense to embrace in some contexts, and I do believe that web is one of them. The more nicely your pieces fit together the harder it'll be to break them apart. You can only refactor cleanly once you are aware of all the requirements, but those requirements are usually constantly changing in the context of web and so your pieces fitting together a little too nicely means that you now have to refactor a lot more code.
This matches my experience of PHP. The questions/advice on stackoverflow and blog posts are also geared towards people who just want to get something done, which helps a lot if that's your goal.Go is the only other programming language I've had this experience with - picking it up with a goal in mind and succeeding in doing something more quickly than I might have with a familiar language.
I remember someone on SO saying "Go isn't a programming language, it's a DSL for writing networked services", and, well, if we can squint and call Go that, we can definitely call PHP a DSL for dynamic webpages.
You don’t even really need to squint that hard.That’s what it started as.It’s entire process model (instantiating the world for each request then tearing it all back down, not having any shared state) is fairly unlike most other general purpose languages.PHP inverts the usual assumption that “this code file is primarily code” on its head—it assumes any file it’s given contains other data until it finds the special open/close tags signifying a section that contains code. (Allowing you to embed it within HTML easily.)The runtime handles things like GET/POST variables natively and has a special way to expose them. Ditto for file uploads.The standard library isn’t extensive but contains a ton of functionality that revolves around managing web requests. (Managing HTTP headers, setting and reading cookies, ...)Etc, etc.
I'd say any sufficiently elaborated template language becomes Php.
Damn that would be a pretty elaborate template language
I’ve been using Go in this capacity quite a lot recently, replacing Java code I had previously been using for these kinds of tasks.  And have been pleasantly surprised how straightforward the code is.Especially now with generics support.  I’ve been able to quickly write little meta functions for things like translating Kafka events to a channel of structure and spin up a number of go routines to handle them by making REST calls.  The code is concise, clean, and simple, without being overly clever.
It's such a perfect match for the HTTP protocol. You drop a file on a server and you're good to go. My toy VPS is full of useful scripts that I use on a daily basis. Most of them are literally one big file with all of the code, no external dependencies. Caddy proxy the request into PHP-FPM and send back the response, no bullshit.Of course this is not what we see at production-grade software, but I really enjoy the fact that the language was designed with the HTTP protocol in mind. It's really unique in this sense.
On the other hand, vanilla PHP effectively "hides" HTTP from the programmer. I taught myself PHP in middle school and high school as my first programming experience, and had no concept of a thing called "HTTP" for a very very long time. I knew the pieces of it that PHP gave me. I knew what $_POST, $_GET, $_SERVER, $_HEADER, set/getcookie(), were and how to manipulate them, and I knew the rules (setting a header after "echo" made it complain), but I didn't understand how that all hung together as a thing outside PHP called HTTP.When I did learn about HTTP, it was very easy, since I already knew it without knowing I knew it, so maybe that's in favor of your point, but there's much to be said for the actual understanding that I didn't have at first. When I started interviewing people for PHP entry-level jobs, asking about HTTP was one of the ways I gauged how well applicants understood their work at a conceptual level.
This mirrors my experience exactly - it took me an embarrassingly long time to learn about http and what it means to be stateless.It also took learning other languages to understand how PHP is so unique in how tied to HTTP it is (rebuilding its entire universe every request).(these learnings happened when moving beyond the PHP-based CMS style of development - agency style work on my case - to make more custom software).
I imagine it took you awhile to understand what “stateless“ meant, because you weren’t exposed to the default state-fullness of most other languages, so didn’t realize stateless wasn’t the default.
Yeah, that's for sure true.
yes, and the fact that you can just put inline HTML outside of PHP tags is so useful and convenient
> Now why no one bats an eye at node/react doing this very thing and calling it JSX is beyond me but...Hey don't drag Node into this, you aren't forced to do any of that.React to me feels like SPA developers discovering the idea of PHP and thinking they invented it. This shouldn't be surprising, since React came from Facebook, and Facebook historically is a PHP shop.Mixing your business logic and presentation is a bad idea, but it's very attractive when you don't have the informative scarsYou might say, doesn't Facebook have the scars to avoid designing React? Well, when you have a hammer, everything looks like a nail.PS: I would suspect the down voting is just the "LOL", otherwise it's a fair comment.
> You might say, doesn't Facebook have the scars to avoid designing React? Well, when you have a hammer, everything looks like a nail.This is accurate, and I never thought of it that way.> PS: I would suspect the down voting is just the "LOL", otherwise it's a fair comment.I did laugh out loud because I did not know WHAT to make of the comment. As someone who buttered my bread on PHP when everyone hated it, it was a sign of how times have changed!
Why is it a "bad idea"? I'm genuinely curious.It works great, it's fast and you don't have to learn a new templating language or dialect every 2-3 years. Or try to figure out how to do trivial things like loops in loops.I don't quite get the use of templating engines in PHP because PHPisa templating engine itself.
Templating systems produce output based on a template and a set of data. PHP produces output based on imperative code that can do anything. While you can certainly adhere to your templates only consuming data (ie some kind of view model), it's actually awkward to do, as PHP files don't take parameters, so you need to use a convention of having your "template" files provide functions and call them, but functions are global so you now need to name them uniquely to avoid collisions. If templates are meant to be pluggable, this is much more difficult because you have two templates that are supposed to be interchangeable, with identifiers for calling them that are different[1]. There are a lot of properties of template systems that PHP does not actually have.[1] It's so much worse than this... You can use some horrible hacks like undefining a well-known function that each template implements, but this would only work one level deep without also adding a mechanism for "calling" a template, and at that point you are making a template system on top of PHP.
> as PHP files don't take parameters$_SERVER, $_POST, $_GET.The rest is not the PHP3 I recognize to be honest, let alone the modern stuff. Remember include() literally just included the code right there, inline, so you could include in functions and gain the function's scope:function render($data) {
        switch ($data['foo']) {
            case 'bar': include('bar.inc'); break;
            case 'baz': include('baz.inc'); break;
        }
    }That's your template router with all the template's data pre-loaded in the template's scope, be it ever so filthy.
All of those variables are global, there's no way to establish an interface between the caller and the callee without using functions. You could certainly have a shared understanding of what variables have been injected into a global, but this is awkward, and requires you to do cleanup after each template instantiation to avoid leaking values between templates, which can cause subtle bugs.> Remember include() literally just included the code right there, inline, so you could include in functions and gain the function's scope:I've talked about this approach elsewhere in thread, it is not nestable without building a way to "call" templates on top of require/include, and when you do that you'll need to undefined the render function to do it as well, which creates additional complexity. At that point, the original premise of just using raw PHP isn't very true, because you are now building a framework or templating system around it.Also, you have to contend with the magic "render" function not being globally defined by something. It's messy.
> there's no way to establish an interface between the caller and the callee without using functionsUm. Can you give me an example to pad that out a bit?> and requires you to do cleanup after each template instantiation to avoid leaking values between templatesIn my render() example, isn't that "reaching the end of the function"? (Edit: Wait, you're only talking about the superglobals, right?)
> Um. Can you give me an example to pad that out a bit?Your example of using a render() function is already an example of this. You can parameterize render() to provide data to the template from the caller without utilizing untyped globals, and without having to clean the globals up after the template has rendered.> Wait, you're only talking about the superglobals, right?Yes. Globals are globals. PHP's super global distinction isn't really relevant to whether you are tainting the execution environment when you pass data to a script.The point is, as I elaborate elsewhere, PHP is very awkward to use as a proper templating system.
>functions are global so you now need to name them uniquely to avoid collisionsI hear this here, and elsewhere I hear that PHP has evolved into a decent language. Both can't be true.
The discussion thread here may underrepresent OOP PHP.
Large software in PHP usually uses namespaces instead of declaring functions at the top-level scope.
And most projects except for legacy ones lean towards objects and classes over plain functions.Namespaces allow non-global functions without a wrapping class already, IIRC.
Looking up though, there seem to be special cases (legacy behavior, making everything at the top level global) when using namespaced files with include() statemtents, if I read the docs correctly.Dumping pure functions as static members into wrapper classes was not uncommon when I used PHP.But primarily, a lot of code was heavy on dependency injection and inversion of control, Symfony being the leader of this coding style maybe.TFA also seems to be about class-oriented programming, but not the heavy design-pattern style mentioned above.The linked TUI CLI parser looks like a nice and lean PHP OOP example.
Function names are scoped to the current namespace. This means that for local closures it is usually better to define functions as variables$closure = function(){};instead offunction closure(){}
Its not true at all.
A few reasons:1. It's a loaded foot gun. PHP was notorious for 1000 line files with HTML and SQL all mixed together. (I speak from personal experiences on this)2. Templating languages are "portable" (In theory). Have a mixed env of PHP and Java... there were templating languages that would work for both teams, it took a step out of scalability.... XML and XSLT were the promise land on this one, but we fucked all that up. Portability is a big deal. We're still slinging CSV files for a good reason.
1. I've seen enough terrible things in my time, but you can make a mess in any language using any number of frameworks. And it's been a hot minute since I've seen one of those 1000+ line PHP+SQL+HTML+JS+CSS monstrosities in any serious environment.Improper use of templating engines or trying to use templating engines that aren't up to the task can give you headaches just as well. Sadly no amount of frameworks or templating engines can stop a bad programmer from writing bad code, in the end we're craftsmen who need to learn how to use our tools.2. This could be a valid use case, but a rather rare one. XML+XSLT is something that sounds fantastic on paper, but as anyone who actually worked with it knows it ranges from a big disappointment to an absolute nightmare.
> Sadly no amount of frameworks or templating engines can stop a bad programmer from writing bad code,It's not a matter of whether the code is bad or not, buthow bad.The entire point of frameworks is to add guard rails to help you stay disciplined and avoid cutting corners on separation of concerns.Using PHP as a template language tempts developers to violate SOC every day.
If you need guard rails to keep you from performing database manipulations in your views you have other problems to worry about. And if anything people are cutting corners on SOC in the M and C part of MVC, not the V part.Also I don't see how using a loop or conditional in PHP is any different from using one in a templating engine, aside from the overhead of the engine and added annoyance of debugging another language in your project.
> If you need guard rails to keep you from performing database manipulations in your views you have other problems to worry about.Those problems are called "junior developers", and I think we'd all like to avoid them, but that's not very sustainable.Perhaps we can fix the education problem, but given that folks just do a boot camp and head into the market, prospects aren't looking good.> Also I don't see how using a loop or conditional in PHP is any different from using one in a templating engine, aside from the overhead of the engine and added annoyance of debugging another language in your project.The problem is convention, or lack thereof. Without convention, who's to say where that database call should live? Frameworks, which tend to use templating languages for this reason, tend to make that convention clear to all teammates.I want to mention that this doesn't mean you can't use PHP as the programming language for your templates as long as the conventions are clear, but PHP is poorly suited to being a template language for reasons I've posted elsewhere in this thread.
>>> If you need guard rails to keep you from performing database manipulations in your views you have other problems to worry about.Its a one off... Its just an internal tool... This is a prototype... It's a hot fix...I know better, I have done it. It is only with dumb luck that they didn't end up as products. Some people dont know that they should not or that it isnt a place they should try to "get away" with it. These things grow and then turn into products and someone has to clean them up.Source: I made a lot of money turning PHP "projects" into "software".> Also I don't see how using a loop or conditional in PHP is any different from using one in a templating engineOne of these things is Turing complete. The other is not.Templating languages have their own laments: see yaml configs used to create "workflows", "environments" and "servers" via templating.
I've seen Python that was almost as bad as PHP. At one company, a guy actually complained that he didn't want to use multiple files, third-party packages, or anything outside of the stdlib. He'd write everything inside of a single "main.py" that ran as an AWS Lambda, which he often edited live in the console. When I first saw this, I thought I had landed on another planet.At another job, another guy built some massive abstract-factory-factory-layer in Python, a class hierarchy 4 or 5 layers deep. 5000+ lines in a single file. It was almost impossible to debug.Both of these are better than some C++ code I once saw. 10,000+ lines in a single file. In that file, there was a function with a 3000+ line case statement, which was mostly copy-pasta'd from other parts of the code (not in that 10K line file.)I have seen plenty of PHP code that smelled like a nuclear dumpster fire, but you can write trash in any language.
> I don't quite get the use of templating engines in PHP because PHP is a templating engine itself.Do you writesafetemplates in PHP ?
Yep. Linters help. And are lighter than other templates engines (eg Blade, Twig) and give me static analysis.
> react doing this very thing and calling it JSXIn PHP, “HTML" is string concatenation; in React, “HTML" is an HTML-flavoured bit of syntax sugar over HTML-generating functions (and you are still welcome to call the functions yourself, if you want your HTML-generation code to avoid looking like HTML). Aside from looking kind-of similar if you squint, I’d say the differences and pros and cons are fairly significant (For example the IMOworstthing about the PHP approach, the ease of shooting yourself in the foot with XSS holes, is a non-issue in JSX).
I built the Swytch Framework to exactly hit these spots. As far as I know, it’s the only templating system out there with contextual escaping (you write html, it parses the html using a streaming parser, escapes output, then writes it out).I use it exactly for rapid dev of stupid ideas. I’m not sure if I’d use it in a production environment because it is quite slow.
> Now why no one bats an eye at node/react doing this very thing and calling it JSX is beyond me but...Indeed.
It did make total sense at the time. Consider we are talking a time where you had static html.It is obviously good to be able to automate generating web pages based on say the state of a database. As this gives you up-to-date pages without someone having to manually build them.And if that - automatically build web-pages from a database - is your goal and your current state of the art is static pages, then creating a language you can interject into your static pages, to build the page dynamically is a no brainer.
In defense of the PHP community, things like Symfony attempt to create some sanity when it comes to separation of concerns. Unfortunately, when people talk about PHP they inevitably talk about raw, framework less PHP and act like it's as sensible as something structured and disciplined like Ruby on Rails or ASP.NET MVC.
> PHP mixed with HTML was one of the "bad ideas" that hurt PHP. It was a bad practice that got out of hand.So what, JSPs are just the same. In the end what matters is the speed to Get Things Done, and there's utterlynothingcompeting with PHP, closely followed by Tomcat+JSP as you can use the insane amount of interfaces with just about everything that the Java world has.
> PHP mixed with HTML was one of the "bad ideas" that hurt PHP. It was a bad practice that got out of hand.PHP receives its share of criticism, and HTML lives on relatively unscathed.So if mixing PHP/HTML is a problem, you'd probably throw out the PHP and keep the HTML.Also, isn't this use case PHP's origin?  A dev wanted some programmable HTML?
> Now why no one bats an eye at node/react doing this very thing and calling it JSX is beyond me but...Because it's not "this very thing". HTML around PHP is output directly to stdout. JSX is just syntax for literals.
> PHP mixed with HTML was one of the "bad ideas" that hurt PHP. It was a bad practice that got out of hand.If you think of PHP as prototype-only, mixing tags and HTML is very convenient, like it is with the other thousand templating tools. And obviously it's more a problem of XSS through badly sanitized inputs more than the mix in itself, blah blah blahIt's PHP in production a bad practice that got out of hand.
You're getting downvotes, but that genuinely puzzled me the first time I saw JSX. ("This looks a lot like 'include("form.php")' in old-school PHP. What am I missing?")Turns out I wasn't missing much. I've mentally pegged it as an example of "the pendulum swings" - thin client vs thick client, centre vs edge, tight coupling vs loose coupling, etc.
Discerning developers avoid PHP for the reasons you mention, and yet it powers a frightening percentage of the Web.React is popular for the same reason as PHP. I can only hope the industry corrects for this soon, because I challenge you to find a startup building raw PHP in 2024, yet nearly all of them build with React.
Any online resources you used to get yourself on the right track or as a starting point to get running?
Try running throughhttps://bootcamp.laravel.com/blade/installationif you've never worked with PHP at all before, and want to see what modern PHP feels like.
Thanks!
In a lot of ways, PHP represents developer productivity maximalism. It's neither pretty nor safe, but there is a lot that other communities could learn by studying popular PHP libraries.
It is powerful indeed. But PHP syntax feels unelegant and making me write unnecessary ceremony. It feels different when I write typescript code, every character I type fits like lego.Especially when my codebase grows so much. Navigating PHP project is like thrown in forest without a map, you can always look up the sun to find your way.
Loved this article, those were all great points that I have faced on my daily job at a PHP shop.A breath of fresh air in amids of thousands of "ew, such a bad language" and "a fractal of bad design", the latter being incredibly outdated and still referenced from time to time.I love PHP, it was my first language and it's one hell of a productive ecosystem to be in. Laravel is an excellent choice for rapid prototyping and Symfony is probably one of the best web frameworks for enterprise projects. Paired with coroutines extensions such as Swoole/OpenSwoole/Swow it puts one hell of a fight performance wise with more modern languages.
I agree. 
Also Laravel is one of the best web frameworks for rapid prototyping :)
Indeed.Also, I have been looking for GraphQL implementations for other server-side languages recently and I have yet to encounter a schema-first implementation that comes close to what the Lighthouse layer for Laravel can do.That is really productive.
Why would you want to use graphql? In my experience, it’s pretty terrible for real-world use-cases.
Lighthouse is sophisticated and productive. I only use it in fully-authenticated contexts but because it is schema-first with good ORM bindings and excellent annotation support, I barely write any logic that isn't a mutation, an accessor or a permissions gate. The occasional top-level query resolver. Beyond that it is the graphql schema and the models.And it gives me the opportunity to separate out the front end concerns in a way I could explain to someone else.Apollo has been a bit of a pickle on the front-end, mind you. That's a decision I'd revisit.But generally it has meant a flexible API interface and leads to nice low latency UIs.Check it out:https://lighthouse-php.comAnd these really good third-party auth mutations for Passport:https://lighthouse-php-auth.com
Funny, my opinion of Apollo on the front end is that it's the bees knees (specifically vue-apollo using the composition API), but it's the PHP graphql backend that I'm stuck with (Symfony API Platform) that I really wish I could ditch in favor of something like Lighthouse.And I _hate_ Eloquent, but I'm that jealous of all the goodies in Lighthouse's graphql dialect.  You pretty much can't use directives at all in API Platform :(
Ah cool! I hadn't seen this before!I'd only seen fairly raw GraphQL from like 4-5 years ago, when you had to write your own auth, resolvers, deal with n+1 queries, etc. This is actually really nice and solves a lot of the issues I was thinking of.
Right. People keep telling me that code-first is better but there is no way all those complex APIs are easier to use than just spitting out some JSON from an endpoint.Schema-first feels more manageable.I'm not going to say I haven't had to do that a _bit_ here, when I've got into quite advanced things.(e.g. sometimes you might want to dynamically provide the values from an enum, or write your own decorators, or you might want a custom top-level resolver.)It's built on the WebOnyx reference implementation, so there's some help out there.But it's amazing how much code Ihaven'thad to write, and being the sort of person I am with difficulties controlling focus, I absolutelylovethe schema-first approach. It interacts well with Eloquent scopes, with the ordinary API gate system, with policies and validations.It's actually weird how good it is. You still have all the same issues you have with GraphQL generally (like limiting graph traversals to things a user is authorized to see), but you have so many tools.
Another nice thing about schema-first is that clients can start interacting with a mock server from day-0, and both sides can build out the implementation independently according to the spec. It really speeds things up on larger projects (IMHO).Working on FrankenPHP, we get a lot of issues from the Laravel people (mostly in regards to octane + worker mode), and I've been getting into more and more Laravel to support these folks and understand what is going on in the SAPI. I've really started to understand the attraction lately. Previously, I worked at Automattic for quite a while and learned the WordPress side of PHP, then worked with Symfony in a corporate setting, so I've yet to get into Laravel in the commercial world, but I'm thinking I probably will for my next job.
Also: I have removed the little bit of snark in my reply above -- it shouldn't have been there and I apologise. Rough brain-day making me jumpy but there's no excuse!
Dude. We've all been there, no offense taken. I probably could have taken a few seconds to explain my experience instead of just assuming everyone else has had the same experience.
This is one I did look at and then forgot about -- thanks!
Huh? This article is talking about very similar issue to the fractal of bad design. Down to repeating specific ones like json_decode(null). Most of the fractal post still applies. The themes of surprises and consistency are strong in both.I agree that the language evolved since then, but the main categories are still not solved in the language. Nice frameworks just hide those well.
The thing that I think PHP developers hate most about the Fractal of Bad Design article is hearing it from full-stack JS developers. They really do not have the moral high ground.PHP has improved since in a way that is rarely considered when reposting it, but JS has some deep language horrors of its own still, and many novel JS horrors like NPM have emerged largely since the Fractal article was published.As the King sang, so eloquently: o/~ clean up your own backyard o/~
As someone who writes PHP and JS professionally every day, I think they're leagues apart.* Sure, people love to look down on JS, but its fundamentals are much stronger than PHP's.PHP is no longer aterriblelanguage- recent editions have made leaps and bounds on language features, and the ecosystem around Symfony is great. But on a weekly or monthly basis I run into something that makes me want to head-desk.JS's recent(ish) language improvements like `let` and ESM have been much more fundamentally significant than PHP's IMO, where we're still stuck with bad scoping and Java-brained class autoloading.*Not leagues apart in terms of productivity. I can certainly get a lot done with PHP. I mean leagues apart at their foundation, the basic concepts at work in the language. Most of that can be ignored until it rears up to harass you. Here's a great example of something similar to an issue that bit me last month:https://stackoverflow.com/q/3307409
> As someone who writes PHP and JS professionally every day, I think they're leagues apart.As someone who’s written a lot of php and JavaScript, I think the same thing but in the opposite way. JavaScript just can’t compare when it comes to designing a complex OO system.
I actually think the opposite is the case. let is nice, but javascript has no typing whatsoever. The PHP type system isn't perfect (with a lack of generics being the biggest pain point), but in javascript you just have to annotate and pray (or use typescript and compile it back to javascript, hoping people interface with your code correctly). And PHP has a dedicated string concatenation operator, which has helped it avoid horrors like '2' + 2 = 22 that javascript has to offer. Javascript will just straight up let you add properties to any object on purpose or by accident, which is useful for polyfills but also fucking horrible for bug avoidance and an invitation for less restrained individuals to make true abominations.
All of those things I see as productivity issues, not language fundamentals. TypeScript solves types in JS for me the way Laravel solves superglobals in PHP.Adding properties to an object is fine IMO. Arbitrary properties and prototypes are, to me, a much cleaner system than PHP's somewhat confused mix of array, object and class. The lower you go in JS the more unity of concepts there is, whereas the lower you go in PHP the more hacks you discover.All of the above said, I would prefer a string concatenation operator to overloading +. JS template literals mostly solve that for me in practise. And what Ireallyactually want is an equivalent of Haskell's <> or mconcat, which concatenates anything monoidal - strings, lists, etc.
In php 8.3, there is a new json_validate function! Stuff changes, it just takes a bit of time. Luckily, the core maintainers have been putting out steady releases every year and old versions are being deprecated on a rolling 3 year cycle. It doesn't solve the historical problem, but hopefully it enforces better habits for the ecosystem moving forward.
Nitpicking on trivialities is pointless.Rather, point out the fact that Symfony is a framework that relies entirely on all sorts of magic behavior, and at the same time it isentirely undocumented.One of the most horrible programming experiences I've ever experienced.PHP is a nice language, but the community is insane.
Just out of curiosity, when was the last time you worked with Symfony?The framework has changed massively after the earliest versions (1~3). These days it's very similar to Java's SpringBoot. After scaffolding all you get is a thin layer with the HTTP abstraction, configuration support, reflection-based Dependency Injection and a testing framework (PHPUnit).Since the framework is component-based you pull dependencies as you need them. I find the documentation really good and honestly I don't see much magic in it, it's an event-based web framework. Laravel and it's facades on the other hand is very magical.
Symfony is not great, but most people utterly misuse it so you end up with spaghetti and ground mud. That being said, Symfony is the most popular framework I know of that liberally uses goto statements.
I haven't worked very much with Symfony but I've never seen a goto. In fact, the last time I've seen a goto statement was maybe 15 years ago in a mIRC script.Where are those goto statements? I'm asking out of curiosity to check them.
The nice thing with GitHub, is that it’s literally a search away:https://github.com/search?q=repo%3Asymfony%2Fsymfony+goto&ty...I highly recommend learning how to use it.
> These days it's very similar to Java's SpringBoot.That's not a positive. Spring Boot is impossible to use for anything except an unmaintainable abomination, since the whole thing runs on undocumented magic.
It is actually documented, surely you must be confused?You have the docs with extensive examples, you have a free book, and the whole framework is typed and all configuration options and the individual components referenced:https://symfony.com/doc/current/index.htmlAnd if you use PhpStorm with the Symfony plugin almost everything gets intellisense.
I don't use PhpStorm.Also, random code snippets that may or may not work is not documentation, much less is it a reference.
I don't get it, what more from the docs do you need?
I think his complaint is that a lot of the Symfony docs don't simply say what things are/do, they instead inform via examples. Which means you have to parse the examples first to understand what's going on.
Yes, "documentation" implies a curated and complete reference, not a collection of code snippets that may or may not apply to your current problem and version of Symfony.(No, random posts oт Stackoverflow and generative AI responses aren't a replacement for documentation either.)
But ... there is all that, right there on the documentation page, just ... scroll?https://symfony.com/doc/current/index.html
Honestly I don't see it that way.The blog author makes solid points that I agree. Meanwhile AFOBD just make fun of stdlib inconsistencies and of language quirks, most of which were fixed throughout the years.AFOBD is so incredibly outdated that this paragraph is still there: "PHP is naturally tied to Apache. Running it separately, or with any other webserver, requires just as much mucking around (possibly more) as deploying any other language.".
Some of the points are outdated, but the soul of the article, that those stdlib inconsistencies and language quirks as you called it, lead to terrible design and a lot of surprising footguns, is still quite true. Laravel is a good framework and it is because it hides a lot of PHP from the user.
I see the advancements in php and I think I could go back by now but I know that 90% of comapnies recruit you to fix some wordpress 4/php 5 bugy and custom plugin infested site that should just be made from scratch but because there is no money and "just quickly fix it in 1 workday" gives me php ptsd once again.
This is absolutely a problem.It's now a powerful, fast, flexible platform with a load of amazing libraries and tools -- graphql, webhooks, databases, all sorts. There's an amazing level of recent PHP support out there you can host on.And then there are the terrible applications, written from inadequate specs, in a hurry, by people who just aren't developers. And they are embedded, and people want them fixed.You have to have a knack for, and some enjoyment from, that work.The worst I have encountered is a Wordpress site built by some people who did not know Wordpress could do several important things, so they'd subverted the loop, ignored where they could hook, and embedded wordpress outside the loop to do stuff, which was a nightmare.The second worst was, it must be said, a Laravel app, but that problem wasn't the PHP so much (though it had been written in a hurry with an awful lot of duplication that we could have refactored out), it was the unreliable assumptions made about MySQL default result ordering.Which is actually the secondary problem here: people who make bad PHP decisions usually make bad SQL, email and HTTP decisions too.If building your own thing from scratch, or starting a new project, etc., PHP is a blast now, actually. But the very old things... not so much.
Yes, back in the "old days" of PHP you could ignore ordering and grouping on MySQL and it would pretty reliably give you back things in a stable "order of insertion" order where there was ambiguity.Of course that was never guaranteed and subsequent optimizations and changes have really removed that ability to ignore order in many situations. Plus, MySQL also changed to actually check if you're doing GROUP BY properly by default.MySQL was always a big part of the PHP story so it's fitting they've followed similar arcs of improvement and growing pains over the years.
PHP is probably like Excel, in that is is really helpful from a raw productivity standpoint to be good at it, but you really don't want other people toknowthat you're good at it.
IME, that also makes PHP worth it for shell scripts. It's miles better than the common baseline that's bash/perl... but once word gets out, people will ask you to rewrite their 30 kLOC sh monstrum into something readable...
Mmm. It really depends on whether you have the scope to start your projects and stay in control.
idk, when I want productivity I go with nodejs these days. lodash for some quick data crunching and pg or mariadb for db access using promises simply beats native php functions. with express you can spawn a http server in under 10 lines, while with php you need to setup apache/nginx or docker.at some point in the past PHP was the most productive tool for some quick & dirty coding, but not anymore for me.
I recommend checking out FrankenPHP, where you can spin up a production php server with a single cli command, or compile your php into a self-executable binary.I’m a contributor over there.
Not my experience. You will see some legacy code but that is to be expected in any coding job.Wordpress is kind of it's own ecosystem. I have been a PHP dev for years and never touched any Wordpress code.Most jobs recruit for specific frameworks like symfony or laravel.
I might be a minority, but i truly enjoy PHPs syntax a lot. No other language i use gives me the same joy.Modern PHP is great, the past & some fundamental decisions are automatic tech debt that i can live with. It'd be great if PHP 8.3 gets forked with no backward compatibility, removing all the old PHP as a template engine designed functions that nobody needs & release under a new name. I just can't find the same type of joy in writing code as i do when writing PHP. But some things are truly annoying. Just not enough for me to switch or start the fork myself.
On a few occasions I've done a few weeks of refactoring the php source toward creating just such a fork, but decided it was just going to be too much work over time for too little benefit for too few people.  And that's true of pretty much all "legacy-free" forks: it's fun to rip out all the legacy crap, but you're left with an incompatible language in the end, at which point you're probably better off starting with a different language entirely.
Anything of your refactorings public to check out?> but you're left with an incompatible language in the end, at which point you're probably better off starting with a different language entirely.Yes, but which one?No matter which one i try, in the end, i am always close to rewriting it with php. 
Eg as many good things go has, i don't enjoy the syntax as much as phps. I could live with it, given the advantages. But i can't get over it, that most of my code seems to be error checking. Sure, that's probably a good thing for serious work. But that's just not where the joy in programming lies for me. Most cases phps try-catch feels much, much more elegant / fun to write (not comparing the efficiency of the outcome).I do love the fact i end up with a single executable. And php without framework requires much more overhead, which is also annoying. And i am done with php frameworks.
I'm afraid I burned it down to the ground, but the last attempt never got me much past reorganizing the headers and ripping out ifdefs for all non-posix systems (bye bye windows support).  These days I'm interested in more green-field languages like unison, though I'm still trying to think of something to write in it (or any inspiring language, really).
Interesting. I haven't even heard about unison. Just skimmed the website and it looks interesting. Thanks for mentioning it!
This is a bit too much of an apples vs oranges. Use cases for PHP (easy to develop, maintain websites) are different from those for Go and Rust.Obviously, PHP came from a place of great inconsistency, and the remains are still there, including the popularity to rant on it. PHP is getting significantly better though, and while a long one, I hugely prefer this route over something more abrupt like python 2-3. The first 3 or so points are valid, but annoyances at best. For the points about closures, statements, inline classes etc., they are just features from other languages that aren't in PHP.
I can't for async/await to reach PHP and see code that awaits 5 queries and 3 http requests in a row. Perfection.
This sentence does not make sense and still I understood it perfectly. It's the reason I love PHP over JS.
PHP buttered my bread for over a decade. I bear it no ill will, and this article was a lot of nostalgia.The "living on a prayer" comment on serialization brought back memories. It made me acutely aware that I use this pattern in go, and there it "just works". I now have a note to go see what  Valinor, PHPStan, Psalm, Serde are because they sound godlike.
I still have contracts in Cold Fusion. PHP is not remotely the worst web templating language out there in active use...
I lasted about a month working on a CF ecomm website many years ago. I've refused to even approach CF since then. More power to you. :)
Hello from maintaining ASP3.0 "apps".
Good for PHP that it's getting more and more traction (attention) lately. Bad press is still press & PHP is quite not bad nowadays, when you start from scratch.
I've been working with PHP for the last couple months or so for the first time in over a decade. I can't say I've enjoyed it. Feels very tedious always having to look up, say, whether the needle comes first or the haystack in a list of arguments. But it runs pretty darn fast, I'll give it that.
Many editors have tools that show language functions and their parameters as you type, so you don't have to subject yourself to that tedium if you don't want.
Oh agree as a daily php writer. The core libs are all over the place for arguments. Doing something that's so elegant in perl results in a mishmash of weird array rules, too helpful built-ins that act weird like isset
It's one way for string functions and the other way for array functions. I have a little post-it on my monitor for it.
> This is a subjective post about things that annoy me, some of the points are invalid and for sure people with far more context and brain power than I have have considered them. It is also to be expected that I take for granted things that would annoy other people.Great disclaimer, since most of the points raised in this article seem very nitpicky to me. This is understandable considering that OP's PHP work is about creating a language server and some benchmarking tool, both of which are definitely not the main use-case for this language. I bet your average PHP dev has no idea about the things mentioned in this article, nor are they interested in improving them.
I work on the same team as the author. I appreciate PHP in general, particularly because it contributes significantly to covering expenses (earning a six-figure income in Europe). While there is undoubtedly room for improvement in the language, this post highlights some valid points that we encounter in our day-to-day work on the 'large E-Commerce project' briefly mentioned at the beginning.I hope that discussions like these raise awareness within the PHP community and eventually lead to solutions. Considering the impressive initiatives the PHP foundation has recently undertaken, I am confident that the language is evolving in the right direction.Certainly, there are still individuals in the PHP world who may not grasp the essence of this post. In some tech interviews, I've encountered people stating that they 'don't know PHP, only Laravel.' I don't oppose Laravel (or WordPress or any other framework); I just want to emphasize that some individuals may not appreciate the underlying technology. Reflecting on my early days of programming, there was a tendency to exclusively focus on learning jQuery, neglecting the importance of understanding JavaScript.
I just launched an app that I've been using with my friends to collect and share memes. PHP on the backend and vanilla JS on the front end. Made a PWA out of the thing with some manifest and now I have something that I'm really proud of, that was put together in one week. If I see a funny meme I can just share it with my PWA and it will post it for me.
I'd love PHP to have proper primitives for working with binary data / buffers. You still have to use strings for that. Those strings are immutable, so performance will suffer.
In JS, there are pretty decent APIs for that. Just copy them, they work good. There is an extension, but you have to build it from source and doesn't cover all of it.Same goes for container data types. All you've got is array. No sets, no hashmaps, ordered sets, sorted sets.
Array is just all of this at the same time. There's also an extension for that, but its API is... not optimal. I wonder how much faster some programs could be if the array wasn't used as the universal data type.If one could use composer to install PHP extensions, that would be awesome. I fiddled around with WASM as a language for universal PHP extensions that can be loaded via composer, but there does not seem to be a lot yet.
The beauty of PHP is that you're always seeing $$$ signs
For "functions that return false", use thecodingmachine/safe which wraps those nasty builtins with ones that throw exceptions.  PHP's gotten a lot better lately, but it's always going to need library fixes like that for its awful legacy builtins.
I like this library and promote that wherever I can, but the safe library was even mentioned in the post:> I love the smell of false in the morning, but despite that I do wish that all PHP’s built-in functions threw exceptions. We have the famous safe library which does just that! But if you’re like me then you don’t like coupling huge amounts of code in perpetuity to an external library.
I just wrap the ones I actually need that for and put them in traits (sometimes multiple related per trait). So it's internal, small footprint, and really needs 0 maintenance. This is also good for e.g. json_* when you want to provide app-wide defaults.
Ah, I'd completely missed that.  As for depending on an external library ... get used to it.  Writing PHP without any external deps is strictly for one-off scripts -- and rarely even then.
The first point is kind of silly: You can make rust-style constructor functions if you want, and have a private constructor to enforce the behavior.Although it does require some boilerplate, which may seem like pointless extra work.
I think this was not the point, see:> [...] only to realise there the class has a private constructor or that there are static constructors which I should be using [...]
“Langauges such as Rust and Go do not have this problem, mainly because they don’t have the new keyword!”Oh but they do. You should spend some time with those languages so you can do a proper comparison.Go has hadnewfor a while now.
Go may (also in my understanding, it's not actually a keyword, but close enough?), but Rust does not.
Oh, excuse me, Box::new :D. At least in rust it’s an explicit method call instead of implicit.
but it's a convention right ? there's nothing special about `new` IIRC
Yeah, whether it’s explicit method call or an implicit macro,somethingis being called. A constructor, a new method, that’s what I was getting at. Saying you dislike the implicitnewis valid because you can’t visually see the call where in rust you can. In go, we often take theNewFactoryapproach even though there’s anew. It’s easier just to return the reference knowing it will out live the stack call.
That's correct.
I respond to every point below.In sum, the native functions should take iterators anywhere it can take arrays.Every other valid criticism he makes and many more I can wrap in the simple statement that: psalm needs to become the runtime type system which is hopefully and appears to be the (maybe distant) future.In the meantime you have 40% and quickly growing of those features in your IDE and 100% in your CI so it’s not a huge deal.Main takeaway for people who haven’t looked at PHP in 10-15 years or since the fractal article and would take the length of this post, which they don’t understand, to say “yep dumb php again” no.—————Constructors
Only had this confusion once with my UUID library and it took me 3 seconds to remember the formula."In attribute land this becomes:"
I've never seen any code or library that uses attributes like this nor do I understand why you would. The only purpose would be static analysis, let's say with psalm, and that's just not how you use attributes in psalm. He says generics are tricky: in psalm they're trivial. The real problem is the best IDEs are still working on getting the integration right.Nested attributes strikes me as an extreme edge case that would only come up in some meta-level tooling you're making for the language which is the provided example. However in this special case presumably this can be accomplished through an extension, xdebug for example does this.Serialization he says is a problem then says, it's a solved problem (there are many such accepted ways to solve this) but then says it still annoys him so not sure?"No Variadic Promoted Properties" I'd like to hear the use case for. I've done very complex things in PHP and never needed this construction. A property can't have a static single type but then also consist of a collection of random types, in this case it would just be an array. It looks like another feature that is solved by psalm.Iterator to Array: Preserve Keys he says he doesn't know if it's wrong.Iterators vs. Arrays this is easily fixed by using the popular Functional library versions of these functions which I agree should be the default.Short closures cannot have statements" I have to convert between them so I kind of get it but would say this is an intentional choice. You can substitute a method call if you really want this."Statement Blocks in General" That would be nice when and if it's very simple though having them anywhere could turn the language into kind of a mess to read considering what those blocks could contain.Functions that return false - basically everyone agrees on this, it's a conversion that's iterated on with each release and will just take time. The specific example he provides I have wrapped with an exception thrower for just this reason and never use the default.Inline Classes - he says he doesn't know if it's a good idea. I'd say no, having a reliable file system convention between codebases is a plus not a minus.
I realize it's an opinion blog, but can't help but notice that the author insists on comparing local compiled languages with PHP, a primarily server side interpreted language. Your static compiled binary program will continue working after a system upgrade, but your mish-mash PHP is going to break probably once per year.That said, I'll comment on the code style this author wants to use. It's flashy, confusing, and unnecessary. This person wants to show proficiency with the language by using all its features. That's not how you write good, readable code. Come up with some personal standards for yourself and stick to them. Stop mixing every possible style. You're increasing cognitive load.Continuing on, you want to use all the latest features of the language. That's great, but why are you trying to skin the cat three different ways in the same program? Pick one way and forget the others. If you can't fit all your code into short closures the rest will look like shit and confuse everyone else. I see this all the time with JS guys mixing bracket and dot notation. I feel like there is probably medication that can help with that.Then we get to the fact that you want everything to throw exceptions. Like file_get_contents. No. Just no. You're not supposed to rely on that function to tell you if the file is there. That's what file_exists does. If you've made it to file_get_contents and you don't know if the file is even there, you're doing PHP wrong. You can use that function with a URL and eval to execute remote code. You're not supposed to swing it around like a broken bottle.
I'll be honest. I really don't like PHP. However when I was running a coding workshop, very frequently people would ask:"How do I make a web page talk to a database?"I'd say: Well, you know that HTML file? Rename it to become a PHP file and you're almost there!As pretty much all cheap hosting already offers support for PHP (and MySQL for that matter) this would almost always work.I would love to be able to do this with NodeJS, but imagine teaching that to an absolute beginner. The conversation would have to begin with hosting platforms / SSH / server management / reverse proxies etc....
You hit the nail on the head, this is exactly why I fell in love with PHP. I learnt it back in the PHP4 days, and it just seemed like the perfectly straightforward way to do web.In a similar fashion, I abstracted away the database connection, query and returning of results into one lazy-inited function, so talking to the database really was just like<?=q("select name from users where id = $userid") ?>I worked a lot with other languages, none feeling as natural to me as this one, aside from Ruby.
Be careful as this syntax can potentially introduce SQL injections.PHP's parameterization features in PDO can be abstracted so you can turn this into:$vars = array(":userid" => $userid);
  q("select name from users where id = :userid", $vars);It's still pretty concise and is much safer.
Two further alternatives for improved expressiveness:q('select name from users where id = :userid', compact('userid'));

  q('select name from users where id = ?', [ $userid ]);Recommend using single quotes for SQL (command) literals, rather than doublequotes. This helps with discouraging string interpolation (" ... WHERE col = $value "). This also helps very much with SQL quoting object names (tables, columns, indexes, etc) - SQL specifies doublequote (") as the quoting character; for example 'SELECT COUNT(users.id) AS "Number of users" FROM users', or 'CREATE VIEW "My daily report" AS SELECT SUM("count") FROM "some strange table" LEFT JOIN ...'.
Parameterized queries and statements are great.  They solve problems where the paramaterized queries are used.  However care must be taken, a script running on the database after information has been entered can still inject long after the initial parameterized statement put it into the database if that script itself does not use parameterized queries, making a SQL injection still work, in a delayed way.
PHP: the originalprogressive enhancement.
It's still far behind PHP[0], but with Next.js/blitz.js I think we're going in the right direction.[0]: as in, I would have nightmares trying to introduce beginners to full JS stack vs I would have nightmares thinking what they will end up coding when they easily become dangerous with PHP (which is I guess why there are so many bad PHP codebases: it's super easy to start)
You need to try swoole/ openswoole  - it brings golang style concurrency to php.    
you dont need to use nginx/apache  and it beats node in performance tests.https://www.swoole.co.uk/
I have used PHP for years. Like it. Have accomplished some nice things with it. Think it's evolved nicely in recent years. Feel it's a great tool for particular problems. Will continue to use it. Will always be open to alternatives.Will never understand why some people find that so offensive and will tell you that you mustn't use it or imply that you are ignorant or stupid for using it.
For people of a certain age and job history, the worst code they've ever inherited was written in PHP.I think JScanbe worse. There are things that are possible with dynamic languages that are literally impossible with static ones.So think of PHP less as a "bad language" and more of a code smell.
I don't think any JS code can be worse than old PHP code. I've had to deal with legacy software written with PHP4. I was to port it to PHP7 since it was not compatible with PHP5.4+. The code used "register globals", meaning that variables were created on the fly from the parameters in the URL, the POST form data, and the cookies.Requesting `index.php?something=X` implied `$something = "X";` in the global scope at the beginning of "index.php". And since the global scope was not limited to a file, tracing a variable through files and side effects was a nightmare. Even understanding the code intent was often hard!Before PHP7, there were many elements of the language that were meant to simplify its usage, but had awful consequences in many cases. Even more because it bent the PHP community toward a quick and dirty process. "Magic quotes", the automatic escaping was one of those abominations. For any request input (e.g. POST form data), it added backslashes before single quotes. It was meant to protect data automatically in case it was inserted into a SQL request... It granted no security gain in this context, and was a mess for any other use.
> I don't think any JS code can be worse than old PHP code.I'm currently working for a company where all our microservices were written in Node.js by juniors.JS canabsolutelybe worse than PHP
I've heard of JS referred to as "PHP with cooler shoes". I smirked.
As far as I know, you can't monkey-patch anything in PHP, but you can in JS[1]. That alone might make JS the more dangerous of the two languages.1.https://www.audero.it/blog/2016/12/05/monkey-patching-javasc...
Don't forget how <??> is built-in and was heavily abused to create insecure, incomprehensible spaghetti messes.You'd have to try really hard to make callback labyrinths in JS match the mess that came out of the above combined with runtime-as-template-engine. This was basically idiomatic at the time.
I don't know man, cleaning up legacy PHP can be kinda fun, but when I work with some batshit insane piece of JS I feel like I'm going psychotic.
Fun fact: to this day you still cannot have request parameters with “.” in them, because a dot is not valid in a variable name—even though register_globals was removed several major versions ago.The value of a form input with the name “foo.bar” will instead be available under $_POST[“foo_bar”].
> So think of PHP less as a "bad language" and more of a code smell.Surely that depends on when the PHP in question was originally written.
Clearly you've never inheritedanythingwritten in Perl.
I haven’t used PHP in over a decade. I can never forgot how much PHP got wrong in terms of how application development on the internet would happen. The ergonomics of using it were just… bad compared to other frameworks that came on the market. I remember when rails came out and it was so mind blowing compared to PHP. The language was certainly useful for a time, and I’m sure the language has progressed since, but switching to PHP still feels like it would be a huge step backwards.
Comparing Rails to PHP is unfair given that one is a framework and one is a programming language. Compare PHP and Ruby or Rails and Laravel to keep things apples to apples and oranges to oranges.
A lot of people 10+ years ago were building websites by interpreting PHP and using the output as HTML. The language (at the time) seemed to encourage this. I agree that PHP is not a framework, but it seemed to have some opinion on how HTML was to be generated, which most languages don’t have. Also rails is 7 years older than Laravel, so my point still stands that PHP was behind the curve.
If your standard is rails then literally everything in every language before rails was "behind the curve". Currently PHP has frameworks that have caught rails, but Ruby's perf is still garbage.
Django was released shortly after Rails. Ruby and Python developers _needed_ to build something like Rails and Django because those languages didn’t promote the same type of script-as-html pattern that PHP did. Had more thought gone in to serving websites, PHP might enjoy more popularity today. PHP had the first mover advantage after all, but frameworks built in other languages were purely better in almost all categories.
10+ is not that long time ago. There was already Zend Framework. And for some basic API using framework may be overkill anyway.
I'd be interested to know what you think PHP got wrong with respect to web development? The majority of the web is running on PHP to this day, so at least in terms of popularity it seems people don't feel this way generally. Furthermore, if one were philosophically-minded, it could be argued that PHP's "shared nothing/one thread per page" execution model is the very quintessence of HTTP.
It‘s also the essence of "serverless" so that model seems almost prescient.
Except Erlang (and nowadays Elixir as well) has that for 30+ years already and it's done much better -- one green thread per request, and you can have 200,000+ of them at the same time on some fairly modest hosts, without any of them stealing run time from the others (as much as the hardware allows, of course).PHP's "prescient" model demanded one OS process per request which is frankly absurd and I don't get how anyone views PHP in serious light because of this single fact alone.
Now think about how many companies/products need the power of Erlang vs PHP where PHP has more tooling, better ecosystem and far more available talent to choose from. Just because Erlang can perform better doesn't mean it is the right tool for the job. Performance is one aspect and PHP is good enough for lot of use cases while it has tons of other advantages that Erlang doesn't.
Not performance per se. It's a much more robust model of work thatin additionis sipping hardware resources more efficiently (so DoS attacks from one user to all others are hard)."How many companies need X" is not a discussion, it's an exchange of opinions and won't ever go anywhere, so I refuse to start it.I was merely responding to the claim that PHP had "prescient" ideas. It didn't.
I’m curious what metric you’re using to determine that a majority of the web is running on PHP.
What alternative language do you propose? Not that asking for a source is unreasonable, but you seem to doubt that PHP has majority market share. Do you suppose that Node is more popular? Rails? Go? Flask?
Surveys generally indicate that of sites where it is possible to determine the language, somewhere between 70% and 80% of them are running PHP. Of course, that figure will include a lot of WordPress sites.
What percentage of websites is it possible to determine the language? My guess is not many. Your metric self-selects for recognizing PHP sites because of Wordpress.
Php has developed a lot in a decade.Lots of new good things in php7/php8. The typecasting is way better than before, but it still allows you to be more "dynamic" if you want to.
$x = [1,null,'xxxx', collect([])];gettype($x) is "array". you can annotate a type as being an `array`.  How does that help me exactly?
Since $x is an array, it will get rejected at runtime by `function f(int $a)`. So this `array` type is limited but useful.You can also add annotations like `/* @var []int */`. External tools (psalm, phpstan) use annotations in their static analysis of the code and will raise an error if $x elements are not integers.Of course, it's far from Haskell, but my experience with types in PHP is smoother than in Python. Though it was 2 years ago in Python,  and the environnement has probably matured.In my opinion, a worse problem with PHP is that classes properties are dynamic. `class A {}; $a=new A; $a->x=1;` is perfectly valid and will add a property to the object that does not exist in the class. There's no simple way to forbid this, even at runtime (hacking the magic `__set()` creates other pain points).
> In my opinion, a worse problem with PHP is that classes properties are dynamic.There's a current RFC that is aiming to deprecate this 'feature'.https://wiki.php.net/rfc/deprecate_dynamic_properties
Here's a choose your own adventure for people new to the field. Pick something you want to build, then see which languages are the best suited. If you want to build several things, see which languages are the most recurring and versatile:- Web frontend: Javascript/TypeScript- Web backend: Javascript/TypeScript, Python- Performant backend (where you manage threads and queues): Go, Java, Rust- Machine learning: Python- Command line scripting: Python- Command line tools (binaries, eg 'ripgrep'): Rust, Go- Mobile: Kotlin, Swift- Systems/bare metal: Rust (discourage C/C++)- Desktop games: C#, C++, GLSL, Rust (in ten years)Mix and match.The safest three to learn that give you the most flexibility are probably Javascript/TypeScript, Python, and Rust. You can build almost anything with those three.
You can build almost anything with any language.I've done shell scripts in PHP. Mobile development in Ruby, JS and haxe. Web development with Go. Nothing is stopping you, and if you know the language it is usually not to weird either.
Rust is great, but if one is looking for a job in systems programming, C and C++ is what gets one hired, regardless of their flaws.Recent example, while Android has adopted Rust for replacing their bluetooth stack, the newly introduced Android Games Development SDK focus on C and C++.Or Microsoft, despite all their security speech, Azure Sphere OS and RTOS only support C on the official SDK, and the new WinUI components are all based on C++.And naturally anyone wanting to contribute to the Rust compilers, most likely will need to brush up their C++ skills if they intend to mess with GCC or LLVM internals.
> Rust is great, but if one is looking for a job in systems programming, C and C++ is what gets one hired, regardless of their flaws.That's true, but as a beginner I feel like starting with Rust is a lot more accessible, and could help someone switch into C++ later.
That I can fully agree on, after all it was learning systems programming via BASIC and Turbo Pascal, that made me adopt best practices in C and C++ from the get go.So from that point of view, learning about lifetimes, modular code, and that bounds checking isn't evil are already good education stepping stones.
And even moreso for the embedded space
I really would not discourage C, at all. Even encourage it, especially for embedded. It really makes you grok the lower levels in a way few other languages do, and it's still widely used.C++, though, agreed.
I'll take anything on that list with static typing, and discard the rest. I've certainly enjoyed many of those languages but I wouldn't build anything with dynamically typed language unless I were forced to.
You might also want to know a few languages were you're sure to get a job, and right now, it seems that Ruby on Rails and PHP are some really safe bets, compared to Python.Sure, Rust is _fun_ but there's little demand for it right now in the market.
Shoutout to Elixir/Phoenix for a (performant) backend.
This would ba a great Ask HN
I haven't used PHP for years. I did some Python-based web stuff for a while.  Python is a daily driver, but I still reach for PHP when I want to make something that responds to HTTP requests.
I don’t find it offensive at all. I do, however, feel like the problems I worked on in many years of PHP were some of the least interesting projects of my career. It wasn’t the language’s fault necessarily but the types of things that language is most commonly used for? Also it was just a different time so PHP is possibly not the issue.
and the best part is they're probably javascript developers that don't understand the hell they're living in.
Pretty rare to find someone who writes a lot of PHP without also writing a lot of JavaScript. If there are JavaScript engineers who’ve never touched PHP then they probably don’t have much feelings about it at all
So your response to the haters is to be a hater yourself? Why can't we just get along?
Now, why’d you have to get JavaScript involved? Can’t something else be a punching bag?
You’re writing style is unique and grabbed my attention. Any tips to write like that?You didn’t use “I” at all, but it seems likely there are some other rules going on here.
No doubt there are people reading this message who speak Japanese who will correct me, but ... 30 years ago I studied Japanese a little bit. One interesting feature of the language was that once a subject was introduced, there was no need to restate the subject if it hadn't changed, resulting in paragraphs like the one which intrigued you."I have used PHP for years."
The first sentence establishes the subject is "I"."Like it." etc
Because this sentence doesn't have an explicit subject, it is implicitly the same one, "I".As I recall, "wa" and "ga" were the Japanese particles which established new subjects. Say you wanted to talk about Bob's new car, you'd say something akin to "About Bob's new car, is expensive. Arrived last week. Has poor gas economy."
This is called pronoun dropping [1] and happens in quite a few languages, including Japanese as noted.I had a friend in college who would always point it out (in English, where it's not very common). I still notice it often years later and I'm pretty sure it's thanks to her making me aware of it.[1]https://en.wikipedia.org/wiki/Pro-drop_language
Interesting. The Chinese examples on the wiki page sounded completely natural to me and are in accordance with how I speak/interpret the language, but I never realized I was dropping pronouns due to their inference.Thanks for the insight!
> Any tips to write like that?You notice the pattern. Mimic it. Struglle with it. Persevere.Endure. Will you reach perfection? Maybe not. No problem. Satisfaction is few layers below.
I was just trying to get a number of key points across calmly and  succinctly   without wasting time diving into a long-winded academic debate about whether or not I am "allowed" to use a programming language that I have used with success for the last decade!Not sure that I have any tips for you. Other than that it is often helpful to remove unnecessary words when communicating. This is something I have become sensitive to over the years. I used to write a lot more voluminously but I find it is harder to convey messages to people when they are confronted with a wall of text.
Hmmm... Most points in this article are shouting "yeah we have those too!!" but it didn't give any convincing arguments why I (or anybody who doesn't already know PHP) would like to learn and use PHP over other decent modern languages and ecosystems, which happen to have those points as well.
My favorite thing about PHP is the execution model. Every single request is brand new and runs the whole program start to finish.IMO that's extremely powerful in its simplicity and while you can get it in other languages, it feels like like a "core competency" for PHP (just like how async code is easier in javascript than in python, because JS kind of had it from day 1)
I see this as the opposite and find it adds quite a load of complexity and prevent to do some form of optimization in an app that has its own server.It adds its load of complexity on how to run the apps itself, you need an external server, apps often requiring some customization of the server that will run it (either mod-php or php-fpm). It means that parts of our app settings lives outside of the app, it also make updating php itself quite annoying.
I don't find this to be true at all.> you need an external serverSpoiler, you need an external server for everything on the web; you've just been brainwashed to think serverless is actually that.
What are you talking about?Lots of languages and frameworks make it easy to be self-hosted with there own server. In Python, .net, Go, Rust this is quite common.This means that your app can be a self-contained app + server and the server part can have some business logic as well.With Go, .net, Rust apps (and potentially others) that's quite nice to be able to produce a single binary app that you can just run anywhere without installing any framework or setting up any external server and it's ready to listen to incoming queries.That can even be a good enough setup for home things that are not exposed to the web and where setting up reverse proxies could be overkill.
Good point, but just to nitpick: I think that ipfs-js let's your external server be a process in someone else's browser, which is about as unserverlike as servers get.
I suppose, but I've never encountered a production site that was using Gunicorn or similar as a true server. Usually that's coupled with something like Nginx or HAProxy.So yeah, you technically don't need one for Ruby or Node.js, but I sure would.
PHP has a built in web server you can launch from the CLI and run the script. `php -S <address:port>`
The kind of optimizations you would do in an application server would prevent you from scaling pass a single server
PHP does have it's own built-in server as well, although it is not really meant for production use.Global PHP configuration options have become less important over time, with resource limits and extensions being most of what has to be configured now.
My bad, I didn't know that about PHP build in serverI only host one PHP app now (Nextcloud) and it has definitely been a bit of a pain in comparison with other things I self host.
Nextcloud is more complex than most PHP apps.
Async code is a good way to achieve some level for performance in I/O bound workloads, but it's a pain for the programmer. Because of that I wouldn't say that it's necessarily a good thing that JS is async-first.In my opinion, high level languages should not expose async primitives to the programmer - this should be abstracted away by the language and its runtime. Go is doing this (all I/O is async under the hood), and it's awesome: You can write synchronous/sequential code and get the performances of async. I would love if other languages copied that.
>In my opinion, high level languages should not expose async primitives to the programmerJust another reason why the "each request gets a process" architecture can work well. You generally don't need to worry about async stuff in PHP, because your request has the whole process to itself.
Before being async as in async/await Javascript was also async as in having an external event loop and being event driven.
Yup. Go too, but the programmer doesn't need to know it.
That's not quite a language feature though: one can write (Fast)CGI or similar programs in any common language.
I've never actually tried writing CGI scripts with a non-PHP language (I've not really seen the point since it's usually more ergonomic to just use a language native-server interface like Python's WSGI).Do any other languages have the same kinds of optimisations that PHP has with FPM where it keeps the process alive but pretends it's a complete fresh execution at the language level? (getting the performance benefits of a persistent process, while having the simplicity of CGI-style execution).
>Do any other languages have the same kinds of optimisations that PHP has with FPM where it keeps the process alive but pretends it's a complete fresh execution at the language level?I know that's how the TCL and Perl FastCGI implementations work.  I suspect that's how most of them work, and there's lots of languages supported by FastCGI.
> Do any other languages have the same kinds of optimisations that PHP has with FPM where it keeps the process alive but pretends it's a complete fresh execution at the language level?I'm not aware of other languages where it is baked into a language itself, but FastCGI libraries tend to be basically drop-in replacements for CGI ones (at least it's the case with common C, Perl, and Haskell libraries; sometimes CGI and FastCGI libraries are combined, so that they are usable in either setting): you get the optimization, while still can pretend that it's a regular CGI. I guess the primary difference from PHP is just that global/static variables would survive.
Forgive me for going a little off topic here but is it really true that JS was async-friendly from day 1? When I started using JS seriously 8 years ago, async code was horrible (callback hell, etc.) The web standards guys retrofitted native async way after the matter.
Doesn‘t this more or less mean "the only execution environment is event based, has a run loop outside of your control and calls your code whenever it wants" and "there is no busy sleep". So it was callback based from day one. Is that the same as async? I think it is?
That makes sense, thanks! It has indeed been run in a loop from the start despite the poor ergonomics - I did not think of it in that light.
async/await is just syntax sugar around promises which are a just a nice way of organizing callbacks, so yes I'd say it's true.
Probably more accurate to say it was async from day one. Which people probably realized the first time they had to deal with setTimeoutThe original promises syntax and chaining in ES6 were not particularly user friendly.
Isn't that exactly the same as most web frameworks except without a few lines of code saying something like "when this URL is accessed, run this function to handle it"?
The best part of PHP is the development model. You copy some files to a server, and load the page. That's it. It is really hard to beat how easy it is to iterate, even if the language is truly terrible.
That ship has sailed a long time ago (or you're just playing around and most languages will have a REPL nowadays)Modern PHP wears a business suit and wants to buddy the "big boys" (Java/C#) of the world. You'll have deployment pipelines, strong push towards classic OOP, strict type checking etc.I personally think ruby for instance is leaner in its dev process in most real world projects.
Many people learn PHP as a first or at least as an early language. They don't want to know about deployment pipelines, CI/CD, or how to configure JDBC, they want to make a website store a list of names. You can't easily generate HTML from Java without some kind of templating language and framework around it, or a billion string concatenations if you're working without external libraries. ASP.NET has an advantage similar to PHP, but getting ASP.NET up and running has always been a chore in my opinion; there are a lot of moving parts that you need to configure right to get the browser to show you the end result.I believe that PHP is the easiest way to just Get Things Done when you're starting out with a programming language. To deploy a website, you sign up for a free account somewhere, often with a free subdomain like mywebsite.cheapwebhosting.com, put the files on there and hit refresh. Seeing a result immediately is very motivating for beginners, and PHP doesn't require knowing anything complex like DOM manipulation to generate web pages the way Javascript does. If there were as many free web hosts that allowed the same ease of use for C# or some other language with inline templating, I'm sure it'd take off just as easily.The language isn't as bad as people claim either, I think it's on par with languages like Python and Javascript. PHP has its quirks, like using a dollar sign for variables, it's really not that much worse than its competitors. Shorthands like $_POST/GET/SESSION are such a relief to work with compared to the "professional" languages with their frameworks upon frameworks and complex, layered objects representing state. It's a great tool for setting up a simple website, maybe even a very basic web shop, where the "big boys" are complete overkill. A website like HN doesn't need more than a few PHP files to function until it hits a certain scale, and even then scaling up PHP websites is relatively easy.I think the real reason people hate PHP is because it's a language used by a lot of beginners and intermediate programmers who overestimate their ability and deliver subpar projects that someone else now needs to maintain or rewrite. I wouldn't want to inherit some kind of custom blogging engine written by an intern three years ago in any programming language, and because of its ease of development many PHP programs are just designed badly.
My issue with your approach is your first time programer still needs to:- install/update PHP or go with the outdated version that shipped with their system.- have a hosting service that will accept random PHP files- know what their hosting's PHP version/configuration is to match it locally. For instance their hosting will keep the most secure config possible, thus no out of the box fetching of URLs.- endlessly fight to find syntax errors as they are too new to have a linter. Depending on the PHP version they settled on they won't have error logs in one place but two.- fight the endless stream of out of date tips and tricks left by 2 decades of PHP programers of various pedigree.All of these have different variations for different languages, they all have their barriers and dead bodies in the closet. My take is that PHP isn't specially beginner friendly at this point, at least not as friendly as it was when it began.Making a public website from scratch will be complex anyway, so they might as well go with a saner setup that uses a templating language and not write code right into the HTML. It won't be much harder and they'll have a fighting chance to find up to date tutorial to host their project easily (hosting a rails project on Heroku for instance could be miles easier in that respect)
OP is correct, you still can develop like this with PHP, and no the ship has not sailed for many.You can have deployment pipelines etc, but if you like, you can still develop the ancient way - it still works.
Well I can still develop like this in ASP.NET if I wanted to and probably and many other languages/frameworks too, so it's not exactly unique.
apt-get install libapache2-mod-pythonNow you can put .py files into your www folder, like .php files.
Sure, but would you have that in production for the company you work for?One can also use old school CGI to serve their site, it’s super lightweight and you just upload the file at the right place, for almost any language. But that has been deprecated for the last 2 decades now.
Odd, I'm getting Perl/CGI gigs still. I should tell them to rewrite to...what's cool now?
I see a number artisans managing their business on pen and paper, and handwrite receipts.It works for them, but I wont tell random people starting a business now to go with pen and paper, 99% of the time that would be a bad advice when there are much much better alternatives now.
Having a ci/cd pipeline is much different than having to setup and maintain local environment build pipelines.
I don't see how that makes the development cycle any better. I can just edit a file, press save, and it compiles and tests run automatically. If I'm doing something in interpreted languages, the code updates in memory.Furthermore if I'm working with JS/TS, hot reloading even makes it so I don't even need to refresh the page. I can even inject code into arbitrary places with the debugger (as if I'm editing the source)!So, all these other ecosystems are on par with the PHP...I'm glad PHP adopting ideas from other communities, and that the community is becoming more cohesive, though.Aside: I used to write PHP before (back in the 3 to 5 days), and worked for a big web hosting provider that had a big shared hosting customer base; PHP was by far the most popular technology in that space.So, I'm not trying to bash on PHP.
Javascript has come a long way, but I think there's still a different.With PHP, you install the toolchain, save a file and the page becomes available.With JS/TS, you install the toolchain, and then enter a complicated process of yarn/npm incantations in the command line to get the project working right. The manual may say "yarn add typescript" but in practice there's always more setup and configuration to be done before it works well.For "real" projects, there's not that much of a difference between yarn and composer. For getting started, though, the process is a lot more involved.Another problem is that running Javascript on the backend is almost completely different from normal frontend development. If you want to store state, you end up using the same (or even worse, a similar) programming language with completely different contexts and available libraries and methods. You can't document.createElement in the backend to tell the user that an operation succeeded or failed, even though that's what you'd do if you were working on a frontend file.With PHP, you can't do frontend, so whenever you write frontend code, you can't get confused. In my opinion, this makes learning PHP backend dev a lot easier. It's only natural that you choose to continue working in the language you've started you development career in. You can see that by the fact that there are still people who swear by VB.NET, despite everything.The JS ecosystem does have the advantage of coming with a debugger, but PHP users can get the same by hooking their PHP install into the PHPStorm debugger. I think it doesn't matter much which language you use at that point, it's just a tooling preference.All in all, I think both languages have their uses. If PHP really was as bad as people say it is, it would've died out already.
I have seen people deploy php this way but I'm not aware of anyone who'd do it today.Locally however it is save, alt-tab, ctrl-r and immediately you see the result. Absolutely no waiting.These days I rather use Quarkus for this but until Quarkus arrived this was a huge advantage that PHP had over every other language and framework I was aware of.Also the documentation was fantastic compared to most of the stuff I have had to suffer through on Java, .Net and even React and Angular.Every thing you may reasonably wonder about was described in a clear, straight forward way  and included examples.
I deploy with a git pullWhich I suppose is just a fancy way of a copying files to the server.
Same. Our Node applications can take up to 10 minutes to build and deploy from a pipeline, but our PHP applications are deployed in <2 seconds by executing `git pull` on a VM.
Same. And git doesn't care if I add a build process or not, or which language I am pushing.
It is kind of just a fancy way to copy but at the same time gives you versioned deployments, rollbacks etc.
I use PHP this way and I think it's great :)
> even if the language is truly terrible.PHP already has caught up to others with 5.6, these days PHP 8 doesn't lack anything found in other major languages.Whatisstill confusing is the standard library, but only for people who never worked with C/C++ before - as most of the native PHP standard library actually originates as a verbatim copy of the C/C++ libraries.
Frankly my reasons for using it boil down to:1. WordPress uses it2. PHP is far less terrible than I remember (having used it in very early days)I manage a WP (woocommerce) site for a small business. It's not my day job, it needs to be simple. Most of the "day job" is handled by content management users. I have written a fair amount of plugins though to enable custom functionality and the process is perfectly fine.I looked at Ruby, I looked at Python, I looked at node. There's nothing as simple and, frankly, as mature aside from commercial platforms like Shopify that charge an arm and leg.
I would not recommend anyone to use WordPress in 2021, though. WordPress maybe simple to setup, it's part of what gave PHP its bad reputation.
Yeah, I hear that a lot, and to me it always seems like a person curling their lip in disapproval from the nearby Ivory Tower.I honestly always wonder: as opposed to what? Let's take my simple requirement, a small business ecommerce store that's not going to look like trash and where non technical users can make pages, edit descriptions, etc.I can do: WordPress, Magento, or I can pay a SaS provider. Essentially both do it yourself approaches are PHP and Magento has really sabotaged itself with the complicated migration. SaS means higher costs and if I want custom functionality (and yes, the business needs it), it ranges from impossible to possible but a headache.So here is a business that is now online for a minimal cost for two years, allowing great flexibility for me, while allowing completely non technical users to get crap done.
I've used php extensively in the past decade. You could kinda of say your argument about any modern web language. If I'm already comfortable in php, .net, node, ruby, or heck even java, for making a web app, do I really "need" to learn another? Not really. Every one has a different way of doing things, sure, not every different thing is better, but it is different. I think just people like to learn about multiple, but sure, you can always be stubborn and stick with your single hammer.The two things I can think of quickly, that I like about php, over another, is the ease of code->browser. You have to manage 0 build configurations or pipelines to get what you want working. Just download the files and open a browser. The second, is 100% transparency with third party libraries. Because of the lack of ability to compile, when I download a third party library, I'm getting their actual true source, and can much easier, navigate and understand the library right through the ide, without having to read a bunch of docs online and  that it's true to source. Being able to control click into third party libraries is quite liberating.
for me the biggest advantage is the size of the market. I know Python and PHP quite decent but I've never found any quick job (or long time job) for my Python skills. For PHP I have to convey some of jobs to others, I am getting so much of them (I even run some job advertisement site only for the purpose to redirect people pinging me with offers, really).But maybe this is just me.
Good jobs though? Lots of PHP jobs in Canada, but the salary is nearly universally always laughably low.
IDK what is a good salary in US/Canada, I live in European Union. My salary as WordPress developer is more than 4,5k USD/month and I see job offers with 8k USD as well (still for WP developers, this is my specialization and I know this field the most; I expect for better recognized PHP fields like modern frameworks like Laravel it could be more)And yes, 4,5k USD/month is massively good salary for Europe.On the other hand, I see many job offers with salaries being just a joke (idk if they find any good developers for such money)
Where in the EU are good (web) devs willing to work for less than 8k USD, considering the current work market situation? I am in urgent need of those. :^)
I also live in the EU, and 4,5k is not a massively good salary for a programmer in my country (Denmark). This is usually what a junior is paid.
Absolutely agree, 4.5K USD (3,970€) is certainly not a "massively good salary for Europe" although that heavily depends on the country. Here in Germany its about entry level for a CS major
Yeah, Europe has significant variance in a) reporting of salaries (some report pre-tax, others post-tax) and median income levels. Generally though, programmers are paid pretty well by the standard of the country they live in.
Is the 4,5k before or after tax?
4,5 K USD/month is 54K USD/year gross which is 47K EUR/year gross. That's not massively good salary across ALL Europe.In eastern and southern europe: that's probably good for a junior engineer, and perhaps average for a seniorIn northern europe: that's probably average for a junior, below average for a senior
I don't think salaries across Europe are comparable. There are huge discrepancies between locations.For example, in Berlin it seems to me that average salaries are around 70k EUR/year (6.6k USD/month) and really good salaries are well above 90k EUR/year (8.5k USD/month).You can see more data inhttps://www.levels.fyi, which it is skewed to the high side, but gives you an idea about what good offers are nowadays.
Same here in Switzerland. And other than working on actual modern PHP these jobs are usually maintaining old software with weird custom scripting languages like typoscript xsml ...I'd consider a PHP job, but only if they quarantee they don't have any of those legacy maintaining things lying around.
> I'd consider a PHP job, but only if they quarantee they don't have any of those legacy maintaining things lying around.I see your point, but there is lots of legacy code (in any language) laying around and making shit tons of money for their owners - hence the need to maintain these systems.
I love maintaining old rails projects. No worries with that, MVC is making it easy to work with any project done by someone who knows the language. The language allows and encourages updating as well. It can be fun even.PHP had no common way to do anything for a long time and you still see it from people writing PHP today.
My point was more that if there's money being made with some chunk of code, a sensible product owner would allow a modern refactor or even a rewrite in the same language to not endanger the long term success of said app.
I see. Well personally I never witnessed such a product owner. My whole carrier with PHP legacy code evolved around 'never touch a running system'But I like the idea that these people may exist out there :)
PHP salaries in the UK are decent. Perhaps a little lower on average than other ecosystems (the high-end has a tendency to use other languages), but I've definitely seen some well paid jobs. As a junior it may well make sense to start with PHP as there are just lots of jobs available, then you can move onto something else. There are other good options too of course.
> use PHP over other decent modern languages and ecosystemsThere's not a lot that is comparable to the PHP ecosystem when it comes to bespoke web-based e-commerce, or anything to do with bespoke customer or content management.If you're trying to integrate with some weird 3rd party API, chances are there's going to be something written in PHP, or you can easily pay someone to do it for you.Not only this, but there are agencies providing long-term support for parts of this ecosystem.Other languages with strong ecosystems in this area would be Java, or Ruby, I think. I like Java for the same reason, and would probably like Rails. Anything that has "batteries included" is good to me.
1. The develop-try cycle is fast: In PHP if you change some code it will be immediately visible - no server reload needed. That's because the "application" is reloaded at every web request. There is no application server.2. The PHP ecosystem is quite mature, and packages are of good quality in general3. Dependency management works well. You will rarely end up in a state where your dependencies are incompatible between each other (something that happen often with npm for instance)4. It's faster than python/perl/ruby
I really don't understand all the PHP dismissal on HN. As a language it has continued to evolve in meaningful ways, especially with the latest releases. Companies like Facebook are built on PHP (yes, they extended with Hack, but most of the benefits are available in PHP 8 now without the downsides).Coming from a C background, I found PHP easy to step into as many of of the underlying libraries and common functions are wrapped and available in PHP (with similar names).
One thing I've noticed is people who code in PHP for work or projects don't bother to come on here and try and defend the language. It's underrepresented, but maybe the groupthink ship against PHP has sailed here a long time ago, they don't bother. Or perhaps, more likely, they are too busy creating.
While I primarily program in python these days I have two major open source PHP projects (millions of downloads each). I was also part of the standards group that tried to modernize some aspects of PHP (to various degrees of success).In general I would never bring them up on this site. It's just not worth my time or effort. I've even gone so far as to ask people who have posted my blog posts here to take them down. Hacker News has one of the worst groupthink cases in tech, where if you speak against various core beliefs you get absolutely hammered with trolls both on the site and off of it. Having a reasonable discussion about the pros and cons of PHP is just not something this site is capable of supporting.
> Hacker News has one of the worst groupthink cases in tech, where if you speak against various core beliefs you get absolutely hammered with trolls both on the site and off of it.Aside from PHP, can you think of any other topics that can be problematic in this regard? So far i haven't personally run into any that would get me disproportionate amounts of negative votes, however i find myself curious about it. The only i could personally think of would be Perl and the discussions surrounding its history.Perhaps i've just been lucky so far, or maybe you can tackle some of those topics by phrasing your points as questions or just pointing out that those are subjective views, instead of absolute truths, thus stimulating a discussion, rather a clash of opinions.Personally, i think that sites like Habr or some Reddit communities could be more biased as far as discussions about topics go, due to the specialization present (e.g. a blockchain centric subreddit might not be receptive of criticism, even if constructive), however i've also heard similar things about Team Blind, whereas my HN experience has generally been fairly pleasant.
Just mention the chat program Telegram. You will have 200+ people immediately dissect everything that its creator ever said and did. Which I don't mind at all but you can see extremely anti-Russian sentiments straight from the middle of the Cold War. Very puzzling. There's not even good factual discussion most of the time.For bonus points, do state one provable and visible fact: that Signal (the program that's always recommended as a replacement for Telegram in HN) is not completely open source either, and then suddenly even more people appear to explain to you how that's somehow okay for Signal but not for Telegram. Even more puzzling.Another one: mention Rust, no matter how. Somehow you're suddenly a zealot, you work with a "flavor of the week" language apparently (nevermind that it's at least 10 years old), and you also feel the need to tell everyone about it everywhere you go, and let's also not forget that C++ can do everything that Rust can and you're a bad programmer for not realizing it. I learn so many new things about myself  every time I mention Rust around here! (warning: this was sarcasm)HN isn't as neutral and factual as you might be imagining it. I've seen ugly and shameless appeals to authority by very prominent and high-profile members of this community.
Answering this question is tricky because any answer is essentially inviting trolling. This community has both extremely technical people as well as a variety of people who basically live on 4chan (and there is quite an overlap between the two) so things can get dicey in that regard.Just some hivemind topics-* Free Speech. This community tends to be extremist about this, which in turn means anything that can be construed as limiting free speech will, somewhat ironically, not result in a productive conversation.* Corporate Libertarianism. This community also tends to be extremely pro-corporate, and there's a lot of "if you don't like it work somewhere else". That being said I've seen some push back against this lately.* Meritocracy. If you challenge the idea that silicon valley is a meritocracy people seem to get really upset.I would definitely say that there are reddit communities that are worse, and some that are better.
Thank you for your input! While the SV bit probably isn't relevant to any of the topics that i might touch upon, I'll keep that in mind.That said, in regards to freedom of speech, i feel like some of Bryan Lunduke's (just as an example) arguments wouldn't necessarily invite hostility, despite their delicateness - such as the idea of de-anonymizing the internet and what implications that could have and what it'd look like.Of course, it might invite prolonged discussions with no clear conclusion, because there are just societally complex topics with layered tradeoffs where no one can definitively cover all of them, but in my eyes that's not necessarily bad, as long as everyone remains civil.I know I've certainly been wrong about a lot of things, though thankfully people so far have corrected me and let me better myself.
Cryptocurrency.
I work mostly in PHP for my day job, and honestly even I can understand people being dismissive of PHP. It undeniably has many advantages you and others mentioned, but equally undeniably it was from the very beginning a huge kludge (famously, its creator only intended today's "PHP language" as a template language, and when its scope gradually grew to a "full-fledged" language, nobody really cared about consistency). And this is a legacy which they have since tried their best to shake off, but they will of course never be able to get rid of it completely.Also, same as many other open source languages, there seems to be a tendency to pick up every language extension someone proposes hoping that it might win over some developers, but I'm not really convinced. Does PHP really need a "match" control structure (https://www.php.net/manual/en/control-structures.match.php) when it already has good ol' "switch" and "if/else"? Of course, I also like the more flexible (Pascal/)Go-style switch statement better than the "classic" C-style one, but maybe they should have given it some more thought years ago instead of slavishly following C/C++ then and inconveniencing thousands of developers by introducing a new keyword now?
Same background and that's the same I used to think years ago before learning Python, after Python and after reading awful spaghetti code in PHP 15 years ago I ended up hating it, I haven't touched nor read PHP code since then, maybe now it's better? but really with all the PLs we have available today, at least to me there's no incentive to touch nor read it again.
Hey if you don't like PHP please don't use it. I 'd hate to bring the culture of tiny packages, fake compilers, transpilers and weekly trends to PHP. Personally I use php because it works well and fast and still supports my 10 year old websites, not because it's cool.
Oh well we are about to break most of said 10 year old web sites.Particularly, PHP 8.1 has some changes that low key force people to update, such as the use of return types when extending a built-in classes (https://php.watch/versions/8.1/internal-method-return-types).
Yeah, the area between "backwards compatibility at all costs" and "progress" is full of potholes. I think PHP was to mach on the "backwards compat." site of that gradient, I think that some bc breaks are onavoidable when improving the language itself and its standard library. 
Sure, it would be nice to have something like rusts "editions" (and I am sure other languages share that concept to some degree) where we could have the runtime support all code that was valid before, but that comes with its own complexity.As someone who still owns their rent coding PHP, I really enjoy the development of the language from php 7 onwards. It certainly feels better in any way compared to the 5.x or even 4.x days.As long as we do not get another python 2 vs 3 disaster, I am happy.
I like PHP and still use it today. But never in my life heard PHP is cool. Am I missing something?
Well, early 2000s it was definitely cool.Using ASP and want to calculate an MD5? Oh, you need to pay an add-on for that. Want to send an email? Ditto.Then there was PHP, with all included (and cheaper hosting, because Linux). I started working on a web shop and after a month ASP was legacy and PHP the new cool thing, together with MySQL instead of using... Access as "database" in ASP.
I was new to the world of software development in 2000 (in high school) but immediately loved PHP / MySQL. Made it easier for me to stand up websites for my two bands and integrate more dynamic and database-oriented features into those sites. And hand-wrote JS for things that at the time seemed cool (silly in retrospect hover effects).It was the SQL part of the book that helped me build the SQL skillset that is an integral part of my day job.Used a book similar to this one:https://www.thriftbooks.com/w/professional-php4-programming_...
"Access as database in ASP"haha. My first ever project as an intern in 2004 was exactly this.
They're making a rhetoric against JS style of development... Though I question what they mean by fake compilers...
A compiler translates code from a source language into a target language, normally targeting either physical hardware or some virtual machine. That is not what happens when "compiling" - or more accurately, "transpiling" [1] - JS-related software where what often feels like the JS-related dialect of the day (coffee-, mocha-, type-, tea-, frappucino-, latte-, pilzener-script) is converted into the resident JS dialect, discombobulated through some language feature thingamajig, transmogrified by some other package-combining gizmo (not the same gizmo as you used last week, that is nowancient technology, the new one is sooo much slower^Wbetter and has a snazzy content-less website to prove it), mixed and matched with a bunch of related packages many of which are marked with dire warning about bugs and staleness by the helpful package manager thing (which you had to update before even trying to proceed since the current version was no longer supported even though you're running version 12 and the box stated you needed at least version 9), uglified (as if it wasn't ugly enough already) and zipped up.Doesn't all that make you long for the days of./configure --prefix=/somewhere/sane && sudo install -d -o yourusername /somewhere/sane && make install? Just addempscriptento the tool chain and you can do web things with it, sort of...[1]https://en.wikipedia.org/wiki/Source-to-source_compiler
transpilers*
If people call something "cool" - that's actually a red flag for me.
That sounds fairly childish. Aside from the very obvious fact that you'll miss out on a lot of cool stuff, if you don't agree with the value judgements of your peers, the problem most likely resides with your choice of peers.
Red flag just means that you take a close and critical look - not that you automatically dismiss. And those "peers" are the people on the internet - f.x. blog authors.
How's that policy working out for you?If I did that I'd have missed a hell of a lot of cool stuff in life haha
good, I'd say. I'm not waiting half an hour in a queue in front of a hipster ice cream parlor. when I go into nature I have a good chance of actually finding some peace b/c I do not go where Instagrammers take their selfies. I'm not torturing my soul on TikTok. I use choose technologies conservatively instead of by hype cycle. List goes on.
Php change from 4.x to 5.x broke my web sites and I still don't trust php after that. I guess they might do it again from 7.x to 8.x, we'll see.If having the same code working for a long time is the most important for you then you should probably use java or .net. Maybe c++ also but that is not as popular for building web apps.
I made my homepage in PHP, nothing important, but I spent some time doing it and I liked the result.Then I didn't have enough time to maintain it, and I stopped paying attention to it for a while.Later I checked my homepage again, the webhosting company updated the PHP version, nothing works anymore. It is not simple to fix, so I gave up.I am not going to spend the same amount of effort on making my homepage in PHP again. Trust is easier lost than gained.I would still be willing to code something in PHP for someone else, because hey, if it stops working in a year or two, it's their problem, not mine. But I would warn them that something like this is possible, and in my opinion likely to happen.
PHP are deprecating language "features" from 7.x to 7.y.It's very hard for me to treat a language seriously when I could write code that simply won't be valid PHP in 2 years time, or worse, behaving differently.Given the severity of some past PHP vulnerabilities, being on an old version can certainly be a problem.> I guess they might do it again from 7.x to 8.x, we'll see.PHP 8 has some _massive_ breaking changes
I found the transition from 4 to 7 oddly easy, but that might just be the conventions i was using. I don't know about 8, don't plan to use it until i have to
Most arguments against PHP miss the point. You know why you should use PHP? Because it'sfunand you can get something running much quicker than figuring out the Elixir, Ruby, Rust, whatever ecosystem and paradigm. Maybe PHP is not so good at WebSockets or async worker threads, but most projects don't need that. There's no shame in doing long polling, users can't tell the difference anyway!PHP shines when you're trying to get a server-rendered web app off the ground. It's the VB6 of the web. Nothing else matches its development velocity, from keyboard to working code.
I used to believe this, but...But that's just not true.All the things you mentioned are a yum/apt/nix/pacman/ install away on Linux, and probably as simple to install on macOS. I'm sure Windows has installers for these, too.So, it's no harder to develop in them than it is in PHP.You could argue it's cheaper because you don't have to pay for a shared hosting provider to host your files. However that's a bit moot since even back in the day there were LAMP stack Vagrantfiles that would automate this local setup.Also, when speaking about dev velocity or time-to-start: you forgot JavaScript, which probably has much greater development velocity than anything else.Furthermore, PHP israrelyjust PHP in production. PHP also comes with various runtime modes (CGI, FPM, etc), .htaccess rules (or nginx equivalents), a bunch of runtime language and feature toggles that are partially controlled by the system (ie your hosting provider), and some can be controlled by the application.The ephemeral process nature of the language makes some tasks very difficult to do in a performant way (but there's caching, so that's at least mitigated).I've seen so many developers (worked for a hosting company) come complain to us about slow servers when in fact they'd just be doing silly stuff. And it was hard to blame them, because the language encourages that model, and the "performant" was was usually orders of magnitude more difficult to implement (ie indexing, image resizing, or most types of batch processing).I'll not go into the horrors of how easy it is to mishandle file uploads in PHP (there's plenty of those around) and how many times people got easily hacked this way.
I went on a rant, but didn't mean to. I don't have anything against PHP, it's got a valuable and relevant place on the the web. It's important to many people, and like you said you find it fun, which I think is important for our productivity as devs.However, I think this recurring misconceptions how easy PHP is to develop in needs to stop. PHP comes with a lot of complexities. Worst kind of complexity to learn: hidden complexity.
I can't think of a single in-use tech/language thatdoes nothave a lot of complexities.  And by definition, these will almost certainly be 'hidden complexities' for someone coming in to that ecosystem.What's been useful about PHP (and many other stacks) is that the good ideas from other worlds usually get assimilated in over time.  PHP is not always at the bleeding edge with respect to language development, but that's just fine.  The PHP ecosystems often adopt/adapt useful ideas/techniques from other ecosystems relatively rapidly, and that's just fine too.
> I can't think of a single in-use tech/language that does not have a lot of complexities. And by definition, these will almost certainly be 'hidden complexities' for someone coming in to that ecosystem.You're 100% right.My original comment focuses on PHP because I was specifically addressing the "PHP is the easiest to develop in" idea.I realise that it might seem a bit too critical maybe because PHP was the only topic in it, but I didn't mean it to come off like that. Hopefully I redeemed PHP a little bit in the follow-up comment! :DAt the end of the day: every ecosystem/language has its own "that shadowy place over there" :P
I think fun is important but I see nodejs and rails as equal to php in the easy and fun part. Maybe python too, have not used it enough.If we are talking about building large web applications then performance, maintainability and other things may start to be more important than fun and then c#, java, go and others can be really good solutions.
One person’s complexity is another person’s valuable job skill. PHP and Apache aren’t hard to setup and configure if you know how it works.
I completely agree that being able to navigate an ecosystem's complexity is a skill.I didn't mean to imply that other languages don't have complexities. All ecosystems come with their own boons and complexity issues (hidden or upfront). The thing I wanted to address is the general idea of  "PHP is the simplest to develop in, it's just uploading a file" (paraphrasing) shouldn't be taken at face value, and that's why I pointed out some of the complexities when working with PHP that PHP developers tend to forget (or some ignore).But, because PHP is so easy to get started with, a lot of the complexity initially gets hidden away, and sometimes people learn about it the hard way.JavaScript used to be much the same, but it has gotten better in the recent years. Maybe PHP has gotten better in this aspect too, but I could be ignorant because I've not been keeping up with PHP as much
With a hosting provider that already has PHP installed, you can simply upload a file to a folder and serve it over the web with no special expertise.PHP makes it easy for beginners and amateur programmers to getsomethingworking without knowing much.Because of the low-barrier to entry and simple hosting setup people have written a lot of crap PHP code over the years. I know, I see it and work with it.Amateurs and well-meaning power-users can get some web pages up and running easier with PHP than with almost anything else, so while inexperienced programmers can write bad code in any language a large number of them choose PHP.None of those facts mean PHP is not suitable for "real" development and "real" programmers. It is not obsolete or dying. A professional programmer who knows how to build production-quality web sites can get great results from PHP. That requires putting in the same time and effort needed to learn any other language and set of tools.
> The ephemeral process nature of the language makes some tasks very difficult to do in a performant way (but there's caching, so that's at least mitigated).I'd rather say that this is actually one of the biggest selling points for PHP. Opcache and JIT works great, and reduces the overhead, but ironically, PHP is great for serverless applications.
Your comment on file uploads in PHP reminded me of the remote code execution via automatic file metadata parsing vulnerability built into PHP that happened a couple years ago.
This is the classic "everyone who does not know how to X is not a real Y". Every single software dev can make such a list. Very few reflect on the fact that no two of those lists look the same.You can't know everything. Programming is about abstraction; so abstracting away devops is a feature (in some contexts), lack of that is a downside (in some contexts).
No one can know everything. We can all learn things we need to know. Or we can post about how something we don’t know is gross, complicated, broken.
That sounds about as nonsensical as saying "If you don‘t draw your own icons I don't think you can call yourself a professional developer".
Very few developers actually do both of those things. If you said "If you couldn‘t learn how to run your own servers…" I could possibly see that.
The distinction I was making was between companies, teams, developers who use cheap hosting services and then bash PHP when the problem is they don’t control the hosting environment. “I can’t change my PHP or Apache config because I pay $5/mo to HostGator” is not a good reason to complain about PHP.
> If you don’t manage your own servers I don’t think you can call yourself a professional developer. “My hosting provider doesn’t let me do X” is a lame excuse with cloud servers in the $10/mo range.Hosting (as a service, and shared hosting) is a very complicated business if you want to do it right.Also, when picking hosting providers, there aremanythings that factor into this. Social, political, and economic status are one thing (of the dev and the client). Another thing that comes to mind is the client's (or sometimes even dev's) location/jurisdiction (or the website's audience).The availability/locality plays a giant role in selection in non-western countries. For example, some European countries/ISPS have super-fast internet within them or up to the closest IX (internet exchange), but horrendous speeds towards anything beyond the IX; sometimes these are intentional (alas, curse politics) sometimes they're not.We had many clients that would migrate to us because they had these issues with previous providers because we were different from other hosting providers.Disclaimer: I used to work for a hosting company
Yes, hosting can get complicated. A production web site should run in a production-quality environment, not on some $5/mo shared setup that doesn’t let you control the PHP/Apache/nginx environment. If that’s your setup you will run into issues eventually, just like you would if you couldn’t change the settings on your work computer.
Surely you also have to figure out the PHP ecosystem and paradigm if you don't have experience in it? In any case, I fail to see how PHP is more fun than, say, Python. I have done a few projects in PHP and I would take Python in a heartbeat. To me this seems like a clear case of Stockholm syndrome, but what do I know... Maybe I'm missing something.
There are other solutions to long polling now. You can use Pusher, ReactPHP or Amp (https://amphp.org/) to use websockets with php instead.
Until someone implements long polling in wordpress and has to load the whole framework for every poll. This can never be the right approach
I've noticed some good bits in PHP, there's indeed a low level thing to it; it's not trying to find the new paradigm. Their cli tools are often nice and to the point (rare quality). But the language per se doesn't seem to bring a lot compared to python in terms of expressiveness, and the regular bugs are still worrisome to me.
I would guess nodejs has the same development velocity. And you can just copy js files into a server that has node to build a web application.
You mention it in passing, how much ruby on rails experience have you ?
That made me laugh, thanks.
PHP is alotbetter. But it still has a lot of the same old issues when you look beneath the service. Good luck remembering what all the str* functions they invented do and what order their arguments are in. Same for the array functions (don't get me started on implode's three signatures - but that's mostly fixed in 8!).And may His Noodly Appendages help you if you come across a function being used which has no documentation and a single decade-old comment from someone asking how it works...And so, to plaster over it's many flaws, people start layering framework upon framework upon framework, each of which slows down the language significantly from all those shiny PHP performance benchmarks you see. And then they wonder why their shiny "what's an array? we need to transit 20 different chained method calls for that" is so slow...And half of them are documented even more poorly than PHP itself. At least their code is in the same language you're already writing, though.
The argument order flaw is never going away. BC. It's a super minor thing.The non-documented functions are often rare and very minor and obivous functions.This layering framework on top of frameworks sounds made up. Mostly people either use Symfony or Laravel. There aren't layers of frameworks. Your example is nonsensical. Frameworks are slower than simple code, this is true for every language.And Symfony and Laravel are both well documented.This comment overall seems to be written by someone who has come in with very little knowledge on PHP worked on a project for 3-4 months. When you work those style projects you're often working on poorly constructed projects. I'm pretty sure I can jump in on a project written in any language that has been poorly constructed and I will end up going wtf.
I am well aware that it is never going away. I wouldn't call it minor, it's an extremely common source of bugs.The non-documented functions are indeed often rare. That's all that can be said about them. They're about as obvious, on average, as the rest of PHP's functions are obvious.Sure, until you want to have a UI framework, and an API framework, and ...LOL @ Laravel being well documented. There's a tutorial and there's autogen API docs. And that's it.This comment overall seems to be written by someone who has worked with PHP for a few years and thinks he knows everything there is to know about it.I've been using PHP since PHP3 and professionally since PHP4, but thanks.
I’m going to try to offer a positive take from a non-PHP-fan perspective: yes it’s obvious both from vaguely checking in on the language’s progress and from the article’s presentation that PHP has made considerable strides. It’s impressive how much, over that time, it’s become less insular and much more readily adopted similar improvements to similar languages. The object over time, for example, more and more closely resembles TypeScript, and that’s a good thing.I haven’t worked in PHP for I don’t know how many years, and I probably still have an unfair negative reaction to it. It has a strange cultural idiosyncrasy I find more limiting than anything about the language itself. But I’m happy to see it evolve and I’m happy to see it evolve alongside other technologies I work with more readily.
The closest this post gets to supporting its thesis is this section:>You might have heard people say that PHP was "doing serverless before serverless was a thing", and this is kind of true.I believe that PHP is...not bad I guess? I'm sure it can make good things. But after reading this I have no idea why I would pick up PHP over any of the other capable tools out there.
Why would you pick any other language instead of PHP for web dev?
Because Elixir has transparent parallelism and trivially scales to 2000 reqs/second on a $5 VPS even though it's a dynamic language, oh and because it has LiveView which eliminates the need for most of the JS in a project (if latency isn't critical), so now a backender can take care of 100% of a web project.I worked with PHP 9-10 years ago. Still not impressed to this day. Why should I use it? Terrible type coercion that can and will catch you with your pants down is my chief complaint -- that alone is enough for me to never touch it again. I want predictable tools, not something I actively have to fight against so I can get my job done. How is this even considered productive?So tell me again, why should I use PHP? How will it truly help me? What does it do better than everyone else?
If you're happy with Elixir, just use Elixir.But companies might want to use PHP, because it has a rich ecosystem, which handles corner cases.Chances are, if you want to send out bulk email, or connect to a payment provider, there's going to be a library in PHP that allows you to do that, often with long term support from an agency.A corner-case I recently had was needing to decode an email. There's a function for that: quoted_printable_decode. This is a common situation for PHP. If you have some sort of issue around the web, there's likely to be a PHP solution.And if you're a small business that needs a bit of bespoke software written, then you can easily hire someone, and know a decade later, you'll be able to hire someone if the requirements change.Much of this can also be said of the Java ecosystem.Just recently, I was using a small business that managed their bespoke business process built on a PHP CMS. They don't need 2000 reqs/second.
>If you're happy with Elixir, just use Elixir.It's not that I never tried anything else. I got through 8 languages and made what I feel is an informed choice.>Much of this can also be said of the Java ecosystem.And yet, so many programmers and companies moved on from both Java and PHP to other tech and are managing very well. The company I work for has mere 6 backenders and we serve millions of visitors regularly without ever hitting >70% CPU on 3-4 servers.Citing the entrenched state of affairs is not an argument either. It's an appeal to statistics (a good chunk of which are flawed as well).I'm not going to try and convince anyone to stop using PHP or Java. Truth is, most programmers want stable predictable careers and there's nothing inherently wrong with that. I simply am not in that group.
You asked> So tell me again, why should I use PHP? How will it truly help me? What does it do better than everyone else?I gave some reasons, citing problem domains for which there are stable, supported solutions in PHP. e.g. payment gateways, email handling, and citing the availability of programmers who can support medium bespoke or tailored systems. This isn't an "appeal to statistics" it's a strength about the ecosystem.Similar to Python having many solutions and libraries built around data science.> I'm not going to try and convince anyone to stop using PHP or Java.I thought you were asking a question.
None of what you enumerate is game-breaking, at least in a chunk of the programming area. You seem to be referring to an area where people pay pennies + have almost zero programming experience so they want to launch a project with clicks.Sure. In that area PHP still more or less dominates. But I thought we were discussing the actual programming?>I thought you were asking a question.That's exactly why I said what you quoted me on: to reassert that I am looking for a good answer on "what does PHP do better" and I am not in fact seeking to change hearts per se.
>  You seem to be referring to an area where people pay pennies + have almost zero programming experience so they want to launch a project with clicks.Over my career, I've worked with companies using PHP in sales. One of those had over a million customer subscriptions, the other was a multi-national looking at PHP for a greenfield e-commerce project. I noticed working in Europe some high-growth agencies that use PHP.> So tell me again, why should I use PHP? How will it truly help me? What does it do better than everyone else?> But I thought we were discussing the actual programming?Your original question just said "use PHP". PHP is a general purpose web scripting language. It's similar to Python or Ruby. It is generally more performant and later versions have a gradual type system. It's traditionally run as a shared-nothing single-threaded script, which makes it easy to reason about, and in real life has proved to be a stable way to run things in production, as it avoid bugs that can arise around stale state, multi-threading and it keeps running if other libraries have bugs that leak memory.Later versions have introduced a JIT and support for concurrency concepts such as fibres, as in the upcoming PHP 8.1https://php.watch/versions/8.1/fibers.Arguably, the thing that would make you use it over Python, or Ruby, is the ecosystem, especially around content management and e-commerce, as the language itself is roughly comparable to others. Also I think there are more agencies that support PHP, rather than Python or Ruby.
>It's traditionally run as a shared-nothing single-threaded script, which makes it easy to reason about, and in real life has proved to be a stable way to run things in production.I think we have a vastly differing definition of "in production". I'll agree PHP was good enough for plenty of things, and likely still is. But good enough in general to run things in production as it's understood today? You'll find that many people will disagree with you here, not just me.>Later versions have introduced a JIT and support for concurrency concepts such as fibres, as in the upcoming PHP 8.1https://php.watch/versions/8.1/fibers.That's what I mean, not only for PHP but for like 99% of all programming languages: they play catch-up, waaaaaaaaay too slowly and gradually, with things that should be baseline by now. Happily Erlang/Elixir are having lightweight and transparent parallelism and concurrency for a long time now. Languages like Go and Rust also progressed very well in this area so I am looking to work more with them in the future as well.---I think you and I are not aligned on what is "successful" or "good enough". You seem to insist that statistical success speaks something of the merits of a technology, and this is where I and many others disagree: people just adapt to what's given to them. That doesn't say almost anything about if the thing is good or not. People simply get what they can. Back then PHP was available so they took that. The rest is post-hoc rationalization. Stretching the simple and isolated historical fact "people used PHP because there was nothing else viable at the time" to mean that "PHP is good and successful" is where I'll disagree with you.But yep, we severely digressed from the original discussion. I am OK with that though.
> I think we have a vastly differing definition of "in production".Running software that customers use, directly or indirectly.I've supported servers running PHP and Java software in production. The shared-nothing per-request nature of PHP meant I didn't have to deal with a bug in a misbehaving library causing memory leaks and taking down the application server.> That's what I mean, not only for PHP but for like 99% of all programming languages: they play catch-up, waaaaaaaaay too slowly and gradually, with things that should be baseline by now.PHP's problem domain has been web-based e-commerce and content management systems. In this area, PHP powers most of the web. You'd want to use PHP in this field, over other languages. Every improvement around PHP has been to advance this goal, such as the recent addition of gradual typing. There's no question of "catching up" in this area. That it is broadening out into different areas, great.> You seem to insist that statistical success speaks something of the merits of a technology.If the technology doesn't have a marketing department, or large companies forcing people to use it, then arguably, this does, as otherwise people would just use something else.There have also been many other qualitative improvements to PHP over the years. I also mentioned its shared-nothing architecture, which is a qualitative, not statistical aspect behind PHP's success, as it has proven to provide stability in production.  People use PHP because in certain problem domains, it is qualitatively, and statistically (assuming you mean, it benefits historically from a wide number of successful, maintained libraries) the best tool for the job.
I haven't worked in PHP for years but 2000request/second doesn't sound unreasonable for PHP either?And that with a language that everyone can use.
2k requests might range from nothing to to hard, depending on what the page does.A simple PHP page 10 years ago on a low-end server using mod_php could do 100k+ rps. Add more logic to it and performance will decrease.
I feel you could be exaggeratingjust a little. :D
All languages can be used by everyone.
That is probably false for all practical values of "used".
Elaborate? Every language can be used, I stand by that statement. Sure they have very differing levels of easiness to start with but all are usable regardless.
Here's what you originally wrote:> All languages can be used by everyone.Now consider brainf#ck.You see? For all practical values of used not every language can be used by everyone.This is of course an extreme outlier (but absolutely not the worst I think) but there is a spectrum, or rather field of possibilities.PHP is trivially simple to get started with. A teenager can manage to do it alone.
Is there now a reliable non-hacky way to do threads or async, to run queries to multiple dbs or backend systems simultaneously in PHP?
Roadrunner or Swoole. Integrated into Laravel as Laravel Octane. Depends what is your definition of hacky.
Maybe Amp -https://amphp.org/
Other than the semi-hacky pclose(popen(call to db))? Not really.
I mean, because I know them already and I would have to learn PHP? But I'll give examples of what I wanted to see for languages I've done amounts of work in:*Python* A disgusting level of flexibility (probably too much). You never really get trapped into anything, you can even (but should not) overwrite functions during runtime. You can make and break all the rules. Supports a number of modalities (often badly). Really killer console-based debugging tools (I love pudb for instance).*Elixir* Insanely durable data/process model that makes it incredibly difficult to damage a working path through a non-working one. Never have your entire web app crash again. Pattern-matching and message-passing based language makes expansion easy and low risk. Macros are best used carefully but when appropriate are a breath of fresh air.All the languages are turning complete. By definition you can solve any problem with any of them.
Have you heard of Nest.js? It's the laravel of JS, and I can assure you it is rock solid.
Folks bashing PHP like it's crap but praising any crappy thing if it's built with an esoteric lisp-based language. I mean, if you're starting out, chances are you're better off with js/py or even go but in the end you're paid for the types of problems you solve, not by the language you use... It just turns out that some problems are easier in this or that language, or even people who are good at solving this or that problem just happen to use an specific language (like the bioinformatics people using R when they could have used py).
R is another language that it is bashed constantly, but it is generally much productive in its field (EDA and stats on structured data) than the alternatives like Python.
This.  While I'm not sure I'd build a website or something with R, for pretty much anything data related R is a first choice.  Even for big data on clusters or something.  It's absolutely amazing at what it does.  Super easy Fortran and C++ interop.  Bonus that it's well enough known in academia and fields like statistics or economics.
I'm not sure I'd build a website or something with RHave you played with Shiny (shiny.rstudio.com). If you're building a website for interactive data exploration and analysis, it is very hard to beat.
I have.  Guess I haven't tried to build something bigger with it.  Seemed to me to be mostly something to share visualisations, not for building say, a whole CRUD site Rails or Django-style.
You're right - in my experience it's great for, say, creating an online calculator/simulator for something specific but it too fast becomes difficult when you started trying to add features like SSO, persistence etc.
Absolutely agreed! You can feel that R was made for its specific use case. Exploration, visualization, experimentation and modeling just __click__ for me in R in a way Python can never inspire.In the Python ML world only the matrix libraries - numpy and similar APIs like torch.tensor and jax feel natural and click in my brain. The rest - data frame, visualization, scientific libraries; I'm not very sure how to explain it, but it always feels like some context switch is needed between using Python the language, and calling out to these libraries.
I like PHP, it pays the bills.I also like other languages, some because they are a pleasure to use, or give me an opportunity to learn something new... but mostly because they pay the bills.I don't think there is anything wrong with that, these are just the tools of the software engineer, nothing more. We use the tools that are appropriate for the job, no reason to make it into something deeper than that.
| php is fast.https://benchmarksgame-team.pages.debian.net/benchmarksgame/...it's faster than python, but my grandma is too and she died in 1993. However, function calls are extremely slow. If you would bench something like a naieve fibonacci implementation (or ackermann's function) you would be surprised.
(naieve fibonacci) like this:<?php
    
    function fib($n) 
    {
        if($n === 0) { return 1;}
        if($n === 1) { return 1;}
        $r = fib($n-1) + fib($n-2);
        return $r;
    }
    

    $n= (int) $argv[1];
    $r = fib($n);
    printf("%d %d\n",$n,$r);just did some measurements on my laptop:| Language             |  n | time(s) |
    |----------------------+----+---------|
    | php (7.4.25)         | 42 |   422.0 |
    | python3              | 42 |    90.0 |
    | haskell (ghc -O3)    | 42 |    13.8 |
    | f#                   | 42 |     5.6 |
    | ts                   | 42 |     2.8 |
    | ocaml (ocamlopt -O3) | 42 |    0.98 |
    | C (gcc -O3)          | 42 |    0.66 |(edit: added php version in table. )
This is what I get locally:time php fib.php 42
    23s

    time python3 fib.py 42
    1m1sI suspect that you're doing something very wrong, like running PHP with an active debugger or similar.If we're talking in comparison to slow interpreted languages like Python, then function calls in PHP are not particularly expensive. Debuggers can make them quite expensive though.Edit: Just to note, PHP's execution time drops to 4s with enabled JIT.
Likely. I tried the benchmark and saw runtimes of over 5 minutes before realizing that XDebug was active and in develop mode. Adding `-d xdebug.mode=off` dropped it to 26s. That was with `opcache.jit` in the (default?) `tracing` mode. Turning it off didn't change the runtime, which is a bit puzzling. This is all with PHP8 on macOS, although I tried 8.1RC in docker and saw similar results.Something doesn't quite add up across everyone's results here, but the extremely slow result at the top of the thread is almost certainly a debugger slowing things down.Edit: I was missing `opcache.jit_buffer_size`, and saw the runtime drop to under ten seconds with that correctly configured.
I also get around 23s, PHP 7.4.5
How is php 422 seconds? Are you basing that off the return value of the function? FWIW, I get 57 seconds when I run your function with PHP 7.4 using microtime().
that was PHP 7.4.25Yes this is a microbenchmark. Yes, I know binet's formula...
Yes it's weird function calls are so slow in php.with php 8.0 (jit enabled) you get something like 120s (for n= 42)
naieve and micro benchmarks is not meaningful in 95% of cases. Did you run on the CLI with -dopcache.enable_cli=1 for example?
Opcache avoids the compilation step. It's not relevant in this case (compilation ~0.01s out of ~400s).Microbenchmarks are meaningful as long as one doesn't read too much from them. This benchmark shows that PHP seems to have a problem with recurrent calls.
Is JIT enabled and configured for PHP?
Is that still true when using PHP 8.0 with JIT enabled?https://twitter.com/ArkadiuszKondas/status/11196548025800212...
Was curious. The same implementation as /u/toolslive:PHP 8.0.12:
  
  $ time php fib.php 42
  42 433494437
  
  real 0m29.274s
  user 0m29.003s
  sys 0m0.105s

  $ time php -dopcache.enable_cli=1 fib.php 42
  42 433494437

  real 0m26.341s
  user 0m26.179s
  sys 0m0.058s
  ----------------------------------------
  PHP 7.3.5:
  $ time php fib.php 42
  42 433494437

  real 10m23.573s
  user 10m16.592s
  sys 0m1.828s
  ----------------------------------------
  Settings for PHP 8:
  PHP Version => 8.0.12
  auto_globals_jit => On => On
  pcre.jit => 1 => 1
  opcache.jit => tracing => tracing
  opcache.jit_bisect_limit => 0 => 0
  opcache.jit_blacklist_root_trace => 16 => 16
  opcache.jit_blacklist_side_trace => 8 => 8
  opcache.jit_buffer_size => 0 => 0
  opcache.jit_debug => 0 => 0
  opcache.jit_hot_func => 127 => 127
  opcache.jit_hot_loop => 64 => 64
  opcache.jit_hot_return => 8 => 8
  opcache.jit_hot_side_exit => 8 => 8
  opcache.jit_max_exit_counters => 8192 => 8192
  opcache.jit_max_loop_unrolls => 8 => 8
  opcache.jit_max_polymorphic_calls => 2 => 2
  opcache.jit_max_recursive_calls => 2 => 2
  opcache.jit_max_recursive_returns => 2 => 2
  opcache.jit_max_root_traces => 1024 => 1024
  opcache.jit_max_side_traces => 128 => 128
  opcache.jit_prof_threshold => 0.005 => 0.005
I have stopped trusting the aforementioned link because they play dirty games with benchmarks, most of the times.Let me give you an example;https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/regexredux-python3-2.htmlandhttps://benchmarksgame-team.pages.debian.net/benchmarksgame/program/regexredux-perl-4.htmlThe Python code uses ctypes, thus the unfair marginal difference.I have seen the same unjust comparison with the majority of the examples and decided to stop relying on this page for validating programming language performance.
> … because they play dirty games with benchmarks, most of the timesNo they do not.Let me give you an example:https://benchmarksgame-team.pages.debian.net/benchmarksgame/...*** You ignored the Python code that does not use ctypes.> I have seen the same unjust comparison with the majority of the examples…No you have not.There are 10 different tasks.pidigits accepts the use of third-party libraries (GMP)regex-redux accepts the use of third-party libraries (PCRE)That's 2 out of 10.
I don't really understand the reasons for using PHP outside of that people are already familiar with it and like working with it or want to find jobs in that area.If someone is new to software development and in an area of the world where it's not mostly PHP shops, so bigger cities, I don't really understand the benefit.PHP is often used to do certain things or it may be faster for you to whip something up in Laravel but if you had someone who was a complete blank slate and could chose any language and any framework in a town that doesn't have PHP jobs...why? What's the reason then?I really think these articles come off really strange like they're trying to convince me as a "fact" but are really just nostalgia, like someone who goes off about how "cars were built so much better back in the day, there's still uses for older cars!" Maybe there is a grain of truth there and some real reasons behind it (repairability) but for 95% of use cases it's just that there's no contest, for a new driver, in an average situation there's no benefit towards going to an older car, and the guy going on about "older cars are the best", while they may have some weird reason that does actually apply to them (and as far as this analogy goes, I think Fortran is a better example than PHP in this case than PHP as for some maths applications it apparently still has an edge but that could have changed) honestly it's just nostalgia/trying to indoctrinate people...
A very pragmatic reason exists: deployment is dead simple for users with very little technical skill. Deploying PHP software is as easy as subscribing to a shared web host (expensive or not, but most will make your life easy), connecting using FTP/SFTP, and extracting a ZIP file into the main directory. Some hosts even skip the last couple of steps and let you apply a template with a well-known PHP CMS to get you started. Hey presto, you have a functioning web shop, business website, charity home page, or whatever other thing you want. There's a (PHP) app for that.In comparison, other programming languages are hard to figure out. Python, Ruby, Java etc all need some kind of a package manager to install dependencies (PHP apps are self-contained) and need to have the correct runtime version installed (PHP just needs to be in the general neighborhood of what's required, since most broadly used packages seem to be written in a backwards compatible fashion). This is scary and unfamiliar, and highly technical. If you're deploying on a VPS (because rarely anyone has managed Python/Ruby/Java hosting services), you've now also become the sysadmin with full responsibility for the box, including patching and downtime. Compared with shared PHP hosting, it's bonkers.
I'm a PHP fan, but I think the following needs clarification>  package manager to install dependencies (PHP apps are self-contained)PHP has Composer, which is one of the best things to happen to the ecosystem. Chances are, the piece of software you install will manage its dependencies in this way, and I'd be reluctant to install it if it didn't, as you wouldn't be able to update the software easily.
It does, but it's mostly transparent to the user. I've never had to think about it when I was installing WordPress.
When you start on a minimal server installation setting up LAMP to the point that wordpress doesn't complain is just as much work as setting up RVM/Node and Passenger to run whatever language you want.
All shared hosts already come with LAMP pre-configured. You just plug already supplied credentials into the WordPress setup page and that's it.
So does ex. heroku for all the other languages, and that actually scales. As well as most shared hosters offering node and rails.Don't get me wrong, my whole point is that this 'simplicity' is given in any ecosystem these days.Except live coding via FTP is something you consider part of the simplicity, then you are stuck with PHP :)
This is not accurate. While some shared hosts offer node or rails you will be limited by memory and it might not even run your app. The reason PHP is so good for shared hosting is that it runs per request and when you have rarely visited PHP application it requires basically no resources. You can have 100s of small websites sharing resources that get few visitors a day on single server and it will be fine. Try doing that with node or rails which are application servers that need to run all the time.Heroku is fine but imagine you are agency managing 50 small sites. Heroku is like 7usd month minimum? You can pay 350usd month for Heroku or put it all on 20usd VPS and result will be same.That's why all self-hosted CMSes worth something are in PHP world and there are very few in python/rails/node.Also its not like PHP devs have been living under a rock for 20 years and don't want nice things. Git deployment is offered even by many shared hostings, people use SFTP+rsync, or things likehttps://deployer.org/. And there is very active market of server management tools likehttps://forge.laravel.com/https://ploi.io/https://moss.sh/that combined with attributes of PHP will give you your own little super easy heroku.And scaling... well most people don't need scale, you scale CMSes by caching anyway. And you can run pretty big scale just on one machine. And if you want automatic extreme scaling it's not like you can't do that with PHPhttps://vapor.laravel.com/
I was just using generic examples.However the way rails apps works with phusion passenger is exactly what you are explaining. I can run hundreds of apps next to each other on a tiny VM. Once a app is loaded I don't have to rebuild the state on each request, if it is not needed anymore (or rather another app needs the resources more) it gets unloaded again.Setting up passenger, nginx and git for pushing is also a job of 10 minutes max.I get there is a market for PHP, I too recommend wordpress when I don't want to code something for someone. I just don't see it's 'simplicity' as argument.
So true. The time to market is unbeatable in PHP.Not a fan, but that is definitely a very good argument.
This argument may have worked in the years before Heroku (or Docker even) but it’s really outdated in 2021.Then you have the myriad of static site hosts that also take 2 clicks to host something without even having to write any code.
You must have not worked with small non-profits with zero technical expertise and zero budget for hiring a consultant/permanent paid staff. Heroku is overcomplicated, and Docker/static sites (or the command line/running a server of any kind) might as well be alien technology. Some orgs know just that little.
I don't see how PHP fits into your example either.Who is writing the code in the first place? They're uploading existing code to a shared host through FTP but then who wrote the code? Is it a prepackaged Wordpress? But then Wordpess hosts already exist.If the developer is giving them a zip to upload, why can't the developer handle the deployment as well?You moved the goalposts so far that the example doesn't make any sense anymore.
> Hey presto, you have a functioning web shop, business website, charity home page, or whatever other thing you want.If we're talking about simple templates to open a store or a simple landing page there are so many no-code options like Wix/Shopify/SquareSpace/Square that I don't think PHP offers any significant advantage.
It's not that hard to get deplatformed, but yes, I can see your point. From an operational ease of use perspective they are strictly better than PHP, at the expense of trusting the providers to do the right thing.
I believe at least one of the options you listed is actually built with PHP (Shopify).
Perhaps, but you don't have to know or care about that that to use it.
Same with WordPress. You install it (or have it installed) once, and then never think about what language it's written in.
Shopify is famously a Rails shop, but it is likely that a couple of the products on that list are built in PHP.
Shopify is Rails actually. I think Magento and Prestashop are PHP
Shopify is famously a Rails application no?
Yes
Does this really hold true in an App Service world? Just load your repo and go.
I'm talking about the kind of small org that doesn't know what a software repo is - zero technical experience at all, except for the very basics.
I think there's value in a large, established ecosystem.Languages tend to go through a few years of flavour-of-the-week fads (think of the Vue/React/Angular competition, and all the also-rans that we can't remember now).  If you get in too early, there's a fair chance you'll bet on the wrong ecosystem, and end up with unsupported dependencies or difficult to maintain code.  In the worst case, you scrap the whole thing in six months and write it for a new framework to keep it alive.PHP went through that phase back when "we've got to support IE6 users" was a legitimate talking point.  You can be reasonably confident Wordpress or Laravel are here to stay.PHP is also fundamentally a hugely battle-tested platform.  It's been ran on 486s in the broom closet, and entire rack clusters in data centres.  If you have some performance or usability problem, there's a good chance someone else has had it already and worked out a solution.  With some new language, your odds of "never seen that before" errors are much higher.
jQuery changed my life.These days I write server code in C++ :(
Why so sad, that sounds like a huge improvement over webdev. Modern C++ is a joy to work with.
How is PHP 8.1 an “older car”? Have you looked at the language and runtime recently? I hear stuff like this from people whose latest PHP knowledge is based on that ancient fractal of bad design article.
Yes, I have. I recently programmed PHP after 10+ year break from it and while some things were fixed many of my old issues with it remained. I would not recommend PHP to anyone unless they have an existing code base in it.
> I don't really understand the reasons for using PHP outside of that people are already familiar with it and like working with it or want to find jobs in that area.I look at it this way sometimes: there are the interpreted languages, the VM-based languages and then systems languages.PHP is a good option in the "interpreted" languages category, if your problem domain is web-based, as it includes a lot of built in functionality for web-based problems. It's also open-source, reasonably performant, has an improved type system, has a C-like syntax and enjoys features inherent to a scripting language e.g. fast startup time, so would be a good option for lambdas.Finally, one of the features that has been unreasonably good about PHP is the shared-nothing request model, which makes running a website on PHP a stable experience, in an imperfect world of weird state issues and libraries that might sometimes have a bug that leaks memory.There are also other options in the "interpreted" category which I would fully expect people to also look into, however that's not to say PHP isn't a good contender for this space, given learning time is a limited resource.However I would expect people to know a VM-based language and a systems-based language (or at least a bit of one) in addition.
If you like PHP, great.Do you plan on creating a start-up that you intend to scale to a babillion customers? That you intend to hire teams of developers for? Probably not a good idea.Are you a new programmer trying to figure out which language to learn first? Absolutely not. Python, Java, JavaScript, C# are much more flexible if nothing else. Anybody who tries to convince new programmers to learn PHP is doing them a great disservice.
> Do you plan on creating a start-up that you intend to scale to a babillion customers?Not interested in PHP in the slightest, but how is this myth still going around?Wikipedia, Pornhub, Facebook (initially at least) were all built on PHP. There are hundreds of other examples.Laravel nowadays has an outstanding reputation and I doubt it's performance is lagging so far behind Django for example.More generally, after all these years I still need to see a story of a startup that failed because they chose the wrong stack. There are some blog posts with spurious claims in this sense, but really, when has a startup with good product-market fit and a finelydesignedproduct ever failed because they chose PHP instead of something else?
Those startups you mention are 15+ years old, would they still choose PHP today?Maybe you haven't heard of startups failing because of choosing the wrong stack, but I'll wager you don't hear about most startups failing because...why would you? Also, have you heard of startups re-platforming? Either because the current stack is falling apart or the company is acquired by a bigger fish and they need to integrate with other services so parts end up getting rewritten to Java/C#.The fact is PHP is good for making websites, and that's all you'd really want to do with it. There are other languages that are good at making websites and they are more popular and have other benefits.If you are building things with PHP and it's working for you, then awesome. But seriously, why encourage it?
Except Facebook literally did that :)But I agree with you.
Wikipedia too. And probably many WordPress websites with a lot of traffic.If anything, PHP has proven it works in this regard.
Facebook and Wikipedia were both founded ~20 years ago, think they would make that same decision today?PHP works, but imho starting a new company or career with PHP is a mistake.
I don't know, why not?Why would it be a mistake?On the one hand I have a few examples of huge, successful projects written in PHP and I know they are still around 20 years later and haven't been rewritten in another language. I use projects in PHP on a daily basis (Nextcloud, Rainloop, Wordpress) that work well and have been maintained for years. On the other hand I have a few comments calling out PHP without convincing arguments. Something is wrong.I practice Python and Javascript daily, I've written PHP code 10 years ago, still use some of my code. I occasionally update PHP code on a website I manage. I've seen good things in the new versions.Should I begin a new project today, I would not rule out PHP that fast. I like Python and Typescript, but PHP projects are often a breeze to install (unzip, done) and survive system upgrades and reboots easily as long as php-fpm runs. Projects in other languages need more babysitting. I know, I also use web software in other languages, including one I author.PHP is dead simple to write too.I would probably go for nodejs for something that requires Websockets or SSEs (or a compiled language). Otherwise, I'd seriously consider PHP because it does not require setting up something like uwsgi or celery, write reverse proxy rules, write init service files or running Docker. Put the files in www and it's done. Also no code for managing routes, the file system organization does this for me. No memory leaks, everything is thrown at the end of each request. The architecture is robust.
Couple reasons:* It's waning in popularity, new programmers aren't being taught and there isn't a lot of incentive for them to seek it out
* Other languages are also good at making websites but many are more popular and more flexible - machine learning, video games, front-end web development, enterprise services (and sure PHP can be "enterprise" but many new cloud/apache projects are java first)So yeah, I'm not saying PHP is dead...just that it's not a good investment for new developers and it's questionable for new projects.
Also Slack, Etsy, Baidu (4th most visited site on the planet), Box, MailChimp, Spotify to name a few more that seem to be doing ok.
Yep, almost 20 years ago and it's been both a technical and hiring problem for them ever since.
Is there any large tech company without technical and hiring problems?
Why make it worse by choosing backend-only web languages with bad reputations?
> Anybody who tries to convince new programmers to learn PHP is doing them a great disservice.It depends what location you're in. In Europe there are pockets where PHP is very popular, where learning it can open up the job market.
> If someone is new to software development and in an area of the world where it's not mostly PHP shops, so bigger citiesIn Europe there is alotof PHP. Even in the bigger cities. And as someone who knows a lot of different programming languages, modern PHP with Laravel is pretty hard to compete with on a productivity basis.
Not a completely fair comparison. Then at least also tell readers that the 'old cars' you talk about are not in the museum or on the junkyard, but make up half of all the active cars on the road. That's not nostalgia.
This seems like a desperate attempt to justify not moving on from a language whose death knell rang a long time ago.You might as well try to convince me I should start my next business with cutting edge software written in Fortran or COBOL.
I consult with startups a lot and routinely program in a variety of programming languages -- C++, Java, Swift, Kotlin, JS/NodeJS, Python, Ruby, PHP and a bunch of bash,awk,sed and perl. Most of these languages have been evolving to support most modern programming styles and have package ecosystems that are well managed and relatively easy to use.The point is not to prove that one language is better. For the most part, for web development, there isn't much difference in productivity for a programmer competent in the language between (JS/NodeJS, PHP, Python and Ruby) Java is a little more heavyweight for pure web development but if you have a bunch of backend services that need to be reliable you will find the type system to be of help.)What is more important for productivity is a deep familiarity with the frameworks, and tools -- the IDEs CI systems etc. that you need to build and deploy your solution.The other important thing is the ease with which you can hire programmers for that language in your market. Here in India finding PHP programmers is easier than say finding Kotlin programmers but harder than finding Java programmers. But that is not the case in other markets like the US. There is also the issue of perception of candidates. If like you, a large majority of candidates think the language is legacy, you'll end up having to pay more to hire them (because they will be harder to find -- most of the extra cost will be search costs not salary costs.)To the extent that the PHP community can convince folks that it is not a legacy language (and it really isn't) that is good for not just the language but the overall tech community. And this article furthers that goal well.
Here’s something to think about: You and some buddies start a startup whose product is a complicated piece of medical software that uses Tensorflow’s inference but most of it is written in Go. Cool stuff, you’d never do that in PHP.You’re getting ready to launch, and you’re going to need a marketing site and a site with documentation and help articles for users. Do you write that site in Go?Hell no. You hire someone cheaper whose skillset isn’t systems programming or ML, and they spit out a templated site in a weekend that looks sleek and makes a good impression, and when you need more content you tell them and they turn it around in an hour, and you spend your time on the Go stuff.And that market, the market for Good Enough sites that front Really Good products and are fast to work with: that’s a great market for a lot of people who want to sling some code, get things done, clock out at 5 and spend time with their kids in a nice house in the suburbs. That’s why for people who want that kind of life, I recommend learning some PHP (or rather, learning the super-common frameworks that use PHP).
100% agree. I can go to any number of hosting providers and have a working WordPress site or even a simple PHP Server up in minutes, the longest part of which is entering my credit card number. Then there's an almost infinite number of agencies that can use an almost infinite number of plugins to make it look nice, perform well and do lots of stuff. If the site isn't more than a marketing front-cum-webshop, honestly, I see no reason to use anything other than PHP.
> Do you write that site in Go?Hum... Probably. (I personally have a thing or two against Go, but yes, probably.)Is the site some empty generic marketing that you'll put up to fill a feature list or is it meant to be useful? On the first case, sure, go offshore to somebody cheaper.But on the second case, the time you can waste due to language, framework, software architecture and every other technical aspect is almost irrelevant near the time you will spend creating content. And you can't offshore the content if you want it to be great.
> Do you write that site in Go?Yes!https://gohugo.io/would be a great choice for that kind of thing.
But you don't write Go if you use hugo?
Depends a bit on how fancy your Hugo-site is. Unless you’re just feeding markdown into a pre-made template, you’ll at least use the Go template syntax, since that’s what Hugo’s templates are written in.And if you want to integrate Hugo with anything, Go is the way.
That would likely then require a developer to update the content. Not ideal for a marketing website.
Depends a lot on your set-up. Many pair Hugo with a headless CMS for exactly this reason.Even with a standard Hugo set-up, most content is in Markdown files, so one could also just train someone from marketing on how to edit those. Not exactly rocket science.
There must be a reason why most languages don't have single good self-hosted CMS and PHP has like 8 really good ones with thriving markets behind them.I mean most of the marketing websites are build with such PHP tools.
Do you write that site in Go?Honestly if all I needed was a marketing site and a place to host my documentation, I would 'write' it in something like Squarespace.
Somewhat related, what's the Go laravel/rails/django equivalent?
There's Hugo (mentioned elsewhere ITT) and I hear it's pretty good. If I were making my own personal site that I was going to spend a lot of time on and I was more into Go than I am (I like Go but prefer Node.js) I'd totally use it.But if you need a site spun up for something and it's not the main focus of your business, shooting for the middle of the market makes a lot of sense. Wordpress is super easy to set up and create pages on, and there are tons of people with expertise in it. It's the kind of thing even non-programmers can administer, which makes it accessible to people who have skills in other stuff like marketing or social media management.
Hugo is a static site generator, it's like jekyll or pelican.I was more thinking if you want to build an interactive site, what is the go to Go web framework?Along the same lines with the Wordpress example, I'd choose Ghost for that as I come from the JS end of the spectrum also. I wonder what the Go based options are here? If I ran a Go shop I'd probably lean towards that (unless, of course, they're all horrible :)
OK.
Nobody cares about convincing YOU; you made up your mind a long time ago and could care less about all the nice things in PHP 8, the performance improvements and the massive ecosystem and huge parts of the web still driven by PHP.
I think the news of PHP's death came a bit too early. Most people I know claimed it was dead during the time Node was getting popular and people started pushing for things like websockets to make updating pages faster. PHP couldn't do that so people said it would die, and honestly if you were in a startup or a FAANG at the time it looked like it would. Everyone was moving from a REST web 2.0 model to a "live, concurrent users" model.But the trend didn't continue. People did it for a whilw, but then moved on to other models which still worked for PHP because few apps really need live data and concurrency like that.The problem for PHP is that the reputation for being "a dying language" stuck.
That reputation is only viewed that way by a tiny number of nerds, typically with static language backgrounds that don't ship much code or product.I added more value to a tech agency and their clients with PHP than several of the senior Java guys did combined. And they were talented. Just set in their ways and lacked a focus of getting things done and adding value.They'd waste time overbuilding shit that nobody used because it was interesting to them, not that it would create value for the client or end-users.Also, I took over several large Node projects built by hipsters and they are the messiest code bases I've ever seen. And I've inherited a lot of trash PHP ones over the years.Regarding the concurrency thing with PHP - ReactPHP is very nice, PHP 7 and on performance gains were massive, and real-time (search, chat, etc) can be better handled by Algolia/Pusher/etc anyway.The Node hype train had a great run. And I still like Node. But PHP is the language of getting shit done.
if people are out here voluntarily writing server-side javascript code, I see no reason to call PHP dead
what are your feelings about server side typescript?it's quite a nice language, and for many many cases is certainly fast enough these days.
It think there is a reasonable argument that in PHP and JS there are an equal amount of issues. Inconsistent API, inconsistent language, bad data types, same speed .. just to name a few.Not that I would not also prefer node over PHP ... But that is mainly because of C/C#/Java familiarity and frontend code reuse/familiarity than anything else.
Is there a preferable language?
I've never regretted the time I took to learn PHP. No matter how bad the language may seem, it paid my bills for a long while. It's one those tools that to keep in your back pocket until you need. Keep in mind what it's good for and what it doesn't do so well.That said, php's online documentation is one of my "gold standards" for what good language documentation should provide. (At least it was the last time I had to reference it.)
I really like how the documentation also includes a huge amount of user contributed notes that demonstrate various alternate examples as pointing out certain caveats/nuances.
This seems like a false dichotomy.Is php totally worthless in 2021. Absolutely not.Is php the best language to spend your limited time learning in 2021?  Almost definitely absolutely not as well.
> Is php the best language to spend your limited time learning in 2021? Almost definitely absolutely not as well.Depends if you want a job or not.At least in many European countries, there are plenty of them doing PHP.In fact, when doing our Java and .NET consulting sales for Web projects, PHP is the adversary, not Python, Ruby, Go, Rust, or whatever is on the frontpage, like everyone likes to discuss over here.
Why are y'all arguing about this when you already learned like 20% of php by reading the OP. Learning enough of a high level scripting language like php to be able to be useful and productive in it is not some huge time sink, it's a few dozen hours of reading docs and tinkering
The core language itself and stdlibs, sure, it'd take just several dozen hours to pick it up. That goes for any high-level, C-family programming language around today, really. Can you do that and be nearly as productive in PHP (or any other language) as you are in your current daily use language? No: you need to invest in learning common design patterns, the library ecosystem, and tooling in order to be productive at a high professional level, and that is a task that takes longer and arguably never even really ends. Putting down real roots in a programming language is a large investment.
Opportunity cost.Those "few dozen hours" reading PHP docs and tinkering could also be used to learn Python, Ruby, or Javascript, each of which are almost certainly better choices with broader applicability and more modern ergonomics.Python gets you web backend + ML, Javascript gets you web backend + web frontend. Ruby gets you a multi-paradigm language with nice ergonomics and cats. PHP gets you job offers customizing Drupal and Wordpress websites.If you already know a "scripting language most popularly used for websites", then you could choose to pick up Rust, Nim, Go, Swift, or Kotlin instead. It's much better to have a new kind of tool in your belt than a second hammer.The world is full of so many choices. PHP has a lot of incredibly compelling alternatives. Unless your job demands PHP, you're probably better off looking elsewhere.
I mean if you tinker around with programming languages a lot, odds are pretty good that you have also spent a few dozen hours on Python, and another few dozen on Ruby, and it's probably pretty hard to avoid spending dozens of hours mucking about with JS even if you don't like learning new languages just by virtue of it being necessary for writing web stuff or scraping stuff off existing webpages.So yeah. Don't make PHP your first language. Probably not your second either. But if you've played with Python, and learned to write the simplest and clearest thing that can possibly work, if you've worked in C, and decided that's as close to the bare metal as you ever want to get, if you've learned enough Java to know when to use the SeriousBusinessFactoryProxyInterface, if Haskell has made you realize that programming is really just math... then sure, learn you some PHP, write a toy web project and discover that the simple things really can be simple.I still don't know of any stacks where it's easier to write a simple, low maintenance side project that will stay up for years without issue, where multiple projects can share a $5 / month VPS, than the LAMP stack.
Not that I code in PHP anymore, and I havent for years (felt like I had to say that).But PHP is a quite nice language with a lot less ceremony than many other languages. Especially nowadays as the article says.Go make a Wordpress site!
> PHP gets you job offers customizing Drupal and Wordpress websitesI get that there's a lot of legacy PHP sites, that you could end up finding yourself working on.
But there are still plenty of new Drupal and Wordpress sites being built.You could also say that building a site with these tools as akin to "customising", as a lot of what you're doing is configuration rather than coding (but I would say sometimes JS + NPM is pretty similar).  
There are still opportunities to push yourself with coding, with some fairly complex Drupal sites being built.
> PHP has a lot of incredibly compelling alternativesThere's no alternative to dropping a file on a LAMP server that goes with almost 0 maintenance for price that goes to almost 0 with 0 downtime whenever you make a change.PHP is my tool of choice whenever I need to create an simple endpoint but don't want to deal with the hassle of running and monitor a full blown application. At best, the alternative to that is AWS Lambda but that's a wall garden in itself> then you could choose to pick up ..... better to have a new kind of tool in your belt than a second hammer.Different tools for different job
PHP has a lot of quirks that have to be learned so that they can be avoided. It's a bit of a time sink in that way, and the sort of time sink that doesn't accumulate new skills that could be applied elsewhere.
There is never a best language. You make it sound like PHP is almost worthless in 2021 which is also not true.
There is probably a set of "good languages to learn" for every individual. There are two good reasons to learn a programming language:1. You're using it for actual work2. Learning it will teach you something fundamentalI feel like the only way 2. might happen with PHP is if it's the first language you're learning.
PHP was my gateway to understanding C. It wasn't my first, but it definitely helped me learn more computer fundamentals than other languages.
PHP was my gateway to _everything_, most importantly employment.I don't use it any more, but in 2002 when shared hosting and deploying by uploading files via FTP was the thing it was a lot easier to get started with than Perl or Java (which I desperately tried to get into back then).
Oh yeah. PHP was the first language where I thought "hey, this thing that already works, I could rewrite it in exactly the same form in another language". I rewrote a Perl payment gateway thing that I had written almost alone earlier into PHP, made it OO and everything. No point whatsoever but what an exercise :P This was ~1997.So it was almost the first language I used to make actual money.
I felt like PHP set me back as a first language (many moons ago). It just works so differently to other languages.
Can you pinpoint anything in PHP that allowed you to gain such knowledge better than whatever your first language was?
I started with BASIC, then shell scripting, then an internally developed language similar to COBOL. Being self taught I didn't really "get" data types, so the big names at the time like C and Java made no sense. PHP was a crutch that allowed me to learn and experiment with functions that were pretty forgiving. The eventual type related bugs I'd introduce into my code where it would work but not correctly eventually helped the concept click in my brain. I still don't get Java.
It depends on what you want to do. The problem is that PHP is hyper-optimised for serving up HTTP. That was great in the 2000s when the web was eating the world and the other options were Java, Python, and Perl, but is less useful in the current climate where there's so many more platforms and web development requires javascript.By learning PHP, you are effectively locking yourself into the narrow niche of backend web development (ask me how I know!), whereas other languages have much broader target platform appeal.As an example, the obvious competitor to PHP of Javascript already beats PHP by also providing backend web services, but also has support from AWS lambda, GCP Cloud functions, and even the somewhat esoteric embedded javascript for micro-controllers options.> Do you shoot for what has had longevity, or what's rising?Coming back to your original question - I think it's both. Depending on what you wanted to do, I'd pick Javascript (see above), then depending on what else you wanted to do, one of Golang, Python, C#, or Kotlin.
Most languages lock you into one type of niche or another.I'm quite happy with the Web niche, it's one of the longest lived, the stablest, the most open, and has some of the longest backwards-compatibility records around.I can write a website today which will work in 25 years worth of client software! I think that's remarkable.
PHP pays my bills. I don't use it for web backends, it runs automations for a number of operations that glue APIs together, as well as exporting some custom document types and sorting out workflows/data.Simplistically speaking, all I have to do is stick the path hashbang at the top of a php file, follow with the business logic and run it as a shell script. Clears any urgent ad-hoc request within a day.
Best since everyone is thinking along the same lines Javascript/Python/Go developers are quickly becoming a commodity; e.g there are millions or tens of millions of developers who learn them as their 1st language (many of them are now hirable remotely). 
Just worth noting I think...
From brutal experience I can tell you that's also been true for PHP programmers for a long time.
Maybe still. But I'm pretty sure 5-10 years from now PHP devs will be in demand since everyone is moving to Node/Go/Other Hype.
If you could predict the future, it'd be easy. And you can pretty much learn any language.The question is who's hiring/where will you work, and what will you work on? In my area, there aren't many PHP shops. So it could be Wordpress or Facebook/Meta. PHP might be long-lived, but if you have to relocate to find a PHP job, does that help? Same with e.g. COBOL, Sharepoint, etc. And to be fair, what's rising has that problem outside tech centres.Something popular like Python is generally a "better" investment, covers more bases.
Python, JavaScript, Java, C# have all had great longevity, and much more popular, and can do anything that you can do w/ PHP and a whole lot more. Encouraging new programmers to learn PHP is cruel.
Encouraging new programmers to learn Java isn't cruel? "Son, today is the first day of a long journey into enterprise software development. Yay"It is cruel, and something Universities have been doing forever.
You prefer customizing wordpress?
I'm still seeing shared hosts offer PHP everywhere at very cheap prices.That's not true for Java or C#.
Java and C# are not website-first languages and have never been popular on webhosts. They're still very widely used, maybe even growing; certainly I'd bet that both have a better growth rate than PHP at the moment.
But what is, if not Visual Basic? Do you shoot for what has had longevity, or what's rising?But what is, if not Motorola 68000 Assembly? Do you shoot for what has had longevity, or what's rising?Pointing out that there is not absolute certainty about what is the top choice for a better idea does not make php, or visual basic, or 68000 worth spending your time on in 2021.
Purely from the outside (I don't really use either), ruby looks more dead than PHP nowadays.
How so?  Ruby just released a new version with a JIT and new concurrency model.  Rails is releasing a new major version later this year with a bunch of great improvements.  Shopify, Stripe and others are putting a ton of improvements into the Ruby interpreter.  Many large tech companies still use it.  Many startups still use it.  If nothing else, it's still a popular scripting language.It's not as 'trendy' as it once was, but it's better than ever and still widely used.
> How so? Ruby just released a new version with a JIT and new concurrency model. Rails is releasing a new major version later this year with a bunch of great improvements. Shopify, Stripe and others are putting a ton of improvements into the Ruby interpreter.Do all of these make it faster than PHP?
> Do all of these make it faster than PHP?We'll need to look at it a year or two from now and compare oranges to oranges; the new Ruby JIT (YJIT) is optimized for real world web apps, not for some artificial fibonacci benchmark. Shopify is using benchmarks on actual Rails apps like their store front to see the improvement (https://speed.yjit.org/).
If I had to bet I think yes Shopify is serious enough about this to make Ruby faster than PHP - who is working on PHP internals now - Zend? In the end it's mostly a question of how much resources you throw at a problem.
Is speed the only measure of a programming language?Honestly, I have no idea how it compares to PHP.  If I wanted truly fast I'd use a compiled language.  The point is more that Ruby is still being used and improved upon all the time; far from 'dead'.
> The point is more that Ruby is still being used and improved upon all the time; far from 'dead'.Exactly the same with PHP.  The handful of Rails devs I know  bemoan the fact that fewer shops are growing their Rails/Ruby use.  I did a stint at a shop that was mainly PHP, but they migrated most stuff to a combination of node and python, because "they couldn't find php developers".  While it was sort of true, they couldn't find affordable php devs to work with the legacy mess (which was only 5-6 years old), and it was cheaper to have less experienced (but more) node/python folks come in and rebuild distinct bits of the older PHP stuff (at least, that was my understanding as an outsider - this happened after I left).Some orgs are moving away from PHP - others are moving towards it.  Same with Ruby, although I don't see as much movement toward Ruby as I do with PHP.  But I do also see orgs moving away from each.
Ok, so similarly "dead" (or not) as PHP.
Ya, but PHP is actually still being used in a lot of agencies and in certain types of work. Far more than elixer and rust, probably just below ruby.Also I wasn't pointing out what you say, you're reading into it a bit. I haven't used PHP in a long ass time. But it seems like not a bad choice for certain markets, at least as much as Python and Ruby imo
PHP is used far more than Ruby. Wordpress alone dwarfes any Ruby usage.
I guess it depends how you quantify it, but I was thinking Shopify's use of Rails would have started competing for %
That's a fair point, I implied individual websites instead of % of traffic on the internet. I interpreted this thread mostly to be about number of jobs, in which case I think the number of websites is more important than the percentage of traffic, but I should have been explicit about it.
Compare what the PHP jobs pay or the career path they put you on compared to elixir or ruby. Not even the same ball park. Not even the same sport.
I bill £650 a day for 'PHP development'.What is this out of the park career path I'd have had choosing ruby? Can you share some more details?Almost the best advice I can give to a developer is stop being fixated on language, and start being fixated on how to solve business problems, on communicating coherently (and like a human being), and being able to quickly grok complexity. The language you program in is almost the least important part of the offer (as long as you're competent in it)
> Compare what the PHP jobs payWhere? At Facebook? Or somewhere else?
yes, with the sole exception of facebook. If you really believe people are going out and learning php just to get jobs at faceboook I've got a bridge to sell you.
Hack isn't PHP anymore...
> Just don't pick a language that is known to be on it's last legs.I’ve heard that exact sentiment over and over since the RoR community aggressively started with their anti-php agenda in about 2006.
Funny, Ruby seems like the language that's most obviously in decline right now. (Though as a Scala fan I shouldn't throw too many stones).
I bet that there is a bigger demand for PHP devs then all the Rust,Go and Elixir combined.So if you need a job you would probably have better chances knowing PHP then knowing Rust. But if in your area is raining with Rust jobs then go ahead and learn only Rust.
If you have to learn a new language for some reason and you don't know what to pick, go for something that has things you've never done before. Perhaps consult TIOBE for extra data points if you value current popularity.Some popular choices in this bubble seem to be:- clojure- common lisp for some reason- php is mentioned often here, also not sure why- rust- swift if you're into ios/apple, kotlin if you're into android- typescript
I can’t tell if you’re arguing for PHP or against COBOL. I kid, but a lot of the other languages/ecosystems people will consider investing in are at least as old and evolving right alongside PHP. Many of them with very similar evolutions.
Ya that's basically what I was getting at. Not about COBOL, but about others that are similarly long lasting in the market, dynamically typed, and general purpose.
Well lets start with things I do like about PHP.
I like that they had the web use case in mind right from the start and this shows in stdlib APIs PHP offers.
For example database interaction, image uploads, cookies etc. 
Many languages need that via a framework but PHP is ready to go from the start.What I do not like is the syntax. Call me picky but referencing attributes with -> instead of a dot (.) is ugly to my eyes and I prefer JS, Ruby or Python when it comes to the pure look of the code.Generally I'm not a fan of dynamically typed languages because I just feel way more productive when I have proper code completion and type safety.In general whatever works for you and makes you happy is good enough.:)
It's fine for the web. I used it for years. Not a great general purpose language though, if for no other reason than the ecosystem is focussed on the web.
Great article for PHP devs too. I've spent a lot of time in PHP over the years and found there is a bunch of stuff I didn't know about.
Agreed! 
I didn't know about this project for payment gateways from the article:https://github.com/thephpleague/omnipay
I am surprised when [1] Python or [2] Ruby is recommended over PHP at  the very least from a performance standpoint. PHP has a lot of built in standard library utilities and it's execution model is so simple for both web applications and scripting system automation jobs.[1]https://benchmarksgame-team.pages.debian.net/benchmarksgame/...[2]https://benchmarksgame-team.pages.debian.net/benchmarksgame/...
PHP is still very popular in EU. In my experience, the consensus of PHP is completely different than what some of the people still post here.
I have used PHP for years. I like it too. Its tight integration with http is nice.The PHP language can be used as a templating language itself:<?php

  $user = 'root';

  ?>

  <p>
     Hello <?= $user ?>
  </p>
I think* with ASP.NET Razor Pages. You can do the same thing as:@page
  @{
    var user = "root";
  }

  <p>
     Hello @user
  </p>
Razor is awesome... It has this productivity of PHP while being consistent and have the benefit of being conceived later.Only thing which hurts there: not everywhere deployed like PHP is :)And technically you need a 2 files boilerplate. But that will vanish within the next year when I understand the .NET team right.
Does PHP still look like that in 'real life'? I was reintroduced to PHP last year via a Laravel based project and it looked nothing like that. It was all Objects and  Models and Controllers spread out across a half dozen folders and scaffolding code generated via CLI commands.  All actual HTML was generated with Blade templates.
Please, do not do that. Use an actual templating language which automatically escapes output.
I have a few questions:- Is the "your app gets initialized and torn down for every request" true for frameworks like Laravel and Symfony?- Does this model uses OS threads? Does it uses green threads?And then a few remarks about the language:- I feel like the Go model is a way better model for server software than async. Since PHP is mostly used for server software, I feel like they shouldn't go with async. Python is currently going through the transition and it's painful and long.- It feels a bit weird to see how full of objects PHP is. Modern languages (Go, Swift, Rust, TypeScript) tend to use less objects, and more plain imperative code or slightly functional code in my experience.
> Is the "your app gets initialized and torn down for every request" true for frameworks like Laravel and Symfony?Yes, though heavy optimization in opcode caching and JIT keeps it fast and the primary process manager today (php-fpm) generally keeps a pool of PHP processes persistent. Each request is initialized from scratch but there's no disk nor interpreter hit after the first.There are, of course, frameworks that simply handle HTTP requests directly (amphp, swoole) that operate as persistent application servers, so state is maintained.> Does this model uses OS threads? Does it uses green threads?No. PHP webserver backends are generally a long-lived forking model.> I feel like the Go model is a way better model for server software than asyncSwoole [1] offers a coroutine and channel model. It's incredibly fast and the techempower benchmarks [2] attest to the raw speed.> It feels a bit weird to see how full of objects PHP isAgreed. It's often way over the top with Java-esque OOP complexity. It does depend on the libraries in question but the popular ones are very heavy (Symfony). You can of course write very simple imperative code just fine too.[1]https://www.swoole.co.uk/[2]https://www.techempower.com/benchmarks/
I don't agree with Symfony being inherently "very heavy". As set of framework components, you can any part you find useful, and wire to together yourself, if necessary. e.g.https://symfony.com/doc/current/configuration/micro_kernel_t...Many other PHP projects, such as Laravel and Drupal pick-and-choose Symfony framework components in this way.
Sorry, I should have clarified "heavy" in terms of the level of OOP [1] insanity but yeah Symfony is very modular.[1] e.g. "Symfony\Component\DependencyInjection\Loader\Configurator\ContainerConfigurator"
> in terms of the level of OOP [1] insanityI would have to question how relevant a piece of core plumbing is to a regular user of the framework, as a regular user of the framework would likely never come across this class.Also if you're working in the domain as a Symfony core developer, the idea of a ContainerConfigurator is not so insane, if you're developing a dependency injection container.
Look at what I was replying to. The guy commented about the amount of OOP in PHP.
That"your app gets initialized and torn down for every request" is _the_ best feature of PHP. This may sound strange first, but it's true. With web applications written in any other language you have a stateful server running all the time with the following "problems":* If you have a memory leak your complete server will get killed some time later when running out of memory
* If you have a bug which crashes your web server every running request is killed
* You get all the hard-to-find concurrency bugs when multiple requests concurrently can access some objects.With PHP's model of (1) initializing and destroying all the state on every request and (2) every request running in it's completely isolated virtual space you don't have any of these problems.And if you really want to have a long-running server with shared space you can have that too, take a look at Laravel Octane.
Excellent article. Learned much for this even though I have used PHP for about 20 years. PHP has vastly improved since version 7 - both in terms of language features as well as in terms of performance.However, error handling continues to be an issue. It isn't uncommon for PHP to fail silently. That would be one complaint I have against PHP.
Nine years ago I decided to use plain old PHP and MySQL to build a self-hosted analytics platform[0], and to this date I still think this was the best decision I could make. Even though nowadays cloud, Docker, Golang, Node.js, Kubernetes are all the rage, most of the websites and hosting providers are still running on PHP/MySQL, which means running the platform can be done on the same server and customers can try it without having to learn to deploy to the "cloud".Not only this, but PHP/MySQL is such a reproductible stack, if the code is properly written you can run the same app on tens of different server configurations (Windows, Ubuntu, CentOS, various versions of MySQL and PHP) without having to change anything.[0]:https://www.uxwizz.com/
<?php
  echo "oh you!";
?>
PHP is an ok language for web frameworks. But for most other things, it is a poor fit.There’s a reason why people are generally not doing scientific computing, machine learning, hardware integration, systems programming, etc. in PHP (yes, there are likely some obscure projects doing all of those, but in general, it’s not done because of limitations in the PHP runtime).If you already know PHP, you can probably have a long and healthy career in that space. But if you’re new to programming, you’ll probably be better off learning Python or Rust, or maybe one of the platform-oriented languages like C#, Kotlin or Swift. JavaScript is also a very popular choice, because it’s currently the only thing you can easily use in the browser, but that might change with the rise of WASM.
There's nothing platform-specific about C# and Kotlin.
In theory, true. In practise, they are most popularly used for the Microsoft and Android ecosystems, respectively. I’ve reworded it to platform-oriented.
I'm not sure what you mean by platform-oriented.
Well, I’m not trying to invent scientific classifications here, but the common reason to choose one of said languages is to use them with the Microsoft/Apple/Android ecosystems, respectively.
Ok, I'm just trying to understand. Not trying to make you create a scientific classiciation :D I just disagree as a .NET developer.
I could be mistaken, but I can’t remember last time I heard of a C# project that wasn’t either targetting Windows as a platform (whether server or desktop) or running against some other Microsoft-thing like Xamarin.In the early days of Mono, there were some attempts at using C# outside Microsoft circles, like building Gnome-apps with GTK#, but most of those projects have faded away.
I have around 500 c# .net lambdas. And several linux servers with .net on it. Also do almost all of my work On linux. Tho I’m starting to switch back to windows 11 with wsl2…
Lots and lots of people do web stuff in Python. There are a whole bunch of Python web frameworks like Django, Pylons, Flask, etc.And there are big sites written in Python, too. Reddit, YouTube, some Google apps, Spotify, Netflix.Rust is still a bit young, but also has several web frameworks like Rocket. No big case studies that I know of, but Rust still has many more fields of applications than PHP does.
Sure, a small minority of sites are partially written in python.
Tons of sites are written exclusively in Python. Django alone has 60k stars and 25k forks on Github. That about the same as Laravel.
A quick search came up with an order of magnitude more sites in laravel than django. And combined are still a small fraction of sites on the internet.
Whichever way you spin it, building web stuff is a perfectly normal thing to do with Python. Thousands of companies do so, even big famous brands like the aforementioned.
people aren't doing web stuff in python?? django, flask, etc. are still very popular. maybe not as much as a few years ago, but people tend to stick to tech they know well, and python's web libraries are pretty battle tested at this point.
I use a hammer for nails and a screwdriver for screws.
It is, but not as "worth it" as python
I really like Python. It's what I reach for when I need something working quickly. I have a whole folder of one-off python scripts I wrote over years that I occasionally still use.For very large projects, however, I advise against it. The dynamic type system bites you a lot in my experience. I prefer static typing.
As someone actually did (re)learn PHP (last time I used PHP was PHP4) last year for a gig, I would probably say no.  Don't get me wrong, it is a much better language now and Laravel is a great framework. With the two you can no doubt build fantastic applications.  But I didn't feel it was 'better' in any way than anything else. With Python, Go, Rust, Elixir, TypeScript etc. I can all point to a thing they do and say "if you are solving this sort of problem, then this language is the right choice because of X, and worth learning". With PHP I just couldn't find that.
I always suspect modern php makes the language nicer but actually reduces it's core feature, the ease of use.Don't get me wrong, I would not like to use older php these days. But just throwing 2 files onto an ftp was always php's biggest strength. It somewhat retains that for "installing" php, which still is often just "copy to server" which makes it really nice for users. But I feel it mostly lost that ease of use for people learning to program.Now, it is still a solid language considering performance and such. It has proven itself to be. But without the easy way from zero to programmer, I am also not sure it is a better choice than anything else. Especially since it always had so many terrible footguns and at least in my opinion is also atrocious to look at.
Here's one: If you want your operations to be as easy as they can be (LAMP), go with PHP.
I had exactly the same experience. Yes, it has improved, but, no, I did not see any reason for using PHP over any other language (Ruby, Python, JS who all have their own selling points).
off-topic, but: Go and Rust seem to aim for the same space (system programming), so when is one preferable to the other, in your opinion?
> Early PHP was not intended to be a new programming language, and grew organically, with Lerdorf noting in retrospect: "I don't know how to stop it, there was never any intent to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way." [0]This might be an unpopular opinion but I think PHP gained mindshare in the early days because Coldfusion (CFML) was neither free nor open source.[0]https://en.wikipedia.org/wiki/PHP
To me personally PHP is the cheapest way of building a dynamic website. Just a few euros/dollars a month will get you a shared web hosting plan with full support for the LAMP stack & free email.
That was true in 2004. Today you get a virtual server for five bucks a month. Feel free to run ANY stack you prefer.
Virtual server is great except now you are reponsible for server management, SSL certificates, backups, DB, firewall configuration, mail server, etc. I don't want any of that which brings me to PaaS providers like Heroku and Vercel where the cost is many times higher.
I learned web programming on PHP, and a ton of anti-patterns well. Making a single script with a very rich stdlib is quite handy, as well as "just running it" on your desktop instantly. However scaling out large projects in a performant way, doing big refactors, or mature server programming, I'd pick nearly any other tool today.Disclaimer: I still maintain my PHP site from '08, so I'm current on trends.
PHP is perfectly fine, and all of the "better languages" are only better in an academic sense. But you can't really use PHP. It's too uncool. If you use PHP in 2021, you had better have a really good understanding with your manager, because your manager may read that PHP is "bad" or "a fractal of bad design" and start to question your competence.
I think PHP gets all the clapping when in fact the statistic that the majority of the Internet uses it to power its services is misleading. Let's face it, Wordpress is a great project, it could have been written in Perl and it would still have had the perks of being Wordpress. When people use it, they don't know what happens behind, I think WP is the perfect example of what a good extensible product is and how it can build an insane ecosystem around it. The plugin architecture is there since 2004, it was and still is very ergonomic. Though Wordpress was not unique in that time, phpBB, vBulletin should be mentioned.
You guys think a hell of a lot about your hammersIt's a tool, use it or don't. Why do we have this weird slap fight every 2 months? It's so weird
Because we use our hammers 40 hours per week. If you use something that much it is perfectly normal to have opinions.
I haven't commented on this thread until now (I left PHP so many years ago, I have nothing to add) but are you suggesting to never discuss with other peers about the available tools for the job? Could you be more specific on your proposal?
No, I'm not suggesting that. I am suggesting that the same conversation happens over and over again"PHP is good now!" "No it isn't!" "That was PHP 4!" "array and string functions" "abstract it with a framework" "PHP is slow" "It isn't" "it is lookbenchmarks nobody will ever need"See y'all in 2 months haha
My team has been using the Slim  Framework for years and it has servered us well. It is a microframework and follows most of the PSR standards so it is possible to replace libraries with relative ease.https://www.slimframework.com/
This actually convinced me that PHP isn't as bad as it used to be. Though it's still not all that inviting, knowing Python, Typescript, F# etc...From Pyjokes: Coding in PHP is like peeing in a swimming pool. Everybody has done it, but it's best not to talk about it.
PHP needs a proper type system with generic support, and would be a killer programming language
https://hhvm.com/
I'm aware of Hack, but I don't have full control over the stack, so having all these features included in core PHP would be the only way  in my case.
I heard that Php is unsecure by default. Wonder what's the state of that?
There used to be bad defaults, such as "magic quotes" and "register globals".Register globals was turned off in later versions of PHP 4. Magic quotes was turned off in PHP 7, released in 2015.PHP today is no more "unsecure by default" than any other language.
Depends on how you use it. It's always been dependent on the programmer.
For me the main turndown of using PHP is when I need to host the PHP website, php-fpm and Apache+mod_php seem to be the only two options. (FastCGI doesn't even have a proper specification).
swoole is a pretty interesting alternative as it allows asynchronous programming in PHP.roadrunner is a PHP server developed using golang, utilizing goroutines for high performance.both used by Laravel Octane, providing very easy integration with the framework.Other than that, php-fpm & FastCGI allows integration with many interestin webserver including Nginx, Caddy, Lighttpd, etc.
I would be a little bit careful while using swoole. They added some code that loaded code from a third party server [1] (a core developer who seems to be located in china). Even though it seems like they removed it doesn't bring a good feeling. It seems like there were also some disagreements with a contributor who maintained the website of swoole and he forked it [2]:https://github.com/openswoole/swoole-src[1]https://github.com/swoole/swoole-src/issues/4434[2]https://news-web.php.net/php.pecl.dev/17446
Roadrunner looks cool, thanks for the recommendation!
Litespeed, or Apache+mod_lsapi are excellent alternatives.If self-hosting, Nginx and FPM is well-tested and very fast.
PHP maybe worth learning and using for building websites, but PHP is one of the worst languages to learn for someone who is interested in learning programming as a hobby, interest or career.
There is also a proposal about generics:https://wiki.php.net/rfc/generics
There are package managers, yes, but probably you won't need one. Because of the mighty standard library. Thats a big advantage, compared to the tiny-package-mess at npm.
If you haven't worked in PHP, you don't know what you are talking about. You only think you know what you have heard.
I have worked in PHP recently and it is still a pretty bad language. Not as bad as it used to be but still pretty bad.
Someone has experience with hyperf?[0][0]https://hyperf.wiki/
After learning and developing with PHP, even with the new stuff, I would never choose to use it for anything.
I've been using this language since 2002. Still good for most kind of tasks in web.
PHP is great as long as you accept it 100% for what it is - a shitty language.
Have you used a version of php from the past decade? Or are you conflating a bad framework or codebase with a bad language?
Yes, it's like an old Model T Ford from the early 1900s that has had a turbocharger, air conditioning, a new stereo, a subwoofer, roof rack for a bike, roof rack for a tent, grounding straps, trailer hookup, clean water system, etc.. bolted onto it.At some point you ask yourself - why did I do all of this to a Model T? Sure, it has some modern facilities but the language itself was neverdesignedand so none of it feels cohesive. The syntax is off-putting. It's just a ton of nightmare for what reason? Why? There are so many other languages to choose from and PHP has no competitive advantage other than $3/mo GoDaddy hosting.
You have to give up arguing.The PHP dev will look at a Model T DIY'd into "The Homer", and beside it a 2016 Toyota Corolla.The PHP dev will argue, sincerely, that The Homer is just as practical of a daily driver as the Corolla. You have to just walk away from this kind of person.
what's new in programming language theory since the 70s?
Learning is always good...
None of the reasons listed exclusively argue for PHP; unconvincing. To start the article with the type system of PHP as a reason to learn it in $CY is insanity.
php is very easy to use,it saved a lot of my time,I have used PHP to created a simple Social networking site: alovez.com ,this is my homepage on my website:https://www.alovez.com/bing
Php can be immensely productive to develop web apps in, it has all the things u need out of the box no libraries needed. Infact that is how most of the old php was written. 
Nowadays people use frameworks bcz they find themselves more productive
