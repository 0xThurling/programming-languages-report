If your code is in more than one file, use TypeScript.
After getting used to TS, you might never want to come back to JS.
After getting used to TS I can‚Äôt believe I ever even liked JS!
There's two separate questions here.
TypeScript- it has massive benefits for work-oriented coding, but I don't personally enjoy having to do battle every day with weird type definitions others have created in the code bases I have to work with.
At the moment I'm building a d.ts file for my JS canvas library; having types defined will help other people who want to use it when they import it into their own TS-coded project. Thankfully I only have to worry about the objects/functions users would create/manipulate using the library; I certainly have no intention of extending TS into the library's internal code (because: life too short).
.NET/C#/WASM taking over the world- no. Wasm is a fantastic new addition to frontend development (though not limited to the frontend) - being able to convert images on the client side using ffmpeg, or supply datasets to the client as an Sqlite database opens up some mind-blowing possibilities. It's an enhancement we can use to create end user experiences, not a replacement for Javascript.
TS is super useful. But even if you're using vanilla JS, use the TypeScript compiler to type check your code. There's a huge chance that you're using some kind of compiler/bundler anyway, so there's literally no downside of usingtscas well.
I'm not just a developer, but also a user of applications. I've seen hundreds of bugs in plain JS code bases that would have been easily eliminated by TS.
Everytime I use some application that's busted I have to wonder if it's one of the issues I've seen myself that flat out would not exist in a TypeScript code base. I have to wonder if this application isn't working because some developer wanted to keep things easier for themselves.
TypeScript may be more difficult for you to use as a developer, but by avoiding it you are simply passing on that pain from yourself to your users. TypeScript doesn't solve every issue, and it can even introduce some issues that might not exist in a plain JS code base, but that is a mindboggingly small set of issues in comparison. So don't be that lazy developer.
I love the freedom JS gives me, no other languages feels that way. TS just take that freedom away.  Write pure JS could be buggy, but there‚Äôs ways deal with it and I think buggy is part of the fun why I love coding.
When you get comfortable with JavaScript types it's never really an issue.
I should learn TypeScript but I honestly don't think I need it. If it was built in to browsers, and if it didn't just make transpiled JavaScript, and if it was not a Microsoft product, maybe I'd be into it. I love typed languages but I also learned how to program a lot in ActionScript, PHP, and JavaScript, so I'm really comfortable with dynamic typing now.
Types should be built into the language. C# supports var for dynamic vars, why can't JavaScript add int, string, etc?
Lol what's the problem with Microsoft? Are you one of the weirdos that don't use VScode?
Javascript can't add these becauae that wouldnt be backwards compatible - so TS does it and transpiles.
"i dont think I need it" - is what people say about basic math too. Any big project benefits from typescript
I'm not a fan of typescript. It feel like an typesystem forced on an language that was intentionally designed not to have one. Don't get me wrong. I like my language typed but not enforced in an way that feels syntactically awkward and strange. It feels for me like it does not belong there. If I want typing that badly for some enterprise Software there its better to have an typesystem I will rather use an actual language that is designed for that. E.g. everthing thats bigger and really benefits from an type system is better placed in Dart for example and than transpiled down to js. It feels way more appropriate and right because its designed for that.
IMO, being build around js forced the ts devs to make a fairly flexible and powerful type system, and that flexibility and power is useful even if you aren't trying to type random js libraries.  It's honestly my favorite type system this side of haskell or f#.  Being built on js does mean that it inherits some really awkward js warts, but I still genuinely like it compared to most non-js languages.
Yeah exactly.
Being able to create types from other types usingkeyof+typeof+ allthe utility typesis extremely powerful + ergonomic.
I've also become a big fan of string template literals to define things like hardcoded domain names, email addresses etc without having to convertuser@example.comto some code/token-friendly enum/key or whatever likeUserAtExampleDotCom(then also requiring even more code to convert back-and-forth).  I don't know of any other languages at all that can do this (typing of literal string values), where the exact string is shown verbatim everywhere.
I really miss this stuff in other "proper" statically typed languages, where you usually need to resort to a lot more manual writing of similar types, or using codegen/macros etc.
Of course not having proper runtime type checking by default is a big downside most of the time, but on balance for most of what I do, it's an ok compromise for all the power that the TS typing system has given us, which pretty much only came about specifically due to it being a transpiler for JS, rather than its own language + runtime altogether where these features never would have "needed" to be conceived in the first place.
It will be interesting see what future languages can takeaway from TS re some of these features.   Some language that had proper static type checking at runtime, but somehow also included all this stuff that TS has specifically because it isn't that.
That, and linters care of most of the warts too. Still not perfect, but really enjoyable. I agree that the type system is my favorite I‚Äôve used.
If you got some time check out Rust's time system :3
Very long time Java and .NET dev. Took a look at TS long time ago, pretty early, not impressed. Just started working with TS again this year (SvelteKit) and now I totally love it. Using WebStorm, Capacitor.
Basically it boils down to the ease of use and enforcement of the types. The ‚Äúsprinkle a bit of TS and use any a lot‚Äù version of TS is grim.
There are a lot of types I can express in TS that are basically impossible in Java or C#.
Very long time Java and .NET dev
Same here, 22 friggin' years of C# alone.
Ihatedworking with JavaScript, especially before ES6 came along.
TypeScript was like a gift from the gods.   Seriously.  It made large-scale web developmentsomuch better.
I am the lead on an Angular project and have turned on the strictest possible ESLint rules, so things like "no-explicit-any".
It just makes everything much, much better.
It‚Äôs one of the main reasons I moved from a b/e to a f/e role: its type system is by far the best I‚Äôve worked with. Lots about JS I really don‚Äôt like but Typescript is so good it makes those things bearable.
I think it's genuinely good, having to jump around to other languages is a nice reminder of how far the type system has come.
Would be nice to have variant types, first class generics and do away with some hidden control flow (throws aren't captured) but there's not a whole lot I'm desperate to change really.
I really like TS as a language. Some of that is because I actually quite like JS (ES6+ that is), and some is because its type system is very good. Structural typing rocks.
I've worked with C++, Haskell, PHP, Go, Python, and a very little bit of C#. Of these, TS is my go-to as a language. I just wish the ecosystem were less of a mess of transpilers and bundlers!
It's a genuinely good language, and if it's hated, it's because of JS
If you know what you‚Äôre doing the type annotations aren‚Äôt much of a burden and you won‚Äôt be stumbling around in the proverbial dark with regards to avoiding type errors.
Maybe bringing arguments would help creating the start of a discussion.
I start: TypeScript can be added on top of a project and still handle JS files. You can incrementally bring more type safety into your project. TypeScript being a superset of JavaScript, you can only discover bugs at transpile-time. Having TypeScript in your JS project is therefore a good idea.
Of course, there are alternatives: using JSDoc for example.
Skill issue
In reality, you've replaced the problem of clearly seeing the data types moving around your program
What? How can can you see data types moving around your program in javascript, which lacks type annotations, more clearly than in typescript, which has them?
managing a TypeScript implementation, which is clunky and overly complicated
Don't overcomplicate it then?
For example, spending an extra 1-2 hours just correcting type errors that don't matter.
Why do you spend 1-2 hours on correcting type errors that don't matter? How do you get those type errors in the first place?
Until you have to scale to a codebase of tens of millions of lines of code in an organization with hundreds to thousands of engineers who need to build libraries and services that support tens of billions of dollars of annual revenue.
Strong typing and bulletproof tooling support is table stakes.
Hard disagree. TS catches a lot of subtle errors for me. I get that it makes the code a bit less readable, but it‚Äôs worth it for not spending hours dealing with annoying bugs.
Work on a 10 year old code base that was originally CoffeeScript, then ES6, now mostly TypeScript.
If you are a lone developer it doesn‚Äôt matter what you use but TypeScript has helped us tremendously as a team.
Also, it doesn‚Äôt take us 1-2 hours to get types correct. Typing adds almost no development overhead once the project is set up.
We have a lot more issues with ESM. üò≠
This is more of an uneducated opinion than an unpopular one. If you are struggling to fix type errors then that sounds like an issue with you, not the language.
This opinion is unpopular because it's wrong. You are exchanging type checks for bugs at runtime, but since those don't show imediately when you're writing code you don't account for them.
Anything bigger than a simple script or very minor app needs typing because humans quickly become inconsistent, forget stuff, miscommunicate, teams change, etc etc. Human memory is trash.
For example, spending an extra 1-2 hours just correcting type errors that don't matter.
Examples?
Ive worked with non TS JavaScript for six years and never experienced a situation in which I though TS would provide some missing value.
So in those 6 years, you'veneverhad "cannot read property from undefined" errors?
Also scrambling to find what data type the API is sending back in responses, I cannot imagine my life now without TS.
If I need to pick just one feature why TypeScript, it would be discriminated unionshttps://mkosir.github.io/typescript-style-guide/#discriminated-union
They are the answer to so many questions.
On top of making development easier and faster (it sure does), it forces you to handle every change when refactoring or updating libraries.
I regularly have to work on old projects. It‚Äôs crazy the amount of bugs that are in existing codebases that are raised and solved when you turn on tsconfig rules.
I have mates that are okay with working on JavaScript instead of Typescript but I pity them.
Also, it frees the brain from some concerns. You just have to write some things down (the typings) to free some mental energy that you can direct to actually solving stuff.
When to use it: every single time.
If your really concerned then why not just use annotations
Less to type (heh) with Typescript.
Also, I'm not sure if annotationsenforcethe proper types to be used in e.g. function calls, and I'm pretty sure JSDoc doesn't, while TS compilerdoescomplain if the proper type hasn't been provided (sometimes annoyingly so).
why would you pick typescript instead of a strongly typed language
That's more like mixing apples and oranges... If I have to work with a JS codebase, I'd use TS every day, it simply takes a big (mental) load off my back. Also, on frontend, you don't really have much choice in the matter. On backend you have many more options/alternatives (Go/Java/C#/...), but if you choose Node as your backend platform, using TS instead of plain JS will again reduce the mental load you need to carry. And anyway, if you really, REALLY need to use plain JS, you can tell the TS compiler to look the other way, but that should happen VERY rarely.
I also questioned the need for Typescript. I started using it, and I would literally never go back. I sometimes have to teach vanilla JS and my god I don‚Äôt like it anymore.
just use annotations in a way that indicates method arguments or data structures
That's a really good description of what typescript is.
You can pry the rigidity of mostly-safe typed code out of my cold dead hands. Since moving to TS I've never had to go chasing some random hidden null value, or a number which I thought was a string etc...
He's not eschewing IntelliSense-supported programming, because he does advocate the use of annotations to that end.  I think he's just not familiar with the many use cases of static typing beyond formal parameter and return types checking.
If you don‚Äôt see the importance then it might be because you have never been in a large project
Bingo.
You're passing it for a reason so will usually know what it is in the object at least type-wise.
This quote is a dead giveaway.
This person has never had to learn someone else‚Äôs application.
TS means I don‚Äôt have to rely on code review and a QA department to find out if my jr‚Äôs thought about handling the case where a framework function might return null.
As soon as the codebase is bigger than fits in your brain at once, TS is your best buddy. It knows what you forgot. And it‚Äôs such a good buddy. He deserves belly rub and some bacon ice cream because he is such a good boy.
This guy fuckin get it.
First, convince me your novice js is well written.
There are so many reasons, but I feel like you've already made up your mind? If you're struggling with typescript might I recommend a playlist on YouTube called "No BS TS" by Jack Herrington? It's very good and you might find it an easier onboarding than struggling with typescript type errors (which are, I admit, not very pretty - there is a vscode extension you can use called prettier typescript errors which will make them a tad more human readable).
If you actually want a reason, I could give you about a million different ones in the 6-7 years I've been developing but ultimately it comes down to narrowing the problem space in order to reduce the chance / likelihood that a bug can occur. If I have a function, and I've typed that function, then I've thought AHEAD of time about this and hopefully implemented this function correctly in order to accommodate the types for e.g. what I'm going to return, or what I'm going to accept as an argument. If I DON'T have this there is a massive unknown that's immediately been introduced.
Programmers are people, and people are not perfect, and they will make mistakes and call your function with the wrong arguments, or they will use the result of the call to your function without handling a possible null / undefined. Maybe I return a promise and they forgot to await it. In JavaScript land you don't know, there's no help from the compiler saying "hey, this value might possibly be undefined so make sure you handle that situation".
A lot of bugs are just unhandled type errors. Typescript helps you catch these, before your users are complaining to customer support about why they can't remove items from their basket.
It's a fucking nightmare working in a repo that just uses JavaScript because you have ABSOLUTELY no idea what anything returns or accepts as arguments. You are not just working with your own code, but very very old code that many people have added and amended and introduced subtle gotchas into over time.
JavaScript is an absolute minefield, and typescript will help prevent a lot of very insidious bugs that you don't want to be resolving at 2am when production goes down.
The typescript LSP is amazing, and you don't feel absolutely blind when writing code with it in comparison.
You have auto-complete with typescript because you have... Types?
You will have less stupid bugs.
Your code will be more readable/maintainable because you can indicate intent, whilst also narrowing usage.
Did I mention less stupid bugs?
If I created a <RandomThing> component, I would never know I needed to pass in x, y, z props until I ran it. I also wouldn't be able to easily tell what optional props it takes. With typescript I do.
Other than what people have already covered, one of the big things is how it really improvesrefactoring.
Refactoring in a JavaScript project is often a source of undetected errors, as it's really easy to overlook the use of something you've changed.  You can try and remember all the places, repeatedly run it and see where it breaks, run your tests (which also need to be changed) and see which fail, etc. But there can be gaps.
With TypeScript you make the change, then instantly your editor shows you all the places you need to fix.  It makes refactoring not only quicker and easier, but much more reliable.
When you're developing commercial software, there can be a lot of iteration due to client changes.  You might switch to other projects for weeks, months, or even years before coming back to make major changes to your code.  It might be someone else making the changes to your code.  You won't be able to remember all the uses and will need to re-learn your codebase.
So having a type system really just makes all that much easier and overall is actually a net time-saver, though I do appreciate it doesn't feel like it when you start out.
You're getting 'type errors' because your code is wrong.
You're spending a lot of time debugging type errors because you're inexperienced and are unable to understand why your code is wrong.
For developers that know what they're doing, TypeScript is a valuable tool that actually makes them faster and saves a ton of time.
Luckily for you there are plugins that canhelp you understandTS errors without actually reading the docs.
I‚Äôll go in a slightly different direction. I‚Äôm not a diehard statically typed advocate (most of my experience is with ruby, JavaScript, elixir, and clojure) but more recently have been writing lots of go and typescript.
I‚Äôm not going to try to convince you statically typed is ‚Äúbetter‚Äù but one major benefit is the developer experience. My god, it is light years better when using one of those languages and that alone has made me use TS for every project moving forward.
Hi there! I work on the TypeScript team and I respect your feedback. Of course I do think TypeScript is worth it, and I'll try to address some of the points you've raised with my thoughts.i. Dependency management is indeed frustrating. TypeScript doesn't create a new major version for every more-advanced check. In cases where inference might improve or new analyses are added, we run the risk of affecting existing builds. My best advice on this front is to lock to a specific minor version of TS.ii. My anecdotal experience is that library documentation could indeed be better; however, that's been the case with JavaScript libraries regardless of types.iii. Our error messages need to get better - I'm in full agreement with you. Often a concrete repro is a good way to get us thinking. Our error reporting system can often take shortcuts to provide a good error message when we recognize a pattern.iv. Compilation can be a burden from tooling overhead. For the front-end, it is usually less of a pain since tools like esbuild and swc are making these so much faster and seamless (assuming you're bundling anyway - which is likely if you use npm). For a platform like Node.js, it is admittedly still a bit annoying. You can still use those tools, or you can even use TypeScript for type-checking `.js` files with JSDoc. Long-term, we've been investigating ways to bring type annotations to JavaScript itself and checked by TypeScript - but that might be years away.I know that these points might not give you back the time you spent working on these issues - but maybe they'll help avoid the same frustrations in the future.If you have any other thoughts or want to dig into specifics, feel free to reach out at Daniel <dot> MyLastName at Microsoft <dot-com>.
Thanks for your work, TS saves me time every day. I was saying something similar to the op 3-4 years ago but really cannot picture working without some kind of type safety in JS now.
> TS saves me time every day.Hmm, not my experience. I do TS for years now and still today I'm spending more time on fighting/pleasing TS compared to the actual code.JS with all its node_modules dependencies is a complete nightmare to get the typing right. I regularly have to change good solid code to please TS, but at the same time TS often doesn't complain when the typing is obviously wrong.I once started with Assembly, Pascal, C and C++. So please don't start to explain to me what strict typing is and the benefits and so on, I know. JS uses dynamic typing by design. And I remember how awesome it felt when JS came out and we could write code without doing type juggling. And I believe that with type inference and some other tooling in the IDE we really don't need TS at all.
I‚Äôm noticing a pattern in your arguments.You need to understand that I (and I suspect many others) don‚Äôt have the same experience as you. I don‚Äôt _fight/battle with_ the type system, I work with the type system - and I enjoy it. It saves me countless hours. I don‚Äôt actually use javascript without TypeScript anymore - it‚Äôs simply not worth _not_ using it - for me.You ask whether it‚Äôs worth using it - and you keep telling people not to explain the primary benefits to you. The answer is yes for many people. It seems like you‚Äôre looking to be convinced that it‚Äôs worth it but you don‚Äôt want anyone to tell you what you already know. I‚Äôve done this myself in the past - I‚Äôm not saying the situation is the same for you but it might be worth looking inside at: when I did this it was because I knew that x was worth it but I‚Äôd put myself in a position where getting down off my hill and accepting that x was worth it would require me to admit that I‚Äôd been wrong about it. Now I could double down on my position that x was simply not worth it, or I could come down slowly and start to enjoy the benefits of x more openly.If you kinda feel that what I‚Äôve just said might be a factor for you, then that‚Äôs already incredibly brave. If you‚Äôre interested in taking it further I can recommend role playing: for a week (just a week) role play as someone who thinks x _is_ worth it. Adopt the positions on the benefits that you already know. Act like you love it, act like the type checker REALLY helps you and saves your time, act like the types aren‚Äôt all that bad and CAN be used in usefully-constricting ways, and of course, help make your code even more self-documenting. You‚Äôve gotta convincingly act, as if you‚Äôre going to win an Oscar. The audience fully believe you‚Äôre a true, light-seeing advocate for x.Being able to change your mind is a great, noble and immensely valuable skill, and I can see that‚Äôs what you‚Äôre trying to do. Consider role playing as an advocate like I suggested above and perhaps you‚Äôll have a new tool in your toolbox.
> a pattern in your arguments> You ask whether it‚Äôs worth> you keep telling peopleI just want to point out that the account you're replying to isn't the OP.
It sounds you are essentially recommending therapy for those who don't like TS.
SM people enjoy their pain too ;-) Typescript for "Consumer" is great, but as soon as you must write own complex typings, that is everything, but really not a joy.
> I do TS for years now and still today I'm spending more time on fighting/pleasing TS compared to the actual code.Admittedly, this mirrors my own experience, at least in some cases, which I shall not deny.Was called in to help with this one particular TypeScript codebase that used React a while back, it was a mess. I suspect that some of the chosen abstractions were overengineered and overcomplicated (and perhaps underdocumented), but at the same time TypeScript made things more finicky and as a result the development velocity tended to be on the lower side of things, when compared to similar projects with JS. This was especially noticeable when new developers needed to be onboarded, though at the very least refactoring could be done with more confidence. Essentially they were not dealing withjustsub-optimal code structure/architecture, notjustthe ever increasing complexity of React, butalsohow it all integrated with TypeScript on top of that.It's a bit of a double edged sword, because when done right, TypeScript is objectively better than JS in at least some regards (refactoring for one, the type system obviously but also how well IDEs can figure out autocomplete because of it, or highlight issues that would otherwise manifest at runtime only with JS), however there is also potential for things to get much worse than your typical JS codebase, when done wrong.This might be a silly comparison, but I'll compare it to something like PHP: when used correctly, you'll get something that lets you iterate pretty fast and just ship stuff, whereas if you go about it the wrong way you'll probably have a badly developed unreadable mess that's full of bugs or security issues, for a variety of reasons. In my experience, TypeScript codebases range from very good to very bad, whereas JS tends to be more mediocre in general, at least in regards to complexity and iteration speed. In regards to maintenance, TypeScript will win in most cases.Use TypeScript responsibly and you'll have a decent time. Give it to someone who wants to be clever about things and you'll have lots of accidental complexity to deal with, more so than with the alternatives. Then again, personally I think that Angular did TS better than React or Vue, so this might be a niche view in of itself.
Sharing your experience is fine. Rebutting someone saying ‚Äúthis saves me time‚Äù, much less in a comment where they‚Äôre thanking someone for something they help make, is a bit ridiculous.
>I remember how awesome it felt when JS came out and we could write code without doing type juggling.You enjoy working with dynamic typing. It more aligns with how you think and program. That's okay!TypeScript may never be worth it, to you, and that's okay too! Not everyone likes and appreciates static typing.If you ever do come to the datk side and think TypeScript is worth your time, it will be because that part is not a time waster but a time saver.
> Hmm, not my experience. I do TS for years now and still today I'm spending more time on fighting/pleasing TS compared to the actual code.What are you doing exactly? I like TS, because it's one of the easiest to use type systems.I'm also intrigued that you used C++ and think TS is bad, C++ error messages are legendary for being hard to understand.
What's Math.sqrt("hello")?
I use TS daily and I think this sort of argument doesn't give TS the credit it deserves.Sure, you _could_ use it to check that you aren't making obvious errors like this (but this seems constrained to the "convince me that it's worth it" level of functionality, as it is just a nice-to-have for an existing working pattern).Where TS shines for me is that it ENABLES new ways of "ad-hoc" coding where it's no longer risky to just create "convenience objects" to represent state when prototyping/refactoring, since you can avoid specifying concrete required types across a load of middle-man code and compose types at each level. This enables the pattern of splatting (composition over inheritance) a bunch of inputs to your data together, and then routing them to the points where they are needed. This scales nicely when you introduce monadic fun (processing some data with children, or something delay-loaded) since your type constraints basically write the boilerplate for you (I'm sure co-pilot will make this even more so in the far future).There's also the fact that your can have your back-end APIs strongly typed on the front-end via something like GQL or Swagger, and this saves a TON of time for API discoverability.
Or 5/"potato"In JS it's NaN, in TypeScript (or any other language with a remotely sane type system) it's a compilation error that saves you from running into a random NaN at runtime.
Please make your substantive points without breaking the site guidelines.https://news.ycombinator.com/newsguidelines.html
What's Math.sqrt(value_from_a_package_that_was_definitely_a_number_before_you_updated_it)?
So then you have to make sure any inputs that get passed into Math.Sqrt aren't strings. You can pay the cost at runtime or compile time, and doing it at compile time saves you headaches later.
I agree that is not a good example, but the exact same thing can happen in more subtle ways that is hard to catch. For instance you might have a function that returns a user. Do you pass in the user ID argument as a string or a number?
>I agree that is not a good exampleIt's actually a great example, because in JS Math.sqrt("4") returns 2 because of JS's idiotic type coercion rules. So if you're passing in user input and don't typecheck it, it will work fine until someone inputs a letter instead of a number.
You won‚Äôt get far with attitude like that.
You know you can just use transpileOnly option and ignore some errors? I use it like that and it‚Äôs helpful to model data and speeds up development.
Assembly? No types there, just registers. The only distinction is floating point and non-floating point registers.
If you're just looking for general feedback, constructor typing has made my life really hard trying to type an existing JS library. In a JS object instance like `const user = new User()` you can call `this.constructor.staticMethod()` and it calls `staticMethod()` on `User` or up the inheritance chain. But TS doesn't type `.constructor` so you're out of luck. In the simple case you call `User.staticMethod()` but that doesn't work for an instance method on a superclass that wants to call the method of the constructor of the instance.I understand why JS makes this difficult to type because you can mess around with the constructor. But for normal every day code you just expect `this.constructor` on an instance of `User` to be `User` and it really sucks that it isn't!
> you can call `this.constructor.staticMethod()` and it calls `staticMethod()` on `User` or up the inheritance chain.This is where I have come to like typescript. 4 years ago, I would have agreed with you, but TS have moved me into a world where I wouldn't write that kind of code any more, and it honestly makes me sick to look at.Instead I would just do `User.staticMethod` because this accomplishes several things:- super classes shouldn't know about inheriting classes. If they do, TS gives you interfaces and abstract classes for this purpose.
  - it still crawls up the proto chain, so the inheriting class doesn't need to know about every super class
  - no risk in `this` pointing to something unintentional (if someone calls or apply's your method)
  - shorter code, easier to read IMO, especially for less experienced devs
I might agree with you but sometimes we have to type up JS code that is written in different styles to what we'd personally prefer. TS should (a) let me generate the types that are used in JS. There are areas like proxies where that's just not possible, but in this case it feels like there's a disparity between TS and JS over classes. (b) I want to work with this code in my editor without red lines all over the place on perfectly valid code.super classes don't need to 'know' about the inheriting classes for static inheritance to work. i.e. here is a simplified problem in the library I'm trying to add types to:superclass:static hasField(name) { return false }
  constructor() {
    if(this.constructor.hasField('id')) { ... }
  }subclass:static hasField(name) { if(name === 'id') return true; }(it doesn't really look like that but you get the idea). That just works in JS, but in TS you get `Property 'hasField' does not exist on type 'Function'`. In the TS definition there are a couple of ways I can trick it to return the right thing for `this.constructor` but if I'm looking at a JS file in vscode with TS' checkJs flag on then this pattern should just work in my opinion.edit: And I don't think I should have to trick it, that makes the definition harder to read and essentially wrong somehow.
Great of you to hop in. Just want to say that while I can typically navigate error messages in TS, I do occasionally have to do some googling on some error messages (specifically ones around generics that have a super type that apparently doesn‚Äôt necessarily agree with a subtype or something ‚Äî still don‚Äôt quite get it), and it‚Äôs nice to see that the TS team recognizes the obtuseness of these messages is an issue.
TS#### error messages was a brilliant idea to make them more ~googleable~ bingable at least.
Isn't that pretty standard for compiler error messages? The C# compiler uses CS\d{4} for example. MSVC, MSBuild, various other build tools (at least on the Microsoft side) all use similar patterns with different prefixes.That being said, it seems like Clang or GCC don't do that at all, which perplexes me a bit. Perhaps it doesn't matter much when error messages are never localized.
I guess TypeScript and C# having Anders Hejlsberg in common probably helps with things like that?
(A bit )off topic - chatGPT managed to infer your email address based on this comment. Required some hints though - most likely due to my lack of experience (first try).
I was curious to see how it can improve indexing in general.
Thanks for responding, and thanks for your work for the community! I sometimes place myself in the shoes of devs building TypeScript, especially when I am a little frustrated, and most of the time I realize that a lot of these issues are incredibly hard to solve.> i. Dependency management is indeed frustrating. TypeScript doesn't create a new major version for every more-advanced check. In cases where inference might improve or new analyses are added, we run the risk of affecting existing builds. My best advice on this front is to lock to a specific minor version of TS.In my recent case, I needed to update Apollo Server to v4, which needs a newer version of TypeScript (seehttps://www.apollographql.com/docs/apollo-server/migration#t...), which in turn broke a type used from ProtobufJS. I am still navigating ProtobufJS source code to figure out what is the correct fix here.> ii. My anecdotal experience is that library documentation could indeed be better; however, that's been the case with JavaScript libraries regardless of types.Actually I think documentation is almost universally bad, I don't think Go or other languages are that much better (I don't want to wade into that debate though). The thing is, having TypeScript means you need more documentation. Even some pretty well documented JS/TS libraries completely neglect TypeScript and the end effect is that you end up having to guess things, or start reading source code. I don't actually know how you could improve this situation.> iii. Our error messages need to get better - I'm in full agreement with you. Often a concrete repro is a good way to get us thinking. Our error reporting system can often take shortcuts to provide a good error message when we recognize a pattern.I will look closer at this and start to think of how it could be better when I see a confusing message. I would probably count this as the biggest area that could yield improvement, because most of the time frustration is born of not being able to understand an error message. Often fixing things lead to trial and error. Can I just open an issue in the TypeScript repo for this sort of thing if I have a concrete suggestion?> iv. Compilation can be a burden from tooling overhead. For the front-end, it is usually less of a pain since tools like esbuild and swc are making these so much faster and seamless (assuming you're bundling anyway - which is likely if you use npm). For a platform like Node.js, it is admittedly still a bit annoying. You can still use those tools, or you can even use TypeScript for type-checking `.js` files with JSDoc. Long-term, we've been investigating ways to bring type annotations to JavaScript itself and checked by TypeScript - but that might be years away.Once it is part of the language, that will help a lot :) I considered using Deno or Bun to get me there on the server side, but need to be careful with production services.
Re libraries incompatible with certain typescript versions - e.g. protobufjs fix - it‚Äôs been my experience that you want to try and only use compilers specific to each library and compile libraries separately. It‚Äôs unfortunate but the JS community often tries to run all JS for a project through the same single compiler tool chain, using one global version of the compiler instead of relying on and effectively linking the JS output for each library. Unless you routinely rewrite third-party libraries to match your toolchain‚Äôs expectations, you‚Äôre going to have a hard time doing that.For a library that generates code, that‚Äôs a special case, as the code it generates must target a particular language version. You have three choices: 1. Upstream a fix as you propose; 2. Side-by-side install both TS 4.6 and TS 4.7 using workspaces or sub-projects and have some of your code compile with 4.6 and then link the results or 3. Find a replacement that is updated to 4.7. For example,https://github.com/stephenh/ts-protohas 4.7 support listed in its readme.
We do generate the protobuf from a different repo which gets published on npm, and we could generate it for different versions of TS. I suppose all of this work is part of the overhead I am not so happy about using TypeScript.
This is a very interesting idea!
> Actually I think documentation is almost universally bad, I don't think Go or other languages are that much better (I don't want to wade into that debate though). The thing is, having TypeScript means you need more documentation. Even some pretty well documented JS/TS libraries completely neglect TypeScript and the end effect is that you end up having to guess things, or start reading source code. I don't actually know how you could improve this situation.I think Rust approach is the best one so far, every package published in crates.io has an entry in docs.rs (that is created automatically when you publish your crate in crates.io), so I think Microsoft could improve it for every package published to create an entry in a domain specifically for js docs, if a project does not have it will look empty, but slowly the devs will start adopting it at the point that major libraries will improve the docs compared to what we have today.
> Can I just open an issue in the TypeScript repo for this sort of thing if I have a concrete suggestion?Yes. There are even issue templates to guide you through writing an issue that the team will be able to address effectively.
>Once it is part of the language, that will help a lot :)If you want to follow along, the proposal to allow type syntax to be part of JavaScript is here:https://github.com/tc39/proposal-type-annotations(To repeat Daniel, there is still a huge amount of work ahead)
> Can I just open an issue in the TypeScript repo for this sort of thing if I have a concrete suggestion?aozgaa has already answered this one - but yes! If you have a concrete suggestion, that's fair game and we can brainstorm on the issue to think of something. We might not come up with something general enough to implement, but it's often a good seed to plant.> which in turn broke a type used from ProtobufJS.I am curious to hear what sort of issue you ran into. Was this the Apollo fork (https://github.com/apollographql/protobuf.js), or the original?
It's the original, which is being compiled on our internal protobuf definitions in a different repository and then installed post compile as an npm module.I spent a while trying to grok the TS error but started to suspect that it didn't make a lot of sense, so I rm -rf node_modules, reinstalled, and it went away.It would be hard to figure out what was at fault, but it's probably a combination of the node module system, protobuf, ProtobufJS and TypeScript. I do sometimes get funny type errors and restarting TypeScript makes them go away, in this case I had to go a step further.I'll let you know if I get this again, or figure out what happened.
I'm old enough to have worked on two different large enterprise applications which predated TypeScript and it was a nightmare.Personally I've found that JavaScript lends better to a functional style of coding but there are no protections in the language to enforce this and both codebases I saw had a weird mismatched set of object oriented and functional style principals.  Defined classes, prototypical inheritance, modifying the prototype chain directly, a factory pattern here, a weird "constructor" there, just figuring out the shape of the data was difficult to do.The lack of guardrails in JavaScript also empowered people writing "clever" code which technically works but was insanely hard to parse and understand, especially when you're 20 function calls down a stack trying to understand what's happening.I agree the TypeScript compiler's error messages are confusing but you should have see the types of stack traces JavaScript produces.
I worked many years before TS too and happened to have been working on very neat codebases back then, though I did have the luck of working with a really talented set of people.I conceed that perhaps you are correct about this - it does force people to write less strange code. JS gives you so much freedom that if you don't keep it simple you can really hang yourself. However if you put care into your code and keep it simple, I don't think TS helps all that much.There have also been situations where I have had to do something a little bit strange, and TypeScript made it an absolute mess. And if you do enough JS you'll know that sometimes you do need to write a function that needs to leverage dynamic typing pretty hard, even if it's quite rare.
IMO TypeScript nudges you away from bad patterns. If it‚Äôs a mess to type it, it‚Äôs probably a mess in general.If you are in a very rare situation and think you know better then there‚Äôs ‚Äúany‚Äù, although at that point you really need to think ‚ÄúI‚Äôm risking runtime errors and this code is confusing, is it worth it or is there another way?‚Äù
> I agree the TypeScript compiler's error messages are confusing but you should have see the types of stack traces JavaScript produces.Non-transpiled js produces fairly sane and useful stack traces. Its just a shame that non-transpiled js is so rare these days.
They might‚Äôve meant the type errors, rather than runtime errors. TypeScript‚Äôs type errors can get flat out unreadable when you‚Äôre dealing with moderately complicated types. Even errors with generics can get ugly.That said, I still love TypeScript
> especially when you're 20 function calls down a stack trying to understand what's happening.Yeah I hate code like that too, but it's not clear to me how type checking would help.
I think type checking helps with that both directly and indirectly.It helps directly by making it much easier to know what type or shape everything is. Without types, all you have are variable names and tracing the code back up the stack yourself. Sometimes good naming conventions are enough. More often than not, a variable called `product` can be one of 3 different types and you have no idea why unless you go up the call stack to figure it out.I find it also helps indirectly by making clever code harder to write. The dynamic nature of JavaScript encourages a degree of cleverness and meta-programming that makes things harder to understand. While you can do the same in TypeScript, making the complier happy makes it much harder to do so, which encourages more straightforward code.Of course, you can write clever type definitions that are impossible to follow. Sometimes you do want to do some meta-programming without fighting the compiler. But in my experience, the path of least resistance when writing TypeScript is fairly straightforward OOP that tends to lead to clearer code.
> I find it also helps indirectly by making clever code harder to write. The dynamic nature of JavaScript encourages a degree of cleverness and meta-programming that makes things harder to understand. While you can do the same in TypeScript, making the complier happy makes it much harder to do so, which encourages more straightforward code.Interesting.Not having to define types makes JS feel very fluid to me when using it to jump into a problem and quickly test out ideas.You can figure out solutions fast, and I suppose with that power comes irresponsibility for those who don't care to clear up the chaos they are able to leave behind in the fast iterations towards discovering the implementation they seek. In short - it takes discipline, and your argument it seems is that typescript enforces a certain degree of discipline... pros and cons to both.
I just can‚Äôt get behind the dynamic typing arguments in the slightest anymore.It doesn‚Äôt take any time to type your code. We‚Äôre talking seconds on the hour, and the benefits are huge
It's not necessarily about the time it takes to type the type definitions.
static typing leads to developers trying to represent the "real" world in a bunch of categories and arbitrary boxes. Thats not necessarily a good thing because you can loose much time in bike shedding discussions like "Is a person class still a valid person class if it has no Surname" which do not provide actual value to your product.
Recommended watch:https://www.youtube.com/watch?v=YR5WdGrpoug
> "Is a person class still a valid person class if it has no Surname"At least you then know the answer to this while writing code rather than at test time, or worse in prod
You don‚Äôt need to do runtime inspection to see what the structure of everything is if it‚Äôs well typed which reduces the mental burden when debugging deeply nested problems. You can also be reasonably sure that there isn‚Äôt a different call stack with an entirely different structure lurking out there which also helps with confidence in pin pointing problems.
All code has types, even if just implicitly. All typescript does is make sure you are consistent with your own usage.
Because you don't have to use the debugger or mentally map the code all the time to see the (actual) shape of the objects at any point in the call chain?
Nothing prevent you from writing mixed paradigms code with TS as well, you still can mix functional and OOP, factory and direct modification to prototype chain, all that and more..
>I want to skip over the static typing benefits argument, because I think it is well understood that static typing is a good thing and if we could bless JavaScript with a built-in and robust typing system then I don't think many people would be against that. My issue is with the amount of extra work it places on developers, much of it the "dumb" kind of work which can eat up hours and doesn't deliver all that much value.If I take your questionprima facie, then yes it's still worth it, since you seem to be dismissing the main reasons people use TypeScript, the static type benefits, and the bulk of your arguments seem to actually be about how TS can improve, not why one should throw out TS wholesale, which I personally would never do.In other words, you're focusing on the 20% BS out of the 80% benefits. Can the 20% be improved? Of course, but I'll take 80% benefits over 0% with JS any day.
Doesn't your counter-argument beg the question whether it is indeed 20% BS vs. 80% value? I think the OP is asking about pretty much that percentage. Personally I feel it's more like 70% BS vs. 30% value. Types, after all, are a very weak ontology, i.e., you still cannot know for sure that just because your code compiles it interprets the values it's getting from other party's code correctly. I would even argue that it may create a false sense of safety -- just think of the Mars satellite that crashed because some developer thought a number was in imperial units when, of course, it was in SI.
You need to parse and/or validate any external input before you declare that a variable or field is a certain type, as you probably should be doing without Typescript anyway. Being strict in what you accept and ensuring that you're not lying to the type checker solves the vast majority of these types of issues.It's been a few years since I worked with TS professionally, but at least at the time, I saw it as 95% value, 5% BS. It provides such plainly obvious value in my eyes that I've decided I'll never write JS again unless it's a single file script or a small throwaway project/PoC.
In my experience, even the one file scripts eventually get converted to Typescript when I realize I cannot specify my types :)
Come on, the OP literally said:> I want to skip over the static typing benefits argument, because I think it is well understood that static typing is a good thingThe OP is interesting in talking about how much of a pain in the ass TS tooling is, and... it's fair to say it's annoying.If you accept that static types are good (and the OPexplicitly said they do), then what are going to do? Basically the OP is saying, "I want static types but not the TSC compiler or ecosystem"; well... it sucks, but you're never going to get that.The comment you're replying to is just saying: "Well, if you want static types, you gotta live with the bad stuff".> Doesn't your counter-argument beg the question whether it is indeed 20% BS vs. 80% value?Nope.
Let me clarify - I pretty much agree with what the parent says -  "it's more like 70% BS vs. 30% value".I do still want that value i.e. static typing, but as you point out I can't get that without the BS. And so I would rather have no typing which is the only other option (except using a different language).
> And so I would rather have no typing which is the only other option (except using a different language).This part is what is so wild to me. I simply cannot imagine throwing the baby out with the bathwater, so to speak, to throw out the entirety of static typing just because of the BS around it. In my experience, static typing is superlative, it would have to be some extremely rare situation for me to give it up.
I spent 6 years programming production JS delivered to millions of people before I went to TS and it just wasn't that bad. The code was clean, and the team didn't ship many bugs - this was for a big frontend and ~12 microservices.Webpack added a lot of overhead - but if you know what came before it, it was a godsend. React added a super complex library, vs Backbone which was only a few hundred lines of code but React is totally worth it.I'm not just trying to hark back to "the good old days", I think the ecosystem is a big improvement from where it came from but I just haven't seen enough benefit from TS for all the work you need to put in.
We have that in the form of ReScript.
Types help prevent a narrow class of errors. They also help with refactoring. They help avoid messy checks getting in the middle of your business logic. 
All of this is more than enough to justify using them.Types do not replace other checks and tests.I don't think the Mars satellite crashed because they trusted the type system.
>Types, after all, are a very weak ontology, i.e., you still cannot know for sure that just because your code compiles it interprets the values it's getting from other party's code correctly.This again seems to be throwing the baby out with the bath water. Just because in some cases types can't be verified does not mean we should fully be without types at all. There are a myriad of ways to mitigate even this,Parse, Don't Validatecomes to mind [0]. Type Driven Development is another way [1], as well as using runtime type checkers like Zod. This article by Kent C Dodds is a really good example of the latter, it covers everything you're talking about regarding unknown types [2].>I would even argue that it may create a false sense of safety -- just think of the Mars satellite that crashed because some developer thought a number was in imperial units when, of course, it was in SI.Actually, that sounds to me like just the opposite case. The dev thought it was in imperial units because they might not have known the type of said number. If the number was instead typed with `ImperialUnit unit = ...`, that issue might not have occurred. Now, if the unit value wasinputtedincorrectly by the programmer, that's a different issue, no amount of typing will fix a business logic typo. As well, if the satellite was fully untyped, issues like these would have occurred far more often, so taking a singular example as a damnation of an entire paradigm doesn't really work.[0]https://news.ycombinator.com/item?id=27639890[1]https://blog.ploeh.dk/2015/08/10/type-driven-development/[2]https://www.epicweb.dev/fully-typed-web-apps
I like TS for the completions and the documentation. I know OP was complaining lack of documentation but knowing what properties a giant object takes, even if those props don't have doc-comments, is still wonderful.What I've been doing is, whenever I'm handed a random JSON blob, I throw it into a JSON->TS interface converter, paste that back into my project, and I never have to question what the heck the server is returning to me again.
> In other words, you're focusing on the 20% BS out of the 80% benefits. Can the 20% be improved? Of course, but I'll take 80% benefits over 0% with JS any day.There are other alternatives outside typescript and javascript,especiallyfor serverside development.
Serverside, sure, I'll agree with you there (I use Rust for my backends).Clientside, I've tried a lot of compile-to-JS or WASM languages and frameworks. They're just not there yet, especially when you run into some compatibility problems, not to even mention library support on the frontend. The reason I like TS for frontend is it's just JS at the end of the day, you can strip out all of the types and it works. Therefore, things like compatibility issues are simply...nonexistent.
I've been working with JavaScript for 20 years. And 5 years with TypeScript. And, well. I still am not convinced.Too much overhead for me. I really dislike typing obvious things and boilerplate. Probably my fluency with JS is to blame. I don't need to see types and autocompletion. If I really need to ‚Äî I just go to the source and inspect the source code, that is how I familiarise myself with the interface. I also think this makes one a better developer.
I think stuff like this really comes down to getting used to and accepting.I had the same views on code prettiers. I thought, aligning your code by hand makes you think about the structure. That you'd invest more time in making your code readable and thus it would be more readable.When I first got to use prettier on a team and accepted it's value, the benefits I perceived were so vast, that my arguments seemed irrelevant in comparison.
Sure! I want prettier for types. So I don't have to manually type the obvious things. The IDEs are smart, but I haven't found one that would be that smart.
I'm wondering what do you mean by obvious things, do you have any example? TypeScript can infer types[0] even through context, and it's even a good practice to let TypeScript do that for you.[0]:https://www.typescriptlang.org/docs/handbook/type-inference....
but wouldn't the static code analysis complain in that example?at least once you want to do anything meaningful with that x
IntelliJ / WebStorm has this exact feature.You can also generate API types based on your backend.
That is cool. Will try that. But the type information the IDE provides to me is sufficient even without TypeScript. So, back again to the question ‚Äî is TypeScript worth it?
I had the same question initially. TypeScript is the way you configure intellisense. Some types can be inferred, but not all, and most of the typing I do is to _restrict_ what data can be used. TS gives you feedback anywhere you ask for it, and paired with IntelliJ I feel like I have superpowers.Another point: You can create types for your API client programatically, meaning your front-end can be aware of exactly what types your backend is returning. This cannot be accomplished with intellisense.
Let's think about what happens on a team: If a single person goes and reads the source code to learn how the public API works instead of simply using the exported types, that's a wasted thirty minutes instead of two - okay, fine, whatever. If all of my engineers have to do this, suddenly each of them is spending that amount individually; and just like that, we've wasted an entire man-day, for nothing.As you declared in your own comment, TypeScript is great for reading, hard for writing. I don't know about you, but my code is read several times more often, and by different people, than written. TypeScript is a no-brainer, time-saving wise.
I am a strong believer that every developer on a team should know how the code works. Emphasis on HOW. You only know that if you go to the source of truth. That is how people become proficient with a skill ‚Äî by doing and re-doing and re-doing things.I disagree that it's wasted time. The time spent investigating how a piece of code works is time extremely well spent.If the code is too difficult to understand ‚Äî of course one can hind behind types.So, yeah, to sum it up ‚Äî I think types are an overhead for a well written piece of code.
If the codebase is small and owned by a few people then it might be true. But when the codebase gets large enough and worked on by multiple teams - it is unreasonable to expect that everyone will understand the workings of the whole application.
I don't agree that typescript makes writing code hard. I believe the opposite-  it makes writing code easier. Editor integrations are a godsend, even the minor things like auto-imports makes writing code easier.More functionally, I also find Typescript's type refinement to help make sure I'm properly using the data and understand the state of it after I've done some checks.
How big is the team that you work with ? The benefit really shines in a large project with lots of devs.
I've also been working in JavaScript for 20 years and TypeScript for 5. You will have to claw TypeScript out of my cold, dead hands. You shouldn't need to type obvious things in most cases, TS should be able to infer it. In my experience TypeScript has prevented many bugs, makes coding more enjoyable, clear and faster, and best of all, refactoring becomes like a super power. I've yet to do a large refactor in a good TS codebase that caused a single regression. The word "good" here is a pretty strong caveat though. TS is only as good as you make it, and overlaying types onto a dynamically typed language (especially manually) can cause issues for sure.
You should try out something like Rescript then. It uses the ocaml type system including its ability to infer all types. You get all the benefits of the compiler enforcing consistent usage of types without having to annotate everything.
When you use TS purely for annotating strings and generic Record<string, any> types, sure. What's the point.Why don't exhaustive matches, unions, and data modelling not get mentioned more often? That's where the true strength lies.
Those are the things I want to use TypeScript for, but it often requires me to adopt the whole ecosystem. I want a middle ground solution; I really just want JavaScript with some parts of TypeScript.
I feel like my JS skills are way above average so I agree with you that if you have the chops then typing obvious stuff just wastes time. However, new developers or those unfamiliar with the ins and outs of JS need help to understand what are they working with. I also feel when a project gets really big/complicated then TS starts to help convey data structures but I think at that point TS becomes the documentation you should have been writing all along. However, the one thing I really don't enjoy about TS is when some library is typed it'll be very strict to the point that valid JS isn't allowed and the invocation of telling TS not to check needs to added for the segment which in turn looks like a code smell. Or the types get to meta-program oriented and I have to start inserting types everywhere instead of them being inferred.
I guess this comes down to personal preference. For me, this is mixing the interface with the implementation. You shouldn't need to know how something works to be able to use it, for me, that's the real overhead. Maybe this works on a small scale, but what if the source code changes?That being said, I do like inspecting the source from time to understand it better, or make up for missing documentation. Sometimes though, with this being JS, I wish that I could unsee the things that I've seen, code that production depends upon, deep within the dependency tree.I agree with the idea of fluency when writing without types, but for me it's not about how fast you can write code. Code for me is a lot of rereading and understanding what the hell you wrote just a few days ago, I find typed code easier to get back into and it's faster to find things that broke in parts of the codebase that you're less familiar with when you change something.
"typing obvious things and boilerplate"That was the center of reservations against TS until I figured out that it's the wrong way of using it. Normally you very rarely have primitive type annotations, or any kind of obvious things, because that's inferable.
"I also think this makes one a better developer."It's a glorified way to put "slowing you down". When you go to your root store key and think about a better name, a single rename action traces all the usages _safely_ down throughout the whole codebase, across packages in a workspace; now compare that with the manual process. No, search & replace doesn't come close to this convenience. Having this kind of refactoring ability at hand makes you speedier, flexible, adaptive, exploring new ideas, and it makes work fun - these in fact makes one a better developer.
By the way, now that I think about it, I could draw a parallel here, remembering another recent thread here on HN:
- TypeScript is easy for reading but hard for writing code
- Tailwind is easy for writing but hard for reading code
> obvious thingsObvious things may not look obvious from other programmers or for yourself sometime in the future or from a code you'd written while feeling asleep.If you'd totally think that's an obvious overhead, just give it "any". Though I never use it.Automatic type mismatch warning and auto completion in the editor feels quite worth the little "documentation" static typing effort.Of course, if anyone is using some basic editors that don't even highlight TS errors in real time, then it feels like a complete waste of time.
For me, it's the tsConfig part, it gets more and more complicated, especially when you work with monorepos, the lack of full config examples in the official doc, they just give you properties and explanation, you have to mix and match to get it right.
As i said before, a lot of people expect that writing typescript is as easy as writing js, which is not. I estimate the typescript tax to be around 40-100% more time, especially if you want to do typescript right and not use `any` all over the place. 
And besides, typescript is a poor fit for someone who is used to writing highly dynamic, lambda based code, which is one of the main niceities of js. 
My guess is that a lot of people with a background in java and c# found themselves writing server side js and were really unconfortable with this paradigm, so they tried again to turn js into what they knew best - an imperative object oriented programming language. 
Now, i'm not saying that types are a bad thing, i for one like typescript especially in projects with a lot of people, but, it's funny to see new people struggling to finish a task that should take a few hours in days.
These estimations are pure imagination. I doubt you have `any` real data to support it. Also, that is not the reason why Typescript was created, nor the reason why people adopt it, not even what Typescript really is. Today, almost every Node.js framework supports Typescript out of the box. I challenge you to provide a modern framework that doesn't provide types. And this is not an opinion, nor it is wishful thinking, it is a fact: type checking and strongly typed languages will take over almost every modern software development paradigm.
I work with typescript everyday. I review prs, i mentor junior devs that are learning typescript. Ofcourse this is my experience, maybe yours is different, if so please tell me about it. The only thing i said is that there is an upfront cost in velocity that people are usually not considering when they are choosing to use ts over js. Sure, that cost may be amortised in fewer bugs and easier collaboration across large development teams. But i see people struggling everyday with specifying correct and complete types. I reject prs, i babysit devs that can't figure out how to type certain code constructs. And if i don't do this the project ends up a mess of anys and ts-ignores which undermines the value proposition of typescript.
I think whatever tax you pay in writing typescript (which, as someone reasonably experienced with it, I believe is none or exceptionally minimal) you easily get back from improved efficiencies of not requiring memorizing the entire shape of your application, looking up in seperate documentation, or a run/inspect/write-code just to see what things are.I think that typescript's type refinement is extremley useful to know whether you've covered all the cases for the types of data as it flows through your system.
If someone cannot reason about types when forced to, I wouldn't want to see their code _without_ typescript.
> These estimations are pure imaginationThere are decades of literature on the matter.You simply have to look for it.Statically typed languages are known to lead to slower initial development times, because languages are inherently more complex and there are more concepts to grasp.usually thy also need to be compiled, which makes times even longer and setups harder.Good news is that long term they tend to be associated with easier maintenance, but it's not totally clear if it's due to static types or the team getting more accustomed to the code base and tools having more metadata to help the programmer.One thing that is unquestionable it's that statically typed languages scale better in large teams.if anything goes well, of course , if you OTOH happen to end up working in places where they use types to build gigantic taxonomies, all the advantages are gone.> Today, almost every Node.js framework supports Typescript out of the boxit doesn't follow that TS is great though.It simply says that people building frameworks want to sell them to the larger audience possible.If they could support Java or C++ or Rust, they would.Many Java libraries or frameworks still support Java 8, doesn't mean Java 8 is the greatest Java out there.
> Statically typed languages are known to lead to slower initial 
> development timesI hear people saying that, but I'm not sure I buy it. Is there any research that supports that, and if so, for which languages?  Also, what does "initial development" mean here?  The first day, week, month, year?  And unless your project is trivial, isn't it somewhat important that as much of the initial work as possible provides a solid foundation for the future of the project so it wouldn't pay off skimping on this?
PDF:https://www.ics.uci.edu/~jajones/INF102-S18/readings/23_hane...see conclusionsintuitively static typing is less forgiving and forces programmers to write code in a specific formthink how much time has been wasted writing Java boilerplate code.
To be honest, that looked a bit thin.  And the most productivity-killing Java boilerplate is hardly due to its static typing but rather the baroque style required by lots of frameworks. It is important to differentiate between language and how people tend to use it.
I converted a few codebases from JS to TS and this takes a surprising amount of time. I won't put out estimates but it's definitely non trivial.> I challenge you to provide a modern framework that doesn't provide typesRuby on Rails
He was clearly talking about nodejs frameworks.
An estimation doesn't need data. It's a best guess. I don't think its fair to call it an imagination. As far as we know that's what he thinks based off his observations.
Strongly typed languages already did take over the software development paradigm. It happened when Java, C++ and C were the dominant languages. Then it regressed back to dynamically typed languages as ruby, php, python and js skyrocketed into popularity.With the advent of typescript and other things like it... types are now back in vogue but for how long?The universe is a four dimensional loop. Programming, like history, like life, moves in an endless flat circle. It's all so predictable... Because This ENTIRE thread represents a precursor to the inevitable and impending oscillation back to the beginning of the circle. Types will fall out of vogue and history will repeat.
> types are now back in vogue but for how long?Probably until startups and organizations that use more flexible languages race past those who strongly type things. Just like in the early days of the web and actually for ~2 decades in which everyone who used loosely typed languages raced past those who strongly typed stuff due to the ease of use and flexibility. If typing was the way to go, already existing typed languages would rule the roost. But they didn't.The end users dont care about any engineering concerns that we have. They care whether they can do what they want with an app or service. And organizations that can ship code fast will keep their strong advantage.
> Strongly typed languages already did take over the software development paradigm. It happened when Java, C++ and C were the dominant languages.C is not a strongly typed language. Did you mean statically typed?
It's definitely "harder" to write TS in the sense that you have to learn more stuff and think about things more, but I seriously doubt it is any slower on anything except the smallest projects.Any time you lose writing type hints you gain back from better IDE support and fewer bugs.It's really a no brainer. I can only assume everyone here arguing against it works on one-man projects using Notepad.
I share your feelings. These times, whenever I'm setting up a new TS project, feel like:1) Look up "this months current way of doing things"2) have a couple of horrible hours wrestling with tooling and the module system3) add a new feature, install 1 lib with 30 deps4) figure out that one dep does not work with TS/the chosen module system/whatever versioning related thing5) go for a walk. scream into the void. come back to the desk.6) browse through dozens of Github issues to figure out what is going on7) decide to fork the according dep knowing that I'll hate myself in 3 months8) ...Yeah, so I'm kind of missing the good old YOLO JS times w/o semi-colons and stuff. But I need to say that I'm usually not opting for NodeJS for deep "OOP-alike" Domains. I think NodeJS' sweet spot is infrastructural things, MQ Consumers, glue code or little http fetching/posting orchestration scripts. 
I never had too many issues without static typing because I intentionally kept things simple, had tests and rolled out updates consciously watching the ongoings.
This is exactly my experience. I think TypeScript is an amazing feat of engineering and one of the best typing systems in existence today, largely because it has to describe such an insane set of hacks common in the JavaScript ecosystem. TypeScript has contributed immensely to the theory of programming languages.But the tooling and the ecosystem arenightmarish! It's skin-crawlingly awful to set up a new project, or to update anything, or add any dependency. This is not TypeScript's fault; not really. But literally everything from the IDEs to the package manager to the output messages areawful. I can even add to your list:8) ignore hundreds of lines of SEVERE SECURITY ISSUES because literally all of them are false positives all the time9) deal with Visual Studio constantly crashing, throwing up 600 "build errors" because it doesn't like the standard DOM typing definitions10) struggle for days to compile and package all the TypeScript files into a re-usable library; give up, and instead set up a script to literally copy the raw *.ts files around.
This is exactly what I struggle a lot with. I just want JavaScript with simple type checking. TypeScript goes way overboard. I also hate TypeScript decorators. I've seen that grossly abused in codebases that just drive my insane.
Maybe we should just jump to a different timeline in which Facebook's Flow won the war against TS
That would have been the best outcome IMO.
I think Typescript isn't worth using, and I find this unfortunate. The Typescript team clearly has put years of work into this, and clearly has tried to shore up the deficiencies in Javascript.Are you writing a brand-new codebase that needs to work on multiple platforms, and not exclusively in a browser? Don't use Typescript, use a language with native WASM support. This includes avoiding solutions that involve Electron, Deno, and CEF, as they are browsers, too.Are you writing a brand-new codebase that only works in the browser? Learn how to use HTML and CSS correctly, avoid as much Javascript and Typescript as possible: Less is more.Are you maintaining an existing codebase with extensive Javascript, and you are not willing to rewrite entirely Typescript? Try using Typescript, but you're better off jumping ship, nothing can save it now.Any codebase that has untyped code in it, that cannot be compile-time analyzed for safety, that requires a significant client-side investment (ie, a giant blob sent to the browser), is kinda doomed to failure, and you will not realize the magnitude of your mistake until it is too late.I realize my opinion is unpopular, as the programmers on HN seem to be a lot of front-end devs and a lot of "fullstack" devs, where the "full" is JS+TS in NodeJS, using some predefined popular NodeJS framework. I just want systems that are designed to minimize the BS, I've chased enough BS in my lifetime, TS can never deliver a no-BS system to me.
> Are you writing a brand-new codebase that only works in the browser? Learn how to use HTML and CSS correctly, avoid as much Javascript and Typescript as possible: Less is more.It's really difficult to construct a comprehensive SPA without a nice framework such as Vue or React; and as it relates to your prior paragraph about WASM, I'd love to take this advice, but reactive UI frameworks suitable for browser are young and immature compared to Vue and React (IMO).I would LOVE to use a different language and compile to WASM, just don't think I can replace my Vue+TS frontends at this time.
I think its good to bring up SPAs in this context: fundamentally, they shouldn't exist, and you're using the browser wrong. They are the poster child of design smell when it comes to "web apps".Do you need SEO to work, even though Google Search torpedoed effective SEO a long time ago? Search engines disfavor websites that are extremely opaque and are made of a single page or few pages.Do you need to be able to open content in new tabs, thus increasing productivity dramatically? Many SPAs will forget the app state and be unable to navigate back to where you were if you open it in a new tab. This also means you can't bookmark them either, and I've also seen browser tab/window restoration screw over SPA state.Do you want browser performance? Using complex JS/TS to mangle the DOM and causing redraws outside of the initial page load is a good way to scare users off when their browser shits itself for 3+ seconds.
> I think its good to bring up SPAs in this context: fundamentally, they shouldn't exist, and you're using the browser wrong. They are the poster child of design smell when it comes to "web apps".So a universal, cross platform, cross device, responsive, accessible UI stack that has simple distribution, avoids walled gardens and has excellent performance is a "design smell"?> Do you need SEO to work, even though Google Search torpedoed effective SEO a long time ago? Search engines disfavor websites that are extremely opaque and are made of a single page or few pages.Nope. I develop PWAs for healthcare and other industries. I rarely, if ever care about SEO. If I did, I agree that SPA is a poor choice, but for 99% of what I develop, the web app is a replacement for a desktop or mobile application. SEO isn't relevant.> Do you need to be able to open content in new tabs, thus increasing productivity dramatically? Many SPAs will forget the app state and be unable to navigate back to where you were if you open it in a new tab. This also means you can't bookmark them either, and I've also seen browser tab/window restoration screw over SPA state.Deep linking has been a solved problem for so long, it honestly makes me wonder why people keep bringing this up. Use a decent router. IMHO this is much easier to do in a web app than a native mobile app.> Do you want browser performance? Using complex JS/TS to mangle the DOM and causing redraws outside of the initial page load is a good way to scare users off when their browser shits itself for 3+ seconds.I'm not sure how you're developing web applications, or what stack you're using, but if you're seeing 3+ second DOM mutations I can tell you that you're doing something very wrong.Web browsers are fantastically performant, I can't think of any other rendering stack that gives you so much capability with such performance.There's a reason why XUL, Silverlight, Flex, XAML and all the others have disappeared or have such tiny market share compared to HTML + CSS.The web has fantastic deployment and update capabilities coupled with a powerful rendering layer. It's easy to see why it's a popular choice for application development.
I agreesomeoneis doing something wrong, wrt sluggish browser performanceandrouting. However, I keep being exposed to this in random SPAs I get exposed to; I can only conclude this continues to be a problem that developers have and the popular frameworks somehow footgun them into this.
They can footgun just as hard with server-side rendering, including breaking when you try to have multiple tabs of the same site.
This is all outdated thinking now that we have PESPA frameworks
I mostly agree with this, and haven't been happy developing JS for some time. I don't enjoy having to deal with bundles, webpack, TypeScript, bloated dependency graphs.Luckily I can use Go for new projects, and even when picking it up at first I quickly found it more pleasurable to use than NodeJS. I don't JS on the backend if I can avoid it.On the frontend, I would still argue on balance SPA/bundling is the best option when your company is developing an application. I appreciate that for many things HTML/CSS with minimal JS works well, but for anything dynamic where you have a team of devs, the community and dependencies around React are too useful to replace with much else.
Although I agree with you, I'm curious how this translates to your full time job (assuming you have one)?I find most companies don't do JS any more (TS experience is a requirement)
Where I work, everything on the frontend is TypeScript, everything Nodejs is TypeScript. I did create a nice little bash utility using Standard style i.e. vanilla js in Node and that's worked out well.Although I'm senior enough to start a new project without TS within my team, I think it would be a little egotistic. Although I am not convinced by TS benefits, most people at my company are convinced it's necessary and I don't think it's worth going against the grain. There's many more important decisions when starting a new project, and I think the architecture is much more important than whether to type or not. Besides, I now choose to use Go on anything server side, and try to shy away from the frontend because I don't find it as fun to code as I used to (partly because of things like TS, partly because the kind of work doesn't feel as engaging, and feels like busywork).I worked at a company previously that had a large NodeJS codebase that was largely created before TypeScript was so popular. That's what I mostly have to compare against, and so I do know what it is like to do massive projects with many people without TypeScript. I don't think we ever felt the need for types, and building and pushing code was always simple and safe.
I get what you mean about BS. For me the most painful thing (JS or TS) is if you leave a project for a year you need to use a newer node for security, you need to upgrade modules for security, and some NPM package creators love to have breaking changes or even pull modules completely, forcing a lot of manual work and refactoring to fix.Whereas in .Net this churn rate is way slower because almost all functionality is provided by the famously backward-compat friendly MS
which also sets the culture for Nuget publishers too.
I won'tdefendTypeScript. Mainly because I'm not interested in doing such a thing; I don't like it that much, clearly not enough to care.But even so, I will say a couple of things about your arguments.Regardingi), no, it's not a framework. But then again, I don't think that's what your argument expresses anyway. You seem to be saying "it's yet another dependency you need to keep up with". This would be correct and a valid argument. But it's unrelated with "being a framework" (which, again, it is not).As forii)... I'm afraid this argument could be valid for any large group you want to pick in software. Are you arguing JS libraries at large arebetterdocumented? Sounds highly dubious. From a different angle, is this a problem with the language itself or is it a problem with the libraries?Finally, regardingiv), there isno"progress including TypeScript in a browser" and you should never have expected it. Not saying it will never happen because some person somewhere might do it, but you shouldn't expect it.
Regarding iv), I disagree that one should not expect this to happen. There's a stage 1 ES proposal for allowing TS-like syntax in the browser:https://github.com/tc39/proposal-type-annotationsSo there's good reason to believe this may actually happen in the next couple of years.
Everyone (including the authors of the Type Annotations proposal) seem to be on the same page that static typing - "including TypeScript in a browser" - is not desirable and will not happen.For the avoidance of doubt, the Type Annotations proposal is not actually static typing, but just a 'fancy comments' for the JS interpreter to completely ignore.
> From a different angle, is this a problem with the language itself or is it a problem with the libraries?It's a problem for me - the developer. From my viewpoint I don't really care where the responsibility of bad documentation lies, only that it makes me not want to use TypeScript.> Are you arguing JS libraries at large are better documented? Sounds highly dubious.You can't really decouple JS libraries from TS. Most JS libraries still maintained support TS these days. My point is that many of them are still documented using JS with JS examples, and don't fully document the types that go along with all their methods.
> You can't really decouple JS libraries from TS. Most JS libraries still maintained support TS these days. My point is that many of them are still documented using JS with JS examples, and don't fully document the types that go along with all their methods.Ok, but... what you're saying here is that, while you're not convinced by TS yourself, youexpectall JS library creators to be convinced. Why should they be?
I am not saying I expect them to be better documented, only that the reality is that they are not well documented in TS and that makes TS difficult to use.
I worked in two different team in two different companies where a full rewrite of the core system was done in typescript.The technology itself had few issues like compilation time and inability to run the application locally because of reasons.The new systems were so complicated that everything ended in neverending bike shedding.The people pushing for "everything to be written in typescript including other teams tooling (aka pulumi)" were very unflexible crowd.The previous system had few issues that could be solved with database indices.It's soul crushing to work on these type of places where technology is used for the sake of technology instead of bringing some business value.
These don't sound like they have much to do with Typescript itself, but just the hell of rewriting a project.
https://www.youtube.com/watch?v=YR5WdGrpougStatic typing is not "obviously good"
The comparison is flawed. There are no advantages to driving without a seatbelt, but there are pros and cons to dynamic typing.
Is it worth it compared to what? Plain JS? Transpilation from a different language? Rust? Growing apples?I have used plain JS, GWT, and TypeScript. TS is an incredible improvement over the two others. The TS type system is excellent, very expressive and helpful. An important advantage you get from static typing is that your IDE has more information to work with and so becomes more powerful. If you code in a text editor, you won't reap the full benefits, and you'll have to do more of the grunt work yourself.
try out dart, its much better than TS
How is it objectively "better"? This depends on context. I am sure Dart is worse given a specific condition. I'm not bashing dart, but you cannot say that "A is better than B" without any sort of context to the statement. It's like saying "apples are better than oranges".
Dart is better in most respects. The standard library islight yearsahead of JS's, the Dart tooling is fantastic, it hassoundtyping.There are a couple of features that I miss from Typescript: the biggest by far is tagged unions.But I would still pick Typescript for a web project for two reasons:* The community is like 1000x bigger. Even though a lot of it producesextremelylow quality code, there's still a lot more solid JS libraries than Dart ones.* Debugging is slightly easier since the compiled JS code is essentially identical to you TS code. Chrome has pretty great support for Dart, but if you ever have to delve into the generated JS it is quite painful.
much less overhead setting it up, it can be both interpreted and compiled. Troubleshooting errors in dart is a much more pleasant experience compared to Typescript. Transpiled languages like Typescript has given me so much trouble over the years at work.
Not that TypeScript doesn't have it's pain points but having tried Dart on an Android application recently, there are so many things I dislike about the language and it's ecosystem compared to modern TS/JS. I feel like it would have been a lot better than JS when it came out but now it's painful to use in comparison.Definitely my preferred route for building mobile apps now though.
I now actually prefer Dart for services and glue code on the backend. I'm so tired of dependabot yelling at me about my hobby projects every week that have yet another vulerability in one of their million dependancies. In Dart I make do with just a handful of deps, then build a binary and call it a day. I tried using Deno with TS, but binaries it generated where absurdly big, 70-100MB depending on the target platform. Also, Deno's --allow-X thing becomes tedious after a while.
Is Dart object oriented language? What is its roadmap? I know it was created by Google, but is it replacing js?
Yes it's Object oriented, it was supposed to replace JS long time ago, but google kinda dropped the ball on that. I wish it replaced JS. Dart was almost dead for a long time but flutter kinda saved it. Developing on flutter for cross platform applications has been a joy to work with even though there are still a lot of drawbacks to flutter right now.you can find their blog here where they talk about future releases and planned featureshttps://medium.com/dartlang
Dart is an object oriented language with optional type inference. It's not replacing JS but it's better designed.
That's subjective and I'm sure it is for you. I personally prefer TypeScript.I'm glad to see passionate developers keeping on both sides. That's how we grow and become better.
that's like saying VHS vs betamax is subjective. VHS won but wasn't better. Or Minidiscs vs CD's. It's mostly due to marketing fails and people hopping onto marketing bandwagons and pre-estalbished products.TS is more popular due to combination of google dropping the ball in defining the standards and getting others onboard with them cause they overestimated the leverage they have, failure at marketing it and how everyone is already bought into Javascript.
yes it is
My use case is a bit odd, but I've been using it for small personal web projects ‚Äî so small that no dependencies are being pulled in and bare tsc is being used in place of a bundler ‚Äî and as someone who doesn't have all of the ins/outs and do's/don'ts of JavaScript committed to memory (the vast majority of code I write is Swift or Kotlin) it's wonderful to have something catching errorsbeforeI save and reload the browser window as well as preventing "silent" bugs JS is notorious for.
Same here, I've found it very useful in projects where I don't have a lot of dependencies.In another project with more exotic dependencies, it has become a hassle somewhat. I've found learning the .d.ts syntax to help easily get out of a situation, but it was a learning curve I still run into sometimes.
I find that I just make the .d.ts files any typesIcoulddocument types for that module, but I don't, and instead assume types as the output of code I have that interacts with them
I do that sometimes too. Sometimes I type the couple things I need out of a module. If it's something I end up relying on more, I usually start digging deeper and end up cloning it. The hardest are the large libraries with no types and no DefinitelyTyped types. Also monorepos can be annoying, when the main package is typed but the individual packages aren't, if you have to start poking at things deeper.You do get a lot of escape hatches for different outcomes though, dependant on amount of desired effort
I add more thorough types for dependencies than for my own code, specifically so I don‚Äôt oops myself on other people‚Äôs code I‚Äôm less familiar with.
Although this seems to be the opposite sentiment to what many are saying which is that it's more useful in larger projects, with many contributors, I think I probably understand this side more.Dependencies are where it starts to get tricky. It also gets tough when someone else has configured TypeScript, or you need to add some complex config. I would still opt out for smaller projects because they don't quite benefit so much from TypeScript, and eventually I would expect to run into something that would eat at hours of my time for a simple change.
Offtopic perhaps, but if most of your code is in Swift or Kotlin, have you tried the new Kotlin frontend support? I don't have any project where I can use Kotlin in the backend right now but I've always wanted to give the Kotlin frontend a go as an alternative to TypeScript.
I haven't, mostly because none of my front end web projects feel large/complex enough to justify the extra overhead (probably wouldn't even be using TypeScript if it were any more involved than running `tsc --watch` in a terminal window). Might look into it for future projects though.
Are tests useful? Because this is what TypeScript gives you: it helps you avoid regressions.If I change a signature, tests fail. If I pass junk data, tests fail. It's like invisiblelivetests and people forget this.As in the other recent discussion, yeah, you can live without tests and you can live in JS-land. Whether it's worth it it depends on you. TS and traditional testing lets me ship updates without even opening node or the browser.
Tests are great and the usual argument from static typing opponents is that they almost completely replace the regression safety from static typing.Types are not the same as tests at all, tests are much better at giving you a glimpse of what the code even does.For clarity, I'll define a static typing opponent as somebody who believes that the return on investment for static typing is negative.
> tests are much better at giving you a glimpse of what the code even doesTypes do that, they tell you the expected input and expected output. No type nor test is all-encompassing of course, but it givesat least someinformation.No test will guarantee that a functionwill neverreturn a number. Types, if valid and without prototypal shenanigans, can.
While I agree that static typing provides some of the benefits of unit tests, I think it provides much more than that: compiler-assisted renames, code completion, extra code documentation...
Short answer:It is worth it if you want me on the team. I refuse to work with anyone who throws out TS for JS in 2023.Slightly longer answer:I have said a number of times"Javascript is a simple version of Java in the same way as a bike with one wheel is a simpler version of an ordinary bike."The same can be said about JS and TS.If you want to do any serious work you go for the serious thing even if it means occasional adjustment of brakes and gears, or in Typescripts case, sometimes figuring out something.If anybody suggest to use Javascript today I won't take them seriously.i) I have used Typeescript since 2017. For some reason I don't have these problems and never had.ii)  Yes, some libraries are poorly documented, that is for me a reason to prove why I am a software engineer by either figuring it out, complain until they fix it or even better use my gut feeling and use some libraries that aren't stuck 10 years ago.iii) Error messages can be hard, but compared to debugging the mess that happens without typing it isn't hard at all.iv) Have someone look at your project setup.And before someone says I don't know Javascript: I wrote my first javascript application (OK ECMAScript since it was in Adobes SVG plugin), which was a working map, dynamically updated based on GPS position, back in the spring of 2005, that is half a year or so before Google Maps and years before most people took Javascript seriously so I should  be qualified to have opinings. Yes, it wasn't production quality, but I built the logic more or less alone in 5 months in between other school work.
I don‚Äôt want to sound harsh, but saying Javascript is a simpler version of Java just tells me you have never used Java seriously.It‚Äôs like saying Korean is a simpler version of Spanish.Yes, Java and Javascript are both programming languages, but they don‚Äôt even share the same paradigm.You might be confusing the motivation that led to the creation of Javascript with the actual implementation.Having said that, I have used Java professionally for more than 7 years, then I switched to mainly Javascript, and later to Typescript, and I‚Äôm never going back. I agree with your overall point.
You misunderstood it : )I love Java and despise Javascript.In my opinion it is up there with null and other billion dollar mistakes.The language only works as well as it does because hundreds of people smarter than me have spent hundreds of man-years creating toolings and ecosystems around it to work around all its problems.This is not to be read as a dismissal of Brendan Eich or anyone - it is totally amazing that he threw together a language that has worked so amazingly well in three weeks.But everytime one switches between TS and JS one wonders how  much money could have been saved if he had somehow invented TS instead back then.
How about instead of analogies (which we've misunderstood even on this thread), just say this: "Java and Javascript are very different languages, don't be confused by the similarity of the names".Of course, at this point virtually everyone knows this, now we are only arguing about which analogy to use to describe something we all understand.
He said "in the same way as a bike with one wheel is a simpler version of an ordinary bike." Meaning, not the same thing.
I don't think that's what he meant.
ha, If I was on that team I'd seriously consider opting for vanilla JS just for not having to work with you.People who make such absolute claims are in my experience causing more trouble than they're worth. They will always nit-pick on anything anyone is saying causing a toxic atmosphere. 
Frequently a little later I then figured out that such people think like that because they haven't seen enough of the world and the gigantic amount of options you have to solve your technical problems.
Totally fine with me.If you don't need my advice you can save a lot of money by not hiring me. Edit: The reason why people hire me as a consultant is hopefully because I give clear and valuable advice, and on JS/TS, if TS doesn't work better you are very probably doing something wrong.But don't complain to me when JS bites you behind again and again.
q.e.d.
With a attitude like that, I wonder if it is worth having you on the team. Might just push me to pick JS then.
Comparing Java & Javascript? This reminds me the last recruiter message I got on LinkedIn. "You are a Javascript expert, I have this mission for you with the same language! They're looking for a Java expert!"
I am pointing out that they are not comparable except very superficially.
It's a pointless point to make, and I think people are rightfully calling you out for it. "If my grandmother had wheels she'd be a bicycle."
whoever said that javascript was a simple version of java? the two languages have almost nothing in common - at least a unicycle and a bicycle share the concepts of "wheel" and "pedals".
The syntax is very similar on the surface, at least compared to Perl, PHP, Python, C and - I would personally say - C++ and a number of other languages.Yes, there is no way you'd mistake one for another if you have worked in any of them - but theylooksuperficially similar.
No they really do not
Java has wheels and pedals. Javascript only has objects that say they are wheels, and objects that say they are pedals, but which are really both and neither at the same time.
Smalltalk has wheels and pedals. Java has AbstractBicyclePartFactoryBuilderSingletons.
Schr√∂dingers Java
In my experience yes, to the extent that I don't intend to write vanilla JS ever again if I can possibly help it. If you've done webdev professionally in the past 5+ years you've almost certainly already been transpiling so to draw the line at introducing something as massively useful as static typing seems both arbitrary and bizarre.FWIW I can't recall the last time I reached for a 3rd-party library and found that it was lacking types. The DefinitelyTyped project has really done a remarkable job expanding type coverage. And even in that rare case where you might need to add type definitions yourself it's simple enough to do so.There's a ton of room for improvement around error messages, no argument there. The TS team is very much aware of this and they're working on it but it'll take time.
I feel like TypeScript is definitely worth it BUT it seems to be getting ever more powerful but not in a good way, in complex way.Too much time is spend fighting TypeScript as opposed to writing application code.I have a question for the language experts out there .... why is TypeScript getting so complex? Are other strongly typed languages this complex?  Or does the complexity arise from trying to overlay typing on JavaScript which is an incredibly dynamic language?And if it is the case that TypeScript's complexity keeps going up because essentially "strongly typed JavaScript" is a hack, then should we all be moving to a much simpler strongly typed language that compiles to WASM, and yet still richly interfaces with the DOM and browser APIs?Does TypeScript just have to keep getting ever and ever more complex and detailed - is that the unavoidable future?
I don‚Äôt know but my experience with TypeScript is it is the C++ of type systems- it wants to have all possible features and caters to the demands of the most sophisticated users at the expense of the 99%. I also enjoy using simple TS like I like to write simple C++.
I wonder if maybe the TypeScript team should have stopped at some point and said "no more, we're just making complex now!".The Wizards Of TypeScript seem to be implementing ever more obscure use cases with ever more diminishing returns in terms of the number of programmers who will ever use those advanced features.What happens when you have a fully funded development team at Microsoft, who actually finished the job long ago?  They just keep developing, ad infinitum.
> Or does the complexity arise from trying to overlay typing on JavaScript which is an incredibly dynamic language?Mostly this. There‚Äôs still some valid constructs in Javascript that are inexpressible in Typescript (though I‚Äôm inclined to believe most common ones are covered by now).But to be honest, that‚Äôs not anything you are forced to use. A lot of people do because the benefits it brings are so nice.
I have such huge issues TypeScript decorators. It's so obvious on how that would work in JavaScript, but it looks completely foreign in TypeScript.
You answered this all yourself. Yes, it's a hack. Yes, probably some other WASM-targeted language will exceed Javascript's mindshare. But that may take many years, and you need to build software now.
Typescript doesn‚Äôt just statically type. That‚Äôs easy. It does program flow analysis to 1) infer type and 2) ensure the inferred types actually work. I think in most statically type environments, the type analysis engine relies a lot of on the developer to define the correct types in the correct places, but the types in TS are always _logically_ correct. As in absolutely correct (unless of course you eject from the type system using coercion).
> but the types in TS are always _logically_ correct. As in absolutely correctErm...type Test = Array<number>;

    const xs: Test = [];
    const x = xs[0];What's the type of x, according to typescript's default behavior? It's number [0]. What's the logically correct type? Some sort of a Maybe<number>, which typescript doesn't have; so a number|undefined instead. Most people don't use typescript at that level of soundness, both because it would be painful, and because typescript doesn't have it as a default.[0] -https://www.typescriptlang.org/play?#code/C4TwDgpgBAKhDOwoF4...
there is --no-unchecked-indexed-access option for it. Which is not on by default or in --stric mode because indeed in practise it's painfullhttps://devblogs.microsoft.com/typescript/announcing-typescr...
I‚Äôve never found it to be overly painful. If you‚Äôre accessing values this way (on an index vs defined fields), you‚Äôre already treading into iffy territory, structure-wise, and its good to undermine your assumptions about what‚Äôs at the index. An extra check might seem very hand-holdy, but I‚Äôve been doing JS long enough now to have seen a large number of errors originate in this class of index access.
I'd say for most people, beyond small scripts/cli/micro-microservices, the ceremony of setup/environment overhead for it is worth it, and continually pays dividends. You can usually copy-paste a common config file around to bootstrap.Most of your (pretty good actually) critique are points to make the least-bad way of doing JavaScript even better, and I'd agree could be improved.Others have taken notice."Native support" of TypeScript is done by Deno.
And tight TypeScript (and other adjacent tooling) integrations with VS Code and WebStorm.And transpilation is being worked on by various builders. Stripping types and running through esbuild or swc is fast. 
For typechecking part, was a proposal to have TypeScript be rewritten in Rust for performance.We can lament that JavaScript went from being a web document enhancer to being shoehorned into a full application compilation toolchain, but the old Jquery thru Expressjs era of doing things has significant drawbacks for full sized applications/APIs/etc.
I haven't found much agreement, or at least to the extent I believe it, that Javascript and HTML and CSS have all been shoehorned and built upon completely beyond their original specs.
Those sound like the least controversial opinions ever.What's nice is that despite looking ugly, those shoe horns have done a pretty good job, and they all make effective tools for building useful stuff, and that stuff can be built by people who aren't very good at building stuff.It's very much a success story that so much html/css/JavaScript is a garbage fire. They're really effective tools, up there with excel
I like it. I wasn't convinced it was worth it for the first year or two, especially when TS was young, but the devs have done a great job and have paved over a lot of the weak spots. Things I didn't even expect would get fixed have been fixed.I just try to type things 90% of the way, until it's good enough, and slap an `as` in there if I get too annoyed or it takes too long to fix. Don't even care. It doesn't put me in a worse spot than JS would have.Getting completions on all my giant objects is wonderful.
> I just try to type things 90% of the way, until it's good enough, and slap an `as` in there if I get too annoyed or it takes too long to fix. Don't even care.Still a js dev in spirit <3
I am quite surprised at the turn out in the comments here against adding type checking to JavaScript.In my opinion, TypeScript is not only essential in the context of any professional project, but it features one of the most ergonomic type systems I have ever worked with.There are certainly pain points with certain TypeScript features (e.g. enums) but any project that takes me longer than 5 minutes to write, I need type checking. If I can't be bothered with setting up tsc - and setup difficulty is a valid criticism - I just use jsdoc.I have seen TypeScript take the heat when applied to JavaScript projects that implement multiple trendy programming paradigms. Often times the projects themselves are so complex that adding a type system requires type-kungfu. It's not the type system at fault - but a needlessly complex architecture.Love TypeScript. Wish there was anything like it that compiled down to static binaries.
> it features one of the most ergonomic type systems I have ever worked with.This is surprising. Which other type systems have you worked with?
Yes, I found the ReScript/OCaml type system much more ergonomic.
Having worked with OCaml and F#, I find that TypeScript requires fewer changes to non-type code in response to changes to the types.For instance, given `type T = { a: string; b: string; c: string }`, if I want to make `b` and `c` nullable but always provided together:// OCaml
    type TOpt = { a: string; bc: (string * string) option } 

    // TypeScript 
    type TOpt = T | { a: string; b: undefined; c: undefined }With the TypeScript approach, code which worked with T still works with TOpt (only requiring an `if(x.b)` guard). With the OCaml approach, any code that accessed b or c needs to be rewritten.The same applies to cases where an object can be in several different modes, but some properties are present in all modes. For example, an AST node can be a literal, identifier, binary operation, etc. but it always has a source location and an inferred type. In OCaml this has to be represented by either separating a "common properties" type from a "kind of node" union type:type node = { loc: location ; inferred_type: exprtype option ; kind: nodekind }
    and nodekind = Lit of string | Id of string | Unary of op * nodeOr by repeating the common properties in all union type constructors:type node = Lit of location * exprtype option * string
              | Id of location * exprtype option * string
              | Unary of location * exprtype option * op * nodeBoth are tedious (although F# makes the second one slightly less tedious by allowing one to define computed properties on union types). By contrast, TypeScript allows you to have only one type:type NodeCommon = { loc: location; inferred_type: exprtype|undefined }
    type Lit = NodeCommon & { kind: "lit"; value: string }
    type Id = NodeCommon & { kind: "id"; value: string }
    type Unary = NodeCommon & { kind: "unary"; op: op; node: Node }
    type Node = Lit | Id | Unary
> Is Typescript worth it?
> I want to skip over the static typing benefits argument‚Ä¶Typescript, as the name implies, adds types to your script. If you don‚Äôt see the benefits of types then typescript may not be for you.> My issue is with the amount of extra work it places on developers‚Ä¶ and doesn't deliver all that much value.If you think adding types doesn't add much value then typescript may not be for you. In my experience, types are defined once then provide a lifetime of value.> you are at the whim of TypeScript developers and how they decide to progress with the language.This is true of any library, programming language, operating system, hardware, etc. But adding types isn‚Äôt somewhere I‚Äôd worry about backward compatibility being broken. All the newer versions of typescript are backward compatible. If you have a library that requires a newer version of ts then upgrading ts won‚Äôt break anything dependent on earlier versions.
> If you think adding types doesn't add much value then typescript may not be for you. In my experience, types are defined once then provide a lifetime of valueYou have misunderstood the OP. The full paragraph is:>> I want to skip over the static typing benefits argument, because I think it is well understood that static typing is a good thing and if we could bless JavaScript with a built-in and robust typing system then I don't think many people would be against that. My issue is with the amount of extra work it places on developers, much of it the "dumb" kind of work which can eat up hours and doesn't deliver all that much value.Summarized: "I agree that static typing is a good thing. My issue is with the extra work (required to use TypeScript)...which doesn't deliver much value".That is - they are saying that types deliver value, but that the extra busywork required to use and maintain a TypeScript project (e.g. keeping dependencies up-to-date) does not - and, by implication, that the overhead of this maintenance work is enough to make them question whether the (acknowledged) value of types is worth it.(Note that I do not have a horse in the race as to whether the OP is correct in thinking that the overhead of TypeScript _as a language_ is greater than the value of the types. I haven't used it enough to have an educated opinion. But I am certain that you are responding to a point that was not actually the one being made)
But that is either not a properly formulated argument, or it denies the benefits of strict(ish) typing. You reformulate it so that one weighs out the other. That would only be the case for projects where you do more work integrating libraries than actual programming. That's something much easier to discuss (IMO), but is it what OP asked?
>You reformulate it so that one weighs out the other. That would only be the case for projects where you do more work integrating libraries than actual programming.No, the net gain with typing with static types as compared to without it, would be less than the increase of time spent with integrated libraries, rendering a total net loss.
That's fair. It appears his issue is more related to libraries with broken, undocumented types and typescript's opaque errors when an error occurs in said library. Unfortunately I think he's conflating typescript's role and a library with broken type definitions (I have no idea whether the type definitions he's had problems with are provided by the library or a community effort that may not keep pace with the official library). When the type definitions don't match the official library it can definitely cause a tremendous amount of frustration and make one doubt the usefulness of types.
> Unfortunately I think he's conflating typescript's role and a library with broken type definitions (I have no idea whether the type definitions he's had problems with are provided by the library or a community effort that may not keep pace with the official library). When the type definitions don't match the official library it can definitely cause a tremendous amount of frustration and make one doubt the usefulness of types.I am not trying to cast blame on any part of the TypeScript system. I have tremendous respect for the TS team and the problems they have had to solve to get this far. My point is, is it actually worth it? Whether people document their libraries is part of the equation, even if it may not be a direct responsibility of the TS team.I thought things might get better as the community matures, but I am still dealing with issues that seem to sometimes outweigh what I get from it.And I want to be clear as well that I mean to shed light on this thought and hear people's opinions. I am still open minded, and will continue to decide whether to use JS or TS depending on many variables whenever that decision comes my way. For personal projects I am currently in the boat that I would not choose TypeScript.
>If you don‚Äôt see the benefits of types then typescript may not be for you.At this point in my 20+ year career working with mostly dynamic languages, my feeling is that if you don't see the benefits of types, then programming isn't for you.
I would narrow this slightly to "programming with other people". For instance, I love Python for small personal projects and interview questions and stuff like that, but I've found working with it professionally to be much more of a headache.
>my feeling is that if you don't see the benefits of types, then programming isn't for you.Maybe it isn't "types" that is the problem, but the way types are implemented in TS. I never had these problems in Java as I do in TS.
Eeexactly.Untyped Python and Javascript are amazing if you're doing things solo or maybe with one other person who has the same style.Now try that with a 20 person group poking the same codebase. The amount of weird bugs you run into because it's not clear what type(s) a function can take in or return is bonkers.
Types are indispensable even just for me. They reduce how much I have to jump over to the docs and how much runtime debugging I do.Most importantly, they help when I revisit something after even a few weeks and forget what certain parts of the code did.
> static typing is a good thing [...] My issue is with the amount of extra work it places on developersThis is one of the eternal complains about type safety, somehow mitigated by type inference. I believe it is totally worth it in the case of Typescript.> i) Like a framework, you are at the whim of TS devs as it gets updated (edited)As a language, it has proven quite stable. Even if development stopped tomorrow you could keep the current version forever.> ii) Libraries are badly documentedIt is inconvenient but, since they are js libraries, they are compatible. You do not need specific ts examples, although it is extra nice.> iii) Error messages are hard to followDid not run into this issue myself but fair enough.> iv) It requires yet more transpilationtsc compiles ts into js. Depending on what you use, you could get rid of webpack etc. and just use tsc.In summary, for me Typescript is totally worth it. All this lost time you mention is different from the lost time adapting to x framework or y packer update, since it reduces errors down the line. It might feel like it is slowing you down, but you can always use any for certain modules and type things at the interface. It is still your decision what to type, the language gives you the tools to do so.
The question of whether it's "worth it" really boils down to you and your specific requirements.Even within the same project, there are times when I don't want typechecking - when I am prototyping something out and want to move fast.And there are other times, when I want typechecking - when I am finalizing a feature implementation or doing integration with existing logic etc.It's not a framework. It definitely is a language in its own right.But from personal experience, the group productivity goes way up with larger codebases with many ICs working on it. Unit tests become type checks. It opens up a lot of extra bandwidth for more sophisticated functionality or better tests.Solo IC, working on a small project, with no intention of ever writing tests - you might see TS be an overhead.To sum up, your requirements decide whether it's worth it.
I have seen this IC vs team aspect discussion before, and it definitely has merit. However I am starting to question if it's even worth it for larger codebases used by many devs, which is why I wanted to pose this question.Can you think of cases where it's actually prevented a bug where that piece of code is unit tested? I have been actively monitoring for this to happen, but so far not seen it (I think I have seen it catch a couple of bugs for codethat did not have unit tests).
Types let you limit the size of the input space - JS lets you go ahead with (foo, bar) where they could be literally anything and you have to handle every edge case to test that (and I bet if you fuzz you'd find stuff) your unit tests don't handle. With a typed language I can specify the input space and know with certainty anything that calls that function (and compiles) is going to be within that space. This lets you dramatically reduce the complexity of your app, tests, and stress of refactoring!Fwiw I'm an SDET and I regularly find bugs, on a daily basis, in a startup of around 40 people with a Python/JS web stack that TypeScript would have caught (and am pushing towards moving over to it).
Unit tests only trace one path at a time; static types cover huge possibility-spaces at once. But of course there are things they can't reason about, which is why we still test, but each of the two is better for catching different kinds of things. One isn't sufficient to replace the other.
A unit test can succeed while being completely wrong.Eg. You test code that calls a dependency that returns a bool, but your tests assume an object responseUnit tests imply assumptions about the integrations, whereas types specify those asumptions
Solo ic on a small project, you don't write tests? That's the easiest time to write tests! You don't have all the complicated context set up or writing test data, and saves you the run/debug loop for setting up specific situations.My childhood not knowing about tests had a ton of wasted time trying to check that a change worked
100% worth it to me. I love typescript. Working on large enterprise applications where one function calls other function and it goes 10+ layers deep I don't know how I would work without typescript. Just being able to see this function takes argument of type FOO and returns type BAR[] is incredibly valuable.
One thing I often tell people is that if a particular technology makes it easier to work with code that's 10 layers deep, it will also make it more likely that people will write code 10 layers deep where they would previously do 5 layers.Somewhat similar tohttps://en.wikipedia.org/wiki/Jevons_paradox
Yes! This is one reason I really like Go. I'm not exuberant about it the way some folks are, but amidst ambivalence about some aspects of it, this is one thing it really gets right. While it's hardly impossible, it's not that easy to write completely impenetrable code Go.
Not in my experience. People will happily write 10 layers deep if you let them anyway. Technologies like Typescript make it easier for other people to untangle the mess.As an example, what parameters does `manim.animation.creation.Create()` accept?
Some people make things as deep as they can handle. If you reduce the pain from deep hierarchies, you will inevitably end up with deeper hierarchies.Also, doesn't your example prove my point?I'm saying focus on types leads to deeper hierarchies. Your example has types and a deep hierarchy.
> Your example has types and a deep hierarchy.It was originally writtenwithouttype hints. It looks like somebody has added them since I last used Manim (a couple of years ago) to make sense of the mess!In my extensive experience code with static types isalwayseasier to follow than dynamically typed code. There's no contest.
That's a lot of layers for a codebase... I see that it could be useful in that situation, but since you presumably need to test and QA your code anyway you could also throw in a console log statement.There is also JSDoc.Although these solutions might not be quite as nice, I'd wager they'd save quite a bit of headache and time.
I have been using TypeScript at work since 2019. Personally I am not convinced that it is worth it, broadly for the reasons you note and also because TypeScript has in practice a soft dependency on Visual Studio, and in turn other MS services such as GitHub and Axure. Adopting TypeScript can often lead to de facto vendor lock-in.There is a good argument for using types (and also a good argument for not doing so). If the argument for wins out, then types will be included in the native js spec and the need for TypeScript will disappear. If the argument against wins, then TypeScript will also disappear.If TypeScript really floats your boat then by all means use it, but treat it for what it is- a hairy dependency that only a minority of developers love or need.
> TypeScript has in practice a soft dependency on Visual StudioHow do you figure? I've been fulltime typescript for almost 4 years now and never opened VS or Viscose once in my life.
I don't like JavaScript, I don't like TypeScript, I don't like front end development at all. Is typescript worth it in my personal projects where I know all the code and they are pretty small? In my opinion, no. Is typescript worth it at work, where multiple people interact in a large codebase? Absolutely. Asking if a language is worth it is pointless unless you add "to my use case"
Can't believe how long I had to scroll to find the answer I agree with, effectively: "it depends".Going with car analogies, the question is similar to "Is a bus better than a race car?" - there's no correct answer without more context. How many people use one or the other, how many people praise one or the other, that's no help either.That said, regardless of whether it makes me happy or whether it's a solid technical decision, TypeScript appears to be used somewhat widely at this point. So learning to deal with the complexities and gotchas of it is IMHO worth it for anyone who's serious about web development. No need to become a zealot though, there's no need to find and defend some silver bullet. It just depends.
The reason may be that people not using either in a professional environment tend to comment faster on HN.I agree that you must learn it at least a bit for web development. I occasionally have to fix some bug and so I learned it. Another month of income earned.
I've worked on multiple Typescript projects for years and I'm still not convinced it is actually an improvement over working with plain JS.Lately I've been using Typescript's JSDoc comments just so I don't have to deal with transpiling code but still get most of the advantages like editor autocomplete and warnings.
As humans it is easy to forget the time savings that we don't see. For a project that uses a lot of Type annotations, it is like getting a bunch of unit tests for free or writing a bunch of boilerplate code to validate inputs.
Yeah it feels like the Seinfeld Effect here. TS is so pervasive now that its vast upsides are just "the new normal", taken for granted.
I worked for many years without TypeScript, and the development flow was a lot more pleasurable without a big difference in the number of bugs I saw us shipping.
I work on a ruby code base that has extremely good test coverage, something around 20,000 unit tests for a relatively simple app, and it‚Äôs still almost impossible to update ruby or rails without breaking something. The thing that broke is always impossible to predict from reading the release notes.The most infuriating thing is it‚Äôs almost always something a typed language would have picked up like a functions parameters changed or things removed.No amount of unit testing or browser automation is a sufficient replacement to type checking.
I don't have a lot to add except that my experience with it has been very positive; your complaints are mostly valid, but for me those pain points disappear in the shadow of all the things I no longer have to spend time stressing about or debugging
So much this.If you‚Äôre learning JavaScript or any components of the language, you‚Äôre better off just starting with typescript (given the technical acumen up front).It‚Äôs absolutely a no brainer, long term roi. If presented the opportunity to integrate or use now vs later.The community is also very active, and it‚Äôs under Microsoft - and has been well maintained and quite active. Lots of libraries.
> you‚Äôre better off just starting with typescriptIt depends. The tooling is still a barrier (even though it's gotten smaller); the cost is small for a real project, but for someone who's learning and knows nothing about the ecosystem, it could be a real obstacle to dive all the way in at once. The exception would be if you're starting with something like Deno that integrates TypeScript seamlessly. Outside of that, tools like esbuild have significantly lowered the bar vs a few years ago when you had no choice but to configure webpack + babel. But even esbuild isn'tquitezero-configuration
If you're just starting off with JS or TS you shouldn't be messing with tooling at all. Just install one of the many create-react-app derivatives, run one command and start developing. All those boilerplate generators support TypeScript now, too, so you don't even need to do anything extra to start using TypeScript. Even TypeScript itself can be incrementally adopted since it's a superset of JS.You will outgrow those app generators, but for a learning project? There is no need for you to even see a webpack file.
I use TS as standard now (because every job requires it), but I dislike it immensely.I've used static langs like Java and GoLang and prefer them over TS. Heck I even like ruby-rails more. Since I'm fullstack (TS on FE/BE), it's hard to move 100% away from TS (becz a use React) and it irks me how everything has changed the last 10 years of so.I am a seasoned developer and can code (in JS) extremely fast, clean and performant. With sufficient test coverage you can go a long way. Of course if you use TS and change something important, the compiler will tell you all the places you have to refactor. This is super useful.However in my experience with a fair amount of TS codebases, there has been a tendency for devs to use as many clever TS features of possible (e.g. utility classes and generating crazy generic types from multiple types). I detest this style of programming, becz when you have to can't get something to work, it's a pain to try and understand the errors. This also extends to TS enabled libraries which can be challenging when you try and do something non-standard.I burn time trying to understand the errors and getting TS out of my way, so I can get on with the task at hand. I find cases that if you look at the logic I've written, there's not a chance that something can be undefined and yet I have to wrap code in "if's" just to satisfy the compiler.Even though I have a ton of experience, I deliberately code for that junior devs can understand/debug/work-with or the support engineer who just got woke up and trying to fix prod, which in my experience, isn't a common approach anymore. This is part of the problem IMHO.Most devs I talk to are using TS as their first language and have mostly never experienced the joy (and lack of safety, I grant you) of dynamic/non-typed languages (e.g. ruby/lisp). Get a lisp-er to do TS and start hearing the flood of swear words. lol.Of course, I understand the benefits of TS, but for me at least there's no joy in it and that's one of the reasons I got in this game in the first place.
I've seen the codebases created and maintained by people who "don't need types because it just slows me down."Hard pass.
Many of the most pleasant codebases I have worked with were built before TypeScript existed. Building a good codebase takes a lot of care and thought and can't come just from using TypeScript, in fact the worst cases I can remember happen to be TypeScript.By no means am I saying TypeScript is the reason these codebases were poor, however it also didn't seem to help them all that much.
This is absolutely on point and just had me cry laughing. Thank you.
As for "worth it" ‚Äî as someone replied in another comment, it's a question for you. You better than us know your use case, your strengths and weaknesses.Me, I love typescript. It's an extra reassurance that my code will probably work correctly ‚Äî and even though it isn't as trustworthy as Elm, Haskell, or Purescript, it's better than nothing. It is a good pair programmer who has many times saved me from stupid mistakes I made while writing code. And it holds my hand while I am refactoring ‚Äî I would be scared to do that in a javascript codebase. Tests would help with refactoring, of course; but they aren't as exhaustive as a static type checker is.
My question wasn't so much asking whether I should continue to use it, that depends largely on what people have already decided to use on a codebase, or what a team or company has decided to do.I pose this question more so to understand how others are thinking about TypeScript, and whether there is sentiment out there like mine that the tradeoffs are not really worth it in any case, regardless of what is being built.
We have been using typescript in large scale JS project with 15-20 library modules and 7-8 product modules. I cannot think of building such product without typescript. When we compile all libraries and products and see no TS errors, we know at least that we are referring to correct properties, and wiring the shape correctly.Typescript has bunch of "clever" things but you don't have to use it. We probably use 30-40% of TS features and that is more than sufficient for us. With that said, here is what I think about your questions.1. Agree, and it is not any better without TS either. In case, a library is not compiling with your TS version, we ignore the error, put a FIXME there and remove the "ignore" sometime later2. Yes but that is not TS problem. Without TS it is even worse.3. Agree sometimes, we get so complicated errors. We search around and see if any smart people have figured what that means. If not, ignore and move on with a FIXME4. Since many years, we are not writing any JS which doesn't need transpiling. If not TS, you would be using babbel or some other tool most of the time anyways so we haven't this to be an issue.
We probably use 30-40% of TS features and that is more than sufficient for usExactly. Some people seem to have the idea that you have to spend weeks writing esoteric type definitions before TS will work for you, which is just not true. You can get a large portion of the benefits with very little additional work, often just adding types for function arguments. (In many cases those types can replace comments that were trying to convey that same information, with the advantage that they won't get out of sync with the code). And for code that intentionally takes advantage of dynamic typing, it's perfectly fine to slap "any" on it rather than trying to come up with a bunch of clever types.
#1 ‚Äì You don't have to upgrade TypeScript versions till you are ready, and newer versions never have breaking changes anyways. The syntax remains strictly compatible with ES6 and beyond. Packages you consume publish compiled JS and aren't dependent on specific TypeScript versions at all.#2 ‚Äì If libraries haven't published types, just use them as pure JavaScript (which is what you would have done anyways). Lack of documentation again applies to both JS and TS equally.#3 ‚Äì I assume you are talking about compiler errors? I have personally found them to be simple to understand, especially when the exact location is highlighted in your IDE. At runtime there will be no difference since it is all the same JS code under the hood.#4 ‚Äì Yes transpilation takes non-zero time. TypeScript has a lot of tooling around incremental compile/watching for changes, so I don't think it should really be that much of a burden during development. I have worked on massive TS projects and don't even notice the compile task running in the background.I find this post weird because TypeScript does have some real drawbacks ‚Äì overly complex type system, makes the codebase more verbose, false sense of security (no runtime type mismatch errors), mix of typed and untyped code in codebase etc., but your reasons for disliking it all seem superficial and easy to overcome.In my personal opinion everyone should be starting new JS projects in strict-mode TypeScript by default unless there is a reason not to.
Regarding #1: this is not true always. Libraries publish types and their type definitions could use new TypeScript features that could force an update.
That shouldn't happenhttps://github.com/DefinitelyTyped/DefinitelyTyped#i-want-to...
I didn't know about this, thanks.
This is rare (I have never run into it in many years of writing TS code and pulling repos from NPM), and if it does happen you can always ignore the definition and turn it back into a plain JS package.
Not rare. Happens every 12 months or so in my experience as a library maintainer. It really sucks that Typescript, let alone .d.ts files produced by the compiler, don‚Äôt follow anything resembling semver.
> newer versions never have breaking changes anyways.I've also seen changes to the type system that break existing library typings.  (e.g. when they started strongly typing generators.)I suppose this only happens when you're using the more strict compilation settings, but that's a major draw of typescript in the first place.
That's the exact case I was referring to in i) - and what drove me to write this post :)
> and newer versions never have breaking changes anywaysHuh? Typescript release note regularly contain information about breaking changes. They may not be dramatic; but they are there.
#3 really depends on how complex your types are. Lots of legacy JS libraries and applications can be quite... esoteric when typed. Then there are the people that love playing with the type system for the sheer joy of it.The net result is that greenfield TS projects often end up simpler and faster but that‚Äôs not very useful for someone buried in an old JS project that enthusiastically abuses the dynamicness allowed.
+1 for the strict mode. I consider it a must-have quality requirement.I honestly don't understand why it's even optional, as being able to know what is nullable or potentially undefined is extremely important, and not having it can lead to tons of bugs.
Just to add to #4, I've worked on some large codebases where transpilation starts taking a very long time, and I begin to think "wow, this is really straining TSC"... so far, every time it's happened, it's been because some sort of data files weren't being excluded from the build.
Idk if I‚Äôm just an idiot but my company‚Äôs codebase for the last year has had pretty slow tsc compile times and nobody on my team has been able to make it better. Probably since we have a decent amount of generated code that pushes the amount of source code up considerably, but still no good answers to make that better.
I don't do anything with generated code. But is it necessary to generate that code every time TSC does a build? Could it be independent? I usually use two different ts export indexes, and create two dist JS files for each app. Most of the boilerplate that rarely gets touched (user management, login and signup screens, common UI elements, utility code) is essentially in an outer JS file that loads the inner JS with the business logic and meat of the app,but has no imports from the inner JS whatsoever. They're basically two separate projects. Not that I've noticed much difference with tsc, but it makes webpack or r.js faster if you can create separate webs of dependencies and only need to repack one of them without touching the other...
If you are autogenerating code you can generate it in JS and skip compilation altogether.
The point of the generation is to build type safe API clients, not for the runtime behavior, so that doesn‚Äôt really fly unfortunately.
Of course, there's more than one way to build a good product.Personally speaking, I'd say that adding another layer of abstraction onto your stack shouldn't be a dogmatic thing that you just reflexively do without considering the actual needs of a particular project. TypeScript offers some benefits for certain types of complex projects, but also some costs and problems that might not be worth dealing with for certain projects.It's a little bit like GraphQL in a sense. That's a phenomenal idea...for a product like Facebook...but probably not actually needed for every single project.
Could you describe the costs and problems that might be considered not worth dealing with?
The short answer is no. Typescript is not worth it. The reason is because:- WebAssembley (which other, controversially better or at least more adopted languages also target)- Javascript's spec. is not time invariant (https://github.com/tc39/proposals#readme)- Typescript isn't the best solution (There are better less adopted solutions providing types, like Elm, Rescript, or Purescript)For Javascript, the real solution is hygienic macros and contracts, but because `eval()` can't get no love or safety on the browser side, everyone on the server-side has to suffer.Ironically, introducing a fake compilation step where Javascript transpiles to Javascript (not like babel.js which targets older JS, but literally just the same lang spec) is the way to side step the `eval()` problem, lol! (expanding those `eval()` in a fake compile step)
What is a bit sad is that JS and TS both get in the way of the development of something more sensible to replace it. I had hoped that WASM would make application development for the browser a bit more sane.  I had hoped that someone would create an application framework for a sane, strongly typed, mainstream, compiled language that has decent tooling. With compiler and dynamic loading as part of the runtime.JS is a garbage language.  You need only look at identity or all the stupid asymmetries in the language to realize it isn't a well designed language. TS tries to fix that, and good job for doing that, but you can't escape the fact that it is desperately trying to fix a pig with lipstick, botox and hold-in pantyhose.
I haven't tested it but I know Kotlin.js exist and you can use it with React. It wouldn't surprise me if it is good but at the moment TS is good enough and "everyone" knows it.
I had some pretty strong pressure applied to use Typescript for pianojacq.com but resisted it for a very simple reason: no tooling other than an editor reduces the barrier for contribution so much that it makes it possible for outsiders that just know Javascript (a large multiple of the ones that know TS) to contribute to the project.It also means there is no 'development environment' as such, it's just a repo on gitlab that anybody can read, fork and contribute to from within gitlab if they want.I have also tried to keep the number of dependencies to an absolute minimum, which also helped to make something that doesn't feel like a moving target.
To make an anology.Js is a shovel. Simple. Does its thing. Digs dirt in our quest for gold.TS is like adding a two stroke petrol engine so the shovel vibrates up and down. Loud, jerky, difficult to handle.A sane person looking in would wonder why not just buy a jackhammer(java/c#)? Or use an excavator(Rust/C++)?Why is it neccesary to attach an engine to a shovel?
I think you are asking the wrong question. The right question is whether it is worth opting out of the benefits of typescript. The answer to that is probably no for lots of people. Another valid question to ask is if typescript is all there is when it comes to those benefits. And the question to that is also no. It's a nice step up from Javascript. But why stop after that? There are so many other languages out there that offer so much more. And some of them even transpile to javascript.Regarding your points:I) this is indeed endemic in the javascript world. I would not blame typescript for this. I work with Java and Kotlin a lot. Things are more stable there. Five years is short for compatibility. In the js world, six months is long.II) The typescript annotations are documentation too. They help your IDE figure out what is what and enable things like autocomplete. The original js code probably isn't a whole lot better. Also, lots of libraries are developed in typescript these days.III) That's what happens in weakly typed and highly asynchronous environments. Pure javascript just moves that burden to runtime. Better to deal with it before you deploy your code.IV) Most modern javascript is transpiled. It's a compilation target at this point. So you might as well make full use of the fact that there is a compilation step. The packaging and minification is actually just as bad.
To me the language is very secondary to me as it exists in an endless swamp of:- chaotic and baroque layers of tooling that need to be figured out and made to keep working- a software tradition where poorly thought out ideas are implemented with vigor resulting in design by accident- ...which then results in frequent rewrites- a universe of low quality libraries and frameworks resulting in frequent discovery of serious bugs- every project having lots and lots of dependenciesAnd that's before we even consider the language or the congenital defects inherited from JavaScript.
Yep. I've had the foolish (mis?)fortune of scaling a couple of frontend projects from small to not-so-small starting in JavaScript and then converting to TypeScript. In each one, starting out with vanilla JavaScript was faster (no build!), but at some point our velocity would slow as changes required more testing infrastructure. After switching to TypeScript, we were faster than before.Sure, dealing with TypeScript can be a hassle, but it is less hassle than dealing with broken software.
> Sure, dealing with TypeScript can be a hassle, but it is less hassle than dealing with broken software.Can you think of examples where it's prevented broken software? I would prefer to spend more time writing good unit test coverage which in my experience would catch anything that TypeScript would have caught. I have seen it be more useful for autocomplete and self-documenting code, which I could get using JSDoc or something similar.
The biggest impact was in refactoring working code.Being able to change something, and then have my IDE know those types elsewhere in the codebase and change them automatically, OR give me a detailed list of where things have broken, immediately, is significantly faster than tracing through failing unit tests to work out what needs to be fixed.It's not that it couldn't be replaced entirely with unit tests - it certainly could. If that's your preference, comprehensive test coverage can be more effective than TypeScript alone. But as an online helper in the IDE pointing out where I've messed up even before running unit tests, it can make writing and iterating on correct code faster.
Piping data around an application where each step applies a transformation. It is very difficult without a type system to keep track of what the inputs and outputs are supposed to be at each step. Typescript makes this a breeze.
If your entire codebase uses static typing, you don't evenneedan entire class of unit tests for checking the validity of inputs/outputs to functions. You can spend that time testing business logic instead.
I know it's happened, but I find out about the error before I've run the tests, or I've used the types to guide me to the correct code rather than writing without and then testing to find out if it's correct.The autocomplete and documentationareabout preventing broken software. You just don't think about it like that because it skips the seeing it break part
100% my experience too. It's not that much more work to get TS setup for a projects and the dividends for doing so are vast in the long run.
I don‚Äôt see the need for TypeScript. A lot of people seem to see dynamic typing as this big bad thing that should just go away.I haven‚Äôt used JS professionally so maybe I don‚Äôt know any better, but I think dynamic typing should be embraced. There are A LOT of applications where you really don‚Äôt need to worry about types. And from my experience working with app/cloud code bases in C#, I‚Äôve seen a lot of ugly classes that I can‚Äôt touch simply because they were written 10 years ago and I don‚Äôt trust them. My guess is the web world is plagued with all sorts of old code you don‚Äôt want to touch, I don‚Äôt think TypeScript solves that with static OOP.I think the prototype based OOP approach in JS is better because you don‚Äôt have to concern yourself with all these hierarchies. You can have multiple car object definitions with dynamic typing, it doesn‚Äôt matter because it‚Äôs all about what‚Äôs being used in the moment. In static typing we expect a single concrete definition to be extended, composited, and reused in an intricate way. That way never works because what is defined today as ‚Äújust the bare minimum‚Äù mutates into something larger and now everything inherited ‚Äúneeds‚Äù it too. But they don‚Äôt always truly need it, they just have to satisfy some argument. And of course that ‚Äúsingle‚Äù definition gets duplicated across the code bases anyway. Initially we think of these approaches as elegant, but it almost always rots in its own hierarchal casket.Dynamic typing allows cleaner OOP and its approach is more honest. ‚ÄúI need a representation of this abstract type right now‚Äù, not that type and a whole bunch of other crap that it‚Äôs fundamentally forced into bringing along for the ride.
i) TS isn't a framework. And you don't have to use it everywhere in your system. You can decide how heavily to leverage it, developing a 'core' TS subset that powers a broader JS layer (or the opposite, or something different)ii) Lots of libraries are extremely well documented and typed. This is the same in any language not just for types but also for docs, capability, perf etc. This argument applies to all software everywhere so it doesn't make sense to single out TSiii) Error messages can sometimes be hard to follow. But you get better at parsing them very quickly when they get gnarly.iv) Transpilation is nearly always a required step anyway. Adding TS support is minimal. There are plenty of tools that do TS to JS on an order of magnitude of MS.All decisions are tradeoffs.What benefits does it bring (ignoring the biggest one of them all)?TS makes it easier to maintain software across large teams by providing a mechanism to express relationships in a codebase.They are self documenting and replace a lot of JSDoc needs (letting you focus docs on more useful info like intent, design choices, example usage, etc).Types can also replace the majority of unit tests validating code is correct saving time on running fewer unit tests and letting devs focus on integration tests.Lastly, I've never seen or experienced something breaking from upgrading the Typescript version in a project. Even when a TS upgrade has 'breaking changes' they never actually break anything in practice that I've seen.
> ii) Lots of libraries are extremely well documented and typed. This is the same in any language not just for types but also for docs, capability, perf etc. This argument applies to all software everywhere so it doesn't make sense to single out TSI am singling out TS because although most good libraries have documentation for all of their methods, along with examples, many useful and popular libraries do not include full documentation of their types. Some hardly any at all.Usage examples are some of the most useful piece of documentation you can have in a library, but many authors choose to show their examples in JS, in order not to be too opinionated. It is the fact that TS is not actually part of the language, and simply an add on, that I believe is the cause of many of these issues.> What benefits does it bring (ignoring the biggest one of them all)?I do believe it brings benefits and agree with what you have written, of course my view is that those benefits just aren't worth the effort. In my experience some of the best codebases I interacted with were neatly written and well documented JavaScript codebases - no TypeScript, whereas many of the TypeScript codebases have been very hard to understand and work with. This is by no means due to TypeScript, however it doesn't make me think that it helps in terms of making anything that much better.I can't even remember many times TypeScript has actually prevented a bug, it's been more useful for documentation. But then I would prefer JSDoc which isn't so difficult to maintain and can still provide autocompletion for you.
> many useful and popular libraries do not include full documentation of their types> but many authors choose to show their examples in JS, in order not to be too opinionatedThis is certainly true sometimes, but I don't see why it's a reason against using TypeScript? If you're calling a TypeScript API, the way you use it should look basically the same as the way you'd use it in JavaScript. Youusuallydon't have to do anything special with the library's types unless you're getting fancyThere are exceptions- I've had a rough time fighting to get code using the styled-components library to fully typecheck, because that library gets super fancy with the way they represent things (I don't like it for that reason personally, but I know others do). But libraries like that are the exception in my experience, and if it's really that big of a drain on productivity, you can always bail out and use `any` types to skip dealing with it
I am thinking of the case where you are passing an object or class to an API that needs to be shaped a certain way. In this case you need to know which type to import/use to pass it through.For many simple libraries it's not too much of an issue, but for more complex things like Apollo (which also doesn't include much TS in their docs) it's a lot of hit and miss until you get it right.
Sure, that can happen. I guess I feel like if it'sthatmuch of a problem for any given library, you always have various ways of disabling checks where you need to and still benefiting from them elsewhere. So it's still a net benefitI will also say- GraphQL almost by nature is gonna be a really hairy thing to statically type, especially on the server side. We've got an Apollo server at my company and thus far we've pretty much just punted on trying to type that part of things. Which is also more okay than might be for other things, because GQL does its own runtime validation anyway
I agree on the "error messages are hard to follow". A lot of times when you have an error it doesn't clearly communicate "hey it should look like this" (something Rust does soooo well) and instead says something like "types or property A incompatible with property B that is incompatible with X and not Y and ....". It basically just explains the nesting but is so hard to actually make sense of or how to solve it.
> It's a framework, with all the usual framework downsides> For example, a new package you install can require a new TypesScript version. Once installed, you then may need to update your source code. This can place quite a high tax on the developer, where perhaps a 10 minute change becomes hours long.No. It's a language compiler. You can upgrade it safely without changing a single line in your codebase. If there is a breaking change (sometimes, regarding the strictness) there's also a configuration option that lets you keep the previous behavior.> ii) Libraries are badly documentedAnd so you're going to lose any and all typing as your solution? I don't understand. Undocumented but typed >>> undocumented and untyped.> iii) Error messages are hard to followI disagree completely, TypeScript has helped me many times to understand what's happening and why - I mean errors that I wasn't aware of in my previously untyped JS codebase.> iv) It requires yet more transpilation> Transpilation takes time, and always adds a burden to developers.Doesn't matter. Use SWC or esbuild for sub-100ms compilation times. Your CI is a long running job due to tests and lint anyways. Nobody is writing pure uncompiled JS these days - you can't use NPM libraries that way, so there's always some (Web)pack step. I haven't seen a single developer who liked having to care about browser versions and wants to go back to that - but if you add a compilation step you get that for free and can write the latest and greatest.
> No. It's a language compiler. You can upgrade it safely without changing a single line in your codebase. If there is a breaking change (sometimes, regarding the strictness) there's also a configuration option that lets you keep the previous behavior.I am currently stuck on a very difficult issue because of a TypeScript upgrade. The upgrade caused a type mismatch with a dependency that wasn't previously an issue, and due to the lack of documentation on that dependency I am currently trawling through source code.> And so you're going to lose any and all typing as your solution? I don't understand. Undocumented but typed >>> undocumented and untyped.No documentation of types means going into source code to see what is there. Sometimes there could be multiple types that could be used for something, and it's not clear which should be used. Most libraries have clear docs to show me how to use a function, I'll take that any day over the uncertainty of which type may be correct in many places in my codebase.> Doesn't matter. Use SWC or esbuild for sub-100ms compilation times. Your CI is a long running job due to tests and lint anyways. Nobody is writing pure uncompiled JS these days - you can't use NPM libraries that way, so there's always some (Web)pack step. I haven't seen a single developer who liked having to care about browser versions and wants to go back to that - but if you add a compilation step you get that for free and can write the latest and greatest.Not arguing for no transpilation though browser compatibility isn't much of an issue these days unless you are using some super new features of the language (the reason is more about bundling the code together and jsx as far as I understand). I am arguing that each transpilation step adds yet more config that needs to be built, understood and maintained. TypeScript is probably the worst offender, almost as much work as maintaining another webpack config in your projects.
Did you upgradeTypescript(and if so, why), or did you upgrade some project dependencies, or type definitions?> No documentation of types means going into source code to see what is there. Sometimes there could be multiple types that could be used for something, and it's not clear which should be used.I haven't had this experience, and I'm not super experienced with Typescript. Are you using VS Code? It typically makes it trivial to find the definitions of things I'm interacting with in the editor.
> Did you upgrade Typescript (and if so, why), or did you upgrade some project dependencies, or type definitions?I need to upgrade it because I upgraded a dependency that needed a newer version of TypeScript to compile! And I needed that dependency to be upgraded to use a newer version of NodeJS.It seems that the newer version of TS was more strict, and now I can't find a type from ProtobufJS that fits the code. I can update here when I understand more about this particular case, but presently my best bet is to loose some typing and autocompleting by using some unknown types :(
Did you try regenerating protobufjs and .d.ts files after upgrading?For me it's something likenpx pbjs -t static-module -o protos.js *.proto
    npx pbts -o protos.d.ts protos.js
> Did you upgrade Typescript (and if so, why),What an odd question! Even ignoring new features and better type inference that comes with new versions ‚Äî once you add typescript to your project, it becomes one of its dependencies. Don't you regularly update your dependencies, just as a good practice, not to let your codebase slowly rot?
>Don't you regularly update your dependenciesNo. Update dependencies as needed for security patches (which typically avoid breaking changes), other than that never update unless there is an explicit business need.
Yeah, I'm with you. I have a lot on my plate, maintaining and developing the main application I work on single-handedly, while also working on several other projects, and putting out fires elsewhere in the company as needed.I don't have time to spend days to weeks figuring out why upgrading Tailwind to version 3 breaks the project because of (presumably) my version of create-react-app.. do I need to eject, or copy the .ts/.tsx files over to a Vite project? Do i want to fuck around with CRACO, or editing the internal monster of a webpack config file directly?Yes, critical security updates are important, but you shouldn't just go around upgrading major versions of other packages in your production app, without the understanding that it might be anincrediblytime-consuming endeavour.
I am the opposite. To me, dependencies in a project are a debt to which I regularly make my payments by keeping them up-to-date and resolving breaking changes as they arise. Allowing dependencies to fall too far out of date, in my experience, made updates ‚Äî when they became necessary ‚Äî too painful.
I agree with your comment, however please don't make new accountsjustto respond to a single post or comment, judging by your username.
Couple of years working with TS and I think I can add my 5 cents here:1. It is worth it, but not as much for benefit of types safety straight forward as for ... "intellisense" that discharge you from remembering stuff and misspelling it2. It is annoying - they (MS/TS team) have very "conservative" approach which leads to:- no operators overloading, 
  - no option to extend primitive types, 
  - no option to get info about your types at transpile time, 
  - no built in options to improve performance at transplantation time,
  - no built in options for transformation plugins
  - no other than JS transpilation targets
  - need of tons of other tools to make your actual target, 
  - ... etc.At the end it does job well, but only because you put in it a lot of man hours (to learn, develop and maintain) - and everyone seem to be happy about that.Sorry for being a bit grumpy, but sometimes it feels like wasting a life working with TS. ;-) (especially when I read again what I just wrote ;-) )Seriously, let me know MS/TS team if you need someone to drive to TS some real fresh new value ;-)
After years of Flow, Typescript, Webpack, React, JSX, etc, I went back to just vanilla HTML, CSS, JS for my most recent production project (https://play.d2lang.com, which is open source). The experience was great. I didn't find myself missing any of those tools.
Just curious - how many developers worked on that project, and for how long?
if you're talking about the playground, I did the initial version in a weekend or so (https://github.com/terrastruct/d2-playground), which includes building a WASM version of D2 (written in Go), putting a text editor, some UI stuff like dropdowns/menu, hooking it up together, layouts and responsiveness whatnot.
For me, TypeScript is like putting lipstick on a pig. It improves one thing about JavaScript while leaving all the numerous other flaws and introducing new ones.
If you are doing JS then you should certainly be using Typescript.The best choice however is to simply use a better ecosystem entirely.IMO JVM+Kotlin is great general purpose combo, Rust is good if you don't write the sort of code that needs GC'd structures, etc. Between those two I rarely need to consider anything else.
I find TypeScript very helpful! As a self taught developer I always used to just use JavaScript, but after joining a big company and working with TypeScript I prefer it now. I like how I always know "what's in the box" now when working with different objects and whatnot.
One of the biggest mistakes that I see devs making is caring too much about making TypeScript happy when they know it doesn't really matter.There are a lot of cases where it's totally reasonable/rational and honestly fairly safe to just throw in a well-scoped "any" cast, a `// @ts-expect-error` comment, etc.If you know what you're trying to do, and TS isn't understanding, sometimes it's just a lot more expedient to tell it to shut up and listen to you.Of course, sometimes you're wrong, and you don't want unsafety to leak, so it does require a fair amount of experience and judgement to do responsibly.
This feels like telling Haskell developers that they should use unsafePerformIO and unsafeCoerce more.
It's much more like reminding TS developers that Go developers have to use `interface{}` all the time, because some types are actually hard for compilers/typecheckers to deal with.
Maybe? Occasionally telling ts to shut up or lying about types is better than not using it because you have a hard time getting 100% type correctness.
TIL: `@ts-expect-error`I've been using ignore a lot and leaving a comment.
If you write a project for yourself, or develop a startup or an MVP it's often not worth it.Late-binding dynamically typed languages are underrated, if you can hold the mental picture of types in tour working memory, that is.
There's elm, a statically-typed language with none of the pain points you described.
So my short answer is:
Compared to javascript, yes, it's worth it.
Compared to elm, no.
The answer to "is {{tool}} worth it" is almost always "sometimes"Typescript is a wonderful tool for many situations. Typescript may not be needed for all situations. There's upfront cost to configuration and tooling. But you get type safety and automatic documentation.In all my new non-trivial projects, I default to typescript. It has caught so many issues and saved me a lot of time. Not having it feels like driving without a rear-view mirror. But, if I'm just writing a little script, I might omit it.
For ii.) Typescript is a superset of javascript. If it annoys you to try to translate JS documentation into TS, then don't. Just use the JS example and use ts-ignore or something similar. Why throw out TS when you can literally suppress those one-off instances?iii) You should see C++ template errors if you think the TS errors are bad. The TS errors do suck sometimes, but when I see which line of code it's complaining about, it's usually enough to clue me in to what the problem is. And once again, ts-ignore exists for a reason ;)iv) The majority of the frameworks I use allow you to skip transpilation while developing. So you can supply the TS files directly, and then transpile when you're done.TS has some problems sure, but these all seem like very surface level complaints that you have to deal with in any other language. Which language has dependency management solved? Or clear and concise error messages all the time? Or super fast compile times? I don't see any alternatives that don't host some or most of all of these warts.Additionally, when I code using Javascript I feel like I'm blindly groping my way through the magical forest of dynamic code. Typescript gives me a clear and concise road map and helps me avoida lotof traps laying around that are obscured by that dynamic magic.Is typescript worth it? 100% yes.
There is a big issue with ‚Äúsuppressing one off instances‚Äù: the truth is you‚Äôre either fully bought in or you‚Äôre not. If you have ‚Äúany‚Äù types or ignores littering your code base, you don‚Äôt have type safety, and at that point, why even have typescript? There‚Äôs not _really_ any such thing as being ‚Äúmostly‚Äù type safe. You could argue that ‚Äúthis part of my code is type safe‚Äù but if it interacts with any other part of your code that isn‚Äôt, then what‚Äôs the win?
Your code is going to run on a computer somewhere.  It will never be completely safe.  And many kinds of error will escape even full detailed types.Mostly safe is useful.  The more you tighten types, the fewer errors can occur.
My problem with typescript is that at the hands of a typescript aficionado the code is nearly impossible to read.It requires so much mental effort to understand what's going on
The way I think of this is, if I were running a small team as lean as possible and trying to grow as a business, getting as much out of expensive developer time as possible, my answer would be that I get productivity gainssometimesfrom the work put in to strictly type inputs and outputs to/from functions, whether they be props on react components or whatever. Otherwise, largely a massive time sink that I'd be pissed I'm paying for.
I've used TS since it came out and it's always been great.There are a few quibbles with TS devs over not implementing certain ideas because it breaks out of the JS superset paradigm, which really makes me wish we had a TS++ or TS# that broke this on purpose but hey.It does have a lot of problems, but it usually comes down to pre-existing ones.
i: yup but like, isn't that true of every framework/language/library? But less so for TS given that it's open sourceii: this is the JS ecosystem in a nutshell, but I think you'll find with any similarly sized ecosystem, built from the thankless efforts of a bunch of amazing individuals in the community that this is true. If you want Oracle level support/docu you gotta pay big $$$ for itiii: this is very true and my advice to other devs I work with is usually to read more towards the bottom of the error. TS currently gives you a lot of context for the error, much of which may be but isn't always useful.iv: realistically we have been waiting for a very long time for node.js/browsers to be able to run TS natively. I would be a huge fan of this. Transpilation on large projects can take a good amount of time, but I'd say the larger the project the _better_ the advantage you will have using TS; sure you'll have to deal with trans times but TS can really save your butt when making a breaking change in a large project.I've used Node.JS pretty much my whole career, whilst I've done a lot of stuff in C# and C/embedded as well my mainstay has been Node & JS and as soon as I could use it, TS.I remember callback hell, I remember adding console logs every few lines to figure out what the fuck is going on, I remember sitting in the debugger trying to make sense of why various vaguely connected chunks of code weren't working properly. I've seen things you people wouldn't believe. Attack ships on fire off the shoulder of Orion. I watched C-beams glitter in the dark near the Tannh√§user Gate. All those moments will be lost in time, like tears in rain.
I love TypeScript in the right places, but I think it‚Äôs often used for things where other tools would be a much better fit.On the backend it can be nice if you‚Äôve got a monorepo including the front ends it supports. Maybe you‚Äôve got graphql happening and you can share types. That seems great sometimes, and there are cases where it‚Äôs super handy and efficient.I don‚Äôt know for sure, but it doesn‚Äôt seem worth it after a certain point. I‚Äôd much rather keep typescript to the front end where I find it really shines. I‚Äôve worked on a lot of projects where it was full stack typescript and there were always these common, nagging, very typescript-and-JavaScript-specific problems.Fundamentally the build and development tool chains in general tend to be awful. I can accept it on the front end out of necessity, but on the back end it gets egregious quickly unless you‚Äôre using micro services and builds stay quick by default.Any time I work on something statically typed with nice tooling I realize how much better life can be. It feels like the minor gains I get from fullstack TS are quickly negated by the plethora of advantages to using something like Go or Rust where I can purpose-build applications with absolutely crazy performance, reliability, and portability.So, TS in the browser is awesome. I think you‚Äôd be crazy not to. On the backend on the other hand ‚Äî unless you‚Äôve got like a perfect fit for using something like Next.js or a static site generator where the backend can be dead simple, I‚Äôm pretty tired of dealing with its deficiencies.And even then it‚Äôs not the language so much as the cruft built up in tooling over the years. It‚Äôs slow and awkward. NPM is plain old awful. Basics like linting are painfully slow. Testing libraries feel like a house of cards. And so on.
There are alternatives to NPM, and high performance build tools.  A lot of code-quality tools like linting are on the slower side though.Ultimately people use TS on the back end because they want to simplify hiring and reduce context switching loss in developers mostly, and in some cases because their application is isomorphic.  This choice works well when the ratio of front end to back end code is high (which is the case for most shops), since these benefits outweigh the downsides of developing services in Typescript compared to go (I wouldn't write most services in rust...).
> Ultimately people use TS on the back end because they want to simplify hiring and reduce context switching loss in developers mostlyIn my experience this hasn‚Äôt panned out particularly well, but I believe it works for some teams.> because their application is isomorphicThis is one case where it had worked out okay for me. The scope has tended to be relatively limited and there was a framework in place which was generally good at gluing things together and ensuring people work along the same rails.> I wouldn‚Äôt write most services in rust‚Ä¶No, me either. I tend to teach for Go for web services these days, but I do like rust for CLIs and situations where optimizations are crucial. Admittedly I don‚Äôt even like Go as a language that much, but it‚Äôs great at what it does if I‚Äôm willing to put my head down, deal with the quirks and verbosity, and crank something out. It‚Äôs not a language of cleverness or elegance, but the results tend to be excellent and easy to maintain.
Ok so I finally created an account just to respond to this post because I wanted to share my experience with typescript.
I really don't get the confusion and doubts about the usefulness of typescript. It's my favorite language to use because of it's expressiveness.In my company we built a lot of web apps in very small teams (mostly just 2 people). We use mostly c# as a backend and typescript + mostly angular, sometimes react as a frontend. When typescript came out I built a conversion utility that allows me to generate typescript definitions and metadata from my c# type definitions. In angular I built my own type safe reactive forms, access control and API framework. Often we use ef core as a database layer on the backend, so we have a single source of truth (the c# types) for database and frontend types for the API. I use mapped types in typescript a lot to reuse the generated API types in my frontend code. If a field in a class is renamed ef core takes care of the database migration. On the frontend I get notified of every error because of the rename. Is there a table column for the field, I get an error. Is there a form that maps to the field I get an error. Do I check for write permissions of the field with the old name somewhere, I get an error. I use exhaustive matching to ensure that all cases of enums or union types in general are handled. Everything is type safe and the types come from a single source of truth.It's so insanely productive it feels like magic!Edit: also wanted to add I mostly do not use libraries outside of framework libs for angular or react in my frontend. Generally most library code I need (with few exceptions) is built by myself rather fast and easily. I avoid libraries because of the npm ecosystem mess but it also has the upside that I don't have problems with outdated type declarations or typescript incompatibilities.
Hoenstly, for production code, TS makes me sleep better. No matter how many tests you write, that one undefined object will get you at some point. TS helps to eliminate a complete set at compile time (as you know) and that's great!Anecdotal evidence from my Haskell experience: If my Haskell programs compiled, they usually worked. Which is amazing. Powerful types for the win.
> Anecdotal evidence from my Haskell experience: If my Haskell programs compiled, they usually worked. Which is amazing. Powerful types for the win.I have the same feeling regarding Haskell, Elm and Swift, the latter I program in 99% of the time. I really don't feel like I get the same sense of security from Typescript, to be honest. Maybe I'm not using it correctly? I tend to lean more towards OP's opinion. I would probably prefer something like Rescript, but haven't looked much into it.
Rescript and its standard library Belt are great. I have been using BuckleScript/ReasonML/Rescript since 2018. It gives better guarantees than TypeScript and has a stronger focus on the functional approach to problems. The only drawback is it has less documentation than TypeScript, and you will likely have to write bindings for JS libraries you want to use.
Thanks for sharing, I'm definitely going to dig into it more.
I agree Typescript doesn't give "if it compiles it works" but itdoesgive "if it compiles there aren't totally noddy errors like typos". And it gives you a codebase that is understandable and maintainable which JavaScript does not.
I get your point, but it actually increases my productivity. Some examples:I no longer have to worry about things unknowingly becoming undefined or falsey.When chaining map, filter, and reduce, I know at every step of the way what kind of object I‚Äôm working with.And when I use a dependency, I don‚Äôt have to trust possibly outdated documentation but can rely on types.Just these three things make it 100% worth it for me.
"Thank you, TypeScript." < something I have said sincerely on a few occasions."Thank you, JavaScript." < something I have said sarcastically on many occasions.
I don't think (i) doesn't make sense to me... I guess a packagecouldfoist a TS dependency on you but it certainly doesn't have to. It's pretty sloppy if it does, so maybe not the greatest package anyway. (ii) has nothing specifically to do with TS. (iii) agree. (iv) sure, though static type checking requires a static type-checking step and tool.You started by skipping over the benefit of static type checking, but that's the direct trade-off: is that benefit worth the extra complexity and time spent satisfying the compiler. For me it's probably usually yes for smaller projects where I know the devs can handle it and definitely yes for larger projects where the communication burden is high (it just partially helps people stay on the rails, organized, and on the same page -- not sufficient by any means, but it eases the strain).
My biggest problems with TypeScript are that it regularly gives me null safety bugs even after I add guards. And I can't really trust the types typescript offers.I've been using typescript for a year now and I just want to go back to Java at this point. Biggest obstacle to that is management believe it or not.
> i) Like a framework, you are at the whim of TS devs as it gets updated (edited)I have been using TypeScript for almost 6 years and not experienced this problem. Like everything else keep things simple, don‚Äôt chase trends, and so long as do right by your product everything will be smooth. I also don‚Äôt waste time with large SPA frameworks.> ii) Libraries are badly documentedI don‚Äôt use many dependencies. The DOM and Node type definitions are extremely well documented and inspired me to write better documentation.> iii) Error messages are hard to followFor me this depends on the complexity of a given object or type definition. When things are primitive the error messages are more clear. My only suggestion is to keep your interfaces primitive.> iv) It requires yet more transpilationI use SWC as a TypeScript stripper. My nearly 50kloc project takes about 2seconds to covert to JS, which pushes out my total build time to about 2.5seconds.
To me it's worth it because as opposed to languages designed to be strictly statically typed, the type system is there to serve you, not the other way around. It's pragmatic and tailor made for its use case.People who've always programmed in traditional statically typed languages like Java scratch their heads on why would anyone not want to have static typing, but the reason for that is simple: in a dynamically typed language you can (and often do) produce code that's hard or impossible to type in said statically typed languages.TypeScript's designers recognized this, so not only there are escape hatches here and there, but also the type system over time evolved to adapt to the real-life use cases instead of imposing some abstract, complex type system which might not even be very useful when used against all the creative ways JS programmers write their code.And it works.
Personally I moved over to Rust for as much as I can.I still use TS on frontend (as frontend framework in rust are not quite there yet when compared to something like solid start - perseus is getting there though) but I definitely use any freely when I'm in a hurry.That's exactly what I don't like about TS: it enables developer to bypass safety making the whole thing not very safe. You can't trust your dependencies as you normally do with Rust (unless your dependencies specifically opt out with unsafe - there is still deps vetting needed, but it really hasn't been a problem).Is it worth it? Before swc I would say no, with swc (typescript compiler written in Rust) the perf hit and DX is not too bad and I'd say yes.
I'm with others (it's worth it when there are more people / the code needs to be correct), but the example of Protobufjs is unfair: I expect it to be super complicated to work well with Typescript. TRPC is growing for a good reason.
I've come to TS from Python.To me, install a new package and it requires "target=ESNext" and modules="ES2022" and suddenly I feel like I'm back in the Python 2 to Python 3 transition debacle.Except this happens every couple of weeks!
We recently brought a large js project from js to ts and, while we had issues, almost all to do with transpiling and the obvious end result being javascript which is not typed. Coming from f#/c#, and having used Purescript, typescript feels familiar, however, it takes too much from js imho. Especially the automatic coercing is pretty annoying to us and still causes pain we would not have in the other languages mentioned above, but it is miles better than js. We can refactor much faster than we could before.We definitely are happy with the move. I will never be a fan, but the alternatives I cannot sell to the team.
I think what you've done here is document the pain introduced by using TypeScript, but you've not documented the (unknown) pain from not using it.The question should really be, are the development pains you have more or less than the (most likely) production pains you'd see if you weren't using it?I personally believe that more problems in development for reduced production outages is the right answer for the vast majority of software development.If would be interesting to know of cases where projects have stepped away from it. I'm sure there are some examples and it would be interesting to understand their reasoning.
For me, the main problem is that TS doesn't follow semantic versioning and this leads to a fragmentation of libraries support - unless they also provide multiple type definitions (some of them actually do) - and migrating to newer versions is usually harder, because breaking changes happen so often. So I guess point i) is correct.Let's see the others.ii) It's true that many libraries don't have type definitions, but the most used ones have an externally-maintained corresponding @types/### package that solves the problem. And even if they don't, how is it the fault of TS? The alternative is no type documentation at all - is that better for you?iii) Yes, error messages are something that can be improved, but then again, the alternative is no static error and eventually an even more laconic runtime error. Would that be better?
At least, TS catches that there's a problembeforeyou run the code.iv) Compilation adds a burden to the CPU, not the developer. But anyway, it's a one-time process, and unless it takes 30 minutes it shouldn't be a problem. There are new, much faster compilers nowadays, like esbuild and SWC, plus other tooling tricks like module caching, that makes your local development almost feel like there's no compilation at all.I won't discuss the merits of the adoption of TypeScript. Since I started using it - except for very simple projects - I always felt like I'd be way less productive without it. And I actually had the confirm recently, when I had to work on a Loopback@3 BE that somehow is in JavaScript (even though Loopback 3 does support TS).It's been a mess. Trying to understand the models, the signature and the sense of all the entities has been a nightmare. The documentation for LB v3 is badly maintained and sometimes broken, and this adds even more difficulty. Some dev tried to add some JSDoc info here and there, but it's not nearly sufficient to understand what's going on without investing hours of study of the existing code.This is part of the cause that prevented the team to upgrade to LB@4, so much that I even suggested to redo the BE altogether in Nest (save for the core business logic parts), rather than trying to make a sense of it.So yeah, I'll stick to TS for the foreseeable future, and strongly suggest all the teams I'm going to work with to do the same.
I've seen "we can't get OpenAPI to automatically generate our types in a sane way" derail a 3 month project to standardize an API". In 20 years of js, I never had that problem. YMMV
In a word: YES.Update TS regularly to avoid making updates hard and lagging behind to much. Unlike a runtime framework, updates are unlikely to break things at runtime, so there are no reason not to update very often. If some external types are wrong or annoying, don't forget _any_ exists and simply brings you back to the crappy situation you'd have without TS (well admittedly it adds transpilation costs, but it's still type checking everything else, which is well worth it).I think TS is nearly the best language that could be done given the constraints of being fully compatible with JS.
What I read isstatic typing is a good thingbut the costs of using it in TS aren't convincing really.I feel that using it optionally where it's easier to maintain and feel its value is the best of both worlds.
I write types everywhere. Without types, I'm in the blind. So yeah, don't look at motifs why some library maintainer has TS errors in their declaration files. I'm a full-stack TS developer, and I can count on my one hand fingers the times when some library had type problems. And if they had, I would fix them with my own declarations. But how do you code without types? It brings so much clarity to everything. Judging by your questions, you haven't worked with TS a bit. Or you like sensational HN titles, drawing in all the kids lol
I've been continuously frustrated by it - but the projects I'm working with are large, or leverage some more complicated dependencies. For example both ProtobufJS and Apollo can be very tricky.I also do a lot of refactoring and improvement on these codebases, often updating packages, so perhaps I run into more issues more frequently than many. I accept that a lot of the time it can be smooth sailing, but anything tricky and it's a real time sink.
For the most part, I only hear from typescript when there's a type mismatch.Understanding the type mismatch is ofter difficult, but it does solve a real problem.I also like that it gives escape hatches, for when I know what the type should look like, or I don't care what it looks likeI haven't found the typescript updates to be difficult, nor situations where packages I'm depend on require incompatible typescript versionsMy pains are on that it's hard to get the setup right where you aren't depending on a giant set of types packages, giving you size bloat for things you mostly don't care about.
I would say, as a person who have been developing in JS/TS daily for the last ~5-7 years that it depends on your team.If you have a larger team, yes it is worth it. If it is your side project or if you are like 2 people working on a project then I would say it's probably not worth it.Typescripts biggest strength is that it's easier to work several people on the same thing. When someone else makes a change, it's easier to figure out what their code does.The bigger the team and project, the bigger benefits you will get from typescript. At least, that is my opinion.
>  If it is your side project or if you are like 2 people working on a project then I would say it's probably not worth it.I have several frontend side projects and they all use TypeScript. The static types makes it way easier to write & refactor even if you're working alone. I have also more confidence in my code and spend less time following JS trails to track stupid runtime bugs. Older projects are easier to pick up again.Any project that goes beyond a few trivial files will benefit from Typescript.
Oh, thank heavens! Finally someone says the quiet part out loud. I thought it was heresy and that the TS bubble would never pop. From my perspective, it's not worth it at all. It's just another hype train. It doesn't prevent bad programmers from writing bad code, nor does it cause good programmers to write better code. It mostly just adds bureaucracy and hindrance, in the ways you allude to in your list. It doesn't make hard things any easier, but it makes easy things harder.It's also way too complicated for what it is. To the extent static typing is beneficial, most developers and projects only need the bottom 30% or so, but the expansive - and expanding - feature set encourages byzantine solutions, especially for showy types for whom tight little chunks of terse syntactic cleverness are an aesthetic (I've been there, I get it). And as if JS build tooling wasn't unnecessarily overcomplicated already, let's pile on a bunch of transpilation infrastructure?Now, I still use TS, having sensed that it's where the centre of gravity was moving as far as JS developer fashions. Plus, of course it's not bad to have types in the language in a rudimentary sense. Sure, why not? Moreover, I try to pick technologies that I could hire someone else to work on or collaborate with me on in the future, and TS is definitely "in". There were subtle nudges from other areas; I'm a very heavy Vue user, and Vue 3.x certainly doesn't mandate TypeScript, but let's be real; they want you to use TypeScript.I make a point of using as few "clever features" as possible; 90% of my uses are banally simple interfaces. I think I did foray once into `Map<Partial<keyof RTCSessionEventMap>, RTCSessionEventMap[keyof RTCSessionEventMap]>`, and it's not at all clear that this got me anything. But it looks cool, doesn't it? I guess that's what leads TS-heavy developers to churn out impenetrable gobbledygook. I'm quite capable of not typoing my own key names. Why are we so fixated on abstruse manipulations of arbitrary contrivances that get transpiled away anyway? I suppose you could ask the same question about any high-level programming language insofar as it ends up machine code in the end, but TypeScript's complexity doesn't reflect an appropriate humility for its place high up the meta-hierarchy. You need to be an actual programming language to ride this ride; as a fancy templating system, it's too entitled with its massive cognitive demands.I'm not going to say there's nothing good about TS. I do appreciate the ability to inspect type definitions to learn more about how a library works, especially if they have crappy documentation--which is often. Naturally, I also pocket the benefits that type definitions afford to IDE autocomplete. But on the whole, it's a drag on my productivity, and I spend an awful lot of time either struggling to decipher someone else's TypeScript or paying some sort of tribute to the exacting and mercurial TS compiler gods. I'm not writing better or error-free code because of it. Good end-to-end testing is a check on my code quality; the ever-so-occasional squiggle in the IDE is not.Related thought: "type safety" has become some sort of metaphysical fixture, an unfalsifiable theory of quality and robustness. "I'm so glad I have type safety!" is a liturgical or ritualistic statement, the kind that nobody in their right mind would question, or attempt to unpack or otherwise anatomise. It's a self-evident, ipso facto good. Types in JavaScript seem to have become a religious totem object.
This oft-posited but seldom materialised correlation between "types" and "quality" remains to be illuminated for me. My background is entirely in statically typed languages (C above all else), so I understand the argument and need no convincing that types are good, and even elegant. However, I can assure you I wrote plenty of buggy code in C, C++, Go, Java...It reminds me a bit of the apex of the TDD hypermania about "refactoring with confidence", or specifically, the naive and childlike optimism of "now that I have unit tests, I can refactor with confidence!" Can you? That depends on many things, doesn't it? Truly, how could it not? And either way, an overabundance of confidence owing to some platitudinal methodology is generally not a great vantage point to bring to engineering. Humbleness about breaking things keeps satellites in the sky, not euphoric, LSD-fuelled campfire paeans to TDD, and certainly not the mere presence of types. </rant>
Yes, 100%. This is exactly how I feel about it - and the idea it has become some unfalsifiable religious ideology is particularly poignant. It's such a drag on development and personally I just don't see the upside that much, just some assertions from people that seem to be repeating something they've heard elsewhere without much experience weighing in on the discussion (except for autocomplete and self documentation which imo is the best part, although could be replaced by something like JSDoc).Sure, I'm okay to live with TS, and it has its uses, but I thought it was about time we had a discussion about how much harder it can make development.
> The type definitions exported by these libraries can be large and complex, and the error messages emitted by TypeScript are so long and crypticWhat‚Äôs the alternative? If you make a type error in TS you get a cryptic error[0], but if you make a type error in JS you get a bug which you learn about after it crashes prod‚Ä¶[0] Personally I rarely get cryptic errors, because I go out of my way to design libraries in a way that the type definitions are kept simple, which also has the benefit of keeping the mental model of how the library works simple ;)
My biggest fear with TS is people forgeting why TS exist in the first place and stop trying to solve the problem TS solves because it's already solved. It's not solved, TS is by far the best option, but its far from being ideal. Deno coming out of the box with TypeScript support and the JavaScript Type Annotations Proposal [1] gives me faith that we will grow past TS.[1]https://github.com/tc39/proposal-type-annotations
You can't believe from how much bugs TypScript has saved me. When it was "first released" (when it became more popular), I have ported our starter kit to TypScript and was amazed on how much stuff it was detecting as not safe.Since then, I can't image working without TS. As for Third Party libraries, I have a different experience from other devs here, it works very well for most (if not all) big libraries/frameworks, and the autocomplete saves me so much time in digging in the docs.
Typescript is great but be aware that sometimes it can annoyingly slow you down. Consider these scenarios:- You want to use a third party library but it is completely untyped
- You need an object but you're just prototyping it. You don't yet know which keys will be optional
- You type a key of one of your objects. Now you load or fetch data from an API and want to assign that to it. But typescript complains because the promise can also return undefined.
- and many moreJust be aware that it will annoy you at times.
If you don't know what parameters are optional, just add the little question mark to every variable and remove the ones that turn out mandatory? Better to have some type info than nothing at all.If you fetch data and TS tells you the result may be undefined then I guarantee you your code would've randomly crashed at some point in the future because of it. That error is a feature, not a bug!
I am aware of those. I am just saying that it will slow you down or annoy you. For me, sometimes I am pretty muchprototypingcode just to see how something works. Once it does, I'll do it properly.Then I have to e.g. check if all keys of an object could be undefined before i do something with them.
You can also toss on an exclamation point to insist it's not null, and come back later to clean those up.
third party libraries can be a pain even when completely typed, if their types rely on complex inference, are really complex, or make heavy use of subtyping
I like using Typescript in general, but sometimes it becomes painfully obvious that it's Javascript with type checking added to it at a later time. So I actually kind of which there was a language I could use instead which is typed from the ground up and requires less boilerplate, no painful syntax and provides more extensive type checking. But of course the major downside would be that it becomes hard to mix that with plain Javascript.. Also due to its popularity I think this is the least of all evils.
i) You could say the same thing for the underlying language: EcmaScript has evolved so much in recent years that new packages may use runtime language features that are not supported by an older interpreter runtime.ii) You could argue that types themselves can be documentation, if named correctly. A JS library without types but great documentation is vulnerable to implementation changes that are not reflected in the documentation. TypeScript at least binds the internal assumptions on function arguments and object types to how they should be used, with a tool to check that there is a match at the call site. Throw in some runtime parsers (eg: Zod) to enforce correct input data at runtime, and from which types are inferred, and you are golden.iii) Agreed, 100%. Some people are making tools around that, see Matt Pocock's Total Typescript error explainer extension in VSCode: mattpocock.ts-error-translatoriv) Agreed again. Transpilation itself can be fast with modern tooling such as SWC or esbuild (or derivatives). Type checking is still the main bottleneck, though people like Donny (@kdy1dev) are working on a Rust-based alternative.https://www.totaltypescript.com/rewriting-typescript-in-rust
No. It doesn't fix any of the problems with JS and it introduces a lot of new ones, namely static types. Also just way more typing, but I suppose that's literally in the name..
The part you would like to skip over - the static typing benefits - is exactly where it provides the most value and that makes it worth it for /me./ Warts and all. I'm new to TypeScript so take it with a grain of salt. I agree with some of your thoughts but I see a lot of these same issues in a lot of languages and frameworks. I'm really enjoying typescript. I'll probably be a little more jaded here in a few more thousand hours of working in it.
I'd like to hear from anyone who has issues with typescript as a build tool, either via `tsc` or an integration via something like `rollup`, what issues are you having? How often?I have not found, even in really large projects with thousands of files, that its been an impediment to anything.My general disposition is the whole "anti build tools" moment is a bit overblown in practice, and I'm always searching for valid counter evidence of persistent issues that can't be easily overcome.
I don't like Typescript. I just like it more than Javascript.
Typescript was only not worth it when your core framework (e.g. react/vue) wasn't native ts and also didn't have ts support.In my experience, any npm library I try to use either already has community created types provided, is too simple to really need types/extra docs, or the docs will still be pre-es6 (pre important, pre async/await, etc.) so it's not like it was going to be convenient to learn anyways.
v) It adds so much extra complexity.vi) You trade a few type bugs that are easily debuggable and avoidable for type composition and hierarchy bugs which are hard to find.I have seen good examples of TS that make sense and made to play with functional paradigm, but in practice it was always a bloated mess of OOP JS introducing heirarchy where none is required producing components that are too-tightly coupled and resistant to change and slowed down developing for at least x10.
In my perception, TypeScript was initially designed to bring more people from Java world to web programming, and it sort of spoiled them, encouraging bad practices and avoiding to learn proper JS. I think TS has never really leaved that niche.True JS programmers are still living without TS, and TS programmers haven't evolved into some culture which could compete with them. That makes TS-based solutions inherently worse.
TypeScript is great for what it is, and definitely worth it. It is like JavaScript, just better. Just don't go overboard with types, because you don't get proper guarantees anyway!I am not using many third-party libraries at the moment, and mainly develop my own, so I am not really running into any of your pain points. For my own libraries, developing them in JavaScript rather than in TypeScript would be just plain stupid.
Something that might help is creating typed / untyped boundaries. Wrap a (possibly untyped) library with your own (maybe incomplete) typed wrapper. Then let Typescript check everything up to your particular boundary and ignore everything afterwards.It's on you to make sure you're not misusing stuff at the boundary, but less hassle to get set up and always something you can clean up later.
I find ReScript (https://rescript-lang.org/) fundamentallybetterthan TypeScript. It has easy FFI and a sound typesystem. With Rescript you wont have any runtime errors, like you can with typescript. But compared to vanilla javascript typescript is a big improvement.
I don‚Äôt mind it, but I do I think its a stretch to consider it a ‚Äúskillset‚Äù that I need to pass memorized questions about when joining a companyits like, just there. I hate how its existence dilutes the javascript community‚Äôs example code for some libraries.I find it cleaner than just JS but its pretty easy for me to keep up with value inferred type in just JSI would write my new projects and tests in Typescript
You're at the whim of the crap dependencies that you choose to use in your projects. If they don't document their code or if they force you to upgrade your tooling, it's not the fault of the TS team.I try avoid 3rd party libraries very aggressively and I don't have half the issues people talk about in front end dev. My normal set up is angular and go.
One pitfall i've found with TypeScript is getting too clever with type definitions. Too much abstraction can end up eating up a lot of time (especially with a large team). This happens because as you say, the error messages are verbose and hard to follow.Once we started keeping our type definitions small and simple we've found it's hugely beneficial.
Very much right. If the TypeScript team created basic typing without endless permutations of infinitely clever ways to create composable type hierarchies, I'd like it more.The problem with the endless permutations of infinitely clever ways is that people actually use them. You end up with shims and meta-shims and meta-meta-shims and adapters to turn this unwieldy behemoth into that one in just the right place. Very soon, you get something like Kubernetes, in the sense that the entire structure is imperiled by the weight of its own complexity. <ducks>
I don‚Äôt think TS is worth it, because I don‚Äôt think gradual typing provides a good cost/benefit ratio.If I‚Äôm going to write a bit of JavaScript, I‚Äôll write JavaScript with the minimal feature set possible. It‚Äôs not a good thing that the language has continued to accrete features.If I‚Äôm going to write something non-trivial, I‚Äôll go straight to Elm ‚Äî an actual sane language.
I pretty much deplore using Typescript for fast paced UI development.I will be using vanilla Javascript in my own projects for the foreseeable future.
TS is okay-ish.The main thing that makes it shine is refactoring.Besides that, the reast isn't that mind blowing.I still get crazy bugs just like I did in JS, TS just removed the countless small and easy to fix bugs. Which is good, because  they can really slow you down. But when you get something ugly, tests and experience are the only thing that saves you.
I can't imagine not having static typing. Maybe I am a bad coder but there is no way I would be able to catch some of the spelling mistakes, objects that are missing a property, etc. I am not sure how people catch these mistakes other than just getting value errors or doing unit tests for the smallest thing.
"ii) Libraries are badly documented"It goes both ways, a counter example which saved me from some frustration: plotly.js has a horribly bad online documentation, but their type def makes it super convenient to explore all the layout config stuff, when you're buildling a custom visualization.
TS can be a pain. I know, I fight with it all the time. That‚Äôs probably my fault though. I‚Äôve learned typescript by being exposed to it in our code base, rather than properly learning it through documentation.For all the struggle, it makes me feel very confident about the code, and its reliability. That‚Äôs worth a lot.
There seems to be a lot of bespoke choices when setting up TS which have to be weighed up.For example:tsc? webpack+plugin? eslint?And then all those compilerflags. Especially module targets.Then monorepo considerations: lots of options.Then how to generate your .d.ts files if it is a package you will publish.
Another point is that Typescript is most powerful when you use it everywhere and share types. 
E.g: Between frontend and backend API. 
It‚Äôs hard to keep track of where something is used when you change it. 
Typescript can do it for you.
I honestly can't see howanyonecan getanythingdone without static typing, for anything other than small scripts.My only issue with TS is that there are no runtime type guarantees. That, and a few odd syntax choices that I mostly don't have to deal with.
What is the alternative? If it' javascript, then no it is not worth it.If you're talking about general backend languages, then there are a lot of options. Since you're talking about large scale applications, that likely means you can use something like java or kotlin.
TypeScript feels like it's trying hard to become Java Enterprise level of complexity :)
I think that's right. I was thinking about that as I composed my own reply to this thread: it's got many of the hallmarks of J2EE.That is to say, it's got features that a thoughtful CTO in a very large organisation somewhere, somehow has a well-articulated and nuanced use-case for, but it's not you and it's not anyone you know. And there are a lot of such features.
I have been writing lots and lots of TypeScript in the last 5 years.Going back to JavaScript just feels...wrong.TypeScript isn't a perfect language, but I also feel like most of its shortcomings are related to the aim of being a JS superset.
i) Never had a problem with this, although I use very very few libraries, so that might be why. (At this point basically only preact)ii) Yes, but this can't be used to favor JS instead. If a library is badly documented, you're going to have a hard time whether using TS or JS.iii) This is true, but it depends on what you are doing. One advice is to avoid defining complex types. Another good measure is to sometimes suppress type checking on a few lines that you know are correct but are near impossible for the compiler to verify.iv) I use esbuild to compile, and have a tsc -watch window open all the time.
"... is with the amount of extra work it places on developers, much of it the "dumb" kind of work which can eat up hours and doesn't deliver all that much value."that sounds terrible.
Absolutely worth it. The benefits far outweigh these downsides, and I‚Äôm surprised someone who‚Äôs been using it for two years doesn‚Äôt agree.I would simply refuse to work on a JavaScript project at this point.
I choose to avoid typescript for most of my projects and teams. There are some exceptions.I have some fundamental guiding principles I apply to engineering, and I find that TypeScript violates these:1) Reduce complexity2) Don't be clever3) Achievement over activity4) Longevity---------------------#1 Reduce complexity---------------------Cross compilation introduces additional complexity with debugging and production support. Sourcemaps work fairly well, but often fail on edge cases - normally where you want to be debugging. I've found that JSDoc with good tooling gets 70%+ of the benefit of TypeScript without the additional complexity of cross compilation.In the browser Javascript ecosystem, I aim to have what executes in the browser be as close as possible to what I've authored. Typescript works against this goal. This is even more important to me on the server side, where introducing a build step diminishes a lot of the value of having a flexible, dynamic environment like Node. If types are desired on the server side due to needed formalism (several problem domains are like this - banking, etc...) there are other languages/execution environments that may be a better choice.------------------#2 Don't be clever------------------Clever code is frequently a maintenance nightmare. Code should be clear, readable,  and approachable. It should tell a story that's easy for anyone (even semi-technical folks) to read.Typescript lends itself to "clever" and arcane types & structures that increase cognitive load and decrease maintainability, especially as the rules change.----------------------------#3 Achievement over activity----------------------------I guide my teams to focus on delivering business results and shipping software. I've seen code bases where up to 40% or more of the total LOC are nothing but types and structures to satisfy the compiler, not to provide features. In some cases, that's a good thing - where the business constraint is correctness over TTM, for example. If not though, it can be a company killer. You can end up shackled by your domain models, and small updates have massive cascading consequences.I've seen developer's entire sprints consumed by tasks that are abstraction related, and don't provide business value. I've personally known several developers that have told me directly that they don't like shipping software, they just prefer to play with frameworks and development theories. While those are extreme cases, I know many more developers that fall somewhere around there. I'm not sure why, but I think Typescript encourages this soft of thing. I get a sense that the whole ecosystem is more about the software process than delivering valuable features to the users. Though those things aren't mutually exclusive, when taken to excess I've seen software process and tooling devolve into a weird sort of navel gazing that's a barrier to delivery.------------#4 Longevity------------I prefer to stick to standards. I also tend to avoid frameworks, I use Web Components as a component solution, and keep everything as vanilla as possible. I don't mind using stable libraries, like date-fns or lit-html, but I've been burned too many times by multimillion dollar boondoggles that result from framework churn.I encourage my team to pick technologies and development methodologies that have a five year lifespan as a minimum goal. I have code I've developed in javascript that's been running in production for 15 years without needing a major overhaul, and with stable dependencies.On the other hand, I've had TypeScript codebases that completely broke based on rule changes that came from a TS update, and required significant revamping withinsix monthsof being authored.While I do think that TS can be beneficial for some projects and teams - specifically ones that require a high degree of formalism - most of the time I don't see it providing concrete business value. I see it consuming dev cycles for limited benefit.I am looking forward to the optional typing that's currently a stage 1 proposal. I miss AS3, which I thought struck the perfect balance between static and dynamic typing. Static by default, but it was easy to opt out when being dynamic made more sense.
I strongly agree with #1 and #2 and that is why I like typescript. It keeps things simple for me. I can look at what a function's inputs and outputs are without having to guess. I don't have to worry about having an array of strings and then someone deciding to throw a boolean in the middle. I know what all the keys on my object are and what kind of values they will contain. Code I have never looked at I can quickly figure out the structure.
I‚Äôm not getting into the pros and cons. All I know is that I dragged my feet for a few years and regret doing that. It‚Äôs been incredible. I now see javascript as a compile target.
I remember Flow being a little more strict. Typescript has much higher adoption now though so that has its own perks. Both are far and away superior to untyped JS.
It's got its advantages, but they had an opportunity to solve one of JS's biggest weaknesses‚Äîthe terrible standard library. And they just... didn't.
Depending on your project, you may find that Dart+Flutter is a suitable alternative. The Dart syntax is simpler than Typescript, while meeting similar goals.
I can't believe they chose an array for the Tuple type. Which has no sensible equality definition as arrays in JS are references.
I generally think it is worth it. In React+Redux, Typescript enables a lot of help in the IDE and catches a few problems or bugs.
On the one hand, I like this very much.On the other hand, if I open a project and I see many lines of complex types that don't do anything and I have to understand these types to use them to fix some bug, I'm going to say words out loud that I cannot write here.I've seen projects where there were many lines of complex types and, after updating some dependencies, there were many type errors even though the project ran fine and the tests were all green. Pisses me off every time.So in the end, I rather just see `params` be `unknown` and create a function to extract typed values, like `getNumberParam(params, 'shopid')` that returns a number or throws some kind of error. That way, you can compile-time checks AND run-time checks.
As always, it's a problem of balancing complexity vs. utility while striving to raise the level of abstraction.With regards to TypeScript,any,unknown,neverare perfectly valid types and plenty useful, just need to be used appropriately.
Did you write that blog post?  Cripes, it is amazing.  What a brilliant idea.  Thank you to share.  My brain is wired for C++ templates, and the technique makes good sense!To your last point: Why not C#?  It is interesting did not mention it, as TypeScript came from Microsoft R&D (as I understand).
I did not write the blog post, it was just a simpleinfer/extendsnon-trivial example explained in depth, commonly used in packages likeexpressand so forth.TDungeon[1], a game running on the TypeScript type system, really showcases how powerful the type system truly is.Why not C#? Probably because Anders Hejlsberg [2], lead architect of C# and core developer of TypeScript, wanted something different. More of a sociological, rather than technological, reason.[1]https://github.com/cassiozen/TDungeon[2]https://en.wikipedia.org/wiki/Anders_Hejlsberg
I want to skip over the static typing benefits argument, because I think it
    is well understood that static typing is a good thing and if we could bless
    JavaScript with a built-in and robust typing system then I don't think many
    people would be against that.Well, yes. That's what Typescript is. If a built-in and robust typing system were added to Javascript, it would be the same thing as integrating Typescript into the ECMA spec. for Javascript.EDIT (some more thoughts):For example, a new package you install can require a new TypesScript
    version. Once installed, you then may need to update your source code. This
    can place quite a high tax on the developer, where perhaps a 10 minute
    change becomes hours long.Yes, that's not very different than upgrading to a new version of e.g. Python or Ruby on the back end. The problem is that you're seeing Typescript as "just a framework", rather than a compiler/interpreter. If you view upgrading Typescript versions the same as e.g. upgrading Python or Ruby versions, and plan for it accordingly, then you'll at least have the correct expectations regarding the scope of work, even if the actual work to do isn't any less.Most libraries do not document their types, or have no examples using
    TypeScript.If a type system were integrated into Javascript itself, it would have to be optional, in order to maintain backwards compatibility with the vast untold billions of lines of Javascript that are out there. Thus, you'd have exactly the same problem. It's very difficult to add a typesystem to a language after the fact.Errors are long and don't provide enough detail. They will explain a type
    mismatch referencing many types you may not have ever seen, and are not
    documented anywhere. Except for simple errors, many of them are very hard to
    follow to a remedy.Poor error messages are an issue with any type system that allows generics. Typescript's error messages are, at least in my experience, better than C++'s error messages. I find this remarkable, given that C++ was designed as a typed language from the beginning, and Typescript has, as one of its design constraints, strict backwards compatibility with Javascript.I referred to TypeScript as a framework which it isn't. However it feels
    similar to me in that you are at the whim of TypeScript developers and how
    they decide to progress with the language.That's true of any programming language, Javascript included. If you're writing Java, you're at the whim of Oracle. If you're writing C#, you're at the whim of Microsoft. If you're writing C++, you're at the whim of the C++ standards committee. If you're writing Python, you're at the whim of the Python Steering Council (and you used to be at the whim of Guido Van Rossum). Every programming language has some person or committee that's in charge of it, and if you're choosing to use that language, you're implicitly accepting the decisions made by that person or committee.
v) It‚Äôs been well over a year, and IntelliJ Idea still requires me to go to the settings page to enable an experimental feature to be able to run a simple helloworld.ts.Not sure whose domain this falls in, but the situation is a coal mine canary that tells me the whole ecosystem is not up to the level I want from my production tools
Since the front-end world was upended by webpack and react, my favourite change that I would abandon last is typescript
i agree, I have to work with typescript for my current job and I hate every second of it. I was never a fan of any languages that require transpiling. the trade off and trouble it comes with is not worth it for the small benefits. Im not a fan of JS in the first place but typescript just makes it worse.
TS can't solve any real problem, so skip it. Dart & Flutter worth it if you need cross-platform GUI.
Flutter web isn't that great. Even scrolling is a fundamental issue with it which is never going to be fast using their current approach.
Compared to javascript, yes. Compared to any other simpler statically-typed language, no.
Well, I like Reason better. The type system is more robust and to infers more type.
TypeScript itself is good but typescript errors are bad and annoying
typescript as a language on it's own, is worth it, however the nightmare of the landscape of all the poorly develop libraries and endless layers around it causes me to never pick it for a backend project.
I prefer to avoid TS. I can‚Äôt stand its type system without pattern matching
Yes, in all cases except proof of concepts only demoed once. And even then probably still.i) You can wait years to update TypeScript itself. I've never run into incompatibilities before.ii) That's the libraries' fault. Without types, you can pass in total garbage and it doesn't work. With types you can only pass in some garbage and it doesn't work.  All the Javascript examples work in TypeScript except now you will be warned that your code won't work before you try to find edge cases to test.I've had the pleasure to use Frida a while back. It allows you to instrument running native applications using hooks written in various languages, though the live debugger usually uses Javascript. The documentation of many functions is scarce, to say it nicely. Without the TypeScript bindings, I would've never gotten most of these functions to work. You can find example code online but half the time that example code will be buggy and not do what it appears to do exactly because there is no type check on the plain JS API.iii) I disagree, they're verbose but not that difficult to read. "You specified this but the type doesn't exist" or "you didn't specify this thing the type needs" is almost always the problem, it's just a little over eager to tell you where you're missing something.iv) Okay this is definitely a downside. If you're not using Babel or another transpiler/minifier/obfuscator already, you'll add an extra build step. A minor one, in my opinion, but a build step nonetheless.In my experience, TypeScript isn't making progress slow. It's making you fix your bugs and broken promises before the customer calls that your code doesn't work anymore. If you're passing strings instead of numbers you're going to break your code eventually, only now you'll have to get your code to working order beforehand.Working on a codebase that's a few years old and added typescript retroactively, my experience is that renaming JS files to TS will instantly show you three to five bugs in every single JS file you come across. Import errors all throughout the code base, because it turns out components got reused wrong and what seemed like an optional label that didn't have any contents was actually broken for five years.TypeScript gets even better with a nice and strict set of linter rules. Not just the builtin ones, also extra stuff like "don't use any everywhere to avoid typing things" and "specify what you're returning when you're returning something". With the stricter guarantees the language can deliver because of types, the code quality analysis can be a lot better as well!
Why are we still talking about this.
Worth it if JS is worth it.
Have you tried Deno?
Yes
The TS type system is incredibly powerful, and I wish I could apply to other languages out there. The biggest annoyances with it come from the fact that it isn't its own language; you get runtime errors due to incorrect or out-of-date types (often maintained by people other than the library authors). Also, "any" and "unknown" types tend to sneak in via default generic arguments, vague external module typedefs, etc. These types can spread through your codebase, preventing the type checker from doing its job, and the "strict" mode doesn't do much about it!Generally speaking, I have to be extremely careful with working on a JS/TS project. I use the strictest modes possible and enable as much linting as possible. I also use the type-coverage module and fail the build if the `any` type gets applied anywhere.As another general complaint, NPM doesn't do enough to incentivize its users to release quality software. JS/TS has always been very trend-based and social, and even just running a few simple lints and prominently displaying a score on NPM would probably really help the community improve its standards.Take pub.dev (Dart), for example. Here's a module page:https://pub.dev/packages/firebase_core. The score is displayed prominently, and if you click on it you get a full breakdown of how it was calculated: static analysis, up-to-date dependencies, and documentation (although the coverage is not 100% for this module, so I think it's wrong to assign full points). When you upload to pub.dev, you want a score of 100! It doesn't guarantee that the module is fantastic software, but at least the basics have been taken care of.In my opinion, the most important piece missing from the score on pub.dev is test coverage. Take for example a page from Metacpan (Perl packages). Here's a module I've released:https://metacpan.org/pod/Algorithm::AM. On the left you see displayed the automated test results, including the test coverage, which has been submitted by volunteers who downloaded and tested the code on a variety of platforms and Perl versions. There's also link to a "kwalitee" page, which is similar to the pub.dev score (though this could be much improved by having an actual score and displaying it prominently on the main module page).Now an NPM module:https://www.npmjs.com/package/react. What info do we have about the quality of the package? Essentially just the activity from the community (open PR's and issues, downloads). We have no idea how well it's tested, what kind of static checks have been performed, whether your editor will be able to display documentation or typing when you mouse over a method from the library, etc. (TypeScript is mainstream enough now that it should be fine for NPM to provide a bit of special handling for it.) Most 3rd party libraries are from individual authors and probably have very little activity. When deciding whether or not to use them, right now you need to dive through the code to check if the basics are taken care of. Having some of this automated would save a lot of time.
Having spent the last two years back in JavaScript, and in the process of moving a >10y project to TS as a part of a larger refactor,emphatically yesit‚Äôs been worth it. I have been hanging on to tsserver to bridge the gap for two years, and well‚Ä¶ it‚Äôs night and day.I can add ~95% of the same safeguards without it, but I‚Äôll spend a lot more time doing so and it‚Äôs a lot harder to get buy in to make them stricter than my own editor.> For example, a new package you install can require a new TypesScript version. Once installed, you then may need to update your source code. This can place quite a high tax on the developer, where perhaps a 10 minute change becomes hours long.If your project is already strict and if you generally have a good sense of the areas TS doesn‚Äôt cover, you probably wouldn‚Äôt need to update anything for the last couple years. If your project isn‚Äôt strict, you‚Äôre probably benefitting from updates more closely matching the semantics you wanted in the first place.> Most libraries do not document their types, or have no examples using TypeScript. Some worst offenders: Apollo, Protobufjs. The type definitions exported by these libraries can be large and complex, and the error messages emitted by TypeScript are so long and cryptic the result is often a drawn out process of trial and error along with trawling through source files.It‚Äôs fairly trivial to add local type defs if you‚Äôre at all interested in the type safety it brings. They‚Äôre almost universally easy to transfer to PRs for DefinitelyTyped (which admittedly I should do more often, and I should open a few after I land this work in my project).> Errors are long and don't provide enough detail. They will explain a type mismatch referencing many types you may not have ever seen, and are not documented anywhere. Except for simple errors, many of them are very hard to follow to a remedy.This is true. You‚Äôre right. If you want a little helpful pointer:type Debug<T> = [AnyType<T>] extends [never]
    ? 'My understanding of AnyType failing'
    : AnyType<T>Edit: this ^ was typed on my phone from recall and I‚Äôm tired and might not be quite right. I‚Äôm happy to revise it tomorrow if that‚Äôs the case.It‚Äôs not great but it‚Äôs basically a very slow way to walk up the type resolution stack until you find what doesn‚Äôt behave the way you expect.> Transpilation takes time, and always adds a burden to developers. I didn't mind so much with ES6 etc because eventually many functions were included in a broad set of browsers. There doesn't seem to be much progress including TypeScript in a browser, and feels like these complicated transpilation steps could be with us for a long time.ESBuild, Vite, SWC and such have basically made the build step instantaneous. They‚Äôre not without config woes, but they‚Äôre worlds better than what came before. So much so I will volunteer to help you set up a project‚Äôs build if you do the very easy legwork to find any number of ways to contact me.
Yes
I make it about 20 minutes into a JS project before I have to go install TS because I'm losing my mind. It's such a no-brainer that the question barely parses. Javascript is medieval and typescript is... less so.I know it's not an interesting answer and a lot of other people say the same thing; guess I'm just casting my vote.
There was a time, once, when I did things with vanilla JavaScript. Not huge, ambitious things, but not trivial things either. Now TypeScript has ruined me. I'm pretty sure it didn't really mean to, but I've become so used to encountering `any` and saying "that needs to not be" and fixing it that now there's a reflex in my head that makes the thought of `any` just uncomfortable. I try to write vanilla and I start sweating, it just feels so unsafe.
You couldn‚Äôt pay me to work with Vanilla JS on any real life project.  It feels like going back to horse and buggy.The biggest things I wouldn‚Äôt be able to live without:- the self-documenting nature of Typescript code (I instantly know what a function accepts and returns by hovering over it).- the comprehensive auto complete my ide gets (saves hundreds of trips to the docs / source code per day).- the incredible productivity gains when refactoring (change one thing, instantly get notified of all 30 places in the codebase that change introduced errors and clean them up in minutes).
I haven't worked on a Ts project, but feels like i already get most of the stuff you mentioned, through ts-check in a regular js project.
> on any real life projectCould you elaborate on what the barometer/measuring stick for what makes a project real life?I think I know what you mean. Bigger than ____ lines of code/files I'm guessing?X number of classes/interfaces/APIs?
Sorry, ‚Äúreal life project‚Äù was a poor metric.  I suppose I meant anything where bugs would have a negative impact on the world ‚Äî either a business or individual.  Realistically though, anything that I‚Äôm expected to spend more than 20 minutes working on.  I‚Äôm quite the extremist when it comes to languages and highly opinionated in general.I compulsively rewrite JS into TS and 100% of the repos I work on have ‚Äúallow-js‚Äù set to false in the tsconfig.  It seems to be fueled by the same ‚ÄúOCD‚Äù I get when designing UI, organizing css, or making music for example.
Not GP but I would never use bare JS again for anything other than maybe like a 20 line script, for the same reasons as GP
Not the parent poster, but‚Ä¶ the size of the codebase is  for sure a criterion, but also code I have to continuously maintain or add to, or code written by a team where I have to read others‚Äô code and vice versa.
Important distinction:Are types worth it? Yes. Is typescript worth it? Maybe.
Agreed. TypeScript is the art of making JavaScript into Java.Never bet against JavaScript.
Can't tell if this is serious or not.
I'd argue that the shtick of javascript is that it runs in a browser.  The dynamic thing seems like more of a coincidence to me.
Id argue the static typing is great, and the best part of Java that is otherwise ruined by OOP. Give me the types and leave out all the OOP factory garbage, and you are left with the best parts. That‚Äôs what typescript ends up being.
Typescript is significantly better than java imo, in that it can figure out what the right object shape is on its own for the most part, rather than needing to write another file for every intermediate data object in a process flow
Good code takes a lot of thought and care, and won't materialize just because you use static typing.So why am I spending so much time applying static typing instead of thinking about how the code should flow, about what's the best abstraction, writing thorough documentation.Typescript comes at a much higher cost than built in static typing, and I don't think it's worth the investment.
I don't think you actually read OPs post. They were actually pro-types, but didn't like the overhead that comes with TypeScript.
I've been mostly writing Typescript the past 3 years - and recently started writing code in Go. Initially I was a little apprehensive, lack of array functions, slightly less flexible type-system, etc.But after spending some time writing Go I now had to re-initialise a typescript project for a small-ish team (4-5 devs). The amount of time spent on things such as linting, selecting the correct library for server routing, the correct server, coding standards, basic error-handling and enforcing it with a custom error or Result type to get out of this nested try/catch hell which still loses the majority of errors. Setting up testing and mocking. Setting up Prisma and what not - and finally the PRs are still a hit and miss, some ok, some make use of weird JS functions..Don't get me wrong, I really do like Typescript. But I gotta say after all of that it's just great using a language with a fantastic standard library, proper type-safety, with some coding standards built-in. It's obviously not without quirks, but it's pretty decent - and great to see that routing has now also moved into the standard library, another bit that you don't have to worry about - can't wait for some map/filter/find slice functions though!
In my CTO newsletter I recently wrote about TS vs Go releases, with Go 1.22 as an example. TS gets more and more complicated with each release, catering to the power users. Go adds things that makes it simpler to use, like the (missing) range over integers. It's like game sequels, they add more and more canon and game mechanics, then game sequels (or comics) need to reset to make them more accessible to newcomers again. Programming languages can't do this, so I'm happy that Go keeps this in mind.
All languages that keep evolving get more complex over time. The changes are always intended to make programs written in the language simpler.Go moves at a pretty slow pace, adding only minor new features (and thus minor complications) in most releases. Even in 1.22, they are previewing  a new feature, range-over-functions, which seem to be basically C#/Python's iterator functions - a feature which will, of course, complicate the language - but make certain programs simpler.As a general rule, the more features a language has, the shorter program that implements a particular algorithm can be, but the harder it is to learn, and the bigger the chance that it will be misunderstood. There are exceptions where certain features make languages more verbose (e.g. access modifiers), but typically only in minor ways.
"range-over-functions"Yes, something people coming to Go would have assumed worked before looking at all range cases, but didn't.
range-over-functions is the experimental new feature where a function can generate a sequence by executing a bit at a time, i.e.s := []string{"hello", "world"}
  for i, x := range slices.Backward(s) {
    fmt.Println(i, x)
  }

  func Backward[E any](s []E) func(func(int, E) bool) {
    return func(yield func(int, E) bool) {
        for i := len(s)-1; i >= 0; i-- {
            if !yield(i, s[i]) {
                return
            }
        }
    }
  }I don't think anyoneexpectsthis to work in Go as it is today, it's just a new feature that will make the language more complex, but it will make certain kinds of programs simpler to write.I should also note that the official name is "range-over-function iterators", I called it by a wrong name earlier.
Yes might depend on where you come from. As someone with decades of Java experience - not a fancy language over most of its lifecycle - I was mystified why there is no Iterator support as in Java for loops.
Oh, now I understand what you mean - you're thinking of this as a way to do `for (T x : collection)` in Java.I see this as more like the `yield return` functions of C#, which I definitely wasn't expecting. That can of course also be used to implement an iterator for a collection, but it seems much more general.Given that before generics Go had exactly 3 types of collections, and that those were all iterable with range, I guess I never thought about this thing missing from the for loop.
Iterator is not only about collections. Its not as powerful as a yield around continuations but you can return whatever you like.~15 (?) years ago I wrote a "famous" blog post on how to use Iterator as a poor man Maybe/Option.for (String s: m Option<String>) {
     // Executed on Some
   }
An idomatic way to do this now is to start a goroutine and range over a channel it writes to. Less ergonomic and more error prone, but it works.
The thing with Typescript is that it is only a fancy JavaScript linter, so the only way to justify newer releases is to keep adding up the type system, there is nothing else when language features that aren't type system related are supposed to come from JavaScript evolution.So they either say they are done, or keep adding type theory stuff until it implodes, I fear.Actually I am looking forward to type annotations in JavaScript now in the roadmap, being good enough for general use cases.
Is there a more simple JS linter that does 90% of what basic TypeScript does? I mostly use simple types (basic times, Promises, arrays, and a bunch of interfaces) and I find TypeScript valuable for that. It saved me  a few times from accidentally treating a Promise<Whatever> as Whatever for example ‚Äì and other things.But I heard an interesting argument: It's not TypeScript vs. vanilla JS; it is TypeScript vs. whatever else full-blown linting/IDE comfort you can get by still writing vanilla JS with no transpile step.
I guess the recent movement started by some projects to go back to JSDoc type annotations kind of answers that.
Do you know if the Javascript type annotations is progressing? I didn't hear anything after the initial proposal.
They held a meeting a few months ago so it's alive but probably still years away.https://github.com/tc39/proposal-type-annotations/issues/184
I don't have the source at hand but I remember seeing that they wouldn't support it until it had progressed as a JavaScript proposal. Their reasoning was that the decorations API is really weak, and it will likely be changed meaning a complete rewrite of the TypeScript decorator implementations.
Yes, but TS users can stay on the "type-newbie" path, which is still a huge improvement over vanilla JS and doesn't take much effort. What I've had issues with is devs who came from the vanilla JS world and love it, so they goout of their wayto avoid utilizing more complex types when they would add no-cost safety (aside from the initial minutes or hour spent learning the feature).
And that's dangerous; give people a lot of advanced options and they will inadvertedly use them, and nobody will dare to touch it, and it'll cause a lot of headaches, etc etc etc. Scala made this mistake as well. Go is the antithesis to TS and Scala, and I hope they keep it up.I also hope but doubt that they will do something few other languages dare: remove features.
Go certainly has a very different philosophy, but I don't think it's necessarily superior. Typescript is not as academic as Scala, but it gives power to developers who are willing to put in the effort to learn. With that power comes greater efficiencies and type safety.
> TS gets more and more complicated with each release, catering to the power users.My understanding about the use of advanced/more expressive TR features is that it's OK if you don't use them, and don't bother wasting time for most products. Bot if you are writing a library of framework in TS, go ahead especially since they are meant to improve the experience of consumers.
every feature that makes a language more complicated will eventually hit you. It might make the typescript compiler slower, harder to refactor, your lsp might also get slower, etc...
One person on the team will use them, if you don't put up a linter that prevents usage.
They just keep adding new features for fear of losing their position because they can't decorate the release notes. MS doesn't give high marks for bug fixes. Thus the bugs keep growing.
I feel very similar to your experience.What made me stay in go is its amazingly unified build toolchain. The things you can do with go:embed and go:generate blow my mind in every other project.The golang.org/x package is also another thing, where there is pretty much every internet RFC related implementation available, ready to use.
Can you give some examples how are you using go:embed and go:generate?
We use go:generate to generate services and types from protobufs.//go:generate protoc --go_out=src/generated/ protos/service.protoOur CI pipeline is a dockerfile that looks vaguely like this:FROM golang:1.21 as build
    go generate
    go build
    go test

    FROM scratch
    COPY --from=build ...The CI steps are: 
    docker build <XXXX> && docker push <XXXX>We have a goland project template that has options for generate, build, test that matches what we do in CI rather than having that _one_ edge case that is the difference between `make build` and `go build`. That difference has caused more than one outage in my career.
One example that comes to mind is building a single-binary full-stack application.You can use whatever frontend framework you want, and just embed the html/css/js/asset files inside the binary with go:embed. In case of dynamic set of files, you can also write a Go utility to generate the embeddings with go:generate.In addition to the ease of distribution (no more assets/ directory - just a single binary executable!), it also increases speed of the application, as it no longer has to perform file system reads in order to serve a webpage.
A good example of a Go project using embed to pack its html/css/js assets in a single binary is PocketBase:https://github.com/pocketbase/pocketbase/blob/master/ui/embe...
Last I checked, AdGuard Home also did this.https://github.com/AdguardTeam/AdGuardHome
I've used go:generate to generate a set of structs based on an XSLT document. That said, since XML is fairly uncommon these days in popularity, the generator was a bit buggy still.And I've used go:embed to include .sql files for database migrations and querying. I should really spend some time on this POC I made (sqlite, goose for migrations, and an implementation of temporal tables) and publish it as a demo.
Not OP, used embedded to add ebpf code compiled for a project, helps to only ship the binary.
Same thing for shipping swagger static html stuff to host an OpenAPI server.
> can't wait for some map/filter/find slice functions thoughTill that day comes, you could use the "lo" library (inspired from lodash). It's my goto Swiss army knife for golang projects.https://github.com/samber/lo
On the other hand, I advise you NOT to use this kind of library and write simple, fast go code most of the time, with the occasional generics helper. Why the hell would I clutter my code with, for example:https://github.com/samber/lo?tab=readme-ov-file#fromentries-...
I've had many cases in the past (not in go) where I've had to make use of that exact same function (in typescript, in F#, and in C#). it is actually quite useful when doing any amount of data manipulation (map/filter/reduce chain that often ends up into a list of key-value pairs, which then get turned into a map/dictionary of sorts).At least in my job(s over the years), turning a flat list of db records into a more complex, nested (potentially on multiple levels) data structure before handing it off to the front-end is a very common. I've seen it done with "simple, fast code" (although not in go specifically, but in other languages), but it very quickly turned into huge messes of of long nested for loops and was very difficult to read. LINQ, Lodash, java's streams... I sincerely can't understand how go developers live without them. They make me a lot more productive both at reading and writing the code.
Part of the issue is that Go has a variety of design choices / limitations that conspire to produce different design patterns in this area than what you might see with e.g. Java.For example: let's say we want to implement something akin to Java's Comparator interface.Java allows interfaces to be extended with default implementations. It also allows methods to specify their own generics separate from the entire interface / class.Thus the "comparing()" method can take in a Function<T, U> that extracts a value of type U from T that is used for comparison purposes. The return type is Comparator<T>.(Generics simplified a bit, there are other overloads, etc.)There's also thenComparing(), which allows chaining Comparator instances and / or chaining Function<T, U>.As a consequence, one can use .thenComparing() to build up a Comparator from the fields on a class pretty quickly. Especially with lambda syntax.Go doesn't support methods having different type parameters than the overall interface / struct.Go also doesn't have default implementations. It doesn't allow function or method overloading.Go does have first class functions, however.To build the equivalent capability, you'd most likely build everything around a comparison function (func[T any](a, b T) int) and write a bunch of functions to glue them together / handle useful operations.That impacts the readability of a long chain of calls, especially since Go doesn't have a lambda syntax to make things a bit tighter.Getting rid of the limitation on method-level generics would make this _significantly_ more ergonomic.
You wouldn't write that exact function.  You'd have some complicated pipeline that ended up in a map; and it might be easier to follow the logic using map / filter / fromentries.
I strongly agree. Map / filter isn't included, but a fair number of the various utilities are included in the standard library in the `slices` and `maps` packages.`context` also helps solve a bunch of the channel related use cases in a more elegant (IMO) way.There are only a handful of things in that package I wish were included, such as "Keys()" on a map.
FYI - ‚ÄúKeys()‚Äù, ‚ÄúValues()‚Äù and others have been pulled because they‚Äôre likely to be implemented using the new range-over-function paradigm.They were included in the experimental packages on google.com/x.
Unrelated, but this link puts me into an infinite refresh loop on two mobile browsers on iOS (Firefox and DDG)
Only if you're willing to take the cost associated with that; it adds a "DSL", an extra language to the language, reducing its goal of simple and readable code. Compare also with using a testing library that adds human-readable assertion phrases (expect(x).toBe(y) etc).
Why not use the generic-based built-in slices?https://pkg.go.dev/slices
Yeah, it's quite productive in a counter intuitive way, not having a ton of features just removes a lot of tiny decisions you have to make in a richer language.
I‚Äôve worked for a while at a client using typescript, after a while I started calling it ‚ÄúTricks Driven Development‚Äù, every time I had to do something I‚Äôd read the docs, but then someone would communicate some trick not on the docs that was possible to use
Go is beautiful, productive, readable. I love Go. It's my "C with niceties".
I feel the same way. I was recently evaluating TypeScript and Go for a small project at work, having little experience with either. I went with Go almost entirely because I‚Äôd made decent progress in solving the problem by the end of my timeboxed investigation period. After a similar time with TypeScript, all I‚Äôd really done was get bogged down trying to work out what tooling I should be using.Compilation, testing, and automatically formatting TypeScript all have multitudes of options with their own pros and cons. All that stuff is just built into the Go toolchain. Yeah it‚Äôs not always perfect but it‚Äôs more than good enough and, importantly, it‚Äôs ubiquitous. There‚Äôs nothing to think about or argue over.That said, I‚Äôve been wanting to try Deno. My understanding is that it takes a much more Go-like approach to running TypeScript.
Yeah someone I know has been banging on about go, too. I have a personal project I want to do so maybe I'll pick go for it.The main pro and con to the JS ecosystem is the fact that it's so flexible; you can mostly do things how you want and there are so many libraries in each space all competing. But because you can do anything how you like it becomes hard to decide which library you want to use (or a diff one every project) and every dev has a different way of accomplishing the same thing.I used to write internal libraries and frameworks a lot in my career and one of my mantras was to use TS to try to lock devs into doing things a certain way but there only so far you can go.My main worry with Go is like, is everything built in? Are there multiple say, Web server libs like with nodejs or only a single option? How are deficiencies addressed if there are fewer options and fewer ways og doing things?
Go is the language for getting sh*t done.
Best summary of Go. That should be the headline of the Go website.
Interesting ...>> The amount of time spent on things such as linting, selecting the correct library for server routing, the correct server, coding standards,I don't fully agree here. Those points are pretty straight forward and coding standards (not formatting, for TS prettier is pretty standard, btw.) need to be defined even in Go projects. Also, Deno has much of the setting up solved.>> basic error-handling and enforcing it with a custom error or Result type to get out of this nested try/catch hell which still loses the majority of errors.Fully agreed. Maybe I have a big lack of understanding of error handling in NodeJS, but how on earth do I find out what functions can throw errors and what are the errors thrown? If someone could enlighten me I'd be really grateful. To be on the safe side I would need to run my whole code in a try..catch block. How to decide how to handle different errors if I don't know which errors can occur? On the other hand, just yesterday I had to debug a Rust panic in a smallish code base. Even with stacktraces turned on it took half an hour to find out where there error occurred. Still, Go and Rusts error handling is much better. IIRC, in Java you see all types of exceptions that can occur in the docs of a function?>> Setting up testing and mocking. Setting up PrismaAgain, not a big thing IMO. If you like an ORM, Prisma is one of the best.>> Don't get me wrong, I really do like Typescript.Yeah, that's the thing. Typescript is such a fantastic language. Writing Go feels like using a hand-axe. Typescript's null handling alone makes it 10 times better (I hope everyone is using it, but that underlines your point regarding the conventions needed ...). I recently found a lib that gives us compile time checked pattern matching like in Rust.
I got to spend a couple years writing Dart (not Flutter) and found it to be the best of both worlds. Such an underappreciated language.
Yeah, Dart is way better / easier to debug, than Typescript in my opinion
Interesting, Dart for backend? Do you build APIs? How is the ecosystem? I heard good thing of Swift as well, but I have concerns that it's to niche for backend stuff.
I was working on Google Assistant at the time; the dialogue manager was written in Dart.  I was mostly writing libraries and platform code...so APIs in a sense.The ecosystem isn't huge outside of Flutter, of course.
The problem of typescript is the lack of convention and the emphasis on configuration, the reverse made Golang a great language.
Other replies miss the point - the problem doesn't lie with Typescript itself exactly. Setting up a nodejs/js project with all of the fixings (linting, Typescript, spell checks, builds if needed, etc) is quite tedious.Sure you can accept some template project or CLI tool to kickstart things if just starting out, but at some point you will need to tweak the configuration and there is an enormous realm of options.I'm surprised no one mentioned this already, but a runtime like Deno goes to great lengths to solve alot of these pain points. You get testing, linting, bundling, and Typescript out-of-the-box with sane settings. If Deno worked better with GRPC I'd probably be using it right now in my work projects!
> can't wait for some map/filter/find slice functions though!just use a for loop. 90% of the time the code will actually be clearer, and faster.the hoops people just through to avoid 2 extra lines of code is mind boggling.
Deno fixes most of the issues you're describing.
I love go. It's just so simple.
If youhaveto use Javascript (you're building the front-end of a web app), then it seems like Typescript is probably a decent solution. For anything else it (or any form of Javascript) isn't the right tool for the job, in part for the reasons outlined in this post. Nothing is more frustrating than to see people build command line apps or servers with Typescript and bring all the added complexity and bad habits of the JS world to a place where much better solutions exist. Go, Rust even Zig are better choices than introducing the JS nightmare workflow and tooling where it doesn't belong.
I strongly disagree. Nothing is worse than developers being forced to work in a language they are not used to - not just because it's inefficient, but because they won't write it in an idiomatic way.If all you have are TS developers, writing a CLI in TS is not just fine, it's the right decision. Forcing Rust upon them is not going to make anyone involved more happy.
I just don't get this way of thinking and can't imagine calling myself an "X developer". The human brain is more than capable of being proficient in more than one language. It's also boring only using one language every day. If all you have are TS developers, then IMHO, you don't have very good developers.
What is this magical world you live in where a company can put up job listings for "Polyglot Software Engineers" and consistently, successfully get them through the hiring pipeline and staff up teams?Where I live, (a) there's much more junior and mid-level talent with 0-2 years of experience than anyone else, (b) talent is far more likely to have TS/JS experience.If you hire for JS talent, you ship. If you try to hire anybody else, you struggle to hire, struggle to collaborate ("I don't know X, so I'd prefer to open a ticket than to struggle and open a PR to that other team's repository"), and therefore ultimately struggle to ship.Startups should run on the JS ecosystem by default and only write code in other ecosystems if there's averygood reason to do so (business competitive advantage, JS ecosystem options are severely lacking...).
Obviously you gotta work with what you got and it might be the bestbusinessdecision to hire some junior devs with no experience outside of JS/TS and build your CLI tool in that.But that's never going to be the best tool for CLI development, and someone with no experience outside of JS/TS (or any single language) is never going to be the best engineer.
> best business decisionThe best business decision is the only relevant decision in the real-world, unless you're building the software as a hobby and you're willing to essentially self-fund the development without regard to anything else outside your own enjoyment.If it's not your hobby, then you don't get to build perfect software, you get to build software that people are willing to fund (either through investment or purchase). People are only willing to fund software thatships. Professional development is an endless struggle to manage the sources of imperfection in the codebase; shipping perfect software is a pipedream. Shipping necessarily requires getting comfortable with shipping something imperfect and improving through iteration by shipping some more. So the first thing that you need to optimize for is shipping, and that is a function of who you can hire, what skillsets they have, and organizational design (including making cross-team collaboration easier by choosing standards, including language standards) that promotes shipping.Should you be so fortunate that you have many, many people purchasing your software, or your investors (or CFO/VP Finance by proxy) are convinced that you need to leave the JS ecosystem to attain or preserve competitive advantage, then fine, build your CLI in a language that offers more technical advantage to building CLI tools. But that's not thedefault.
EDIT: formattingThis feels a lot like a self-fulfilling prophecy that Javascript just happened to be chosen for.- Javascript is "easy" and the only option for browsers, so lets teach it to beginners.- We have all of these beginner programmers who can't work on the backend without learning a new language, so lets put javascript on servers.- CPU, memory, and bandwidth have continued to become cheaper, so lets just run everything in javascript because "we can"- Let's hire javascript developers because we've made them the easiest to hire for- It's too expensive to use a different technology because our entire engineering team is javascript developersI honestly can't fathom the reasons why we've encouraged Javascript to eat the world, but I don't think there's any arguing that it has. Is this good or bad for business in the long term? My personal take is that it isn't, but there are enough variables to make this really difficult to say with any kind of certainty. It feels more like we've just:- Lowered the bar for acceptable quality over time- Convinced ourselves that the Javascript ecosystem is a one-size-fits all optimization for time-to-product
> I honestly can't fathom the reasons why we've encouraged JavaScript to eat the worldWho is "we"? The scenario isn't some God-like figure who made the decisions and handed them down to mortals to live with. The reality is more like evolution (one you actually described very well), where many different, independent players are each working in their own interest.> Lowered the bar for acceptable qualityDefine "quality". Especially given the evolution prism, I'd argue that quality is not a rubric like "best technical performance" but rather one like "permits as many people as possible to engage with as many parts of the stack as possible." With that definition of quality, the JS ecosystem isby farandindisputablythe king of the mountain. Graveyards are littered with many "best technical quality" options (Betamax, Itanium...).> time-to-productNitpick, the term is time-to-market. What matters is not just building and shipping your MVP (which can be done by one person, who can choose whichever technology stack) but continually shipping at high velocity over time as the company grows, the original engineers leave, etc.
> Who is "we"?"we" is everyone in the industry. I recognize it's more of an evolutionary thing, it's just my stance that the current environment is pushing us towards an evolutionary dead end.> Define "quality"I also agree that software quality is fairly subjective depending on your lense, unfortunately. For example, I wouldn't view quality as permitting as many people as possible to work at every level. Diversity of ideas is great, but I want those ideas to come from folks who have the skillset. If someone who roofs houses decides to pour foundations without gaining the proper skillset or picking up different tools I would view that as a loss of quality, not a gain.> the term is time-to-marketI chose time-to-product fairly intentionally, because I think the benefits of something like Javascript start to rapidly decay once you start approaching any sort of product maturity. The problem is teams rarely optimize towards stability and quality until they have literally no other option
> I want those ideas to come from folks who have the skillsetWhen the industry/society comes around and finally can get behind the idea of requiring licensing for software engineers to practice, get back to me :) . Until such a level playing field is imposed on all players, such practices impose a cost that your competitors are not paying, and they will out-manuever you and out-ship you.> start to rapidly decay once you start approaching any sort of product maturityPerhaps time-to-maturity then? Because it's besides the point that maturity is a characteristic necessarily of successful products. You find success by iteratively shipping.> teams rarely optimize towards stability and quality until they have literally no other optionFirst make it run, then make it stable, then make it optimized. Pre-mature optimization is the root of all evil. This additionally lends focus to why the business can get behind such efforts: you need product flexibility to grow from $0 to $Xmillion/year, then you need to protect the $Xmillion/year so that it's not at risk from incompetence, hackers, etc., then after your user count stops growing, you continue to grow profits by cutting costs (e.g. by using more efficient languages like Rust that let you serve the same customers on less hardware).
Most developers I work with seem to prefer to stick to a single language. I don‚Äôt have this preference or consider myself a ‚Äútypescript only developer‚Äù, however since I primarily contribute to a Typescript codebase day to day I end up the most practiced at Typescript. TS code flows out my fingers much faster than other languages I know like Go or Ruby. I am fine reading Rust or Ocaml but need a lot of reference material to write new features.Sure I could ask my devs to write our CLI tools in Rust, and some of them would habituate to both languages but there‚Äôs no denying it‚Äôs a higher mental burden to split training time between two languages, or three languages.
Proficient? Yes. But I have better things to do with my time. I enjoy spending time with my family, woodworking, baking, gardening, home remodeling, painting, studying ancient Afro-asiatic languages, reading, hiking, etc.The only way I‚Äôm going to learn a new language is if my work requires it and makes time for me to learn it. Well, we have far too much work to do to carve out time to learn new languages, so they just keep us using what we already know. That‚Äôs fine with me. I receive a hefty six figure income to pay for my life outside of work.
On the other hand, it's quite plausible that TS is one of only a small number of languages that you know thatallyour co-workers will be proficient in.And in general I expect that the actual work I'm doing will be more interesting than the programming language I get to use.  I really enjoy learning new things, and digging into new programming languages just for the sake of it, but when I need to actually ship something I don'twantmy programming language to be the exciting part of what I'm doing.
> it's quite plausible that TS is one of only a small number of languages that you know that all your co-workers will be proficient in.If by TS you mean Javascript with ": any" tacked onto the end of each variable, then perhaps. Actual TS proficiency is rare, in my experience.But if proficiency is a concern, you're not going to slap any random web developer on a command line tool project. It is an entirely different skillset. Amongst the developers proficient in command line tools, I expect the common language they are familiar with is typically not TS.
> If by TS you mean Javascript with ": any" tacked onto the end of each variable, then perhaps. Actual TS proficiency is rare, in my experience.This isn't even a lack of proficiency, this is just hiring bad people. Who doesn't know how to annotate a type? That hardly takes Typescript "proficiency," you can learn it in 5 minutes.
> This isn't even a lack of proficiency, this is just hiring bad people.If there was some specific reason to hire Typescript developers, maybe.But across an organization, many developers won't be working on Typescript projects and there would be no reason to hire based on Typescript ability for those projects. It may be one of the few language all developers have some familiarity with, as proposed earlier, but that doesn't mean it is the language all developers focus on.And when hiring developers with a background in building command line tooling, it is likely that Typescript has never been a language that has garnered their attention.> Who doesn't know how to annotate a type? That hardly takes Typescript "proficiency," you can learn it in 5 minutes.Typescript is its own language ‚Äì one that is even turing complete. While you likely can learn it in 5 minutes, same goes for any language, including the aforementioned Go, Rust, and Zig. Proficiency takes quite a lot longer, though.
I think that‚Äôs not really relevant.  Not every company can afford to have the best developers that can do everything. And not every developer wants to struggle through a new language for (unknown time) writing a tool (or anything) that could be done in an hour in a language they‚Äôre familiar with instead.A lot of common screwdrivers can turn Philips head screws enough to get the job done.
> If all you have are TS developers, the. IMHO, you don‚Äôt have very good developers.Does it change anything to reframe this as having a common denominator across all developers? As in, rather than ‚ÄúAll of my developers know only TS‚Äù to ‚ÄúTS is the common language all of my developers know‚Äù.Particularly in small companies I think it makes more sense to focus on a restricted set of tools and technologies. It makes interviewing easier, ensures mobility of hires to different areas of the code, and produces an easier onboarding experience for new team members.> It is also boring using only one programming language every dayInterest and passion come from more aspects of a project than the language it was written in. Some projects are interesting because of they incorporate cutting edge research, some because they have highly visible impact on users, and others because the solution involves a careful balance of design constraints. Choice of (or diversity between) language doesn‚Äôt have to be the distinguishing factor that makes a project interesting.
Obligatory 'I am not a "JavaScript Developer"' by Andrew Kelley[1][2].[1]:https://andrewkelley.me/post/not-a-js-developer.html[2]: The creator of Zig[3][3]:https://ziglang.org/
You can build a hundred bridges and they still don't call you a bridge builder... lol
While I totally agree, and I come from a time where one couldn't be a full stack JavaScript developer. (Also a time when folks DID make their living doing bread and butter style Delphi/PowerBuilder/FoxPro/VB apps). I get that some folks spend ALL day in a certain language/stack and it's easy for everything to begin to look like a problem they could solve using that language/stack.I do agree that is boring, but it also pays the bills!
Then imagine he said "all-round developers who in their current job spend 95%+ of their programming time writing Typescript", if that's less offensive.
His point remains.  If someone is so uncomfortable in all other languages that they have to pick a bad tool for the job, then they are probably not a good developer.  Obviously, we can't always pick or even know the absolute 'best' tool, but good grief there are a lot of better choices than typescript for cli tools.
Even if they know better suited languages, do they know thesamebetter suited languages?I'm in a TS shop, 95% of our code is TS. I would assume that almost everyone we've hired knows at least one compiled language but that language might be C++, Go, or Java. The only way to write a CLI tool that anyone at the company can edit is to write it in TS and so, indeed, >90% of the CLI tools we write are in TS. Works fine.
> The only way to write a CLI tool that anyone at the company can edit is to write it in TSThe only way? If you know C++, Java, or Go, even Typescript for that matter, they are all almost exactly the same. There is a little nuance with respect to setting up a project idiomatically, but once that groundwork is laid anyone can come along as they're simply going to copy the structure and style of what is already there anyway.
>  There is a little nuance with respect to setting up a project idiomatically, but once that groundwork is laid anyone can come along as they're simply going to copy the structure and style of what is already there anyway.You might think so! Having seen this tried in multiple 100+ engineering orgs, I think empirical evidence is against you. CLI tools can get surprisingly complicated (or use a surprisingly complicated set of language features). Many engineers will simply give up if a solution is not obvious in the first 5 minutes.The end result is you have a lot of team A asking team B for a minor feature or fix to team B's CLI tool, or worse, team A just writes a hacky workaround to the broken-ness in the CLI tool.Most people just don't care enough to put in the kind of effort for anything but the easy path.
I'm not an X developer, but I have experience with certain tools. Building on that experience is usually more efficient than starting over at 0.
Transitioning from any derivative of a given ur-language to another should be fairly trivial. I don't think anyone expects table stakes for devs to be proficiency in Java as well as APL
Well most people aren't goodlinguistscertainly.
> If all you have are TS developers, writing a CLI in TS is not just fine, it's the right decision.Companies should be properly staffed to support the platforms they're distributing on. If you're building a CLI tool, you should have devs familiar with doing that use an appropriate language. You should not repurpose front-end web developers to build the CLI tool in a web front-end language just because that's all they know. That's pushing your business, training and hiring problems down to the user.Not to say web front-end devs can't make great CLIs (or servers)! It's just that they should train up on an appropriate stack if they're going to do so.
If everyone thought as you do, many companies simply wouldn't release a CLI tool, because hiring experienced developers just so you can use the "appropriate" language for a domain isn't realistic for most companies. I know it sounds nice, and I'd like the world to work differently too, but the reality is that resources are constrained enough that many developers have to be all-rounders, and you don't do that by learning the "right" language for every problem.
> many companies simply wouldn't release a CLI toolThat's his point, though. Command line tools require a different skillset. If a team has only worked on browser applications, they won't have the skills for command line tools and will need to learn them. Taking time to learn contradicts the grandparent comment, which suggests that people should stay in their lane and that there is nothing worse than forcing developers to work on things they are not already familiar with.If one is going to hold that developers shouldn't be forced to learn on the job, even if by way of fellow teammates trying new approaches that others will need to maintain, you simply can't have them working on CLI tools and bringing on new teams that will operate independently is the only way to see movement into new areas.
> Taking time to learn contradicts the grandparent comment, which suggests that people should stay in their lane and that there is nothing worse than forcing developers to work on things they are not already familiar with.My comment said no such thing. There is a difference between "types of applications you build in a language" and "language" (the first 7 words in the earlier one). It is much easier to learn how to write a different kind of application in a language you know,because you already know the language. You have to learn less.I'm not sure why you're putting things as if I've made some absolutist statement. All I'm saying is: You only have the resources you have, and the efficient way to use them (especially in the long term) isnotto leave architecture and implementation to a team that knows neither the language nor the environment.
What's proper here? I work in a TS shop, 95% of our in-house CLIs are in written in TS and to date it has been an issue... once a year? If wereallyneed better than TS has to offer then sure, go write some Rust or Go, but most of the time we get a lot of added benefit from the fact that literally any developer in the company can bugfix or extend the CLIs without assistance from these teams.
This line of thinking is precisely why node and TypeScript are so pervasive. It has nothing to do with them being the right tool for the right job and everything to do with perceived lower barrier to entry and resistance to learning better tools. I would never try and use a hammer to saw a board in half, and yet that's exactly what people try and do with node/TS
I mean, they're also just kind of fun. Suppose you are building a CLI tool just for yourself, Deno is way more fun than Bash, say. Especially if your usecase starts to get into like tree traversals and stuff.
I'm not saying that you should use TS & Node for everything, not sure how you got that wrong. I'm saying: use the tools your developers know. If you have Java developers, use Java. If you have Rust developers, use Rust. If you have Typescript developers, use Typescript. Don't give a metaphorical person without arms a saw to split a board in half, even if it's supposedly the right tool.
I didn't really think you were saying they should be used for everything, but I do think discouraging branching out into better suited tools perpetuates using the lowest common denominator. If devs are never pushed out of their comfort zones, it's really hard for them to grow arms in order to use the saw.I do acknowledge I have a lot of bias, though, because I work at a TS shop where the primary reason we continue to use it is because we always have. The longer I have to put up with it, the more I feel like this is a broken foundation to stand on
You shouldn't let developers branch out by trying to write their first real application in a completely new language as a productive thing for your company or your customers. They should learn by implementing real projects that willnotbe important or improved and maintained long-term.
What about the users?  This whole thread is entirely developer centric.  Odds are you are going to have 1000x more time users than developers.  A native solution and not some node interpreted monstrosity is the right choice.  We all loathe electron apps because they perform like shit.  What's worse, inconvenience a handful of developers to learn a native language, or make thousands of users run node apps?  The carbon footprint alone is worth it.
I disagree. If the program is fast enough for its purpose, and my developers can write better code (as in, code with better architecture allowing for flexible development while being easy to read) and develop features faster, it doesn't matter which language is "right", it matters which one will get the thing developed in an acceptable amount of time. Users would rather have bad software than no software, as you can see with Electron apps that perform like shit.I'm not saying that performance, memory consumption etc. are completely insignificant. I myself prefer to use faster tools that use less memory. But if all you have is a bunch of Typescript devs, and you want them to develop a CLI, you're not going to get a better result by telling them to do it in Rust. To get a better result you'd have to tell them to learn Rust and work in it for half a year. And yes, that would be better for users in the long run, but that doesn't mean it's realistic in all cases.
A large part of the bullshit that this industry has had to endure was exactly because a lot of front-end developers writing Javascript declared "we are all backend engineers now" and started using Node, thinking that UI development somehow translates to backend concepts. These are totally different areas of craft, like e-commerce vs game development.
But also many, many wonderful things came aboutbecausebackend development became more approachable. You're right that inexperienced developers working in an environment they don't know produces a lot of horrible stuff, but that doesn't invalidate the good!And I wouldn't strictly differentiate between these areas. My game development experience helps me to write better backends and frontends alike. They are separate insofar that you have to learn each environment to be able to write idiomatic code, but it's not like you can't re-use parts of your knowledge across all of them.
I think the worst aspect of it is that the cohort of engineers was not taught to appreciate the complexity (of distributed systems in particular). This is something the industry is just trying to burry itself out of.It was a bad combination of "green" JS engineers writing servers and a new batch of fresh FAANG veterans mentoring them into writing extremely complex and expensive systems. There is a large dollar value attached to this fiasco.
> I think the worst aspect of it is that the cohort of engineers was not taught to appreciate the complexity (of distributed systems in particular). This is something the industry is just trying to burry itself out of.It sounds like you have a bone to pick - because when was this evernotthe case? Most developers of any generation don't really know about the complexity of distributed systems. Some developers do, even in "the cohort of engineers" who you say wasn't taught this. People using inexperienced (in the topic) developers for complex systems is not something new either. People use who they have.
I mean while I think hiring and availability is an important reason to pick a language, and so it makes sense to have e.g. Node / JS / TS as a back-end language. But it's not ideal.Another one would be to pick Java or C#, but the stereotype of a developer like that is that they will overcomplicate and make a heavy, enterprisey back-end; Node backends feel lighter, so I can again understand why they would rather have a Node / JS type developer, they're more pragmatic.Ideally you'd get a "polyglot" developer, or a developer who has embraced that language is just an implementation detail, someone who can see beyond a language and its ecosystem and stereotypes. But the hiring pool for those is small, and convincing them to work for your company is really difficult if it doesn't do anything exciting, new, or cannot pay a lot.
> Ideally you'd get a "polyglot" developer, or a developer who has embraced that language is just an implementation detail, someone who can see beyond a language and its ecosystem and stereotypes. But the hiring pool for those is small, and convincing them to work for your company is really difficult if it doesn't do anything exciting, new, or cannot pay a lot.That's kind of the approach I'm proposing. Don't care about the language, use the one your developers know best, because the language itself is just an implementation detail, while the proficiency will help you in any language. You're not going to get a large group of great polyglot developers, so you have to reverse the process and choose the language your developers know best.
>Nothing is worse than developers being forced to work in a language they are not used toI think there are much, much worse things than this. Most of the time, I would count among those things the humongous downsides of JS, but it depends on your situation, obviously. There are plenty of cases where you should use JS/TS. But if I only knew TS and had an opportunity to write a CLI in Rust, I'd jump at the opportunity. It's not always the case, but lots of things are appropriate to use as an excuse to learn something new.
Writing a CLI in rust is just dumb. Really really really dumb.Just write it in C# and take the afternoon off.
If you're saying "just use something else", you'll have to actually compare TS to the languages you're proposing. If for example someone were to suggest Python for a backend, I'd argue that TS is many, many times better than Python. Can you explain why TS is so very much the wrong tool in your eyes?
Just on a quick skim it seems like there are enough other people willing to take the other side of your "JS is good actually" position so I'm gonna pass today.
It's fine if you don't like JS, but it speaks to a bias or lack of experience if you think Zig is a better tool. Maybe it will be one day, but it's a flat out unfinished language with numerous bugs.I was with you when you said command lines, but servers? JS is a fine choice for servers. I haven't seen Rust do anything on the server but slow people down, and I have found people who think they know Rust don't reallyPlenty of people are productive in JS, and when working with ES6, it can even be comparable to immutable functional languages. It's on the team if they aren't reviewing code or are allowing bad habits.
The fact that JS is single threaded doesn't make it any less useful as a web server. It seems like you're evaluating languages based on runtime performance and some made-up arbitrary metric that JS fails to meet, while completely ignoring the ecosystem that makes shipping projects possible in the first place.Zig looks promising, but the ecosystem isn't mature yet. Suggesting that Zig can replace a production-grade server based on Express.jstodayis.. madness.
> You don't always need multi-threaded programming but there are times you do!Are you a working web developer? If so, can you give a concrete example of a web application you've worked on that required multithreading on the web server?I've needed it client-side to avoid freezing the UI with heavy computations, but in all my years working on server-side code (in PHP, Java, Ruby, JavaScript, and Python) I have never wanted to manually create a new thread on the server, even in Java where I could have!> I've also noticed that devs that understand how to do multi-threaded programming are the most proficient.Knowing howto do multi-threaded is different from insisting on using a language that supports multi-threading on a project that willneverrequire multi-threading. I've noticed that devs that understand their project requirements and don't engineer for problems that the project will never face are the most proficient.
> Are you a working web developer? If so, can you give a concrete example of a web application you've worked on that required multithreading on the web server?Yep, I'm a working (and successful) developer who has built a lot of different types of programs, often web servers.A concrete multi-threaded example would be a web server that federates to Mastodon (which is quite noisy and benefits from having the "bridge" be in its own long running thread(s)). Really anything with long running processes that aren't keyed off of ux events is best done with multiple threads.
Fair enough. If you're working on something like that, absolutely go with a different server than TypeScript! But it's still weird to insist that TypeScript has no valid applications when long-running processes that aren't direct responses to users are the exception and not the norm.When I've run into specific cases in TypeScript projects that require that, I've tended to just spin up a new long-running service for those requirements.
> When I've run into specific cases in TypeScript projects that require that, I've tended to just spin up a new long-running service for those requirements.But then you're not sharing memory and have to rely on message passing... it's all doable of course, but this is just one of many examples where the language will hold you back.
Yes, you're not sharing, but the deployment requirements are usually quite different for services like that, which makes them better as standalone services regardless of implementation language. For one thing, you usually don't want to run multiple copies of long-running daemon-type services, where for your application servers redundancy is good to have no matter what language you're using.
In actual practice a single thread is a non-issue. Web applications are almost never CPU bound, wait times are almost always a function of IO‚Äîdatabase queries and requests to external services.JavaScript's async IO is plenty fast for any typical web use case, and the marginal savings you might get from having a few fewer servers will be more than made up for by the time your team of web developers (who already know JavaScript) wasted learning Rust or Zig.
The single threading isn't an issue for many backend use cases and even though JS was initially designed for use in the browser, there's been a decade of development on the language and ecosystem for using it outside the browser.
Also people routinely use other single threaded things for the web, notably Python and Ruby have global interpreter locks and PHP has also usually been multithreaded only by being multi-process (you have to add pthreads on I think?).Multithreading is a nice to have; it has a bunch of costs around needing to introduce locking and synchronization primitives into the language, those costs aren't the worst thing ever but it's often nice to not have to deal with them.
I think you are mixing up lots of stuff or at least write about them in a misleading way.Python has async, has green threads, and has OS threads through the multiprocessing module. The fact that it has the GIL does not mean, that it cannot use OS threads or multiple processes. JavaScript in comparison does not have multithreading. NodeJS itself is multithreaded, but you cannot put application computation on those threads. You will need to use worker-threads and basically like PHP run multiple instances.However, neither of those languages is particularly nice for using the multiple cores available in modern machines anyway.
So then Python, Ruby, and PHP are also bad for servers?
In my controversial opinion: yes they're bad for servers. Not just because they're single threaded but because they're interpreted and have dated tooling. Compiled languages have reached a DX level that I see no reason to use something interpreted in 2023 unless you really are building a web page and need to use js in the browser.
Because compiled languages tend to introduce a class of errors that are hard to deal with and offers no benefit for IO bound applications.Compiled GC languages? Maybe. There's a reason Go is exploding, even though it's type system actually sucks.
As in compiled languages are usually low level languages that require some amount of memory management. So in C++, I have to worry about integer overflow. In Rust, I have to worry about how I return a variable or where a variable can still be used.In JavaScript, I return whatever I want and the garbage collector handles it. Slower, but perfectly fine when my servers main job is waiting. Using Rust instead is not just "better errors," it's more potential for errors. If CPU cycles aren't important for my app, why not just use Typescript? Rust is not just "JavaScript but with better errors," it's targeting a completely different use case.If you want a fast, multi threaded language with a good type system, you can do it without Rust. C# is extremely fast, and in some use cases, faster than Rust.
> As in compiled languages are usually low level languages that require some amount of memory management.That's not true of any of the languages I've listed. You may not like the borrow checker, but it's not manual memory management. Also, Go has a garbage collector you don't manually manage memory there. I don't think any of these languages would be considered "low level".
That's why I brought up golang as an example of a GC language. It's a bigger success story for servers because a GC language is more appropriateBut no, just because Rust has a borrow checker doesn't mean you aren't manually managing memory. It just means there are guard rails for it and the way you do it is different. Here's the gut check, does Go not allow me to use a variable because it's location has already been freed? That's what automatic memory management looks like. Not only does Rust not have that, it's even more complicated than c++ RAII in some places
> But claiming that that is the reason JavaScript is faster is actually a reflection of not understanding what this compilation does for you.I didn't even kind of say this. Rust is complicated for reasons beyond compilation. I actually like F# and strong type systems.> The amount of tooling that you need to use to surround your JavaScript code to make it somewhat correct is insane.There's no practical evidence of this, it's just a feeling you have. Big systems are built in dynamic languages fine.> This statement is the reason we're all having to use Electron applications.How is "JS is fine for servers" the reason you have to use Electron apps? Pick a topic. I am not overapplying JS> You're using a dynamic language. There is literally a whole slew of bugs that you cannot detect until you actually run the code.If you're using Rust, you're introducing a whole slew of bugs that you cannot detect unless you compile the code, and that you wouldn't run into in a GC language. And you're potentially doing it for no benefit because you don't understand servers aren't typically CPU bound.
A programming language is a tool to get to the desired outcome. The 'best' programming language is one that allows me to get to my desired outcome the quickest, with the fewest bugs and highest maintainability.For me (and, I would argue, for pretty much everyone), that would probably be whatever programming language I am most familiar with. Unless the language has huge barriers compared to another one I am somewhat familiar but less familiar with.I wish the dogmatic hate on JS would stop, it was boring 10 years ago, it's still boring.
I too wish the dogmatic hate of anything in particular would stop, but I also wish the stubborn assertion that the decades-long hate of JS is all dogmatic would stop. As long as JS is extremely wide-spread and has very stand-out negatives as compared to almost all other ecosystems, the hate will understandably continue.
What's boring is your aproach.Even if that part of the desired outcome is true (it's not though, as it rarely takes into consideration long term benefits and focuses purely on "instant gratification"), people who go to online programming forums as HN are hobbyists. And hobbyists do care about tools. You can't expect enthusiast to have this boring approach of someone who simply want to finish job onpassablelevel and get the fuck out of office as quickly as possible.And even if you are not a hobbyist, using a computer to do your/some job for you is literally what programming is about. So dismissing the topic of improving that process with better tools is simply ignorant
A nice, bad faith read
How is this bad faith?
You're assuming I'm not a hobbyist programmer (I am). Or that I don't take into account future requirements (I do). That I only care about apassablelevel of software (I am a big proponent of software craftsmanship... see:https://news.ycombinator.com/item?id=36586248#36587807, and also my original comment talked about maintainability...)In a hobbyist mentality, go wild! Do whatever makes you happy. In a professional, business environment I want to deliver outcomes first, my personal happiness comes from delivering those outcomes so it matters less on the technical choice.
Typescript is the language I am most familiar with (and Javascript before that, going back to the early Netscape days), being the language I use like 90% of the time in the work I do, but it unquestionably won't be the quickest way to the desired outcome for me. I'mwaymore productive in certain other languages, even when I only use them infrequently. The Typescript/Javascript tooling is just not there to support efficient, bug free, and maintainable development.The Javascript hate is absolutely warranted.
> For anything else it (or any form of Javascript) isn't the right tool for the job, in part for the reasons outlined in this post.I genuinely don't understand how someone could make a statement like this. You mention command line apps and servers, but surely whether TS is the best solution would depend entirely what you're trying to achieve. If there's a great NPM library to help you with the problem you're solving why wouldn't you use TypeScript?Not to mention the fact that TypeScript servers when paired with web frontends have obvious advantages. One project I worked on involved analysing 3D objects then visualising this on a web app. The simplest solution we found for visualising the analysis we were doing on the backend was just to build it all with Three.js and TypeScript then use common libraries.I'll also note that good JS developers are generally competent enough to avoid "bad habits" and that "bad habits" in my experience are not isolated to the JS ecosystem.
That you suggest Rust and Zig as alternatives suggests to me that you may not understand the requirements of a typical web application. These aren't usually CPU-bound apps that benefit from running close to the metal: the main bottleneck is DB queries and requests to other services. Adding all the complexity of the borrow checker isn't usually worth it unless your devs are already fluent in Rust, and using an early-stage C replacement like Zig would be an odd choice.Here are the criteria I'd use for choosing a language for a web server, in order of importance:1. What does my team already know?2. What languages have a robust ecosystem of web-related libraries?3. Static types are better than dynamic if the team is larger than 1 or if the project will last more than 6 months.Performance considerationsmightcome in after this if there are still two languages left to decide between. But judging from those criteria, I think you can see why TypeScript would not be a bad choice for a full stack web team.
I find this kind of approach so limiting to a business in general. Basically you limit your choice of programming language and with that the ecosystem early on. You got 3 devs only knowing language X? OK cannot use any other language ever, because then they would have to learn something new (oh noes!). This will of course mean that additional developers also cannot apply their additional knowledge and will have to use the same language and ecosystem as the others, because they can't possibly be bothered to learn another language.Learning a new language should be a frequent thing. I don't know how many languages I have learned, but it has only ever increased my understanding of computer programming, advantages and disadvantages of approaches and it certainly has made me a better engineer. If a business does not want better engineers, sure, stick to the "we can only use what we already know!" approach.Let it take 2 weeks for people to learn a language! So what? It will pay off in the long run. You will have more experienced engineers, we have a less limited idea about computer programming and how to solve programming problems well, since they have gotten into contact with other concepts from other languages. You also get a more flexible team, that can accept building better and safer services, using the right tool for the job, instead of shoehorning everything into their only one language. You will open up more ecosystems for your whole business.
I have no dog in the game, I love plain Javascript as my second programming language and have limited knowledge of TypeScript. That said, please look at the large set of CLI tools that have already been created in Javascript. It's not inappropriate language for the job by any means. Even portions of NPM and Node are written in Javascript. Grunt, Bower, Angular CLI etc. are just a few examples of CLI tools in Javascript.
Use the right tool for the job, not the meme tool for the job.Zig may be useful in some contexts but it‚Äôs also in beta and it has a bus factor of one.Rust is unnecessary for most projects that don‚Äôt need the extreme degree of efficiency it offers and would rather have a GC do all that work for them.Go is fine, if you get along with it. Many people don‚Äôt like it because the type system is from the 1980s, but if you like that kind of thing then go ahead.
> If youhaveto use Javascript (you're building the front-end of a web app), then it seems like Typescript is probably a decent solution.Why choose Typescript over any of the other hundreds of languages that transpile to JavaScript?
I've tried a few of those, and the bundle size is typically insane. The amount of code you have to ship just to get the semantics of your language and your standard library is nuts.There may be a few exceptions that were designed from the outset with JavaScript in mind, but then you're back to being at the mercy of JS quirks.
Because the good part of TypeScript is that it works seamlessly with the JavaScript ecosystem. Transpiled languages add too much friction.
Why need another dialect if you can just use Javascript.
I think most people don't really know Javascript, and what is possible.
Most arguments to use Typescript are not good arguments, and Javascript can more than most people think.
Typescript is more a combined box of tools, and a lot of things can be done without Typescript or another dialects.
If you use TypeScript on the server and client, you can define object types (interfaces) just once, which makes it a lot faster to write. If you use anything else you lose out on this luxury.
That's true, and I was impressed first time someone showed me that. But the cost of this luxury might not be worth it. Indeed, you mostly (only ?) communicate through an API. And if it's properly documented, which is now essentially automatic, you can easily generate your types from the frontend. To me, the cost of bringing JS to the backend dominates this luxury to the point where it's just not worth it. I'll just generate my types from the frontend and be done with it.
> Go, Rust even ZigOf all the languages you could pitch to someone already familiar with JS these would be at the bottom of the list. You want something dynamically typed, well trodden, and with a huge package ecosystem which to me sounds like Python or maybe Ruby. But honestly JS minus mountains of tooling is a really good general purpose language.
I think, if you write server code / command line apps.
It is better to choose for Javascript over Typescript, so you don't have the translation, and you know the system where you running on, and you can build for that Node version.
Typescript makes it indeed too complex, keep it simple with just Node.js without a build step, or use indeed another language like Go or Rust.
> Go, Rust even Zig are better choicesThis is a joke, right?
Wow I'm going to get downvoted for saying this, but Typescript lets me write, scale and maintain apps without writing tests.It's enough knowing client/server types move together, avoids null/undefined/[]/0/falsy edge case bugs, param/return mismatches, etc.
But do those languages have conditional types and template literal types, two great TypeScript features I now can't imagine programming without?
> If you want to get into TypeScript, don‚Äôt think you can leave JavaScript behind. It will find you, and it will get you.And do what?Perhaps it's my experience with a somewhat large(150k LoC) pre-CommonJS codebase, but I get the feeling that the language is being presented as much more intimidating than it really is.Yeah, strange things happen when you add an array literal to an array literal, or do any sort of type coercion really.My advice is: don't do it then. Seriously, you have to actively try to even encounter these quirks - especially now that we have language constructs like template strings, which prevent most such issues.
Lots of exaggerations here. But I guess that leads to more clicks and engagement
As he's written a few books about it, unless he exaggerates, the books may look boring but the reality is, JS/TS isn't as bad as he wants to exaggerate.So, the better advice is, real world can't be perfect, live with it and move on than complain. If you have so much to say, you're better off contributing to the project.
The cost benefit of typescript is a range. The benefit is that you have some greater chance that your code does not suffer from passing bad parameters. Bad parameters have some characteristics: missing, too many, too few, wrong types and bad values at least.It is important to understand that you are not "using typescript". You are in fact adding a layer of code on top of javascript. This layer is a variant of javascript, adds tooling and requires additional effort.  One overlooked aspect of typescript is that it requires of typescript to read it. If you publish your typescript code, for example in an open source project, it is less accessible to javascript programmers.The tradeoff between these two is something that is use case dependent.As a sole developer, after a couple of attempts I am adopting option #3. Instead of`function dosomething(params) { console.log("%s, %s",params.duck, params.dog)}`I now write` function dosomething({duck, dog}) { console.log("%s, %s", duck, dog)} `I find this gets me at least 50% of type problems that I usually miss, and the cost is extremely low.As a sole developer who needs to be extremely productive I simply can't afford typescript. I can afford this. And maybe there are other easier-to-use ways to catch other type problems?
My list:- extremely verbose- even further verbose and hard to read compiler errors- advanced uses require extreme prophiciency in TS- poorly typed libraries (including the standard ones, for easier transitions to ts), e.g. JSON.parse returning `any`s- untyped error channels. Got a function that can throw an error? You can't type it unless you change the shape of the returned type to some ADT like `Either<A,B>`. Have a promise that can reject with some generic error `E`? Well, `Promise<A>` takes only one generic argument, the errors are untyped, so you need to use stuff like `Promise<Either<A,B>>` and handle it manually or with external libraries.- Hard time to implement many kinds of stuff with a fluent api (meaning stuff like Foo.get().map(someMappingFunction).call(Baz) needs to be implemented as `get`, `map`, `call` as separate functions, not as methods). This is what forced `fp-ts` to go for `pipeable` APIs ( pipe(get, map(someMappingFunction), call(Baz) ) rather than the fluent api before. It also led for a period the `effect` ecosystem to write their own extensions for TS, called TS+ [1][1]https://dev.to/effect-ts/the-case-for-ts-18b3With all of that being said, TypeScript is one of the most productive and efficient and flexible programming languages out there, I know very few languages that allow to write so many kind of software for so many kind of platforms. TypeScript's structural typing has a long list of pros, and for functionally-inclined developers like me TypeScript allows to express and implement stuff that other languages e.g. Haskell cannot such as more generic typeclasses like Ordering, Eq, etc, without the same being "attached" to the type itself and being unique (which has no mathematical foundation, there's infinite ways to implement a sorting on any kind of type, there's zero mathematical reasons why there should be only one).
With the way its type inference works, it's probably the least verbose type system out there.
> JSON.parse returning `any`sHow do you type it?
Something like this [1] is the should be the real type of the function.[1]https://www.typescriptlang.org/play?#code/C4TwDgpgBAUgygeQHI...
I think only (3) lands as a good point.  And it is a big weakness of Typescript.  Practically, any TS application is going to get data from an API or DB.  You really would like to validate the shape of this data and TS offers little here.  Hence the explosion of tools like zod to go to/from TS type definition to validation rules.  Feels very wrong to have to add in a type manipulation library to a language that is basically only Types.
I'm not understanding the point.In every single decent language with a static type system you'll have to convince the type checker that data coming from outside the boundaries is of a certain shape by parsing it. If you're not doing it, then you are implicitly assuming it's of some type and you risk runtime type errors.E.g. in Elm you do have to parse every single thing coming in from outside the boundaries both from http requests or other external ports.
>risk runtime type errors.This is the part that's missing.  Or more completely there's no runtime types at all.  So you can't do stuff like:result = fetch....

    if(result is User){
      return result 
    }else{
       Throw error
    }The mechanism TS gives you to do that is essentially recreating all your type rules in a validation.  Which is keeping the same information in two places and risks them getting out of sync.Most people pick up a library that generates the types and validations for you to solve this.  Which works but it's kind of weird that you have to.
> Most people pick up a library that generates the types and validations for you to solve this. Which works but it's kind of weird that you have to.Why would it?Which static languages include automatic parsing at boundaries? Elm sort of does on ports, but that's like the only example I can think of, I'm perfectly sure that I may not know enough about it.
It's not a must, you can absolutely model IO and roll your own class validation/serializers methods and get both build time type safety and runtime validations without including a library for it. It's typical old school JS style validation we've done for decades with just some stylistic adaptations to stay type safe.However, grabbing Zod or io/ts is a lot less work and with tools likehttps://quicktype.io/typescriptorhttps://transform.tools/json-to-zodyou can paste in an API response, copy over a validator and export a type. My homegrown validator classes won't be nearly as clean or as quick.
Sort of tangential question, but does anyone outside of Meta still use the Flow type system for JavaScript?
Only in legacy code we haven‚Äôt replaced yet as we switched to TypeScript a few years ago. We don‚Äôt upgrade the flow dependency anymore either.
I always say, Typescript is no language but a dialect.
JavaScript is the official language that will used in production.
You can talk in a dialect, but for official things you have to write and talk the official language.
Always think if the Typescript dialect will help your team, or it can cause confusion, e.g. after translation to the code that runs in production.
(Error reporting, debugging, running tests, ...)Javascript is easy to write and understand, easy to play with, without transpiling, e.g. in your browser.
When you write code in the native language, you know what you write, how it will run on the system.
When you write in Typescript, it generates some Javascript that is sometimes hard to recognize as your code.
> When you write in Typescript, it generates some Javascript that is sometimes hard to recognize as your code.Every time I have tried to compare the output of `tsc`, I have reached the opposite conclusion.It's incredibly faithful most of the time. And when not, it's consistent. 
So if you understand why it does what it does once, life becomes much easier.Perhaps you are referring to minified code. Even then, with source-maps correctly setup,
I rarely if ever have a reason to leave TypeScript-land.Without the type-checker, my productivity (and sanity!) would likely be cut in 1/2 or more.I'd be very interested in examples that resulted in your opinion.
I subscribe to one of the TypeScript newsletters, just to keep and eye on the latest additions, and at some point I became exhausted. Every update (and those are very frequent!) comes with some new esoteric option most average developers will never use or will be totally confused by.TypeScript seems to be losing the plot to its own movie, turning into a sprawling, complex language like C++ or Scala - the "choose your own adventure" type.
I found it easy to pick up, and my React development experience is much better than when I used vanilla JS. I'm not even close to a full time frontend guy, so your experience may be completely different. I guess when you have worked with a bunch of languages, you tend to see them as tools to fix problems rather than something to be crazy about.
Typescript is currently the best way to avoid the myriad of issues writing JS. It's an amazing hold over until we get native types. ECMAScript proposals take a long time, but it will eventually come.https://github.com/tc39/proposal-type-annotations
Genuine question here: would it be better for a backend server or cli to be written in a language that allows for compilation to a single executable, or run through an interpreter (python, deno/node/ts-node etc)? I'm not familiar with Go or Zig in that regard.
That depends on what you mean by "better". What's your goal here?
A single executable would be easier to deploy/version/sign. You could in theory also make a bundle with typescript/javascript files as well. It would be no different from deploying a WAR file on a server running JAVA.Do what is the easiest for you and your team.
Better than what, and in what way?
Compiling to a single executable like Go and Rust and Haskell do, has a bunch of benefits for a server. Notably, itusedto be the case (before the container revolution) that if you used a scripting language like Python, say, you had to carefully pip install all your dependencies identically between your prod and staging and test environments and your local dev env. Scripting languages have this nasty habit of preferring to not break, they will start a script without having all of its dependencies in the hopes that by the time the dependency is actually used, it will have been installed dynamically. This is also why wizened programmers from those cultures write so many damn tests, because if there is a dependency that does not get exercised at test time then you might have a prod outage on the weekend when some user figures out how to exercise it, etc.In other words you can view the rise of Docker as saying, ‚Äúgive me your scripts and I will give you this magical unicorn called a container image, which can be used to run your script like a single executable.‚Äù People did not use Docker for its security features (the people who cared about that used VMs before Docker and put Docker into a VM after), but for its operational feature. If anyone had understood this before the rise of Docker, I think they would have architected Docker differently: multiprocess containers and weird networking stacks could have been done away with, you would probably not throw all of the OS into the binary because that's overkill (just Terraform-like ‚Äúproviders‚Äù or so?) ...also Docker needs to run as root to establish its tentacular spectacular: if you had viewed the goal as packaging the scripting language as a virtual binary you probably wouldn't need this stuff.If you are running a large enough company then you need something like kubernetes because you have thousands of developers all needing to deploy on to the same prod hardware clusters. Cloud computing generally tries to lump you into this bucket too. In those cases there is no difference.But if you are running a small dev shop of less than 20 devs at a larger 100-300 person company, now prod is whatever Casey your sysadmin says it is, and Docker is forbidden by some policy that you can't run as root or so, so now it's easiest to just compile static binaries and then build a lightweight gitops thing out of that, put an NginX server in front (except Casey gets mad and makes you use Apache) and some FastCGI and with a bit of luck you can get it so that if the build or tests fail, the system sends you an email via nagios but keeps humming along with the old build. It's a few weeks of work and you'll complain to every dev you onboard ‚ÄúI'm sorry this is all held together by duct tape‚Äù but it'll chug along fine until that company becomes 5,000 strong and you have 500 developers and can afford to containerize or shift to cloud for new applications and "do it right".
It's awful to incorporate as part of a project (all the configuration for compilation, mapping errors etc.). It's also extremely complex language with plenty of footguns. The required TS tooling is also an argument against it.
I need that celebrate switch on every website, how whimsical.
The developer experience is excellent with Typescript. It's so much nicer to get auto complete suggestions based on a type system rather than mostly heuristics in plain JS. Refactoring is breeze. I enjoy using TS. I enjoy basic correctness guarantees caught at transpile time.Of course there's trade-offs, but the whole article is a list of unconvincing appeals to authority.And then the author ends with:> Our tendency to just blinding reach for tools because it‚Äôs what Google or Facebook does often just makes things worse for both developers and the people who use what they build.You spent 4 paragraphs giving examples of other people using plain JS as the reason we should be blindly switching back to plain JS. Svelte swapped back to JS for n reasons that aren't applicable to you or most people.> I help people learn vanilla JavaScript, and I believe there‚Äôs a simpler, more resilient way to make things for the web.> I create courses and ebooks, run online workshops, and host the Vanilla JS Podcast. My developer tips newsletter is read by over 14k developers each weekday.Oh.
I have not been able to jump on the TS train. For the longest time, it has just not quite felt right. Adding layers upon layers of complexity for a static type system and some related syntactic sugar, all while guaranteeing that it remains a superset of JavaScript has left it in a similar position to C++. It‚Äôs fragility has left it with a house of cards-type feel with unending dependency trees and poor visibility into itself as a runtime.
It‚Äôs definitely possible to create very brittle types that feel like a house of cards.I think the most common mistake people make is re-using types. Even if a type works in two places, you can‚Äôt guarantee that the semantics in those places will stay consistent.Devs working in TypeScript often think that in order to keep things DRY you should reuse the same types all over a codebase. For me it‚Äôs the opposite: using a type in two places is a code smell. You‚Äôre not really leaning on the compiler if you‚Äôre re-using types. The compilerlovesto take two types and tell you if they‚Äôre compatible. Sharing the same type across use cases is just not necessary.I find keeping types as local to a function as possible helps a LOT with alleviating that ‚Äúhouse of cards‚Äù feeling you‚Äôre describing.It‚Äôs a real problem though.
I would hate to make judgement after such a small piece of text, but your argument just doesn't make sense to me. Reusing types would suggest you're actually coding against a design. Why should the data have a different shape in two different places in your code? If you're working with the same data shouldn't its type have a single identity?
> If you're working with the same data shouldn't its type have a single identity?That's a good instinct, which is probably why people do it in TypeScript.But, IMO this is not how TypeScript works best. When you write a function, you should fully type the data that you needfor that function. This type is semantically tied to the implementation of the function: by writing out that type, you are "certifying" that that is the type that the function needs.If you then go and use that type in another function, you've lost that "certification" inbothplaces. You now have a type which is the union of the data structure needed by both functions.This has two negative results:1) There is no longer any point in the code where you are actually describing the specific contract requested by either function. And,2) If you want to change Function A, you now have to spend 30 minutes reasoning out whether the contract required by Function B is still compatible with their shared type.Result 2) is what causes the "I write the code and then I spend 2 hours making the types happy" issue that I was responding to.Some side notes:- I can't claim that this is the right approach for all typed languages. But the TypeScript compiler specifically isveryhappy to exchange one type for another as long as they're compatible. It is designed to handle "duck typing" like this at its core.- I want to emphasize thatsyntacticallyit makes no difference whether you reuse types. And certainly it saves you keystrokes. The problem with reusing a type is you're omitting crucialsemanticinformation about which "slice" of that type is needed for a function.- I will accept that sometimes it's worthwhile to Pick<> some properties off of an object. But even this is usually avoidable.
> I‚Äôve been a developer for a decade now and never run into an issue where JavaScript‚Äôs loosely typed nature has created a problem for me.yeah... ok
I think if you are so reliant on static type checking that you can‚Äôt live without it, well, there you go. But it doesn‚Äôt seem like it has to be more of a problem than an hundred other oopses you deal with like passing parameters in the wrong order.Most of JS‚Äôs most public issues come from thinking every programming language is
C++.
Statically typing your parameters prevents a lot of instances of passing them in in the wrong order. And if you make a habit of using a single statically typed options parameter instead of multiple parameters that have the same type, you can make passing parameters in the wrong order completely impossible in your codebase.
Framing type checking as a crutch is a new one to me.
It‚Äôs not a crutch at all, it‚Äôs a very useful tool and central to a certain style of programming. There are other styles of programming, like prototyping and scripting, where just relying on yourself not making the mistake in the first place is better.
Wat
Cannot disagree more. The author is either a Javascript savant or has never worked on a 100k LOC Javascript project.I remember the days before Typescript, chasing down those ‚Äúundefined‚Äù Javascript bugs. Not fun.
For smaller applications, an acceptable middle ground is using the TS language server[0] and JSDoc[1] comments.Writing// @ts-check
  /** @type {number} */
  let x;works very well for example in VSCode. The JSDoc comments are not as convenient as Typescript, but otherwise the experience is almost the same. The language server correctly keeps track of the types for me.[0]:https://www.typescriptlang.org/docs/handbook/intro-to-js-ts....[1]:https://jsdoc.app/
> Incremental compile time when changing files in cli/js takes minutes. This is crushingly slow and painful to modify.This is in my opinion the worst offender of TypeScript. TSC is insanely slow even in incremental mode for large code bases, and no alternative compiler exists. There are projects whichcanstrip types and convert TS into JavaScript, but they do not check types.Alternative implementations have been swatted down by TypeScript maintainers like Daniel Rosenwasser, with the leading argument being that the TS spec moves insanely fast and keeping two or more implementations up to spec would not be worth it due to the work it would require.
Well, if there would be multiple TypeScript implementations available, especially ones that are faster, Microsoft would suddenly lose their moat they gathered by getting TypeScript to be wildly used.Keeping the spec moving fast and breaking it with new updates servers multiple purposes, not only to make the language itself different, but to avoid competing implementations.When I say "spec" I main the Microsoft TypeScript implementation, as they don't actually maintain any actual specification anymore.> The spec is now an "archived" artifact and we won't be tracking defects against it anymore. -https://github.com/Microsoft/TypeScript/issues/15711
Wow. That is pretty bad.
Have you heard of ReScript?Their website:https://rescript-lang.org/
I do wish we were in the timeline where we got a super powered jsdoc, instead of TS.Something like that would be my guess for what‚Äôs next, once this current trend has run its course.
We already have that! And it‚Äôs TypeScript. You can and probably do use 98% (made up number but close enough to reality I don‚Äôt need to quantify it) of the benefits of TS while authoring JS code if you bother annotating types in JSDoc.You can also get the same type checking benefits outside of the editor (eg in CI) with very minimal tooling effort. That‚Äôs what Svelte is doing.Granted I work on JS projects which embraced this from the opposite direction (gradual typing where nothing is enforced statically), and it‚Äôs strictly worse than just using the tools how they work best (you‚Äôd be hard pressed to make an incremental decision about anything without knowingly preserving bugs or increasing the incremental scope).Anyway, the alternate timeline you seek already exists. It‚Äôs just so optional that you could easily miss it.
Typescript is one of the most popular languages in the world at this point and continuing to grow (see Stack Overflow developer survey for the last 3 years). It covers the majority of the mature ecosystem on npm by now. Characterizing it as a trend is beyond incorrect. For all intents and purposes, JS is now statically typed.
TypeScript would have to become more popular than JavaScript for your last part to become true. And it's nowhere near of getting there (outside of SV/hip development world).https://trends.google.com/trends/explore?q=%2Fm%2F0n50hxv,%2...(last 12 months worldwide)Last datapoint: TypeScript - 10, JavaScript - 82
I don't think that's a fair metric. Many people using TS (myself included) will typically use "JavaScript" in search queries because the answer is usually the same. The only time I search for "typescript" is if I have a problem with the type checking, which isn't very often.That said, I think you're right that JS is still quite popular.
I think that‚Äôs literally Flow:https://flow.org/en/docs/types/comments/
I could definitely see the benefit of TS on a giant, modern app with a big team. However, at my job I am a solo developer on literally dozens of smaller JS projects of varying age that I need to keep running essentially forever. Typescript is enough of a pain in my npm build process that I just ditched it long ago. The fewer dev dependencies the better for me personally.
I also work on small apps, and like it there. I needed a day to set up TS the way I wanted, and I don't use strict mode. This way I can have TS check the few places I feel  it's most useful, and not bother with the rest.I feel confident making small components, and functions. But I like adding types to form data and product objects, especially when decorating product objects. Otherwise I'm prone to get confused as to whether the props have been decorated already, or not, maybe check for it? TS just feels really smooth sometimes, but admittedly I am not using it in strict mode.
For small things, sure. Substantial things like apps, its like shooting yourself in the foot before you've ever begun, and good luck refactoring anything with any confidence short of covering your whole app in tests.Also, I think the examples given in the article are circumstantially exceptional, if you read more closely into the why.
> refactoring anything with any confidence short of covering your whole app in testsI don't have any confidence in refactor large swaths of code without widespread tests, with or without TypeScript. Types covers such a small area of where we (I) usually introduce bugs.
I've found in strongly typed systems if I lean heavily on the type system refactoring is a dream. I make the changes I want. Then follow the compiler errors. Most of the time it just works. Rarely does that introduce bugs. However if you use a Typed language without using the type system to enforce the design constraints then the type system just gets in your way. In that case refactoring is just as hard. It's very easy in Type Script to write code that might as well be written in a dynamic language. It often is.
That‚Äôs not my experience. I find in carefully typed projects I can do pretty large refactors with high confidence  that once the types are correct again, a lot of tests will pass, and a lot of behavior will work.It‚Äôs not that there aren‚Äôt bugs, but I have a high degree of confidence after fixing a small number of bugs that the overall system has a high degree of correctness.There are several things that go into this- good types- good tests- good interfaces between modulesAll three I think give me a big jump in how quickly and confidently I can refactor.
Tests are very important, don't get me wrong. What I mean is that it's trivial to refactor large _trivial_ things with types -- ie, big restructures, renames, clarifying things, etc -- where without it even small "large" things become dangerous and worksome.
I love this thread, it has two of my favorite HN topics:
1) People shitting on JavaScript not realizing that their "obviously better" solution was considered and found not a good solution.
2) People shitting on TypeScript not realizing that conditional types and template literal types are awesome. I really like those type-safe routers (https://tanstack.com/router/v1/docs/guide/type-safety) and fully-typed database clients (https://www.edgedb.com/docs/clients/js/index#the-query-build...).
Typescript is one of those things that makes me so productive that I have absolutely nothing to argue or prove. Their loss.
Not a rebuttal, just curious, how do you find your productivity compares to a "real" statically typed language (e.g. Go, Java, etc.)? Does your increase in productivity compared to JavaScript simply come from static typing, or is TypeScript itself the source?
Both.  Static typing makes JavaScript well more than tolerable. Dare I say enjoyable!  But I also love TS' duck typing and I love how it's totally optional.The optionality is a special trait that most "real" static languages don't get to enjoy (for better or worse). By being optional, I can simply ignore types when I'm hacking/prototyping something and type safety/soundness is the last thing I care about.  Rust, for example, can feel really tedious when it makes me "show my work" and I'm just trying to scribble something up quickly.  If that makes sense?  I just make `any` a linting error so I can use it during my experimentation/prototyping but I cannot ship it.
Typescript has quite a few pitfalls like the uselessness of Readonly<T>, which can just vanish with an assignment to a variable typed T where TS will neither warn nor error out nor require an explicit cast.
I agree. I feel like sketching in JS and solidifying in TS is super productive. Being able to go from a plain old JS object to a type is really satisfying. I feel like full stack TS might be a great choice for new web projects. And if you find a bottleneck, you could rewrite in Rust.
> And if you find a bottleneck, you could rewrite in Rust.Sounds pretty extreme..? What kind of bottlenecks would you be talking about that would prompt me to re-write my entire application in another language?
I'm pretty sure they mean rewrite the bottleneck.
no just rewrite the bottleneck/hot-path
Not GP, and not a direct answer to the question‚Ä¶ in these discussions a lot of the ‚Äúbenefit of static types‚Äù gets boiled down to:- documentation- aids tooling (eg improved static references in editor, static analysis by linter, etc)- catches a whole class of problems before runtime (eg a typecheck-time substitute for certain runtime checks and their corresponding tests)I often like to add:- promotes better designThis puts TypeScript‚Äôs type system in a unique position, where it‚Äôs simultaneously expressive and complex in ways many others are not (because it‚Äôs designed to express extraordinarily dynamic idioms used in JS) and equally mundane  and simple if you use it from the start (because all that complexity is a good forcing function for deciding whether you all of that dynamism it can express is of value for the thing you‚Äôre actually building).In a more general sense, it strongly encourages developers to think about their interfaces explicitly where they might otherwise ‚Äúrapidly prototype‚Äù a monstrous one.The vast majority of the time, TypeScript will encourage simpler APIs thatdon‚Äôt needmost of TypeScript‚Äôs ‚Äúadvanced‚Äù type system features. And in terms of productivity, that‚Äôs a benefit you only get if you‚Äôre starting from the proverbial Dynamic Wild West. So it might not be absolutely more productive than other statically typed languages, but still relatively an enormous productivity boost in its context.
Not OP but a well-typed codebase means you have to remember less, your broken code gets caught before you even run/compile it, and you can just lean on the type system to write the code for you.And TypeScript has a much more expressive type system compared to Go, Java, and frankly most languages. Java in particular still has pretty bad type reification (where ArrayList<Integer> and ArrayList<Float> are essentially the same and cannot be used to overload methods, for example).I use a lot of the utility TypeScript functions (i.e. Partial<>, Record<>) and it catches all sorts of mistakes that might be made by myself in the future or someone not familiar with the codebase. For example, if therehasto be a A->B mapping somewhere, I would type B so it would raise a type error if something was added in A but not B. Most type systems are not flexible enough to do anything remotely like that and instead you have to write a bunch of tests where you end up 20 lines of very basic test code for 1 actual line of code.
I have a bit of experience with TypeScript and I think that its types are pretty good at catching mistakes. You need to run linter (like eslint) and some strict compiler options to take a full advantage of it, but that's not a big deal. And TypeScript type system is miles ahead of Java. I'm not sure if those types provide any productivity increase compared to Java, that's questionable, but at least it's not JavaScript and that's good enough for me. Now JavaScript is truly atrocious hit to productivity. I just can't stand it.My only issue with TypeScript is its strange design with regard to interface and types. Those are pretty fundamental concepts and they're absolutely similar. I don't understand this design and I think that only one thing should have left, but may be I'm wrong about it. Also I think that TypeScript documentation would benefit from more examples with hard concepts, I didn't fully understand its advanced generics concepts. But that's not a big thing and probably more on me.
> My only issue with TypeScript is its strange design with regard to interface and types. Those are pretty fundamental concepts and they're absolutely similar. I don't understand this design and I think that only one thing should have left, but may be I'm wrong about it.I feel the same way. IIRC, earlier versions of Typescript were much more clearly influenced by .NET and other Microsoft idioms, and there were a few features that didn't seem to make much sense coming from the Javascript side of things. I also had a buddy of mine that's a Java developer be very confused about how they were supposed to work.> Also I think that TypeScript documentation would benefit from more examples with hard concepts, I didn't fully understand its advanced generics concepts. But that's not a big thing and probably more on me.Absolutely agree on this, although things are getting better. For awhile it seemed like the only documentation for more advanced features was the main website's blog posts and release notes.
One major downside of TypeScript is that types are not available at runtime and that computations on types can't be done by writing regular TypeScript (both possible with code generators of course).
Types are absolutely available at runtime, you just have to start from the runtime. Type guards are the solution everyone wants +- a tiny bit of ceremony, and adding type system information to the runtime would just hurt performance for no good reason.This:type Foo = {
    bar: string
    // ‚Ä¶
  }Can just as easily be addressed as:const parseFoo = parse.object({
    bar: parse.string,
    // ‚Ä¶
  })

  type Foo = Foo<typeof parseFoo>(Where parse methods here are type guards for their respective parsed return types, and can similarly be used to serialize runtime values as needed.)For that little bit of extra ceremony, you get to isolate runtime stuff to the boundaries you need to care about, and let the type checker deal with everything else (typically most everything internal).
Have you ever used a language where types can influence runtime behavior? It's an extremely powerful tool to do things like choosing a specialized sort algorithm based on the type of contents of array you are sorting. This has zero overhead iff types are known at compile time and can yet hit different code paths at runtime. To just dismiss this as not needed is extremely short sighted in my opinion.
Having types at runtime is a big deal and I lament that typescript can‚Äôt do it (for understandable reasons.)
I have. And I think the limitation is good for a language that doesn‚Äôt have that. I don‚Äôt want TypeScript to lie to me about its capabilities, I want it to help me make good decisions with the runtime code I actually have.
You can always use zod or io-TS.
> Types are absolutely available at runtimeTypeScript types are not available at runtime. As the name implies, runtime type information requires runtime support. Since TypeScript compiles to JavaScript, the only type information available is that provided by JavaScript.
Types are absolutely available at runtime. You just have to start with the runtime.const parseStr = (value: unknown): assert value is string => {
    if (typeof value === 'string') return value

    throw new Error(‚Ä¶)
  }

  const str = parseStr(anythingYouCanThrowAtIt)I can 100% guarantee you str is going to have the same static and runtime type once you‚Äôve checked it, or parsed it from whatever type you‚Äôd accept as a string. TypeScript won‚Äôt do the parsing for you, because JavaScript doesn‚Äôt have clear semantics for runtime casting that anyone wants or would accept. But type guards are exactly the solution to that and incredibly composable. Once you accept that reality and embrace it, getting the static type out of your runtime parser is a single added line of static type code. And all of this is almost exactly equivalent to what languages with runtime casts do, but you have complete visibility into it because you determine how casts behave. There are whole libraries which do this for you so don‚Äôt worry about rolling your own unless you have very particular needs. But TypeScript definitely has the facility to align static and runtime types however you see fit. You just need to tell the type system what types the runtime conveys, same as every other aspect of the type system.
You seem knowledgeable about TypeScript, so you certainly very well understand what people mean by "types are not available at runtime". Once your typescript is compiled to javascript, there's nothing left of your user-defined types and interfaces. Type guards are a security that is very much a workaround for the lack of types at runtime.
I‚Äôm encouraging thinking about the problem from a different angle. If you parse rather than validate[0][1], you have roughly all of the type information you could want in the runtime, and by using type guards the type system will reflect the runtime types.It‚Äôs not a workaround. Every language with runtime types will have some logic devoted to this kind of casting/narrowing. TypeScriptrightlydoesn‚Äôt build it into the compiler because most of the time you don‚Äôtwanttypes to have runtime behavior. For internal logic which can be validated statically, runtime types would be an unnecessary overhead. So it‚Äôs up to developers to determine where it should be applied. Type guards are explicitly an affordance for that, designed specifically toconveytypes with runtime casting/narrowing.If you use good, composable primitives like zod or io-ts or any of several other implementations, your code will typically be almost identical to deriving runtime from types rather than the inverse.0:https://itnext.io/parse-dont-validate-incoming-data-in-types...1:https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-va...
You can use discriminated unions with TS (https://antman-does-software.com/typescripts-discriminated-u...), and you can even parse them from unknown data using tools like zod (https://zod.dev/?id=discriminated-unions), io-ts, or the likes.I can't think of anything I can do in .NET (which has runtime types) that I can't  do in TS with the help of a library or two.
> I can't do in TS with the help of a library or two.Libraries like io-ts and zod embed the type information into JavaScript, so the information is available at runtime but only for wrapped types. If TypeScript provided runtime type information, such libraries wouldn't be necessary.
Can only speak for java. But I'm way more productive with typescript. Typescript has 2 things going for it:- type system is way more flexible. You can create, merge, pick keys and manipulate types in all kinds of ways. You have better type inference, type conditionals and lots more-there's an escape hatch. Sometimes you just want to quickly try something, or you're under time pressure and need to either break the types or do a bigger rewrite, or you just don't care about a certain variable's type. Then there's the any/unknown/plain js/@ts-expect-error escape hatches to do just that.
It's a bit of both for me. I'd say 90% of it is from simply having types; 10% is from some of the cool things you can do with TS types that aren't common in most statically typed languages.
> cool things you can do with TS types that aren't common in most statically typed languageslike what?
For me (coming from C++) being able to easily union and intersect types, and being able to specify certain values (not sure the right name for this). For example:type ServerResponse = {success:true, response:JSON} | {success:false, error:string};In C++ I would probably have to type success:boolean, and make response and error optionals, but the TS type is more expressive.if success==true, then response must exist. 
if success==false, then error must exist.const sr: ServerResponse = {success:true, error:"moo"); // won't compile, doesn't matchTS understands this type really well, and type narrowing makes it easy to work with.// NOT LEGAL; error might not exist
    console.log(sr.error);

    // IS LEGAL; we test for success first, which narrows the type. 
    if(sr.success){
        console.log(sr.response);
    } else {
        console.log(sr.error);
    }
Too late to EDIT: but "literal types" was the word I am looking for.I used "success:true" and "success:false" as part of the two types I was combining; it seems like "success:boolean" would server the same function, but it does not. The type I created has more information that that.https://www.typescriptlang.org/docs/handbook/literal-types.h...
I'm a big fan of TS, but discriminated unions are available in a lot of languages and when not, there's usually some library adding it like boost::variant if the language has runtime types or templating/macros.
C++ has std::variant these days, no need for Boost‚Ä¶ however, neither version has particularly good ergonomics.
If I understand std::variant, it THROWS if you try to access the wrong type?I should have been specific, but all of the errors I mention above are compile-time errors, not run-time.
> boostNo, thanks.
Some folks have built whole SQL databases and DSL compilers in the TS type system. These tend to be toy projects with disclaimers not to use them. But the type system being Turing complete[0] (for better or worse), pretty much whatever you can imagine. This project[1] is one I actually return to frequently for practical ideas.0:https://github.com/microsoft/TypeScript/issues/148331:https://github.com/sindresorhus/type-fest
- easy referencing the type of another struct's field. As in `function parseInput(input: SomeType['someField']) { }`- it's ability to infer types in general- parsing. given a route string like `/users/:userId` TypeScript can force you to always pass `{ userId: 1234 }` when actually building the route without having to declare the interface anywhere- conditional types
I think the biggest benefit I've found is TypeScript's inference is extremely smart and in fact it's considered a best practice to basically write as little TypeScript as possible and rely as much as possible on TS's inferenceIn general, if a "best practice" of a language is to write less code that tends to translate to great productivity
> Does your increase in productivity compared to JavaScript simply come from static typing, or is TypeScript itself the source?As far as I can tell, TypeScript doesn't add any new features or behavior to JS other than static typing.If you ask me, of course TS isn't as good as the real deal, but it's darn close andwaybetter than vanilla JS or compilers for other languages that target JS.
I really dislike how unpredictable the typescript compiler can be. What I mean is, there isn‚Äôt a simple set of rules I can understand to know when annotations will be required. Most of the time, this doesn‚Äôt matter, but occasionally it blows up and development comes to a screeching halt. Contrast this to, say, Java and ML type-systems, which are highly predictable.
I think the opposite, TS is much more predictable than hindley-milner inference, mostly because the inference only flows forward.Yes, there are a couple of weird edge cases with arrow functions in generics, and it gets a bit more complicated with narrowing, but aside from that this never a problem I've run into. IMO the verbose error messages for complex types are a much bigger problem, which could be solved with better UIs for error messages (syntax highlighting and code folding).
The rule I tend to follow is "annotate as little as possible". This has worked out great for me so far since TypeScript's inference gets it right 90% of the time and it leads to more maintainable code.Also after coding 5 days a week for a full year with it I really can't relate to the idea that it is somehow unpredictable. I think, like most things, you eventually get a "feel" for it and don't even have to think about it.That's what I love most about it. It feels like it takes up no extra mental real estate for me. It's excellent at never "getting in the way" (when used properly)
Use LSP feature that reveals what TS thinks is the type of the identifier under the cursor (I have it bound to Shift+K in Neovim). If not right, annotate (or better go back and type properly whatever means you obtained that value).
When I see things like this I have a visceral reaction that I just can't get over.https://www.typescriptlang.org/play#code/MYewdgziA2CmB00QHMA...
Yeah, not wrapping your hook before sticking it in unknown interfaces is a recipe for visceral disease. They don't teach that in school these days?Practice safe interactions - say no to unprotected injections.
Code looks fine to me. Classic blame the programmer mentality. Shame on you.
Hey, I think it's mutual responsibility on both API provider and user to engage in communication before mixing parts.Who to blame is less important when you have an abandoned/orphaned child processes to take care of :/No kink shaming, tho.
> I think it's mutual responsibility on both API provider and user to engage in communication before mixing partsAnd I think it is the responsibility of the type system to at least catch if I'm passing too many arguments to a function.
TypeScript flags when I call a function that takes two parameters max with three arguments as an issue in many contexts, but not in contexts like this.I understand why they chose to do this, but I reach for better type systems any time I have the choice.
On the other hand, Stockholm Syndrome is an underrated and under-researched effect in software engineering.There are people ready to defend with their life the most obtuse, inane piece of technology, just because they have invested a non-negligible amount of time getting used to its quirks, that they become completely blind to its faults, and start to believe those very quirks are actually positive and to be cherished.
> TanStack Router is built to be extremely type-safe.This is alludes to my only major complaint about typescript.  IMO, something is either type-safe or it ain't.  I don't like how the JS bleeds through if you aren't careful.I'm not a TS hater by any means, I use it regularly and am usually pleased.  I just can't help but compare it to the [S,Oca]ML compilers I'm so fond of.
There is so much wrong with JS, the only reason it is used is because people are literally forced to.It took a long time for js devs to accept the notion of a compiler with TS. While TS is an improvement, it‚Äôs only a localized one. No chance ever, any other language could have replaced it.
> There is so much wrong with JS, the only reason it is used is because people are literally forced to.There are perhaps at least a hundred (when not hundreds of) compile-to-js languages, yet people still use it. Even in back-end!> It took a long time for js devs to accept the notion of a compilerPeople who write programs in JS cannot be so easily grouped together, I think. There's this eternal September of bootcamp devs writing... interesting... code as we all did when we first started, but I personally went first with C, Perl, then PHP, then JS, then .NET, then Python and now continue mostly in TS and Java. Among them TS is the one I like the most (and the ones starting with P are the ones I dislike the most - not that it matters, use whatever works for you).
Have you used EdgeDB in prod? I‚Äôm itching to try it, but am too worried about general instability. Seems like too many moving parts. Love the DX though, it‚Äôs really clean and well thought out.
No, not in production yet. But I'm not really worried.
From the comments here, I was expecting to find myself hopelessly out of date, and to end up with a migraine trying to parse through a mindnumbing list of changes. Turned out I was mistaken.> Me: oh, cool, they fixed so many tiny things I had bumped up against
  > Some others: oh no, why are things changingI'm not getting it. Maybe I'm reading this wrong, but to me these seem pretty obvious small issues to smooth over.
The way JS/TS change _feels_ a lot more haphazard.For example why introduce a new method to support negative indexing. Supporting `array[-1]` instead of `array.at(-1)` would mean one less thing to remember.Many of the changes make the language feel like a hodge podge made from parts of other languages. This lack of cohesion is IMO what makes upgrading the language always feel like moved cheese.
Because your example is a breaking change, and breaking changes are hard to make in a runtime that needs to reasonably support two decades worth of web content.For example, if you have a `binarySearch` function that returns -1 if an element isn't found, a developer might do something. `const result = arr[index]; if (result !== undefined) { ... }`. This would then start returning the last element instead of undefined at that index.
We already have things like "use strict", because of backwards compatibility. Following the same idea, we could have something like "use ES2023" or something along those lines. Issue with JavaScript is that browsers have in-flux implementations of new features (as browser parent companies see it fit for their usage), and there's no cohesive point in time release process. I think "living" standards, are part of the reason why the web stack is so jumbled.But what do I care, whatever mess and complexity arises from these "good enough" implementations is left for the generation after us to deal with :)
In some sense, the messiness of the living standard is also what enables large-scale web archival.A lot of old code in other languages may be hard or impossible to compile and run without significant work.
Exactly right. `arr[-1]` means `arr["-1"]` and already does something.
No, because changing browsers to interpret `arr[-1]` as `arr[arr.length - 1]` breaks existing sites that expect `arr[-1]` to be interpreted as `arr['-1']`: That is, the value stored on object `arr` at key name '-1'.Changing browsers to interpret `arr.get(-1)` as `arr[arr.length - 1]` doesn't affect any old code using `arr[-1]`.It's not about supporting old browsers. It's about supporting old code.
I think you're confusing your application with the language itself.Adding new syntax and functions to the language is not a breaking change. Old code will continue to work.If you start using these new features in your application, and it no longer works on old browsers, then sure that's a breaking change. But that's a choice for you to make. The language is still backwards compatible.
`indexes[haystack.indexOf(needle)] = true`There's a valid example of code that would be broken (`indexOf` returns `-1` as "not found"). Is it a good way of solving whatever the author was trying to do? Probably not, especially now that sets exist. Is it code you might conceivably find on hunreds of sites across the past decades of the world wide web? You bet.Yes, we could introduce another "use strict". But we only just got rid of the one via ESM (which enforces strict mode). That was a one-off hacky solution to a hard problem coming off the end of a failed major version release of the language (look up ECMAScript 4 if you get a chance). We don't want to see a repeat of that.
Why is there still no simple way of handling changes like this?Surely there should be a simple way to have a header in each file with the language version, and then the file will be interpreted as that version?
All of this was hashed out during the "Harmony"[1] days. Versioned-JS was of course one possible future. Maybe even still is. But the prevailing decision coming out around that time and leading to ES5 and ES2015: We'll add "use strict" as a single-point-in-time breaking opt-in upgrade to fix a lot of the common problems, but let's otherwise stick to "One JavaScript"[2].You may find [2] and [3] especially enlightening to understanding this thinking, and any other discussions from ES Discuss on the topic if you fell like digging into history.[1]https://johnresig.com/blog/ecmascript-harmony/[2]https://2ality.com/2014/12/one-javascript.html[3]https://esdiscuss.org/topic/es6-doesn-t-need-opt-in
Well, "use stricter" and "use strictest" are still available...
!important
Maybethis is simple in implementation, but it's definitely not simple in developer experience.You grab some code in one of your old projects for implementing a binary search. Can you copy-paste it into a new project that targets a newer language version?The question isn't as simple as "does it have syntax errors", because we're talking about changing semantics here. Given a set of semantic changes and a piece of code, figuring out (either as a human or a computer) whether the observable characteristics of that code have changed is somewhere between vexing and impossible. It's entirely possible, for example, that your code encounters changed semantics, but not in a way that changes the actual behavior of the code.In this world it just becomes very, very difficult to reason about extremely common operations; it'd be a constant source of frustration. There's a good reason you rarely see languages versioning theirbehaviorin impactful ways.
> Why is there still no simple way of handling changes like this?This is nothing JS specific. Breaking changes are breaking changes.
If you can, don't introduce them.> simple way to have a header in each file with the language versionOne special aspect that differentiates JS from other languages:It's both a language AND a universal runtime. A lot of JS that's executed is not JS that's written by humans but generated by a compiler/transpiler.So adding a layer of header versioning is not a big win in terms of developer experience: It would anyways be the deployment toolchain that's responsible to deal with such a versioning scheme. It would ideally be invisible to the developer.
To be pedantic adding an at function is a breaking change too.
Not really.You can add a polyfill to check if `Array.at()` exists, and if it doesn't, create a function that does the same thing and add it to the `Array` object, so now all `Array.at()` code works as expected.Then once every environment you target supports `Array.at()` by default, you can remove the polyfill to reduce the size of your code.
if (array.at) {
      explode();
    }Adding the at function would break the above code which depends on array.at being undefined.
They test a lot of websites before introducing new methods. Something somewhere may break but it's very unlikely and this pragmatic approach allows progress.This is also why the language got Array.prorotype.flat instead of flatten (flatten was breaking an old version of a popular library called Mootools):https://developer.chrome.com/blog/smooshgate/
And extending javascript's built-in objects has been considered bad practice since at least 2007.Before that point, browser environments were so different that you needed to write code per-browser. Those theoretical concerns didn't really matter since in-practice you were essentially coding the same app in different scripting languages.
> extending javascript's built-in objects has been considered bad practice since at least 2007Totally. It's just extending the prototype that causes the problem though, not extending from (class myclass extends array). This causes a lot of confusion among new js devs so I underline this on every opportunity.
When I look at clever TypeScript, I always think the code was written by either Haskell or C++ template metaprogramming refugee, and this isn't good for the longevity of the language, see what happened to Scala's adoption because of it.
Typescript will have no adoption problem. It is the defacto only compile to js language supported in NPM. It is also ergonomic to JS devs who want or are forced (at work) to use typing and an option on most scaffolding tools like NextJS or CRA. The fact that TS is actually very good just confounds this more!It will live as long ad JS is popular. The main threat is web assembly which will make JS compatibility seem quaint.
Something should be pointed out to outsiders looking at typescript, otherwise they might get the wrong idea about the language.In practice there seems to two different sides of typescript code.1. Regular projects: tend to have rather easy to understand/write/maintain code.2. Dependency code: tends to have code-golfed metaprogramming that the IDE uses to auto-magically autocomplete and highlight issues in regular project code.
While I'm an C++ refugee, most of the "clever" TS stuff I write is due to JS framework idioms creating duplicate work(redux-reducer typings...) or forcing 'any' escape doors to the degree TS use doesn't help. Doesn't mean I'm "above" using any escape hatches where appropriate though or keeping things "dumb" (most of my TS code is fairly monomorphic).
After coding it with it daily for the past year I can think of very few times I've had to write "clever" TypeScript. And half of those are now solved with TypeScript's new `satisfies` operator :PThe only consistently annoying thing about it is how dumb it plays with JavaScript's built in array methods but it still is sufficiently smart 80% of the time (and the other 15% a simple `as const` does the trick)
On the contrary, many of the new TS features over the last year or more have been around making type inference smarter and allowing for less explicit typing
Yep! Or making type checking safer (this list is enormous), or better aligning TS specifics with how JS is actually used (upcoming 5.0 getting import specifiers more or less right as a great example).
Developers love hating on JavaScript, on change, and on "complexification." This is all of the above.The first comment I read after yours is literally"I hate how much programming languages change"
Agreed. My main complaint is that some of these changes don‚Äôt filter down fast enough for my liking, because I‚Äôve bumped into the issues they fix, often enough.That, and for various reasons, it‚Äôs easy to use "import" everywhere in browser-side code, but painful to use "import" in Node. That‚Äôs a major selling point for ESBuild in my mind‚ÄîI can avoid dealing with Node as much.
Yeah, the language changes seem pretty minor and incremental. I think the more interesting changes in the last few years have been with engines. All major browsers now support ESM modules and custom elements.
The big hurdle is a lot of new jargon that sounds more complicated than what it's doing.
hmm... I've been using JS/TS for almost as long as they've existed. A lot of these are nice. Some less so. Some quick thoughts:- Tagged template strings. This just feels dirty to me. Probably won't use, but when I see it in a code base I won't be so confused at least- matchAll. I've never needed this. I've used match with g a bunch, but I never need the capture group.- Promise.allSettled. THIS is useful. I've implemented this (under a different name) in almost every code base I've worked on, and got bit HARD by not understanding this behavior long ago (huge production outage that took hours and many engineers to discover)- globalThis. EW. Don't think I have to elaborate- replaceAll. It's always annoyed me needing to use RegEx for simple replace all. so Yay!- ??=, &&=, ||= These seem really useful, but also potentially hard to read, but I think if I get used to their existence they'd become second nature- # private... not sure why they didn't just use the "private" keyword, but I don't care. I almost always use TypeScript anyways- static ... YAY! finally. Again, if they could do this i don't see why not "private"For the TypeScript stuff I'll just say the type system has kinda jumped the shark, but I don't hate it. It's SO robust and of all the new stuff being added I'll maybe use 1/10 of it, but it's good to know I can describe literally anything* with it if needed.* EXCEPT IF I WANT TO USE AN ENUM/TYPE AS A KEY IN AN DICT WHICH I REALLY WANT TO DO!!
> - Tagged template strings. This just feels dirty to me. Probably won't use, but when I see it in a code base I won't be so confused at leastTagged template strings are an absolutelybrilliantfeature and have tons of valuable uses. In particular, many sql libraries in node let you do this:const query = sql`select foo from bar where zed = ${param}`;From a developer standpoint it "feels" just like you're doing string concatenation, but in reality the query variable will contain a prepared statement so that it safely prevents any kind of SQL injection, e.g. it gets parsed to{
        sql: "select foo from bar where zed = ?",
        parameters: [param]
    }There are lots of use cases where things are easily expressed as an interpolated string, but the thing you want back is NOT just a plain string, and tagged template literals are great for that. It's also a nice way to call a parser, e.g. many GraphQL libraries let you do:const parsedGraphQLSchema = gql`type Query { foo: Int }`;
Is it really an good thing that a vulnerable sql string interpolation code pattern and this sql tagged string look and feel the same?
Actually, yes, it is. The way these libraries work, since the thing that is parsed is NOT just a plain string, in most cases it'simpossibleto have sql injection without doing some deliberately nasty stuff. That is, you can't just do this:const query = `select foo from bar where zed = ${param}`; // forgot the sql tag
    await runQuery(query);In that case, the type of query is just string, but the `runQuery` method doesn't take strings, it takes a parsed query, so that wouldn't work.After using the tagged template literal pattern for SQL queries exclusively for the past couple years, I can't say enough how awesome it is to use in practice. Libraries even let you do strong typing with TypeScript to define the expected structure of the result, e.g.sql<MyExpectedReturnType>`select foo from bar where zed = ${param}`
> Libraries even let you do strong typing with TypeScript to define the expected structure of the result.The tagged template does not return a string in this case?
No, it usually returns a parsed object. For example the gql tag in the apollo client libraries return a completely parsed query with all its various children and sub-objects.
I was thinking the same thing... If I do that I'm going to forget the "sql" part at least once and nothing's going to alert me about it.
The way libraries work it's impossible to forget the "sql" part and still have that query be executed - see my sibling comment.
Why wouldn‚Äôt it be? Do you think developers get inspired by this slick API and decide to write functions that talk directly to the database using unescaped interpolated strings? I doubt it.
I fear that syntactic sugar creates as many problems as it solves.
For instance, one might wish to sort the results by whitelisted column:query = sql`select foo from bar where zed = ${p} order by ${col} asc`;Unless the lib implements a real SQL parser for the right dialect, it will quote each expression in the same way, and will either fail or produce a broken SQL.
Definitely a lot of misconceptions around how this would work. Just check out something like slonik,https://github.com/gajus/slonik, which is an excellent implementation.The example you gave actually isn't valid, because what you're doing is generating SQL dynamically, and that doesn't work the way prepared statements work. That is, you can't have a prepared statement like "select foo from bar where zed = ? order by ? asc", because with prepared statements the question marks can only substitute for VALUES, not schema names. So if you wanted to do something like that it slonik, it would fail. With slonik you CAN do dynamic SQL, that is guaranteed to be safe and checked at compile time with TypeScript, because you can nest SQL tagged templates. That is you can do this:const colToSortBy = useFoo ? sql`foo` : sql`bar`;
    const query = sql`select col from mytable order by ${colToSortBy}`;In that case slonik will know how to safely "merge" the parent and child parsed SQL.
We actually did the same for ArangoDB (I think we first did this in 2015, I remember being surprised nobody had done something similar for SQL at the time). Here's the JS driver's current implementation of it:https://github.com/arangodb/arangojs/blob/main/src/aql.ts#L1...Basically the `aql` template tag returns an object that can also be fed back into it and we also deduplicate arguments to avoid sending redundant data over the wire. There's also an escape hatch via a helper function (`aql.literal`) in cases where you need to insert literals that aren't known at compile time (e.g. you load query filters from a configuration file).
> - # private... not sure why they didn't just use the "private" keyword, but I don't care. I almost always use TypeScript anywaysOne of the reasons was to allow private and public fields of the same name, so that subclasses are free to add own public fields without accidentally discovering private fields of superclasses. There were many more considerations that went into the design:https://github.com/tc39/proposal-class-fields/blob/main/PRIV....There was a heated debate about this and the choice of the # sigil back in 2015 at the time private fields were being designed:https://github.com/tc39/proposal-private-fields/issues/14.
>* EXCEPT IF I WANT TO USE AN ENUM/TYPE AS A KEY IN AN DICT WHICH I REALLY WANT TO DO!!It's better just to use an actual array for enums:myEnum = ["E1", "E2"...] as consttype  myEnum = typeof myEnum[number]That gets you both an enum type and an enum array you can use at runtime
I've used globalThis for polyfills in code that needs to run both in the browser and on node.
WRT Enum as key in object:enum TestEnum {
    Fizz = 0,
    Buzz,
    Bar,
    Baz
  }

  type EnumKeyedObject = Record<TestEnum, string>;

  type EnumKeyedObjectAlt = { [P in TestEnum]: string };
That's still awkward and confusing for what would be one of the most common use-cases, if it were less awkward.
How would you simplify the syntax here?
I'd like to be able to just do...type UserType = 'default' | 'admin' | 'manager';

    interface UserTypeCounts {
        [key: UserType]: number
    }Not the best example, but it gets the point across. When you do this it says the key must be a string type which it actually is. It's just a string limited to specific values.Yes, I could do an interface with explicitly named keys instead, but if that type (or enum) could have dozens of possible values it's annoying to duplicate it.
Isn't Record<EnumType, whatever> working?Then instantiate like:```
{
  [EnumType.First]: ...,
  [EnumType.Second]: ...
}
```
Yep, do this all the time. It's also really nice because when you define a type asRecord<EnumType, any>then when you are creating an instance of that Record object, it requires a key forallthe EnumType values, and will fail if you forgot one. Still possible to doPartial<Record<EnumType, any>>if you want the keys to be only of the EnumType, but don't require all the EnumType values to be used as a key in the Record.
> - Tagged template strings. This just feels dirty to me. Probably won't use, but when I see it in a code base I won't be so confused at leastWhat's funny is the go-to example of using it for translations is just wrong:  It only does numeric indexing, so can't be reliably used with languages where words would be in a different order.  You still need a library or something that builds on top of it to handle that.
Realistically changing word order isn't enough for translation either, you need a special language like ICU message syntax so you can handle grammatical number, gender, etc.
Regarding your last point, I think the general consensus in TypeScript is to avoid using enums entirely.
What about union string types?I'd really like to be able to just do...type UserType = 'default' | 'admin' | 'manager';

    interface UserTypeCounts {
        [key: UserType]: number
    }
"when I see it in a code base I won't be so confused at least"When I first started using node way back when I discovered all kinds of idioms in use that I had never seen. It was a confusing few weeks for sure.
"??=, &&=, ||=" Yes they are, i stuck always when i see them.
I think we just need more practice and need to see them more often until it becomes normal. Currently i avoid to use them.
No, Promise.allSettled didn't exist yet. It was Promise.all.Someone basically made the assumption that await Promise.all would wait until ALL promises finished. Which is true..... unless one of them throws. In which case it continues. This caused a race condition. It was an extremely complex code base with 100s of engineers and the error very rarely happened, and when it did happen the app would get stuck on a loading screen forever. Also, it turns out "rarely" happens to a lot of people when you have millions of users.
I'm guessing the more common error, which I've definitely hit years ago, is not knowing that Promise.all returns immediately if any of the included promises reject.
Correct. It was millions of lines of code in a huge code base at a giant enterprise company with 100s of engineers. Somewhere buried in there there was a Promise.all that someone assumed would finish ALL of the promises, and didn't account for the fact that it bails on the first error.
That's what I'm guessing, too.
"The only programming languages that people don't hate on are the ones nobody uses." - someone onlineNegative indexes might actually be useful.At some point I actually need to read the actual language specs, I guess.
For reference, here's the current spec...all 833(!) pages of it.https://www.ecma-international.org/publications-and-standard...
tbf that statement is only usefull if you have a choice, but is there really a choice for typescript/javascript? you can't have rich apps without it. and wasm isn't there yet.
C++: an octopus made by nailing extra legs onto a dog. ‚Äî Steve TaylorBut more seriously, languages that are less formally made and have grown organically all deal with these types of things. PHP is a great example of a language with a TERRIBLE core library filled with numerous "don't use this" and "yes this doesn't make sense" and esoteric foot guns.Of course, these languages are the ones that took off and people use everywhere. And languages like PHP have made great strides to the point that using PHP8 with a modern set of libraries is not so bad.
Yes, but Go is also popular and famously resists doing that as much as possible. Maybe language popularity isn't a good metric, since there could be other reasons a language becomes popular. Worse is better, and what not.
‚ÄúHaha, C++ bad meme.‚Äù
Object.hasOwn(obj, name): Finally! That took long. Why would you even think that obj.hasOwnProperty(name) would be ok? If its unclear what properties there are you can't expect that the hasOwnProperty property to be working correctly. Always had to do the Object.prototype.hasOwnProperty.call(obj, name) dance.
We need an equivalent "All AI breakthroughs in the last week explained"
Two Minute Papers is a relatively good proxy for this!https://www.youtube.com/channel/UCbfYPyITQ-7l4upoX8nvctg
too bad i simply can‚Äôt stand the way he talks :(
am i the only one?
Something grating going on with him.  I think it might be the way he tries to make it sound exciting for a general audience.
>I think it might be the way he tries to make it sound exciting for a general audience.Looking at other videos of K√°roly Zsolnai-Feh√©r speaking at a podium to an audience, I think he's genuinely enthusiastic about the subject instead of putting on an act.  However, when combining that unusual enthusiasm with a Hungarian accent, some listeners may find it odd sounding.Example vid:https://www.youtube.com/watch?v=-JdmOBA0WQ0&t=1m49s
Probably not, I dislike video / audio as a means to explain and update things, I'll watch the news (because the video adds to the story) but I'd rather have a text version if it's about software things.
"Two Minute Papers"......ironically in video format.
That's not ironic to me, the intent seemed to be "papers presented in two minutes", although maybe there's some irony in exceeding that length in every video?
Sure.
What is the irony?
a paper in video format?I actually hate videos, it's easier for me to read than to listen to someone taking 5 minutes to explain a paragraph's worth of stuff."It's longer because monetization."
How is that ironic? I wonder if people actually know the meaning of irony these days.
It discusses papers in two minutes, not sure how that's ironic at all, unless you are deliberately expecting that a YouTube channel somehow has written papers rather than videos. These papers would also take one longer than two minutes to read and might not have context from someone in the field, so I'm happy for the expert to go over it for me.
Two minute papers-- but they are videos.I feel like I am repeating myself.Definition of irony...
Just because two things sound odd doesn't mean there is anything ironic about it. I could also name my YouTube channel something like Full Orchestral Performances but have them be videos and not music. That's not the definition of irony, but I don't think me explaining it further will make you understand what irony is.
This is a false analogy though. If you had a YouTube channel called Two Minute Full Orchestral Performances I would expect Full Orchestral Performances of two minutes, basically a musical performance.Since we consume either articles (which are often rated as "This will take you 3 minutes to read") or video, the title is deceiving. Particularly as someone who finds consuming information infuriatingly slow in videos, and prefer to read or scan articles, I find it has a sense of irony to it.
Right I agree with this. I hate videos too, it's the worst way to compress information.
My friend runs a newsletter called Bot Eat Brain which is precisely this.https://www.boteatbrain.com/
@eluna.ai posts summaries on ig
I took the time to explain all the latest (and some older) JavaScript and TypeScript changes, including code examples.
Symbols are not an ES2022 feature. I believe they were introduced in ES2015.
Just looked it up, you are of course correct. I will move them into the "Past" part.
Looked up on MDN (and from there the ES spec), import assertions don't seem to actually be standard. You might want to mark that somehow (or drop it).
You are correct, I added a note.
Thanks for doing this! I found this post very helpful to get exposed to recent changes from the last couple years.
As a swe that works with typescript / javascript, I find this post exhausting.Am I the only one? Am I a shit swe?Edit - comments seem to suggest I was asking this question seriously. I was not, I was just (sort of) joking.That being said, front end engineering is rapidly changing all the time, so the confidence I have in knowing I will always have work to do (read that to mean: a job) is satisfying.
It‚Äôs exhausting because: _____If you find yourself struggling to articulate it, seriously and honestly consider whether you‚Äôre simply choosing to be stressed about it.I‚Äôm speaking from experience here.
I don't find it exhausting. There's some stuff I already use, some I'll remember, some I'll forget, and one day I'll probably google for one of these features, but until then it's not going to weigh on me.
Yeah I'm the same. I try not to worry and learn everything, but I try and at least read on new changes just so I'm familiar with them.Then when I see it in the code, I'll know what it does or I'll be like "Oh wait, that new feature I read about, maybe that could be of use here".I'm never going to remember everything and I'm okay with that :)
I don't think it's that bad but I wish they'd focus more on improving the terrible JS web API rather than adding language features.I mean they are adding features like static initialisation blocks when we only just got String.replaceAll(), and they somehow managed to fuck that API up despite it being explicitly a replacement for an existing bad API!Where are all the containers? Sorted sets/maps? Why can't I even map an iterator?
> focus more on improving the terrible JS web APIThat's W3C‚Äôs job, not ECMA‚Äôs.> Where are all the containers??> Sorted sets/maps?Sets and Mapsaresorted (by insertion order)>  Why can't I even map an iterator?It's coming, but someone will likely beexhaustedby that addition.https://github.com/tc39/proposal-iterator-helpers
By sorted sets/maps, I think they are referring to a binary-search-tree-backed implementation that is efficient for operations like find all keys between x and y, e.g. something like Java's SortedSet[1].[1]https://docs.oracle.com/javase/7/docs/api/java/util/SortedSe...
> Sets and Maps are sorted (by insertion order)That's not what a "sorted set" is. C++ and Rust provide sets (and maps) that sort based on an arbitrary comparison operator.> ??> but someone will likely be exhausted by that additionI suppose. I guess it's one of those things that they really should have got right the first time. Like String.replaceAll(). I guess they will never add String.replaceAllSafe() - well just have to rely on linters to tell us that the API is terrible forever.
I think one can both learn about the new features without feeling the need to use them all or refactor old code.My biggest learning while writing this was just how much is possible in JavaScript and TypeScript now, but I also realize that a lot of this I will not use myself or only use to understand some really specific code.
It's understandable of you haven't touched JS for a few years. But if you work with JS/TS a lot and are not aware of/already using many of the features listed here, you need to ask yourself (or maybe your company) if that's ok. A lot of these are very nice features that are used daily -- they help code to be cleaner and more concise, and you can work more productively.
Not to mention -- most of these features have been in other languages for years. So in this case, JS/TS have been behind and are just catching up to what you'd find everywhere else.
You're certainly not the only shit SWE if you are one. I used to be a good all-rounder, but I've stagnated badly for years everywhere but the database. I should probably have shuffled to management (I understand more than I can do!) but Ihatethe very idea.
> #private: [‚Ä¶] This is not recommended for TypeScript projects, instead just use the existing private keyword.Why not?
I was told the opposite: now that the feature is in JS natively, it can be used.
The Deno style guide encourages the use of `#prop` over `private prop` [0].
Other guides such as the Google TypeScript Guide discourages their use [1] for now because they are transpiled to slow code.What I could conclude is: use `#` over `private` for runtimes that support them or projects that can target recent runtimes and browsers.[0]https://deno.land/manual@v1.29.3/references/contributing/sty...[1]https://google.github.io/styleguide/tsguide.html#private-fie...
Probably so that tsc can transpile it differently for older browsers.
Not to be the perpetual Luddite, but I hate how much programming languages change. I don‚Äôt particularly like go as a language (good board game though), but the minimal changes over time starts to feel really correct.
I don't think the issue is that languages change per se - it's that they borrow features from other languages, that people ask "can we have $feature from $language please?"in JS (and years before that, PHP), one example was object-oriented programming / classes, except in both JS and PHP it was never implemented fully, with JS not even having access modifiers for a long time. JS didn't need classes and the implementation is lacking, but someone decided it should be added.Likewise, Java had functional programming bolted on; they never extended the base List types with functional modifiers, so now you have to transform or wrap your List in a Stream to make it work with Java's attempts at functional programming. Personally, I think if you want to do FP or FP-style coding on the JVM, you should rewrite things in Scala. You can write Scala and Java side-by-side.Same with JS, you want JS but with types? You can have Typescript. I wish they did the same with JS-with-classes, just write a new language that compiles to JS instead of bolt classes onto the JS standard.
My second love was LISP. I love me some functional programming.But I greatly dislike multi-paradigm programming languages. Mostly because I've worked with other programmers.Borrowing features (idioms) from other languages is great. Pattern matching is nice. For Java, I'm looking forward to (interpolated) string templates and implicit classes. Destructuring would be nice too.--But for the love of Larry, where are intrinsic regex expressions?Path expressions?Most of our work is data processing.Input -> munging -> output.Meaning cutting and pasting strings.So I mostly want new features related to string and data processing.--The evergreen fetish (kink) with arcana like type systems, monads, and metaprogramming is just so besides the point. That's what Lambda the Ultimate and HN are for.For "commercial" languages, just give me tools for work.Fussing with novel languages is for my hobby projects.
What does "intrinsic regex" mean?
Sorry. I should have written "regex intrinsics". Meaning native to the language, vs implemented as a library. Just like Perl's syntax for regex.
So like the /^regex(.*)syntax$/g that we have in vanilla JS?(I agree with your overall point BTW.)
Yup.I just checked; the MDN docs refer to them as "regular expressionliterals".
> I wish they did the same with JS-with-classes, just write a new language that compiles to JS instead of bolt classes onto the JS standard.I think the classes were a good thing. Better would have been to change the OO model entirely, but if you're going to have one and can't change it, nice to at least have some sugar to make it usable. IDK if it's better elsewhere, but prototypal OO was pretty clearly a miss-step for Javascript, and sugar to make the OO system usable and less-obtuse (while making it easier to ignore the parts that should basically never be used, which parts amount toallthe distinctive things about prototypal OO) is a decent move.
> Same with JS, you want JS but with types? You can have Typescript. I wish they did the same with JS-with-classes, just write a new language that compiles to JS instead of bolt classes onto the JS standard.Wow, relevant username for this take, as you'd end up with an eldritch creature as soon as people tried to bolt these DSLs together intotheiropinionated bags of features, and a meta-language landscape that resembles the already fragmented frontend landscape of today
> I wish they did the same with JS-with-classes, just write a new language that compiles to JS instead of bolt classes onto the JS standard.Jeremy triedhttps://arcturo.github.io/library/coffeescript/03_classes.ht...
To be fair, now that almost all professionally-written passes through a rewriting compiler, Javascript actually has evolved to a ecosystem that _can_ handle rapid (non-breaking) changes to a language spec.I'd also argue that the majority of these changes are to the standard library (new methods on String, Array, RegExp, etc). Not really core language changes. I don't know how often the go libs update but surely faster than the language spec?
They're likely referring to Babel and TypeScript. In short, it doesn't matter what you're writing as long as your transpiler has the right `target` so it works in older browsers/engines too.
There are popular JavaScript tools that nearly everyone uses, that reimplement Lisp poorly by source-to-source compiling stuff written against the latest new hotness spec into something that can be run by some old-and-busted JavaScript runtime (e.g., in browsers).In fact this is how TypeScript is implemented.
A pass to strip some type annotations isn't a poor reimplementation of Lisp, jeez.I know the quote you're referring to but you're stretching a mile to get there.
To add the above - I also meant to write "Professionally-written Javascript" in case it was the grammar that threw you off. Sorry!
Thanks. :) Wasn‚Äôt able to fill in the dropped word.
The changes aren't breaking.   Javascript from the 90's still works.
I'm more annoyed that the direction of change is mostly converging. Maybe that's a good thing, but it seems every language needs to add every popular feature of other languages until it's possible to code any language as any other language except in incompatible syntax.In the case of TypeScript, we have the base JavaScript, template literals, and the type system all playing this game in the same file. Three systems trying to out feature each other. Tagged template literals, template literal types, etc.
Template literal types (a) have nothing to do with tagged template literals, and (b) are a game-changing feature, allowing you to write compile-time string parsers.
> allowing you to write compile-time string parsersI‚Äôm not entirely sure this is a good thing. But it‚Äôs certainly convenient in some instances.
It‚Äôs a cutesy thing thatbasically alwayscomes with a ‚Äúdon‚Äôt actually do/use this!‚Äù disclaimer. The thing that‚Äôs actually good about template literal types is that they allow for modeling a whole class of real world JS that wasn‚Äôt possible otherwise. That is and always has been the fundamental goal of TS.
I, for one, love that my ORM can statically check my SQL statements.
Go helped me realize that how much you like a language can partially be a function of how you try to use it.I used Go wrong for years. Once I stopped doing dumb stuff with it (especially with the type system), it got a lot more pleasant. I don‚Äôt think I‚Äôd design it the same way, but I‚Äôm quite a bit happier using it now.It‚Äôs kind of like using a hammer to drive a screw. The problem isn‚Äôt the screw or the hammer. Go seems to be a hammer-screw situation for a lot of people, but there really is a happy path.Not saying this because I think you‚Äôre unaware ‚Äî mostly thinking out loud because I used to feel like Go needed new features and your comment reminded me of this. I also like the relative stability of Go now, though. It has a great foundational toolset and good design overall, so to its credit, it hasn‚Äôt really needed to change so much. I only thought it did because I used it wrong.
If it's any consolation, the guy from nomadlist is building AI businesses with jQuery and PHP:https://twitter.com/levelsio/status/1633422349012992007
How does it work, though?
C doesn't seem to have substantially changed in 20+ years.
The C99 changes were pretty radical, but couldn't be broadly used until around 2016 when the Microsoft compiler finally caught up and started to implement the most important C99 features.
C11 provides a lot of useful goodies too. I don't relish the idea of writing C89 and giving up all the improvements.
C23 adds support for type inference.
It has.
There is another list with concise code sampleshttps://www.javascripttutorial.net/es-next/
For me, the most awesome and useful change to Javascript has been the addition of private and static modifiers, although the implementation is kinda weird (why use ‚Äústatic‚Äù keyword but not ‚Äúprivate‚Äù and the # sigil instead?). I use both TS and JS professionally but much prefer native JS and use it in my personal projects, however, the closer native JS can get to TS, the better, as I really do appreciate many of it‚Äôs features.
The # sigil has always bummed me out too.Supposedly it's because of this:> Why isn't access this.x?> Having a private field named x must not prevent there from being a public field named x, so accessing a private field can't just be a normal lookup.https://github.com/tc39/proposal-class-fields/blob/main/PRIV...Combined with this:> Why aren't declarations private x?> This sort of declaration is what other languages use (notably Java), and implies that access would be done with this.x. Assuming that isn't the case (see above), in JavaScript this would silently create or access a public field, rather than throwing an error. This is a major potential source of bugs or invisibly making public fields which were intended to be private.https://github.com/tc39/proposal-class-fields/blob/main/PRIV...But I still think it's weird.
Because they awkwardly bolted C++-like class syntax on top of prototype-based language and are now fighting that.Same goes for methods that you have to manually bind to `this` in the constructor etc.It literally is one of the "they didn't think if they should" parts of the language.
This is why I appreciate TypeScript, as it fixes a lot of Javascript‚Äôs syntactic goofiness, but of course I can‚Äôt use it natively, which takes it off the table for some projects.
The # for private throws me every time I look at my code.  Keyword "private" would have been so much cleaner and in line with most programming languages out there.
"
Negative indexing (.at(-1)): When indexing an array or a string, at can be used to 
index from the end. It‚Äôs equivalent to arr[arr.length - 1)
"
sic arr[arr.length-1)This is wrong. Array.at can get, but not set the value. So they're not equivalent.console.log( arr[arr.length-1] ); // worksarr[arr.length-1] = 1; // worksconsole.log( arr.at(-1) ); // worksarr.at(-1) = 1; // ReferenceError: Invalid left-hand side in assignment
Thanks, I edited it to include this, just to make it clear.
Is it me or are Tagged templates a recipe for hard to read code?Just the way it extracts the substrings into arguments for unpredictable strings. It doesn't translate to readable code.I'd much rather use repetitive template strings. Unless I was doing some really fancy string manipulation. Or make my own functions with explicit arguments.
They've allowed "styled-components" to work though, which is pretty nice. I always thought of them as providing a way to parse DSLs directly in your code. For example, a fictional way to generate some config could look like this (using tagged templates):const thingies = ["a", "b"];
  const config = yaml`
    - foo
    - bar
    - baz
    - thingies: ${thingies.map(thing => yaml`- thing: ${thing}`)}
  `;
  // config = ["foo", "bar", "baz", { "thingies": [{"thing": "a"}, {"thing": "b"}] }]At a company I worked at people were generating YAML using Jinja templates, but tagged templates to me would be a better approach. Is it hard to read? It can be, but compared to the alternatives it's not too bad.
const thingies = ["a", "b"];
  const thingToYaml = thing => 
    yaml`- thing: ${thing}`
  const thingiesYaml =
    thingies.map(thingToYaml)

  const config = yaml`
    - foo
    - bar
    - baz
    - thingies: ${thingiesYaml}
  `;It doesn‚Äôt have to be hard to read
In this example, why use YAML at all?...const thingies = ["a", "b"];
    const config = [
      "foo",
      "bar",
      "baz",
      {
        thingies: thingies.map(thing => ({ thing })),
      },
    ]
    // config = ["foo", "bar", "baz", { "thingies": [{"thing": "a"}, {"thing": "b"}] }]
Right, it's not a great example since yaml is intentionally equivalent to JS objects.
Well, styled components also has a plain object syntax which I think a lot of people prefer me included.
To me, the single best example, is a function that turns a template into a parameterized query, and then makes an async database request...var result = await query`
      SELECT * FROM foo.bar where baz = ${baz}
    `;There are libraries that allow for construction of queries as well using template strings.  I don't know of too many instances beyond this where there's custom functions for tagged templates, vs just string building with parameters.
I agree this is pretty much the best example of this feature in action... which is why I don't think it should have been made a language feature.It's nifty, but not nearly better enough to justify its existence, IMO. Here's the alternative:var result = await query(
        'SELECT * FROM foo.bar where bar = :baz',
        {baz}
    );I get it... there's that extra level of indirection. But people are working hard, as we speak, to abuse the feature.
I'd rather have the language settle on one single templating syntax rather than every library and their son bake a half-assed one. "Oh, does query use the : syntax? The $ one? Does it take the template string first, or the arguments?" And with your example, `query` needs to figure out how to parse the string, extract the template slots, and pass the correct arguments into the correct slots. It's a recipe for disaster if every library needs to reimplement that.
Well, people could settle on a common templating syntax without making it a language feature. The fact that they haven't tells you it's not that important, relative to other concerns.It's not like "figure out how to parse the string, extract the template slots, and pass the correct arguments into the correct slots" is rocket science.And it's not like people are going to rewrite the numerous existing libraries for this kind of thing. The new tagged-template APIs are going transform their arguments and call the existing APIs.I guess it's nice that new Javascript-specific templating languages can have common escaping syntax. It's just hard to get excited about the 15th standard.
I like tagged template strings but nowadays most libraries use TS (or at least JSDocs) and any serious IDE will be able to quickly answer your question of what type of parameters a function is expecting
In this case - the thing I personally value in the template version is I don't have to name the parameters and specify them in a separate place.  It's especially useful in larger queries.var result = await query(
        'SELECT * FROM foo.bar where bar = :baz
          -- 100 more lines of where clauses, CTEs, etc.
        ',
        {baz} // where did I use this again?  I'd need to scroll up.
    );versusvar result = await query(
        sql'SELECT * FROM foo.bar where bar = ${baz}
          -- 100 more lines of where clauses, CTEs, etc.
        `);
Can confirm. This is the best use case I've come across. You can dynamically compose queries and not even think about argument positioning. No concern about injection. Better performance than named variables that are translated into positional.
I find them to be really useful for simple and targeted tasks. For example, simplur[1] for pluralizing strings and dedent[2] just for developer ergonomics.[1]https://www.npmjs.com/package/simplur[2]https://github.com/dmnd/dedent
Is there a difference betweendedent`something ${code}`anddedent(`something ${code}`)? Not sure to understand the advantage of tagged strings here...
The difference is on the tag side. "Tag functions" receive the string segments separately from the interpolated values, so like:function exampleTag(stringSegment, ...values) {
      console.log(stringSegment);
      console.log(values);
    }

    const myNumber = 123;
    
    exampleTag`foo ${myNumber} bar ${myNumber}`;

    // Prints:
    // ['foo', 'bar', '']
    // [123, 123]This gives the tag function a way to access the interpolated values themselves, before they get coerced to a String. You're correct, though, that it really doesn't make much of a difference for a dedent function.
It is actually important for a dedent function when the interpolands contain newlines. Consider this example:function fmt(q, a) {
      return dedent`\
        Question: ${q}
        Answer: ${a}
      `;
    }Since `dedent` is basically syntactic sugar for developer convenience, we want this function to be equivalent to this:function fmtDesugared(q, a) {
      return `Question: ${q}\nAnswer: ${a}\n`;
    }Now consider this input:console.log(fmt("a\nb", "c\nd"));
    // should print:
    Question: a
    b
    Answer: c
    dBut if `dedent` only got to see the string after interpolation‚Äîlike this‚Äîfunction fmtWrong(q, a) {
      return dedent(`\
        Question: ${q}
        Answer: ${a}
      `);
    }then theinputto `dedent` would beQuestion: a
    b
      Answer: c
    dand so `dedent` would not strip any indentation. That is, `dedent` is meant to identify the maximal common leading indentationin the templateas written by the developer, which should not depend on the values of the interpolands.A stale GitHub issue on the dmnd/dedent repo has a real-world example where this matters and led to a subtle bug:https://github.com/dmnd/dedent/issues/22
That is an absolutely fantastic point, and one I hadn‚Äôt considered. Thanks for the explanation, and also for teaching me the word ‚Äúinterpolands‚Äù. :)
Matching up the template strings with the values is a little wonky because there‚Äôs always one more string than value. But it‚Äôs pretty rare that you‚Äôd write lots of different tagging functions, usually you write a generic one to use with many different types of templates. Tucking away complexity into a function to make nice and easy-to-use templates is a reasonable trade off I think.
I love tagged templates and am so relieved to finally have something like Perl/Ruby/PHP's heredocs.We should be able to write multi-line strings without having to break our linter's tab rules or write some silly post processing function!
Not mentioned: importmap is supported in Firefox as of February. Also supported in Chrome and upcoming for Safari. Just in time as I finally started getting more into cutting edge JS with a personal project - job's been stuck on older JS for a long time and I haven't done personal projects in just as long.I've been running this project straight in the browser with no JS compiler. Are JS compilers going to be on the way out now?
Import map is an HTML feature and not in any JavaScript specification. JavaScript language does not care about how to find files.
Is there a complete list of proper modern JavaScript features and examples covering all and only the features and styles which are modern (not neccesarily this new, perhaps some are 4-year-old) and relevantant + those which have never been replaced by any newer so are sill relevant although old but excluding outdated features and styles?
straight legs jeans instead of bell-bottom jeans because less fabric required.
Hats have been replaced by caps, or just go without either, because we are mostly inside anyway.
We still use suits, but it's not required. Most people use jeans, because SWE's can't afford wool.Ohh, sorry, you mean JavaScript...
const is the new var because Java programmers don't understand function scope.
()=>{} is the new function declaration because many people want to go back to Perl like syntax.
class instead of prototype because Java programmers don't understand prototype.
TypeScript instead of JavaScript because Java programmers can't live without type annotations and editor autocomplete.
async/await instead of Promise because what we can't see (async code) can't hurt us.
import instead of require because JetBean intellicense could not autocomplete dynamic require/imports.
I don't know why this got downvoted but this is a great comment.
Can you make an example of features/styles that have been replaced? I'm not really sure what you mean by that.
The classic example is .then .catch callbacks vs async await, though .then is still occasionally useful.
As an example, the immediately invoked function expression (IIFE) has been superseded by ES 6 modules.
Others have provided great examples of what I meant.
I want this for TypeScript, but also for C#, and C++, who have all been modernizing quite quickly.
I‚Äôm not sure if this matches what you want, but I made a note of this site when I ran across it for a similar reason:https://javascript.info/
I haven't found one yet, but I'm sure there's one somewhere out there. I will try to keep updating this article so someday it will be what you're looking for.
If you asked me what the biggest areas were where JS needs work, it wouldn't be "syntax sugar for separating numeric literals", it would be stuff like "integers".At this point I'm almost afraid to ask, but if JS can evolve in major ways like this, why can't we address some of the basic shortcomings of the language?
Is BigInt not what you want?https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refe...
Ironically this is the only JavaScript change (except for top level await) I did not include, maybe I'll edit it and add it.
Those are 2 of the most significant (and eagerly awaited) new(er) features though (although I thought BigInt was more like 5-6 years old)edit: Edge and Safari only added support in 2020, so it has only been useable without polyfills for a few years
I added them now so the article is complete.
I develop with JavaScript professionally and I rarely think about floating point number/integers when building UI or Node.js code. The "number" type is good enough in 99% of use cases. If you really need integers, there are specialized uint arrays and BigInt that handle various use cases.
None of these changes are that major. They don't breaking existing code.Breaking existing code is a pretty major line to cross for anyone maintaining a language, library or tool. (Even though some people do it willy nilly....)
> String.prototype.replaceAll14-year old me hacking up my first JS on Freewebs.com is doing backflips right now....And 31-year old me is saying "What the fuck took them so long?"
There must be a mistake in the "Exact Optional Property Types" section?
Hey, if you think you found a mistake, please also tell me what it is so I can fix it.
The error message talks about having flags set wrong and doesn't complain about anything the code is doing.Also your code for "Tuple Optional Elements and Rest" is broken.  Pad is declared twice and it's returning the wrong thing.
Thanks, I fixed both of them.
I think you mean to have undefined after the equal sign, otherwise I don‚Äôt see how there could be an error
Yes, the error was also wrong, fixed it.
I'd also assign undefined to 'age' to show that it's not erroring
Good point, done.
Are * and default the same?
No. The former importsallthe exports, and the latter imports thedefaultexport only.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refe...https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refe...
`*` is the namespace object. `default` is a special named property on the namespace object.someModule.js:export default 'foo';
    export const bar = 'bar';namespaceImport.js:import * as SomeNamespace from './someModule.js';
    console.assert(SomeNamespace.default === 'foo');
    console.assert(SomeNamespace.bar === 'bar');defaultImport.js:import foo from './someModule.js';
    console.assert(foo === 'foo');namedImports.js:import { default as foo, bar } from './someModule.js';
    console.assert(foo === 'foo');
    console.assert(bar === 'bar');
Note that there's an error on the default export:- export default foo = 'foo';
    + export default 'foo';
thanks, fixed
A lot of 'x1' should be 'x2' in the examples
Can you clarify the question? In what sense are you asking if they're the same / not the same?In general, `import * from X` will pull every exported symbol of X into your current module at the top level (generally not recommended except for special cases like testing libraries; you shackle yourself to an assumption that the imported module won't ever add new symbols that might interact surprisingly with the importing module). `import * as Y from X` is slightly safer; it'll pull in all the exported symbols from X, but will wrap them in a Y namespace (so X's `foo` function is now `Y.foo`, etc.). `import {foo} from X` will just import the `foo` symbol from X and make it available in your module. Finally, `import foo from X` imports the single export in X that is tagged as default and names it `foo` in your module.(To my money, I don't like defaults very much. I much prefer `import {foo} from X` over `import foo from X` for clarity, even if `foo` is the only symbol X exports. It allows for future growth of X and avoids the unsightly `import foo, {bar} from X` that some modules end up growing in the future).
