Had the opportunity to use it for the couple months with Spring Boot and I don't think I can ever go back to Java.
It is so much for flexible and easy to do stuff with that it's going to feel painful when I have to pick up some Java work again
Almost all of the spring documentation for spring security is for java. How are you finding working with security in kotlin yourself, if at all?
I've been using Kotlin for 7+ years now.
It often competes with Java. Java got better lately. I'd still go for Kotlin, mostly due to some features not being available in java:
Nullability in the type system
Extension methods
reified , allowing reflection on generics
coroutines being more mature and integrated into existing frameworks than green threads
More compact syntax
More goodies coming from standard library
etc
Having said all that, Java is still better supported in most of major web frameworks. With Kotlin, you have to tweak things around until it fully or kind of works. With Kotlin you're supposed to use JetBrains products, whereas with Java it seems like you can use other IDEs as well.
Using Kotlin for RESTful APIs worked quite well for me. I was using it with Quarkus, Vert.x and Spring Boot frameworks.
With Quarkus, for instance, live reload mode wasn't really working for some reason, so mostly I had to restart my server after I change something, whereas in Java this works fine without a restart.
With all pros and cons, I'd still always go for Kotlin at the time of writing this.
Thank you for your instructive answer !
H i am an Android dev, i use Kotlin, and it's a nice language to work with. Kotlin is mostly used for Android, but you can also develop spring boot apps using kotlin, if you want something else you can use Ktor, this was for backend dev, if you want to do front there is compose multiplatform (mobile desktop and web).
I have seen it used quite a bit for APIs in different products and it does it well
My daily languages are TypeScript/C#, so I'm not part of the community Kotlin is aimed for.
However, having tried both Java and Kotlin, the experience of using Kotlin was miles better. I don't understand why Kotlin's adoption hasn't grown more, but then again, I think I'm underestimating the aversion to change of the average enterprise Java developers.
Kotlin's a good language, but it seems stuck in an ecosystem that's too timid to give it a try.
Would you say Kotlin is gaining in popularity ? Does it scale well for large project
Yes, and don’t know about the second quite yet. I’ve heard from some friends @ AWS that it’s been gaining popularity internally, though.
Haven't learned yet.
Please followrediquette(TL;DR: be excellent to each other). If someone has posted in the wrong sub, direct them to a better sub (e.g.r/AndroidDev). If someone is spamming, report them. In either case, please remain polite and constructive at all times to ensure this remains a friendly and welcoming community.
Don't shill your product. Don't post job listings. Don't repeatedly post links to your blog.
If you find yourself posting something for self-promotion, rather than for the benefit of the community, please think again as this is neither welcome here, nor onReddit in general.
This is a Kotlin subreddit where we discuss development in/of the Kotlin programming language. Other topics should not be discussed here.
Even if your post involves Kotlin, please check the other subs in the sidebar to ensure that this is the best place for it. This is not the best place to discuss issues which are only incidentally related to Kotlin such as genericAndroid developmentquestions.
Please don't post memes, image macros or other low-effort content. We're here to discuss Kotlin the language; other subs are available if you just want to vent or let off steam.
Its still definetely a best choice for Android and decent choice for backend replacing Java.
If your main goal is android, then yes Kotlin + Jetpack Compose is pretty much the standard now. You could then try out Kotlin Multiplatform if you want to eventually target iOS
Yes it is worth it but don't forget to learn Java as well since most companies still have a lot of legacy code in Java.
Start-ups or new companies/new projects tend to adopt Kotlin even for the backend not only Android or Desktop UI. So it definitely makes a difference which company you will work at.
I don't disagree that companies still have legacy Java code. However as a consultant that has touched many different codebases in the last 3.5 years, I've exactly 1 client that had java code in their codebase. Anecdotal sure, but Kotlin is more ubiquitous than people think.
It’s amazing for backend
Use go come on
Flutter and React Native provide faster paths to cross-plattform apps than what Kotlin does, but they don't offer the same flexibility and native support on Android.
Kotlin is a good language to start with. Especially for beginners it has a few advantages over other popular languages.
compared to Javascript it is statically typed and void safe, which will prevent a lot of headaches at the start. An experienced Javascript developer might have an easy time debugging all the runtime failures but for a beginner the clear compiler errors of kotlin are a big advantage. (don't just take it from me, most teaching institutions start with a static language like Java or C#)
it is quite popular and versatile when looking for jobs. This is a big benefit over a niche language like Dart which is only used for Flutter
it is a modern language but at the same time most of the problems already have java answers that are easily applicable due to the compatibility.
One notable downside for beginners is the build system Gradle. It's not exactly beginner friendly, especially for multiplatform. Jetbrains is working on amper to help with that but it's still work in progress. I recommend you use the project wizards of Android studio or online and you should have minimal interaction with gradle for a while.
I recommend you start with an Android only app with jetpack compose. You can easily extend to multiplatform once you have gotten comfortable.
If what you care about is programming ability and knowledge it's probably the single best language. It will teach you many good habits, designs and patterns etc. It won't be the easiest language to learn though, expect to it to be hard but also expect commensurately good rewards for doing so.
If you just want a job, Typescript/Javascript.
If you just want to learn a programming language that will be as easy as possible then probably Python. Or if you are interested in the current AI/ML hype too.
If you want to learn something that is a bit hipster now but still great for making your own stuff and writing pretty code consider Ruby.
If you want to really push yourself learn Rust or Haskell (or both!).
If you want to work at a big company just learn Java.
If you want to build apps in the modern way definitely you should learn Kotlin because Jetpack Compose is using it.
Gradle
My most awful experience while using Kotlin was encountering Java Developers with no interest in new ideas.  I can't give you any technical pain points since I honestly can't think of any, your biggest frustration will be dealing with the old ways.
I'm currently working on a project where the legacy code is obviously made by a Java Developper and it's either full java style nullable everywhere with !! to make it work or they try to use kotlin features and it becomes a lambda hell where you have a single expression function that returns multiple nested ?.let(), ?.takeIf() and ?.also() with multiple ?: branches...
I'm working on a legacy project in kotlin but coded like it's java, the devs were using custom getters and setters everywhere for no valid reason.  Sometimes getting rid of optionals by forcing a non-optional '!!' on the getter lol.
Debugging errors from inline functions. Inline functions can report errors on lines outside of the file.
Debugging coroutine-heavy code. Stepping in/over is frustrating, as most of the times it doesn't do what you expect.
Gradle. That's a Gradle problem, but since Kotlin builds primarily work with Gradle and nowadays vice versa, Gradle is configured with Kotlin, basically the Kotlin experience inherits Gradle's problems. And they are many. Gradle is very dynamic by design. A pure Kotlin build system would be very strongly and statically typed and configured, while having all the syntactic sugar like lambdas, DSLs, etc. But after having worked with Gradle for nearly 8 years, this year I finally found a little bit that I was getting used to it, and getting what I and it needed to do. Maybe that's a sign that the Gradle ecosystem is finally getting better thanks to Kotlin.
Otherwise, Kotlin's coroutines have a bit of a learning curve. The theory is easy, but putting it in practice takes experience. Especially if coming from similar or completely different asynchronous and concurrent programming patterns, like async/await or RxJava/RxKotlin.
I came from the classic async-await so at the beginning I couldn't understand that witchcraft called the coroutines
Using Spring Boot when Kotlin support was still very new. I had a hard time figure out why some things just didn't work, especially annotations for caching or Spring Security annotations on suspend functions. They were just not supporting Kotlin yet. To this day I'm unsure whether or not the Cacheable annotation works on a suspend function.
Kotlin is a more expressive language, which is good and bad. Good because it lets you really do things the way you want, and bad because two Kotlin developers might be writing code that looks completely different from each other.
Null safety is a killer feature. That alone makes Kotlin worth considering. It's so good.
Also, Kotlin coroutines work with reactive-programming based Java libraries for impressive backend performance without the headache of reactive programming, which is honestly pretty awesome.
I don't feel like you really gain much by switching to Kotlin and writing in standard spring/hibernate/blah. That's just Java with .kt files, in my opinion, because the Java frameworks always return "maybe nullable" types and use threads and use annotations. You barely get to leverage kotlin's best features.
Java is just as good as Kotlin if you want to rely on the tried-and-true goliaths in the JVM tooling space. It's the new territory where Kotlin shines.
> Java is just as good as Kotlin if you want to rely on the tried-and-true goliaths in the JVM tooling space. It's the new territory where Kotlin shines.
I'm not sure I could go back to a statement based language. Having most things in kotlin be expressions is a huge and underrated feature (same as Scala).
I would respectfully offer a slightly different take on one point:Kotlin is actually super useful when using older Java based libraries like spring, hibernate, jdbc, etc.This is because you can extend java classes with Kotlin. Even if you don't own the source code of the Java library. The Kotlin feature that makes this possible is called extension methods (and extension properties).
What's nice about this is, you can gradually add small extension methods here and there for minor conveniences. And after a while they start to add up. Until JDBC, Hibernate and Spring are much easier to use.
For example, in JDBC, I can do this:
val resultSet = connection.executeQuery("select * from User where userName=? and pw=?","dford","somePassword")
val list:List<User> = resultSet.map{User(it.str("userName"), it.str("pw"),it.strOrNull("phone")}
If you have ever used JDBC, you will notice 4 extension methods not normally present in JDBC):
Connection.executeQueryResultSet.mapResultSet.strResultSet.strOrNull
Creating these were super simple, and I did it over time.
It really results in less code and (subjectively) more readable code.
Without even making an effort, JDBC, Hibernate and Spring are now much nicer and more concise.
Kotlin is fine, another solid JVM language. Honestly think it would have faded away if it wasn't propped up by Android use. A language can be as neat as it wants to be but library support is going to make it.
I think android support enabled kotlin to get off to a solid start but it's pretty popular in the backend in its own right now.
Wait but all JVM languages have the excellent Java libraries ecosystem support, so how can this be a reason for it to fade away?
I loved Kotlin when it first came out in the Java 7 era. With Java then stagnating around the time of Sun's demise, it was just what was needed. But with time, it's become not only less attractive, but encumbered with features that put it at odds with the Java platform. This is no accident. Of the several platforms Kotlin targets: Android, Java, JS, and LLVM, Kotlin only has significant use, and so some measure of influence, on one — Android. Moreover, those platforms have grown increasingly more different in their features from each other, leaving a language that wants to target all of them needing to compromise in some ways. Kotlin is at the mercy of the direction these platforms take, and is far too small (except on Android) to shape their direction.
As Java has opted to take a very different path than Kotlin on things like records and virtual threads, features such as data classes and async clash not only with the design of the platform itself, but with time, also the library ecosystem, leaving Kotlin with quite a bit of ill-fitting baggage.
So while some minority of programmers prefer more feature-rich languages, including controversial features such as extension methods, the only more universal "positive" feature Kotlin has compared to the Java language is nullability types, and, on the other hand, it's accumulating "negative" features that clash with the ecosystem, and this trend will only continue.
Not only will the intrinsic negative gradually outweigh the positive for more and more people — regardless of whether and when Java adopts nullability types or some other approach to null-handling — but the downside of being used by a relatively very small number of people in an ecosystem over which it has little if any influence, is quite significant. Of course, Android is a different story, and if Google doesn't push people toward Dart, Kotlin might well remain an important player there.
I love Kotlin, it feels more natural to write and 'solves' a lot of the annoyances Java has. But I also find Kotlin harder to read, which may be a bit ironic.
But I also find Kotlin harder to read, which may be a bit ironic.
this.. i hate Kotlin for this reason. It hurts
I enjoy programming in Kotlin a lot and like to use it when my programs are using a lot of math.
But I'm very hesitant to use it professionally. There are just too many different ways to do the same thing and Kotling has weird and sharp corners just like Java.
As Brian Goetz once said: It's like Java, but with incremental advantages and disadvantages.
The features you describe in a way is what I see the biggest downfall.The idea of Kotlin multiplatform itself is good, but I don't think Jetbrains as a company can sustain it. They're trying to do too much for their size and it shows. There are bits and pieces everywhere but they lack polish.There's a lot of "Kotlin way" libraries, frameworks and language constructs that are all 1/2 backed. They either have bugs, missing enough features that you can't use it in a full project or get abandoned. It lost focus moving to multiplatform. Perhaps it'd be better if they focused back on being a better Java. Not to mention the Kotlin compiler is as slow as a snail. This is being worked on in 2.0, but for now and for a long time it's been terrible.On the other hand Java has gotten stronger and caught up a lot. There's now less incentive for Java developers to migrate. The only big switch has been Google and Android. Whilst others have moved - those are all Java first frameworks with Kotlin "support". This arguable relies on the developer to somewhat know Java.For non-Java developers - Kotlin is as hard to get into as Java. You need Intellij (the Jetbrains IDE), to install the JVM and work out Gradle (in Kotlin it's recommended vs Maven). This enough can be a showstopper for some. There are a lot of layers and hurdles before you can even "Hello World". For the some crowd, there are those that are anti Java / JVM and hence won't adopt it.Likely a lot more pain points...I wanted to like Kotlin a lot more and do, but it's not all perfect.
These are good points. In my opinion, Kotlin is easy to get into for anyone with some programming experience (not necessarily Java) and it is very well documented.
The issue though is the tooling. Maven or Gradle is what's hard to get into, not Kotlin itself as a language. It sucks that there is such a barrier to just get things running. If there was a simple "rustup" or "cargo" like command that sets everything up imo. it would be more popular.
Kotlin does not produce machine executables. Kotlin produces JVM bytecode and JVM languages have not caught the attention of HN folks very frequently. Clojure comes up from time to time but I am sure that's because it is a Lisp which is discussed favorably by HN folks.Both Zig and Rust fill important gaps in the programming languages. If someone wants a better C, they look at Zig. Zig is simple like C. It has less concepts, good memory management story and protects the developer from shooting their foot.If someone wants a better C++, they look at Rust. Rust is complex but has strong memory safety guarantees.Both Zig and Rust are great alternatives for C and C++ both of which have been used extensively in the IT. What gap is Kotlin fulfilling? What is Kotlin doing so well that another language cannot do today?
> What gap is Kotlin fulfilling?Being a more fun-to-use Java? That's probably a big reason why it's done so well on the Android front AFAICT. But as you said, maybe JVM isn't that hot on HN> Kotlin does not produce machine executables.I haven't used KN before [0], but it does seem to do this. Overall, maybe Kotlin's "problem" is that it is tied to one ecosystem (native mobile development) which isn't as popular as web is.[0]https://kotlinlang.org/docs/native-overview.html
> Being a more fun-to-use Java?That's fine. What I meant earlier was that both Zig and Rust are filling a very important technical gap. Both Zig and Rust are solving memory safety issues in different ways. Java is already a memory safe language so the motivation to move from Java to Kotlin is not as strong as the motivation to move from C to Zig or C++ to Rust.
> Kotlin does not produce machine executables. Kotlin produces JVM bytecodeStrictly speaking - not true. JVM languages via GraalVM have been able to produce native executables for quite a while already. A lot of frameworks / libraries support this too.
You mean in comparison to Rust which is trending all the time? If we look back on comments for the last 30 days, Kotlin gets mentioneda lot,https://hn.algolia.com/?dateRange=pastMonth&page=0&prefix=tr...I think the issue is as you say, Kotlin is limited to a specific domain mostly. And I would also say that perhaps most people working with Kotlin are doing it for specific companies and aren’t as popular as Rust which is being used to port everything to it.
I feel like this is the only place I hear about Kotlin actually.
Except for the syntax which is a bit better imo, there's very little reason to use Kotlin over Java. Also it's very slow to compile, it's unnerving.
The future is very certain. Mainline Java has been cherry picking the best features from these languages after there's sufficient traction and the issues have already surfaced. Since the tooling has to support both Java and some other contender, Java always gets first-class support. Using any of the alternative JVM languages (except maybe Clojure) gives you better syntax, somewhat better abstractions for a few years, and worse tooling. And syntax is overrated. Java might be verbose, but it's well-understood, and it's notactuallywhat slows development.
Yep, all true.These days Java isn't slow to develop on at all. There are plenty of very good frameworks where you can get going with developing a web app or rest service in next to no time with far better tooling support, sophistication etc..NET is a serious contender though.Node isn't really on the same ballpark in terms of maturity.
>.NET is a serious contender though.It the other way around. Java has barely caught up with C#. C# team is typically introducing more features, faster.
I'm not sure language design should be a race to see who can add the most features, though.I prefer Java's more thoughtful approach to introducing new features.
in what way do you think it's more thoughtful than C#?
No OP, but for example you still see the C# folks still struggling to add discriminated unions to the language because of complex interactions due to its too many features[1]. Virtual threads are easier to use than async/await is another example.[1]https://github.com/dotnet/csharplang/issues/113
Performantimplementation of discriminated unions in .NET (unlike any that you would see in JVM) requires modification of both the type system and the runtime to account for non-boxing representation of struct unions as well as unions in which GC references alias value types/structs. This is highly non-trivial and the people who could be working on this are currently busy with other features namely Rust-like traits called explicit and implicit extensions. Don't forget that .NET is worked on by at least 10x smaller community and teams than JVM implementations and yet delivers much better YoY degree of improvement and much nicer user experience (Gradle lol).In addition, green threads approach is a strictly worse and a more limited solution that only solves thread blocking without unlocking the variety of terse concurrency patterns enabled by the way the tasks are handled in .NET. They also add significant overhead to interop with native code due to thread pinning/stack switching (also applies to Go).
Not to mention that Node isn't a language, and Deno is cleaner.
I was referring to Java as a platform rather than just as a language. .NET isn't a language either
Indeed, but I only wanted to include so much pedantry!
Kotlin has great tooling, and Java library compatibility, so why wouldn't you use it? When you work in Kotlin, you give the masses of Java programmers the ability to contribute and a licence to check their EnterpriseGradeFizzBuzzSolutionStrategyFactory mentality at the door. Do Java projects in industry even use the new stuff? Also, you can use virtual threads with coroutines.
>Do Java projects in industry even use the new stuff?Yes. Kotlin fans need to understand that Kotlin is not competing with the old Java ways and stop mentioning bloody enterprise as an argument against Java, because bloody enterprise is largely ignorant to Kotlin‘s cause. EnterpriseStrategyAdapter anti-pattern is not a language problem, it is a management problem. It won’t be solved neither by new features of Java nor by new features of Kotlin. The real competition is in the new code in startups and Java has one big advantage there: faster recruiting, more reliability in tooling, better quality of business code for the money. 
Kotlin is a good perk for developers in late stage startups, where the teams are big, delivery timelines more relaxed and you can afford fancy but less mature language or tool to consume resources instead of delivering more business value.
Your sibling commenter said (s)he just got off Java 8 in 2023. My experience was similar; that's why I asked.Also, it's hard to find Java programmers who haven't been tainted by that enterprise mentality, so in a way it makes hiring hard if you don't have the resources to filter the junk. When you see Clojure or Scala on a resume you know they're above that.
Well, my team is now on latest LTS (21) and we do use new features in our code. Hiring an engineer who can write modern code is not any more difficult than hiring without this requirement. It is generally a management problem, that any skilled senior manager should be able to solve. After all, enterprise anti-patterns are not uncurable poison, e.g. switching to record-style accessors is something people can do on their first day easily.
>Kotlin is a good perk for developers in late stage startups, where the teams are big, delivery timelines more relaxed and you can afford fancy but less mature language or tool to consume resources instead of delivering more business value.The proof being?
I have never seen Golang being used for business logic backends, its Java, Kotlin or .NET, and then nothing else for a long while. It is not expressive enough but shines in other areas, mainly infrastructure.Remember that "Systems Programming", which is what Golang was designed for, isn't necessarily just Kernel and device drivers, but everything that isn't "Application Programming", and that includes the whole K8S networking and container stuff where it is very successful.
Kotlin is weird inclusion in that list with Java and .NET unless you'd include Android.
Java is often faster than Rust on typical single-threaded code. Rust is faster when you want to leverage features like SIMD.And when it comes to concurrency Rust is the worst language I've ever used by far. The type checker makes dealing with objects between threads extremely painful. With the JVM it's all just handed for you.Rust is great when you want a tiny binary with minimal memory consumption.
I know a number of them, but that’s not really important. You didn’t mention Kotlin, right? :)
Often enough whatever stack was used at the seed stage, it is eventually either replaced or complemented by Java, meaning that new code is written either on latest LTS or even on evergreen version.
So you think Rust and Go are more frequently used than Java for new code? Do you have something to support you claim?Looking at TIOBE and PYPL, it comes that for backend Java and .NET are huge, followed by .Node.js, followed by Python and then PHP.
> new code in startups and Java has one big advantage there: faster recruiting, more reliability in tooling, better quality of business code for the money.You're delusional if you really think any of this is true. There are, proportionally to "enterprise", extremely few startups using java. For good reasons.
I have no idea what „good reasons“ are you talking about except fancy language as a compensation perk. Java is a good choice for startups, even if it is not the most popular choice (often for bad reasons). I have proven it several times by being able to ship working and scalable solutions quickly and hiring decent team with time to close open vacancy within 1 month.
We use Java 17 features on all our projects now, expecting to update the platform to 21 in a year or so. Allowed features vary by project, some reviewers don't like vars (though I do) because it makes it harder to understand the code for them.
>Kotlin has great tooling, and Java library compatibility, so why wouldn't you use it?As an average company what you want from a language is: your team already knows it or is fast to learn, it is arguably better in a measurable way (development is faster, codebase is easier to maintain), developers like it more, it has a large support and audience.How many of these does Kotlin check?
Kotlin is the Dvorak to Java's Qwerty. It looks better in theory, but not where it actually counts, and not enough to justify going against the grain.
All of them except first.
I'm allowed to use Streams but var isn't because it makes GitHub PRs difficult to parse.We got to upgrade from Java 8 to Java 17 in 2023.
I've worked in "enterprise" and have a different experience. The enterprise projects that I was working on switched to Java 8 in 2015. There were some legacy services that remained on 5 or 6 for a while, but they were mostly in "maintenance" mode and nobody wanted to spend time on them.I have over two decades of experience and there has always been room for trying out the "new" technologies and keeping up with the latest best practices, even in enterprise. I know that not everyone has this experience, but there are actually a lot that happens outside slow big American legacy companies...In my current startup we use the latest JVM and have a mix of Java and Kotlin. It works really well and we have never experienced any problems with development speed that was related to code or language syntax. JVM + Spring boot + Postgres may be the "boring" choice, but it has enabled us to focus on getting things done and focusing on the product. It didn't take long for juniors to be productive in our stack either. Spring itself looks a bit scary at first sight, but once you learned the basic philosophy you have less issues than a Node project in my experience.I know that my experience may not match your experience, so I recognize that I can't make a generic statement. It's just a bit frustrating to see similar statements made by people with bad experiences.- Not all Java development happens in enterprise. There is a thriving eco system of small to middle sized companies and startups using Java- Not all enterprises are the same. I've actually noticed a shift to the other extreme, where enterprise uses the latest technologies to attract new employees. Nobody who has a choice wants to work with factory patterns on an old version of Java- Old Java patterns like factories and extreme use of inheritance is out of fashion. There is of course a lag like in any trends, but remember that Java is so widely used so you will always find companies that are slow to adopt, or have legacy software that is in maintenance mode.
Luckily I don't have to deal with FactoryFactories either.I have to keep alternating between startup and enterprise so that I can keep sane but also get pension contributions, so I do know there is a great world out there. Just not always great paid (am in UK).
> Java might be verbose, but it's well-understood, and it's not actually what slows development.I think you're onto something. Maybe some Java-by-default workplaces lack technically interesting problems that engineers want to solve, so those engineers instead overfocus on the frictions of the parts they can control. Maybe those engineers desire expressiveness in their working programming language to compensate for the restrictions on the rest of their work.Just a hunch though.
I think you may have a point. At mature companies, they have largely solved the product market fit and uses a stable stack that just works. I have worked worked for such companies, and developers jumped at the chance to use the latest (untested) technologies for greenfield projects if they had the chance.In my startup we also use a "boring" stack, but the problems we solve are innovative and motivation in itself. The developers work closely with customers and can see the impact that the product has. They are no longer working in a Jira-factory and while they are still interested in technology they also find motivation in the product itself.
> syntax is overratedSpeak for yourself there good buddy. It's pretty important to me!But I do agree with your broader point. From one perspective, Kotlin has been a great success if we define its mission as a test-bed and laboratory for improving Java proper. Unfortunately, while it has arguably succeeded in that mission, in doing so it might unavoidably fail in another mission, which is to thrive as an independent language.I'd liken it to yarn and npm. Yarn was a huge success.. at forcing npm to massively improve and thus basically rendering itself irrelevant. A bittersweet success, but a success nonetheless..I wonder if there's a term for this kind of self-sacrificial project which makes the world better for having existed but doesn't survive the process..
This. I love the Kotlin language but Java had just caught up and the things that made Kotlin super exciting several years ago are less exciting now as Java advanced. Also I looked back at Kotlin recently and things have gotten way more complex than I remember around 1.0.Kotlin needed to succeed on the native front to live beyond Java. It didn't and that puts it in a perilous long-term spot.
The one major thing Kotlin still has going for it is null safety, and IMO it eclipses every other „nice“ feature. But Java will get this too, and then I‘m not sure I can justify using it.Oh and I wish Java would support „it“ in lambdas, very useful.
Java will not have the same level of null safety as Kotlin. Instead Types can be explicitly marked as "not null", so the default is still that every reference type can be null.
Yes unfortunately, but I mostly miss null safety in domain classes, not in the stdlib. It remains to be seen if this is "good enough" or not.
Will Java have null-safety?? Can you link to that, I haven't heard anything at all about this.
See "Use of null-restricted types" which is part of Project Valhalla[0], the proposed syntax is the opposite of Kotlin, where everything is non-null by default but can be made nullable by adding a "?", eg "val s: String? = null".The Java version instead looks like this, where you add an exclamation mark to mark it as non-nullable:class Cursor {
        private Point! position;
    }[0]https://bugs.openjdk.org/browse/JDK-8251554
Ok, but notice that's not about making Java null-safe in any sense. It's about making "value types" (which will be introduced by Project Valhalla) possibly non-null, mostly for optimization purposes (though it should also benefit programmers reason about value types if they can't be null).As mentioned in the relevant JEP[1]:"A null-restricted type is a reference type expressed with the name of a value class followed by the ! symbol."Goals: "Allow a value class to "opt in" to the automatic creation of an appropriate default value used to initialize fields and arrays that don't store null."Non-goals: "It is not a goal to support null-restricted types for identity classes or classes that do not provide a default value."So, I don't see how that's in any way going to threaten Kotlin's position as a null-safe language - Java will almost certainly always have "unsafe" `null`, removing it from Java seems simply impossible at this point (notice that Dart managed to do it, but it had a much, much smaller ecosystem than Java, and even then, it required multiple years of migration of every single Dart package in Pub - and the ones that were unmaintained were simply abandoned and no longer work with the latest versions of Dart which is fully null-safe).[1]https://openjdk.org/jeps/8316779
I actually missed that it was restricted to value classes, thanks for the correction, this is unfortunate. To be fair null-checking (or just documenting null-safety) the data classes is the main use case, as other cases of nullability (class collaborators, eg a repository injected into a service) are usually a bug and quickly fixed.The data that flows through the app at runtime is the big issue, and even just documenting null-safety at the API interfaces goes a long way in making refactorings safer and maintenance less of a pain. Those are usually records nowadays (DTOs, VOs, Entities).
Syntax may be overrated but expressiveness is not.
Clojure is such a joy to use. I get the maturity of the Java ecosystem and the immutability, functional style, and concision of a lisp. If performance really matters, and Clojure does perform well, you can always dive into stuff with all the Java tooling and interop is extremely easy. I really wish more people picked it up.
I feel no desire to use dynamic typing again, as nice as Clojure might otherwise be. While Kotlin is not strictly immutable, it is much better in this regard than Java. Collections are immutable by default in Kotlin (or more precisely you get an immutable view defined by the respective interface) and that is quite useful in practice.
Will they cherry pick Kotlin’s null safety…?
No, they will allow to mark types as explicitly not null (the other way around). The default in Java will still be that everything can be null.
What a low quality article. Language is more just a set of features. Anyone who tried both Java and Kotlin for reasonable amount of time will understand that. Regardless of how many features Java adopts from Kotlin or other modern language it will still remain shackled by billions of lines of legacy code and boilerplate consequently.The only one who might like the article is self-conscious Java developer who wants to feel good by bashing on competing language.Wish it wasn’t morning so I could elaborate on every point. Might reply later to this comment.
> Null was always a pitfall in Java. It has slightly improved with the controversial Optional type. It’s also why I suggest that everyone use only wrapper types everywhere, instead of primitives, unless they can prove with a JMH test that a primitive provides enough of a performance benefit.That doesn't make sense at all! Why should one do it without a need? To have NullPointerException with "primitive" types, too?> Kotlin ecosystem is severely lacking compared to Java. FAANG has first-class support and commitments to Java, like providing JDK with multi-year support commitments.It is not really needed to provide JDKs or something else especially for Kotlin, because Kotlin basically just uses the JVM (at least if you use the JVM as a target).> To this day, there are significantly fewer Kotlin developers than Java developers.Yes, that is probably true. Although almost every Android developer should know Kotlin these days and there are quite a few them. But even if a developer doesn't know Kotlin at all, it is relatively easy for a Java developer to learn it. In my experience it a takes a few days to a few weeks to be at least as productive as with Java (even not all Kotlin features are learnt in this time).> Lack of progress: Compared to Java lately (e.g., records two years ago, pattern matching, and VT release this year), Kotlin has been stagnating in delivering the big features that would bring us (Infobip) value over alternatives.Here, I agree. Some years ago I was super excited about Kotlin and couldn't wait for a new release. These days new releases are mostly boring. Maybe the most important stuff is simply done, but then there are enough interesting ideas to improve it (real pattern matching, meta programming, union types, ...). But JetBrains and Google decided that it is more important to improve the fundamental infrastructure first and decided to create a new, faster compiler (K2). As boring at it is feature-wise, I think it is a wise decision, because every project would benefit from it. The plan is to add new features, once the compiler is ready.
Maybe in the backend but for mobile (android) kotlin is still a thing and will be for a long time.
Scala isn’t dead. I’m job hunting right now, and seeing plenty of Scala jobs. Not as many as Node+TS+React, but what do you expect?
"Scala isn't dead" reminded me of this one "No no he's not dead, he's, he's restin'!":https://www.youtube.com/watch?v=vZw35VUBdzo
It also benefits from being one of the only full-stack languages.Scala.js has excellent front-end frameworks like Slinky React [1], Laminar [2] and Scala has industry-leading concurrency libraries like ZIO [3]. I've yet to find anything that comes close for end to end web apps.[1]https://slinky.dev[2]https://laminar.dev[3]https://zio.dev
If you subtract Spark/Flink-related ones not really. Plenty only in comparison with Kotlin backend roles (i.e. non-existent in the Bay Area). It's very disappointing to me personally but it is what it is.
>Scala isn’t dead.Scala isn't dead. It went to play between the stars with Pearl and Ruby.
in my opinion, modern java's language ergonimics are good but kotlin is still far better. i didn't write much plain java in long time since having to adopt kotlin.i love the integrated null safety / handling at a syntax level with the ? operator; optional felt clunky in comparison. lambdas plus everthing's an expression allows for concise, readable code. and i love the scope functions. i agree that extension methods may have turned out to be a footgun, but i feel like it hasn't been a huge issue in the field. it's doubtful java is able to integrate most of those ideas in a way that feels as natural.i don't understand why the author chose to ignore android, it's an elephant in this room. as long as android doesn't drop kotlin for something else as the lingua franca of the platform it's got certain guarantees.
Absolutely, while Kotlin is a first class citizen in Android, it isn't going away. Neither is Scala because there are plenty of developers who like bleeding-edge and experimental language features. Personally I don't use it anymore as really don't need things like implicit parameters, but props to each and every early adopter of language features that help Java evolve. Thanks to Kotlin and Scala, Java can now be very pleasant to code in.
While the author dislikes extension functions in kotlin they enable one feature that Java doesn't have: With them you can create domain specific languages within kotlin that are quite ergonomic.- Jetbrains has built a nice reactive js wrapper with them.
 - The gradle configuration is written in a kotlin dsl.They can be used to specify configuration and add meta information and thus replace Java annotations.That is my kotlin "killer" feature because I personally don't like annotations.Java's language design has always been "pedagogical" (or patronizing) to not give the developer to much power to create to much abstractions and complexity.
So it's not just its age but also this philosophy that has made Java a rather inelegant language ( compared with e.g. kotlin)
There are two problems Kotlin faces; Kotlin the project/product and Kotlin the language. While this article touches Kotlin as a Product, it’s very thin on the Language aspect.Here’s an old post discussing the real troubles Kotlin Lang might face due to the inevitable divergence of Java/JVM.https://np.reddit.com/r/java/comments/ndwz92/can_i_get_some_...
Make sure you read the reply a few comments down from the original post, it invalidates much of the op.
True, the old article had some nice rebuttals. I wonder how many of these predictions came out to be true so far.
My only issue with Kotlin is Kotlin's over reliance on JetBrain products and being so tightly tied to a company which priority it is to of course sell their IDE.
To be fair, one of course use the free community edition but still you kinda need a JetBrain product to ensure you getting the most out the language.
With language servers these days, that feels like it is going the opposite direction.
As I see, the only purpose of Kotlin is a be test bed for novel features to JVM based languages. And eventually Java is going to integrate those features better than Kotlin. And Kotlin's advantages are gone like that. To be honest, I have never seen Kotlin used in environments other than Android. The day Google decides to move Android development to another language will be the day Kotlin dies. Or becomes a zombie.
>And eventually Java is going to integrate those features better than KotlinKotlin has better syntax and is less verbose. That matters for a lot of developers. Kotlin deals with null in a better way. Kotlin has better types.
> I have never seen Kotlin used in environments other than AndroidI have seen several companies that use Kotlin as a backend language (often with Spring). I personally don't find the differences enough to bother switching from Java, but I also don't mind working with Kotlin in existing projects.
Does the "pattern matching" referred to here work like JavaScript's "destructuring?" It's the thing where you can call a function with an object, but the function's parameters extract one or more of the object's members directly without mentioning the object's class, so it'll take anything that has appropriately named members.
no, pattern matching is more like destructuring AS CONDITIONS (eg: if object has this structure) of switch blocks. While destructuring is simply sugar for assignment, pattern matching is more complex. I don't know about Java but in some languages you can customize the pattern so that it is not neccessarily in the actual shape of the object. In some languages applying pattern matching at the top level of the function is the equivalence of overloading.
Thanks! Intuitively this sounds like it enables what at one time would have been called bad programming (widespread reliance on RTTI), but on the other hand a lot of rules have turned out to be arbitrary.
I think they've partly implemented C# version of pattern matching.
To me, Kotlin is so similar to Java that it might just survive in the way that Elixir and Erlang coexist.
yes, even years ago before 1.0, Kotlin blended in with existing Java code pretty well, it's not that big a learning curve and adds a really nice std lib on top of Java. So I don't really relate to the framing that it competes with modern Java.
I'd love to see Java adopt Kotlin's more advanced type system:  Proper support of nullable/non-nullable types, better generics and no primitives.Not sure how they could get there but that would be amazing.Also Kotlin has a pretty good JavaScript and Native support story now.
I agree, I remember learning Ceylon few years ago in the metro while going at work, now it is probably one of the rarest programming language that we can say for sure it's dead (has been archived few years ago iirc).
"FAANG has first-class support and commitments to Java"Nobody told Apple that.
Apple has an incredible amount of Java running server side, and they maintain their own JVM/tooling.Support on Mac is admittedly not the best though.
one thing i definitely liked about kotlin was reduced verbosity. otherwise all the other points, you made me ponder a bit. let's see where kotlin goes.
The future is always a bit uncertain. But Kotlin's future actually looks pretty good to me. This article looks like the author is not really clued in to the massive amount of progress and change happening especially in the last year. There's nothing wrong with being a bit old an conservative and stuck in your Java ways. Been there done that and trying to be better than that now. But this article is just a bit overly dismissive and poorly argued.I'm biased of course having used Kotlin extensively for the last six years and having made the switch from Java. From my perspective It's simply a much better Java. And I have 25 years experience with that, mostly server side.And the way I'm using it, it's also a better Typescript for me. If you have trouble parsing that last bit, I'm using kotlin-js to develop frontend code. It's actually really nice for that even though not many people do this. Well worth a look if you are getting tired of dealing with Javascript's idiosyncrasies (which typescript inherits) and a bit jealous of what all the cool kids doing mobile applications are using. Which would be using fancy Kotlin and Swift UI frameworks mainly.Kotlin-js being nice to use should not be that surprising because of course a lot of Android developers use and love it and a lot of the libraries and practices port over very well to the web if you use kotlin-js. E.g. I use dependency injection (koin); which as it turns out is equally useful and nice to have in a browser as it is on Android and in Spring or other places.There are a few changes happening this year with Kotlin that are exciting for Kotlin users and interesting for people not yet using it:- Kotlin native is stabilizing. It now works well on IOs, Android, Linux, Windows, and MacOS. It's not "just another jvm language" anymore. The multiplatform library ecosystem is really starting to thrive. Lots of growth there. Especially in the last year. And I maintain a few myself.- The web assembly compiler is now available in an alpha version and browser support for garbage collection in WASM just rolled out in Firefox and Chrome a few months ago. This is required by Kotlin's wasm support as it does not bundle its own garbage collector. Safari should follow soon/eventually. This means you can now use kotlin-wasm in a browser without having to fiddle with feature flags in your browser. Multiplatform library support for this is still a bit a work in progress but most kotlin multi platform libraries should start having wasm targets in the next few months. Wasm works in servers and on servers, lambda functions, and edge networking. So, first class Kotlin support for wasm is a big deal and the whole kotlin multi platform library ecosystem is coming along.- Kotlin 2.0 is in Beta currently and should release in a few months (spring?). Kotlin native and wasm support and that are all happening at the same time and come on the tail end of a years long effort to re-engineer the compiler and IDE toolchain. Work on Kotlin 2.0 actually started about three or so years ago and it has included a gradual rewrite of the compiler through the 1.6-1.9 releases.- Building on all this is Compose multiplatform, which brings Google's Jetpack Compose to other platforms. That's currently stable for a few platforms, in alpha versions on others (like IOS and web). That's something that should stabilize towards the end of the year. We'll have a cross platform, natively compiling UI framework that is usable across web (wasm), IOS (native), Android (native) and the three Desktop platforms (jvm, for now). So, that could end up being a nice alternative to things like flutter and react-native. Or indeed to packaging up web applications as PWAs or using things like electron.It might not be everybody's cup of tea but that's a lot of progress that came together in the last year. I use other languages besides Kotlin. So, I can appreciate other languages as well. But Kotlin is just really nice.
Perhaps the most important piece of this:> ...the new Kotlin K2 compiler is used by default and it is Stable for all target platforms: JVM, Native, Wasm, and JS. The new compiler brings major performance improvements, speeds up new language feature development, unifies all platforms that Kotlin supports, and provides a better architecture for multiplatform projects.
I'm a big fan of Kotlin, but the developer experience in the IDE has been pretty rocky recently, various of their secondary libraries are semi-abandoned, and their ecosystem documentation is a mixed bag at best. My ideal for the next 12 months would be for them to focus solely on quality. There's incredible potential, but they're going to shoot themselves in the foot if they don't get on top of this soon.
Are you thinking of certain secondary libraries in particular?
Kotlin is great, but we are having a hard time finding solid devs due to the smaller ecosystem for it.If anyone is looking or just wants to find a place that truly cares about its customers and team, please give me a shot out.  We pay very competitively, share company profits and give everyone 3 weeks off over winter.  You wont have a 1/10000 chance of your options going to the moon, but you will love the team, the mission and you will never get called after 5.https://www.pocketprep.com/jobs/
You could try extending your candidate pool if you haven’t yet. Java devs are the fastest to onboard for Kotlin, also Scala, and vice versa. The stdlib APIs and the third-party libraries are the same, plus you get the Kotlin libraries. Lots of modern Java projects transition piecewise to Kotlin, so often hiring for Java turns out to be for Kotlin, in part or in whole.
That is a good call.  Having platform knowledge is definitely a plus, but core language skills are probably more important considering the minimal complexity of our system.
> Kotlin is great, but we are having a hard time finding solid devs due to the smaller ecosystem for it.Well, maybe you need to train them?
I would advocate for this. If your codebase is low in complexity then I think it would be wise to invest engineering time towards kotlin training. I've taken several courses on pluralsight and they get you up to speed quickly but informatively.Also if you place kotlin in high regards or believe it saves you time/money as opposed to java (as i do too) then why not train java devs on kotlin and introduce them to a low complexity app before high complexity sets in (potentially)
Perhaps its due to limiting the candidates to the US, you'd have a very large pool if you opened to worldwide.
Are you saying you don’t give equity, or are you saying that you don’t expect the equity you give to be valuable?
We don't give equity. The company is bootstrapped and the founders ran it completely until cash flow positive.  It is now a fantastic mission driven small business, not a startup, focused on post graduate certification exam prep.
I noticed [JetBrains] appears to have an UI framework which works on all 3 desktop OS and 2 mobile OS.Does anyone have hands-on experience?
Not hands on but I've been paying attention. IMHO several things world mentioning:- Compose desktop is for now dependent on the JVM. That is despite Kotlin now having a stable native compiler. Reason for this is that the library eco system is still lagging. That being said, you can build some nice things with it pretty quickly.- IOS support is not stable yet. It kind of works but you'd be an early adopter.- On web, there are two compose variants. Compose HTML is a bit of side show but uses a traditional DOM based approach. Compose web exists in wasm and js variants and renders its own components in a canvas either way. Compose web mainly makes sense for people wishing to target the web with their mobile Android/IOS code base.- Google just announced a recommended status for KMP on mobile at Google IO. So, this is significant in light of the recent layoff rounds affecting e.g. the Flutter and Dart teams.If you feel adventurous it's worth checking out now but you probably have to wait something like a year plus for this to stabilize on IOS. I'm personally curious to see how the whole wasm/web part evolves. The wasm compiler is currently alpha. My prediction is that  compose multi-platform will stabilize over 2025 and will start going mainstream the year after. At that point it could become a serious alternative to flutter and react-native.
>  That is despite Kotlin now having a stable native compiler.K/N for desktop platforms exists basically in name only. The runtime is too slow, the ecosystem simply doesn't exist, and you have to go through the C interop layer (which was marked entirely unstable in a point release, breaking everything!!!!) to do things such as I/O which lacks any sort of resource management (making it trivial to e.g. leak sockets everywhere).
This could get better over time. Most of the native community seems focused on mobile. But if this is ever addressed, Kotlin could emerge as an alternative to things like Go and other statically compiled languages. It's early days for native. There are similar challenges with wasm support; particularly the wasmWasi target.
I also think that in the longer term Google's embrace of KMP does not bode well for Dart and Flutter, especially in light of recent cost-cutting measures.But for now Flutter seems like a much more mature stack, at least on desktop.
You probably mean Compose Multiplatform?That is a fork, or rather, extension to Jetpack Compose, Google's declarative UI framework for Android. It uses Skia for rendering but has an the identical API to Jetpack Compose, hence from the point of view of a framework user, there is nothing new about it (other than that it works on Android, iOS, desktop OSs and web).
It's inspired by React, but way more purist about it. So there's no CSS or equivalent, it's all done using contexts, there's no HTML, it's all React-style function components the whole way down.There are some advantages to doing things that way, but I found there were also disadvantages. How much you like it will depend on how much you like ReactJS.
funny that they mentioned Gradle as the first feature change when the only thing we requested was the compiler to run without this gradle mess
you can use Kotlin in a Maven project as well (configuration here:https://void2unit.onrender.com/post/multimodule-maven-java-k...) or maybe your request is what triggered Jetbrains to develop Amper (https://blog.jetbrains.com/amper/)
I'd love to use kotlin standalone, as other normal programming languages, without any configuration scripts or build tools
A while ago, I tried compiling a simple Kotlin hello world on the command line (my preferred "IDE"). I vividly recall it taking around 7 seconds to evencompile, every time. It could be that my rickety laptop was to blame, but not probably wholly.AFAICT, the only viable avenue of Kotlin developemnt is by using an IDE (or maybe launch a Gradle deamon--but that'll be another rant).
And that is my major criterion for every modern programming language: How easy is it to use on the CLI (also my preferred IDE)? IMHO all fail there
If you accept to use gradle, then Kotlin works great without an IDE.
I've been an early adopter of Kotlin 2.0. We use kotlin for our backend (vanilla spring boot setup) and our frontend via kotlin-js. We also have a multi platform library for out backend API client. This powers both our server integration tests and our frontend. If you are wondering why we did that, it's mostly accidental. I had a kotlin/android developer and no time to retrain him on react/javascript. So we picked a Kotlin-js web framework and discovered that it worked well enough for us. It's called Fritz2 and relatively obscure. But definitely worth looking at.This setup has worked fairly well but it was a rough ride of the typical early adopter bugs, compiler issues, etc. over the years. Consequently when Kotlin 2.0 came out of alpha and entered beta last year, we tried it out and immediately liked it for one big reason: massively improved compiler performance.Especially with kotlin-js the difference was big enough that we were reluctant to revert back to 1.9. We are talking from edit -> compile -> webpack (by far the slowest thing now) round trips going from > 30 seconds to < 10-15 seconds. About half of that is webpack. I still wouldn't call it fast but it's definitely better.The early betas we had some code that didn't compile and we found some workarounds and on a few occasions engaged with the developers via the Kotlin slack on specific bugs. They are awesome and very responsive. By beta 2, we had everything working that we cared about. We didn't look back after that. I wouldn't recommend being an early adopter for bigger companies; but for us it was fine. Worst case would have been having to roll back to something that worked and then waiting for a fix.Highlights of this release are pretty simple:- no new language changes relative to 1.9. This is on purpose because the whole point of this release is the compiler. So, this should be an easy one to update to. Everything should just work. If it doesn't file a bug or fix your code because it probably does soms sub-optimal things.- New compiler backend and frontend that have come together over the last few several major releases. This clears the path for a lot of stuff. Including better IDE integration, language changes, and less headaches supporting different compiler targets.- wasm support is coming together (in alpha release currently). The main limitation is not the compiler but the lack of multi platform libraries that support it. This is slowly being addressed. I'm currently waiting for ktor-client to get support. Wasm has two targets: wasmWasi and wasmJs. wasmWasi is problematic with library support right now but should catch up in the next months.- Some improvements in the kts gradle dsl for the multi-platform plugin. Nice but not world shocking.
wait a second, the improvement is 30 seconds to 10-15? how is that workable? that would drive me insanemaybe i'm spoilt, but modern frontend with hot reloading on save is just about instant.even when i used kotlin (spring boot ~2.3), re-running a test with the intellij compiler took around 1 second.is kotlin-js really usable with that performance?
It's very usable. What you loose in performance, you gain in confidence provided by a statically compiled language. So, you can simply go longer in between reloads without risking too much fall out. If it compiles, it will probably run without a lot of weirdness. So there's less need to feel insecure whether things will still run.Also, I should point out that this is on a largish three year old code base. Re-running tests without recompiling is similarly fast with kotlin-js. A Spring integration test with some code in main and test needing recompilation and the Spring Boot start up time will also set you back 15-20 seconds or so.And as I pointed out webpack is at least half of the time you are waiting these days. IMHO, getting rid of that and replacing it with something faster could be worthwhile.
this may be the effect of what people are used to. Going from 30 to 15 is huge, even if it's awful compared to a couple seconds / hot reloading. I've worked on projects where the development loop required deploying to a test environment. You get used to programming without the feedback loop (not to say that this feedback loop shouldn't be sought after, only that one adapts to their circumstances)
I also hypothesized that working in anactualstatically and strongly typed language leads to less "save, reload, pray" loops than a typical front-end developer may have gotten used to
No, and it won't. Checked exceptions were explicitly removed compared to Java, and most people view them as a mistake (including the Java 8+ ecosystem e.g. streams).Try is a bit better and Kotlin has a bit of that with Result + runCatching. You can find a pretty good overview of the Kotlin error handling phylosphy here [1][1]https://github.com/Kotlin/KEEP/blob/master/proposals/stdlib/...
Also, Arrow.kt is worth mentioning for functional error handling.
Kotlin is one of those things that I avoided learning for so long just because I didn't want to learn another new thing.And one day I had to work on a project that was 100% kotlin and so i decided to do a 3 hour crash course on Youtube (actually watched it at 3x speed so it was really 1 hour) and once I grasped the basics it really made so much sense and I don't think I'm ever going back to writing Java classes anymore after having seen the light.Same happened with xpath long back. So long I resisted learning it because CSS selectors did the job but once I reluctantly learned it it changes your whole way of thinking.I think my fear of learning new things comes from coffeescript, something that actually had a negative impact and I would have better off not learning it which also made me scared of learning new technologies.
Java developers are rightfully conservative and sceptical of "new things". That said I believe Kotlin really provides a strong value proposition over Java. You also don't sacrifice much, there is less tools ofc but enough to get by, performance is equal for the most part etc.Also unlike stuff like CS it has a very strong future with Android backing.
I'm not sure how well "less tools" holds up when Jetbrains has done an awesome job of supporting Kotlin in their Java IDEs. There's something to be said for a dev tool shop developing a language.
To have used both, Kotlin is probably the #2 language with best IDE support, and the gap between the #2 and the others is as huge as the gap between #2 and #1 (Java)!Java has much more inspections, more intentions and some next generation inlay hints such as the "related problems" view.
Thankfully Kotlin is catching up (and is e.g currently getting support for code vision)On the other side Kotlin is THE language optimized for developper Happiness/ergonomics and its shows that it has been designed by IDE developers.
Oracle does a really good job improving the Java language. I really don't see any reason for why I should start using Kotlin. I use Groovy when I just need to do something fast without all the boilerplate code. But for 95% of the business problems, plain old Java is exactly what I need. For anything else, its Rust, Python, Javascript that shines in each of their category.
I felt the exact same way until last year. Java 8+, IntelliJ IDEA, and Lombok combined massively reduced boilerplate.Groovy was great for “more than Bash” and DSLs.I was wrong. Last year we gave Kotlin a try as a team and at this point we’re 100% Kotlin where we would’ve been using Java or Groovy (which would be the vast majority of our code).Spring and IDE support has made this transition easy. Coroutines are great for the type of code we write, SAM advances in Kotlin 1.4x have removed the last couple “I like the way Java handles that better”. Best off, all of those libraries we already created and use are still completely usable, we didn’t have to rewrite anything.For me nullability checks by default, synthetic/map backed properties, extension functions, inline/reified functions, and coroutines have so drastically improved the readability AND conciseness of our code I can’t imagine going back.
Oracle is doing a good job adding features to Java to keep up with modern languages, but it’s not just about adding — some things need to be removed or changed.By way of example:Final classes by default with an open keyword instead of open by default with a final keyword. Inheritance is a very tricky thing to get right and it’s better to explicitly say “I thought about this and put in the effort to make it work”.Checked exceptions are a contentious topic and I’m not sure which choice I prefer, but Kotlin chose to remove that, and it has an impact on style.
I can see checked exceptions being a good option for a pre-Java8 world, but they interact horribly with functional interfaces, which are fundamental to a bunch of other newer Java features.A lot of those are almost philosophical differences, though. A Java feature that is unambiguously bad, but probably impossible to remove, is the different equality semantics between atomic types and their boxed versions.
How is Valhalla affecting those semantics?
> Final classes by default with an open keyword...is exactly the wrong way around.  Inheritance is very much about unplanned reuse and programming by difference.  That is:  there is something that almost works the way you want, but not quite.If you are actually planning this ahead, then typically inheritance is the wrong approach and you're better off using composition.
The whole point of OOP is that each object is responsible for maintaining its own invariants. Open classes are useless without open methods, and open methods are a weak point in terms of letting your child classes mess up those invariants.Interfaces are completely free of this burden. Abstract classes signal that you're working with an incomplete implementation and you're expected to cooperate with the base case to make things work. Final classes just opt out of this whole thing altogether.What, exactly, does a class being open say? In a default-open context, you don't know whether this is an omission or a design choice. In a default-final context, you're explicitly allowed to mess with the class (and, because of the explicitly open methods, only in safe ways).
> The whole point of OOP is that each object is responsible for maintaining its own invariants.I think there are a whole lot of people who might disagree with the assertion that this is "the whole point" of OOP.  Including one Alan Curtis Kay.OOP to me means only messaging, local retention and protection and 
hiding of state-process, and extreme late-binding of all things. It 
can be done in Smalltalk and in LISP. There are possibly other 
systems in which this is possible, but I'm not aware of them.http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay...> Open classes are useless without open methodsYou seem to mix "class" and "object" rather freely.  They are quite different things.  Also, not sure what you mean with "open methods".  I can add methods to something in a subclass.  I can override methods in a subclass.> letting your child classes mess up those invariants.Who is the "you" of the "your" in this context?  A class?  But a class is not a really a thing, objects are.  And it is theobjectsthat are the units of encapsulation in OOP.  Not classes.  Classes are just convenient bundles of behaviour and templates for state that is attached to objects.You might think this is silly nitpicking, but it's actually a really, really important distinction:As a teacher of object-oriented programming, I know that I have succeeded when students anthropomorphise their objects, that is, when they turn to their partners and speak of one object asking another object to do something. I have found that this happens more often, and more quickly, when I teach with Smalltalk than when I teach with Java: Smalltalk programmers tend to talk about objects, while Java programmers tend to talk about classes. I suspect that this is because Smalltalk is the more dynamic language: the language and the programming environment are designed to help programmers interact with objects, as well as with code. Indeed, I am tempted to deﬁne a “Dynamic Programming Language” as one designed to help the programmer learn from the run-time behaviour of the program.http://web.cecs.pdx.edu/~black/publications/O-JDahl.pdfAnd the object in question is an instance of the subclass, and if you are going to involve classes, it is the subclass that is responsible for maintaining invariants.  The superclass no longer has that responsibility for instances of the subclass.  So nobody is messing with anyone's invariants.
Wow, I am pretty much exactly of the same view (except for using Python, I really don't like Python, been burned too much by its constant problems with using system libs that only ever seem to work on "my machine" - Groovy is a lot more reliable for scripts IMO)... but I do use Kotlin sometimes, but with Java 17 likely bringing sealed classes/interfaces to Java, I am less and less excited about using Kotlin.
Yeah, for me, Java 16 bringing record classes (data classes/case classes etc.) to the table is making Kotlin less compelling.Simply because using Kotlin brings in more moving parts. For example:https://docs.micronaut.io/latest/guide/index.html#kotlin> When you use any Micronaut AOP Advice, it creates a subclass at compile-time to provide the AOP behaviour. This can be a problem because Kotlin classes are final by default. If the application was created with the Micronaut CLI, the Kotlin all-open plugin is configured for you to automatically change your classes to open when an AOP annotation is used. To configure it yourself, add the Around class to the list of supported annotations.
Yeah, right, so why do I still have to escape regex metacharacters in Java in 2021? That's just so 1988.
You don't have to, java support raw strings.
But yeah Kotlin is far superior, denying it is only proof of partial knowledge/ignorance.
Raw strings don't apply to regexen. You still have to escape the metacharacaters.
Many years ago, I used to think that Scala was going to be my "next Java".Now, guess it's not Scala, by Kotlin. Why?
- First class citizen for Android development. Yes, most of my works is on Android.- Not to foreign compared to Java. In general, Java devs should be able to Kotlin in relatively short time. Not sure about Scala, which is influenced by Haskell/ML etc. At least in my circle, not many folks familiar with functional programming.- Of course now Spring also supports Kotlin :)
Everything was hot, shiny and new at one point. Java is no longer that, and the developers referenced in the parent comment may not have had any interest in Java when it was hot, shiny and new.
From my modest experience with Kotlin few months ago in a small Android project for learning purposes. I can just say that the language resulted very expressive, concise and easy to use for me. Coming from other languages (Go, Rust, C#, JS, PHP among others) but doing almost no Java in the past, I was able to getting started with that Android project few weeks later after have been passed across Kotlin's docshttps://kotlinlang.org/docs/home.htmlSo basically I can confirm "Android’s Kotlin-first approach"https://developer.android.com/kotlin/first
Would you mind sharing a link to that YouTube crash course? That would be awesome. Thanks.
Sure it was this one:https://www.youtube.com/watch?v=H_oGi8uuDpA(from history)I guess I remember incorrectly it was 3 hours long. It is only 1hr few minutes and you can easily watch it at 2x speed.But overall Youtube is a great resource for learning new things. If you search Kotlin crash course (filter by duration > 20min) you will find ton of such courses and you can easily judge them by number of likes/dislikes.And make sure to watch it at 3x speed with subs ON initially (video speed controller for chrome). This is truly a great hack when learning tech things via video.
Why do you feel like that about Coffeescript?
The thing about Coffeescript is that you don't really gain anything other than syntactic sugar. Compare it to, say,  Typescript and Clojurescript where you gain a whole set of features and, with Clojurescript, the semblance of a standard library.
I really don't remember it was a long time ago but from what I recall there was just too much magic happening and things would break a lot of times because it was easy to make mistakes with it.Come to think of maybe I didn't learn it well enough at that time and blamed it for my silly mistakes. CS did introduce a lot of good things like the fat arrow which was just amazing at that time.
yeah i'm surprised too, cs wasn't the holy grail but it was a good improvement over es5 at the time.. it really made writing code different
Completely different motivations, and I suspect Kotlin is a reason that Clojure and Scala seem to be losing much of their initial steam. Clojure offers Lisp on the JVM, but what most people really wanted was a fixed Java. That's exactly what Kotlin delivers. Clojure has decent Java interop, but there's a serious impedance mismatch working with native Clojure and Java libs. Kotlin otoh dogmatically sticks to Java's model of programming, just a cleaned up version.
IME many Clojure programmers come from non-Java backgrounds and aren't looking for a Java like experience. So I can believe the "more better Java" audience probably heads for Kotlin today. I think this is a win for both the Clojure and Kotlin communities and developer cultures.To inject some time perspective, Clojure is 14 years old, so it's not too bad to be moving from initial steam to young-adulthood steam now :)
Having used Kotlin on and off for the better part of a decade, the one thing I can say is that their editor support is unrivaled by any other language today. While Kotlin's build tools leave much to be desired (looking at you, Gradle), their focus on building a "toolable" language was the right thing to lean into. You can add all the fancy type system features you want, but if the IDE does not understand them, convincing users is going to be a hard sell.Whenever I try to get into another language today, the lack of language-aware editing tools are my main source of frustration - specifically, I expect navigation, refactoring and completion to work flawlessly. I know of no other programming language that puts as much effort into context- and structure-aware refactoring - if another language does one day replace Kotlin, it will need to offer a comparable editing experience.
I attribute this to the fact that Kotlin was developed by the same team that created IntelliJ, and fantastic IDE support was a requirement from day zero.A big part of why Kotlin works isbecauseIDE support is so fantastic now. And likewise, a lot of the reasons Java ties developers' hands is because there was no guarantee about the IDE they would be using.As a trivial example, declaring variables. In Java, you have `final String foo = "bar";` while in Kotlin you can just say `val foo = "bar"`. They type is implied, but if you aren't sure, you can hover over `foo` and the IDE will tell you what the type is, so there's no longer a reason to type it out every time.Also, you can now have multiple classes in a single file. When Java was created, the one-class-per-file rule madefindingthe source code to a file easy; just do a `find` for `Classname.java`. But with a modern IDE, you can just command-click an instance and be taken to the source code automatically.Java's boilerplate is meant to make code discoverable, but the Kotlin IDE does that work for you, allowing developers to be more flexible.
This is funny because the other language I think of which wouldn’t be nearly as popular without an IDE, is Java. Especially older versions of Java.Java is way too verbose to be workable if I have to write out all of the class declarations and anonymous classes and “equals/hashCode/toString” boilerplate and “ExtremelyLongClassName foo = bar.extremelyLongMethodName(…)”; and there are too many pitfalls like comparing with “==“ instead of “Object.equals” and implicit null. Except that I don’t have to write out anything or worry about any pitfalls (well, implicit null still hits me sometimes, but @NotNull and @Nullable make it much less common) in IntelliJ. IntelliJ has such powerful and seamless analysis, it does aggressive code folding on Java 7 so that you are looking at code with “var”s and lambdas. It also has built-in support for popular libraries like Spring and Lombok.IntelliJ single-handedly turns Java from a verbose, legacy language intosomething I could actually recommend and start new projects on(although at that point I usually go with Kotlin). And Eclipse, NetBeans have very deep Java analysis as well. Java may have started off without expecting IDE support but now IDE support is responsible for a large part of its popularity.
Yes. You either have a language that is easy or you have tooling to make it easy.If I cannot access documentation for a library/function at a mere tap of a button - that language isn't going into my toolbelt. I have to code in like 5 languages at my dayjob, that's at least 3 different types of semantics for ==.Java, and Kotlin, are great at that. It's the major pitfall for Scala(and a laundry list of others), on the other side(hey implicits and converters, that make even IntelliJ go "wut?"). Those long names in Java are actually a godsend. Give me "int indexInTheArray" over "int x" anyday. Explicitness of Python is also a pleasant thing to work with.People forget that most software is boring website backends, business processes and similar tools. Most devs don't have mental capacity to devote to "the one and only" language+platform+ISA.
It's not just the tooling. Having tried to work with Python in Intellij, the lack of typing means you literally have to GUESS what any non-primitive object can do.It might also be an unhappy coincidence, but the library I was playing around with (scrapy) also had HORRENDOUSLY documented code. With Java/Kotlin, you can just click into any method/class and you'll get a useful doc string 99% of the time. With Python, I had to read the (incomplete) documentation.
This has been my experience with Scala. Even IntelliJ can’t figure it out sometimes and the documentation is all crazy type theory stuff.
Are there languages out there that have done both?
Do you think the same for Go as well? Because Go is by all means much more verbose than Java.(But I do agree actually, a good IDE is much better investment than a minimal syntax revision)
I'm curious how you come to this conclusion. Granted I never wrote much Java (and not in the last 10 years), but it was painfully verbose at the time. I've never had that reaction while writing golang (which over the last 3 years I've done a decent amount). Has Java gotten much more succinct?
That’s the interesting thing, how did this verbose feeling stuck to Java while not to Go, where your code is literally littered with if errs, you have way too deeply nested for loops, etc.Java is a surprisingly expressive language even though it does have a few warts.
I'll have to give it another look if the situation presents itself. I think one factor of Java being remembered so unfavorably was it being early in my career.I do think there should be a distinction on what is lumped as verbosity. Golang is vertically verbose with its error checking, and Java in my experience is at least more horizontally verbose (long lines).
Go is definitely far more verbose. Go cannot compete with switch expressions, pattern matching, and streams.
> As a trivial example, declaring variables. In Java, you have final String foo = "bar"; while in Kotlin you can just say val foo = "bar". They type is implied, but if you aren't sure, you can hover over foo and the IDE will tell you what the type is, so there's no longer a reason to type it out every time.This is something I've learned about Groovy that I really like. You can declare variables in multiple ways (terms are my own):foo = 1     # normal assignmentvar foo = 1 # declared assignmentint foo = 1 # typed assignmentA lot of our current code used the first "normal assignment" that you would see in shell scripts, Python, whatever. There's nothing interesting about this.I started using the second kind consistently. The "declared assignment" says "I am creating a new variable foo and its value is 1". If you arenotcreating a new variable (i.e. if the variable exists already) your program fails. This is a great way to ensure you're not overriding variables from earlier in the program or from another scope. My experience tends to be that this throws errors "now" for mistakes you're currently making (at this point in the control flow) by overwriting a variable that existed before.The last is a "typed assignment", where you're not just saying "I am creating a new variable", but specifically the type of variable is important. This errors if you ever try to misuse a variable down the road, and helps with ambiguity. It solves the "somestring = somestring.split()" issue of discounting a variable as the potential issue due to "it can't be this one, that's a string" being right for a while and then wrong for a while (or vice-versa).Anyway, all that to say: not having to specify data types is nice in some circumstances, but I've been leaning into adding data types to my code just to make absolutely sure I know what everything is all the time. Not having to in Kotlin sounds nice, but I hope there's a way to be explicit about everything.
Perfectly valid Java for the last 4 years:var foo = “bar”;
that's not final though, like val in Kotlin
we talked about having val as well in java but it just wasn't that interesting. if for some reason you think you need final you can use final var.
Java supports curly quotes?
iOS got me again!
You realize that Java has either released or has in preview most of the Kotlin features? Your example in Java 10+ is:var foo = "bar"; // you can add final if you feel like itYou could always have multiple classes in a Java file as long as there was only one public class.
I think many of us have stale conceptions of Java formed decades ago. But some time ago, Java started evolving quickly and now isn’t that far off from Kotlin. When Kotlin started, that was not the case.People still think of Java as stuffed full of wordiness, slow startup, garbage collection seizing up code, and long compile times, but that’s all in the past.
I'm not so sure about the slow startup claim here :-) I.e. Spring apps still take several MINUTES to start (with Java or Kotlin...)Please correct me if I'm wrong, but I don't think Java's dependency discovery mechanism has evolved much (if at all) from prehistoric times (hence, the slow startup remains). Although GraalVM sort of addresses that.
I think you are right. Many also got their first experience with Java in school or at their first job. Languages like Java/C# can seem intimidating at first.
As a long time Visual Studio and C# .Net developer it’s always fun to hear people wax lyrical about these “amazing new” IDE features that have been pretty much standard in the toolchain for more than a decade…
> but the Kotlin IDE does that work for youSo long as everyone on your team uses IntelliJ, then no problems. But not everyone uses IntelliJ, and now you've written code that is only easy to parse in a particular IDE...For this reason, and being able to read my own code outside of just my IDE (say, in Github, etc), I've found it more necessary to be explicit with my typing in Kotlin for all but the most trivial snippets.
This is not a compelling argument. I'm not going to stop using a powersaw to cut beams just because another contractor refuses to use anything but his handsaw.Besides, reading implicit types has _never_ been an issue on any team or collaboration effort in the 30 years of my programming experience and I find it _really_ hard to believe anyone that claims it is a bonified problem for readability. In fact the complete opposite is true for me, personally, that too much information in front of me becomes noise and the signal gets lost.
They're not talking about someone using a hand-saw, they're talking about someone using a powersaw from a different manufacturer. Or, y'know, a table saw, or a CNC machine. Kotlin has tight integration withone particularIDE, not withallIDEs; let alone with things that are powerful in ways orthogonal to the ways IDEs are powerful, e.g. Emacs.
"bonified" is a particularly satisfying bone apple tea
yeah I've no idea why I spelled it that way.
Considering that many people willingly work with languages like Python and JavaScript, which make ANY IDE/Editors job of completion horribly difficult, the worst case is you end up with an editing experience on par with other languages.
Eclipse has feature-parity with IntelliJ in this space, it just has questionable usability and performance.
I would argue that C# and Visual Studio (and maybe Rider) has as good, if not better tooling integration compared to Kotlin, especially considering nuget and sln files solve the “build system leaves things to be desired” part of your comment.This isn’t to say that Kotlin isn’t absolutely incredible, but I do not want to undersell the pleasure that C# is to work in with its tooling.
> I expect navigation, refactoring and completion to work flawlessly.Same, but this was the case for C# in Visual Studio 20 years ago.> I know of no other programming language that puts as much effort into context- and structure-aware refactoringTypeScript + VSCode do all this and more.
C# also have great IDE support in VisualStudioespeciallywith the ReSharper extension. Which is also developed by JetBrains.
Dart is also extremely good from a tooling point of view.
what do you have in mind about refactoring support with Typescript and VSCode? Maybe I'm missing something obvious but the only "refactoring" functionalities that VSCode provides me are "rename this variable", "rename this file" and "move this export to a new file" (can't move to an existing file, and can't even chose the name of the new file)
In VSCode what's in the refactoring menu depends a lot on what you have selected or under the cursor. For example with a selection of a block of code you should get the "extract to method" menu item appear in the refactoring menu, etc. I don't remember there being quite as many as what IntelliJ has for Java though.
Have you tried TypeScript? My impression having used it in both JetBrains and VSCode is that it achieves basically what you're describing.I similarly get irritated using anything else now.
I've used both and Kotlin was a better overall experience for me. TypeScript has weird typing problems far more often due to the underlying runtime being dynamically typed.
What problems in particular have you run into? Genuinely curious.
While I like TS and it is my primary language currently, having worked with Kotlin in past I find the dev experience with kotlin to much better, esp. if you steer clear of libraries that lean heavily on bytecode weaving, compiler hooks etc.Kotlin's type system is nominative and so while it is not as flexible as typescript (no intersection types, conditional types etc.) it also means that you don't run into those multi-page long type errors which need 5 mins of debugging to figure that some deeply nested object is null where undefined is expected.It is particularly funny when the language server truncates the errors and it becomes impossible to infer the actual issue from the message. Every now and then I find myself extracting things out of objects and adding type annotations to simplify the errors. It is doable, but never needed in Kotlin.
Types in TS are Turing Complete [1], so any static analysis you build ontop of that language is bound to be unsound or undecidable. You could argue this rarely occurs in practice, but I would prefer a type system that is incomplete but sound and decidable. Incidentally, this issue also affects Java, which is both unsound [2] and undecidable [3]. Kotlin does have a fairly complicated subtyping relation [4], which has caused similar issues in languages like Scala [5], however whether the same issue affects languages based on mixed use-site and declaration-site variance like Kotlin is still an open question and requires further investigation.[1]:https://github.com/microsoft/TypeScript/issues/14833[2]:https://io.livecode.ch/learn/namin/unsound[3]:https://arxiv.org/abs/1605.05274[4]:https://kotlinlang.org/spec/type-system.html#subtyping[5]:https://arxiv.org/abs/1908.05294
TypeScript works well because they don’t worry about soundness and completeness. The type system isn’t trying to be perfect, just useful. This scares PL theorists, but I think it has been a very profitable corner of the design space to explore.Variance rarely comes up in Kotlin because they don’t push immutability as much as Scala did. It’s like, there as an option but I’ve used it a total of two times in the last two years of full time Kotlin programming. Compared to typescript, Kotlin is fairly boring, but it is tooled well and is a vast improvement over Java.
So your reason to avoid TypeScript is some very rarely encountered corner case? Talk about perfect being the enemy of the good.No language is perfect. Your comment is absurd, and the citations are pedantic.
Jetbrains and rust have brilliant refactoring. No idea how it compares to kotlin, but I can confidently move methods to other modules and files, rename anything, navigate to definition with no fear. Auto complete / auto import is also insanely good and is almost to the point where I’m auto completing almost every symbol because the IDE knows what I want precisely.I can’t recommend jetbrains rust support enough.
That's a JetBrains thing - they added loads of fantastic refactoring options to Visual Studio for C# which have now largely been integrated into the IDE directly. I've had an all-products subscription for close to a decade now and it's money well spent.
ReShaper was what kept JetBrains alive 10+ years ago and Microsoft couldn't release a new version of Visual Studio until ReSharper was ready for it due to how many people used/depended on it.
Honestly. Every JetBrains IDE is incredible.
I was actually very disappointed to find the kotlin refactorings lagging what for Java in IntelliJ.  A few examples:https://youtrack.jetbrains.com/issue/KTIJ-12496/Provide-inte...https://youtrack.jetbrains.com/issue/KTIJ-10606/Support-movi...https://youtrack.jetbrains.com/issue/KTIJ-5063/Extract-prope...
Kotlin has one of the poorer LSP implementations out of the popular JVM languages. Last I tried it was buggy, and slow. Developers are pushed into using JetBrains products directly or indirectly (Android Studios) I suspect leaving the wider ecosystem poorly supported.
I was evaluating Kotlin for a Spring Boot project a few years ago and would have loved to have programmed in it, but this was exactly why I stuck with Java.
Back when I was doing audits, the only languages that really had good IDE support for that were objective-C / swift using XCode. You could get a caller hierarchy and get some sort of recursive dropdown menu to go through the entire call stack, it was magical.
Last I was looking into Kotlin (couple years ago) they seemed hostile towards efforts to bring a similar level of support to editors outside the Idea family; basically they weren't going to do or support anything that threatened their "walled" garden of Kotlin + Idea. Is that still the case?As a huge fan of Jetbrains products (I maintain a personal IDEA Ultimate subscription) this was still a huge turn off to me.> I know of no other programming language that puts as much effort into context- and structure-aware refactoringDo you mean JVM language? TypeScript, C#, and F# at least come to mind.
> Do you mean JVM language? TypeScript, C#, and F# at least come to mind.As I mentioned in another comment [1] on this thread, soundness and decidability are non-negotiable for me. Types in C#, F# and TS are all Turing Complete [2], and therefor these languages are tooling-adverse in the sense that static analysis is fundamentally unreliable.[1]:https://news.ycombinator.com/item?id=33329509#33332183[2]:https://3fx.ch/typing-is-hard.html
> As I mentioned in another comment [1] on this thread, soundness and decidability are non-negotiable for me. Types in C#, F# and TS are all Turing Complete [2], and therefor these languages are tooling-adverse in the sense that static analysis is fundamentally unreliable.How on earth do you consider Kotlin acceptable then? Kotlin's type system has never been shown to be sound or decidable and is visibly a lot more ad-hoc than any of that list (and if by some miracle it was sound or decidable last week, I'm sure whatever new feature they added this week broke it). I suspect the only reason it hasn't been formally proven to be Turing Complete is that Kotlin's developers haven't bothered to write a specification for it - as far as I can see your link's example for C# would translate directly into Kotlin with the same properties.
Try it! I certainly have. You may find encoding a typelevel TM or λ-calculus more difficult than it appears...> link's example for C# would translate directly into KotlinT() is not possible for a generic T in Kotlin.
> Try it! I certainly have. You may find encoding a typelevel TM or λ-calculus more difficult than it appears...These languages were stable, well-specified, and heavily studied for years before these cases were found. One person noodling around for a few weeks failing to find an example is not evidence of anything; a language being too obscure to have seen much academic study is not an indicator that it's likely to have a good type system, if anything it's the opposite.> T() is not possible for a generic T in Kotlin.T isn't generic in that code, it's just a class.
> One person noodling around for a few weeksWell, I've been trying for about three years, but to be fair I'm a pretty slow programmer so you may have better luck.> a language being too obscure to have seen much academic studyDoesn't seem too obscure to me.https://scholar.google.com/scholar?hl=en&as_sdt=0%2C5&q=kotl...> T isn't generic in that code, it's just a class.I think it needs to be a generic type in Kotlin for this to work, because otherwise it will dispatch to a single method. It's tricky to get Kotlin to do much compile time computation. Not saying that it's impossible, but LMK when you've actually tried it. Here's some sample code if you want to try encoding a Boolean logic:https://github.com/breandan/galoisenne/blob/2e465e7a753f6341...
> Well, I've been trying for about three years, but to be fair I'm a pretty slow programmer so you may have better luck.Well, your own link proves it, doesn't it? Kotlin has nominal subtyping, contravariance, and generics, therefore its type system is undecidable.> I think it needs to be a generic type in Kotlin for this to work, because otherwise it will dispatch to a single method.That's the whole point - the type system has to decide which overload to dispatch it to at compile time, which it can only do by performing an arbitrarily complex computation. I ported that code directly to Kotlin and it doesn't compile but it "should", which, well, I don't know what you were expecting or what you'd accept as proof when we've already got an academic paper that proves the point.
> Well, your own link proves it, doesn't it?That code simulates aboundedcellular automaton, which effectively reduces to a regular language, but that's about as far as I've been able to get. If it's possible to implement general recursion, I'm not quite sure how - yet.> Kotlin has nominal subtyping, contravariance, and generics, therefore its type system is undecidable.They're not using Kennedy and Pierce's system, but it's closely related. See Tate (2013) [1], in particular, "In general, since declaration-site variance can easily be encoded into use-site variance..."> I ported that code directly to KotlinCan you share your translation of Eric's code? Maybe we can get it to work.[1]:https://fool2013.cs.brown.edu/tate.pdf
> They're not using Kennedy and Pierce's system, but it's closely related. See Tate (2013) [1], in particular, "In general, since declaration-site variance can easily be encoded into use-site variance..."Well, Kotlin has both declaration-site and use-site variance. So surely that result applies.> Can you share your translation of Eric's code? Maybe we can get it to work.Ah I didn't mean that code, I meant the earlier C# one from SO.https://pl.kotl.in/4BrbZAmZG
Literally majority of languages are either unsound, undecidable or both in the link that you've provided. The only exceptions are Haskell, Idris, ML and Go (given the date of the post, this was pre generics which would probably exclude it also).
That's certainly a design choice they're free to make. Undecidability itself is less of a deal-breaker, although I would argue that a statically-typed language which is unsound defeats the purpose of having static types in the first place.Ideally, you want type inference to terminate in the amount of time it takes to type a few keystrokes to get realtime assistance, so decidability is still an over-approximation from a tooling standpoint and in practice anything strongly super-linear is not a fun experience to use.
I still don't follow how you came from> I know of no other programming language that puts as much effort into context- and structure-aware refactoringTo soundness and decidability.Was there some study done where soundness and decability of Kotlin is provided?
> I still don't follow...The premise was "toolability" in language design, which is one of Kotlin's main design principles. To do type-safe completion, navigation or refactoring, you need soundness, and to do it rapidly in the context of a live programming environment, you need to be able to resolve a type with keystroke latency. Rapzid asked [paraphrasing] "why not TypeScript, C#, or F#?" to which I responded that I do not consider these languages "toolable" because type checking is essentially broken (i.e., it might take forever, or give the wrong answer).> Was there some study done...?No, not that I am aware of. If you find one, I would be keen to read about it.
Have you ever used VS/Resharper/Rider with C#?I don't understand how you can come to the conclusion that type checking is broken and the language is not toolable? Can you give an example of where Kotlin's tooling achieves something that is not achievable at the moment in a C# IDE?(I've not used Kotlin much but I have never felt that the tooling for C# was lacking, so I am genuinely curious)
> Have you ever used VS/Resharper/Rider with C#?Yes, and to be clear I have never encountered these issues on practical problems. I am alsonotclaiming Kotlin has or lacks these properties, just pointing out the fact if you care about toolability, soundness and decidability are important factors to consider andifthere is a language design issue, it makes me less confident in any tooling which is built around it.It comes down to whether you want type checking to work all the time, or most of the time? If your answer is "most of the time", then just use a dynamically typed language with GPT-based autocompletion. Most of the time completion and refactoring will work just fine.Re: type checking in C#, maybe try the following example?https://learn.microsoft.com/en-us/archive/blogs/ericlippert/...
There's a fairly big difference between:a) "most of the time" being 60% (very roughly what I'd expect when doing renaming beyond a single function in JS, and that's being optimistic).
b) "most of the time" being 99% (very roughly what I'd expect in a typical C#/java/kotlin codebase that isn't using too much reflection).Even aside from that, I'd argue that nullability, array covariance, and reflection all have MUCH bigger practical impacts on typechecking reliability than Turing-completeness. Most languages will simply fail to compile if the computed types require too much recursion, making the issue relatively moot.Type-checkers don't actually need to solve the halting problem to be sound, they just need to guarantee completion for _most_ types of code, and anything that can't be guaranteed can simply be rejected.
> "most of the time" being 60%I would expect this number to get closer to 99% with LLM-based AI code completion tools, so the gap between dynamically-typed languages and "good enough" languages that claim to be statically typed (but are in fact unsound) will become much less significant. But if you want correctness, you will need stronger guarantees.> I'd argue that nullability, array covariance, and reflection...I would mostly agree with that statement, with the caveat that it depends on what you want from your type system. Personally, I want the checker to be (1) sound and (2) decidable and (3) fast. For everything else there's runtime type checking.> Type-checkers don't actually need to solve the halting problem to be sound, they just need to guarantee completion for _most_ types of codeAlthough I don't see much difference between undecidable type systems and dynamically typed languages, as I wrote, I see undecidability as less of an issue. My main concern is unsoundness, which is more critical and unclear how to fix. By "soundness" I specifically mean the formal property that "well-typed programs cannot go wrong". "Most types of code" is just a statistical claim, in which case you might as well use Python or JS/TS with a linter. Too many statically-typed languages decide to go off and roll their own types without reading PL literature, then end up with dealing with these issues later down the line.
> It comes down to whether you want type checking to work all the time, or most of the time? If your answer is "most of the time", then just use a dynamically typed language with GPT-based autocompletion. Most of the time completion and refactoring will work just fine.This is bad advice. Such an approach will go wrong often enough to burn you, and it will go wrong silently, whereas the kind of issues you describe tend to lead to something far more visible (and therefore correctible) like a complier internal error or an IDE refusing to perform a refactor.
Have you used TypeScript? Not only is it better type system than Kotlin, it has great IDE support in VSCode, AND there’s a language server so you can get IDE support in Emacs/vim.
I'll bring up the Kotlin LSP[0] every time I see Kotlin on HN because I really hope the LSP takes off (which would make it viable to use Kotlin with a non-IntelliJ editor).Kotlin as a language looks really cool, but I don't want to give up terminal-based, modal editing (which I'd have to in order to use IntelliJ).Along those lines, I once tried diving into using Gradle outside IntelliJ, and I couldn't find any good resources to help with that. If folks have hints/links-to-blog-posts with regards to that as well, that'd be great![0]https://github.com/fwcd/kotlin-language-server#this-reposito...
I think the LSP for Scala works really well. It's not Kotlin, but you might want to try it out.
Thanks for the tip!I keep reading on HN and elsewhere that Scala's feature-full-ness encourages complex/unmaintainable code, but I gotta check out myself.
Totally the opposite - I think that's really from Scala's first versions of so.But Scala has a steep learning curve for the advanced techniques and the compile times can be very annoying when using those. And if you don't use the advanced techniques, you might as well pick Kotlin or Java instead.
Thanks. My interest is piqued now for sure.
I'm sure you're aware it exists, but the Vim plugin for IntelliJ is actually good enough, imho. Might be worth a try.
When a language has only one practical choice of IDE, that's a red-flag to me.
Exactly. LSP for Kotlin in VSCode unfortunately had far inferior experience compared to IntelliJ native support.
Why is that?
You're right. I should give it another try.
One of the things they don't mention is that J2K makes you pick between:* A conversion in 1 commit: complicating/breaking the 'follow' behaviour of 'git blame'* A conversion in 2 commits: the first 'rename' commit doesn't compile, complicating/breaking 'git bisect'I hacked up a script which makes the 'rename' commit compile (when I was working with a ~100KLOC Kotlin conversion). This may be useful for others:*https://github.com/ankidroid/Anki-Android/blob/937a6560913ec...*https://github.com/ankidroid/Anki-Android/blob/937a6560913ec...
Hi HN! I’m the author of this post. I’d be happy to answer questions here on this subject!
Hi! Congrats on the huge accomplishment.Is that list of disadvantages really accurate? Reading them, I get the impression that the "popularity gap" between Kotlin and Java was a major reason FB was behind the industry on converting to Kotlin. (For context for non-Android engineers reading this, Kotlin has been the first party recommended language for 3 years now, and has been supported for 5 years) I can't imagine y'all were interviewing Android candidates in Java? And while certainly the Kotlin ecosystem as a whole is smaller than the Java ecosystem, the JavaAndroidecosystem is miniscule.My recollection from my time in the building at IG was that build times and binary sizes were the two heaviest lifts, almost to the exclusion of anything else. Am I misremembering, or did the conversation change? Or does that list of tradeoffs reflect a realization by your team that you'd need to converteverythingto Kotlin, not just the Android code?
>  Is that list of disadvantages really accurate?I think this is a good depiction of our worries. Our biggest is and always was build times.> I can't imagine y'all were interviewing Android candidates in Java?We let people choose their preferred language for a while now. Also, while this blog is celebrating some milestones in the conversion, some smaller apps and new code was using Kotlin for a while now.> My recollection from my time in the building at IG was that build times and binary sizes were the two heaviest lifts, almost to the exclusion of anything else. Am I misremembering, or did the conversation change? Or does that list of tradeoffs reflect a realization by your team that you'd need to convert everything to Kotlin, not just the Android code?Binary size has generally not been an issue. Build times are an issue. We migrated and migrating some optimizations we have to alleviate that. We're also crossing fingers for more wins from the new Kotlin compiler JetBrains is working on.
I hear that KSP makes a huge difference, as you call out. Not an easy task to get rid of kapt, though, so - good luck! And again, congrats. :)
I know it’s not the NYT, but just curious how it feels to wake up and see your work on the front page of HN
It’s pretty nice. :)This post is the (pretty short) summary of a lot of work which took us a long time to do. So it’s nice to get any kind of validation.Personally I read HN a lot and it’s my main source for interesting articles nowadays. So that makes me appreciate HN upvotes even more.
For us hackers, it'sbetterthan the NYT!
Yeah.  NYT reporters don't show up here to answer our questions.
1) Is that a mono repo?2) If not, how many LOC is the largest Kotlin repo?3) How do you tackle challenges of large codebases like language servers/synthax highlighting crawling to a halt in IDEs?
1 & 2) Yes, almost all of the mobile code lives in one repo, and the 10M number quoted is all in one mercurial repo.3) There's a lot of different things we do to work around such issues. Some things that come to mind right now:
- We have plugins for Android Studio to avoid loading all the code at once that help.
- We had forks for the Kotlin plugin for Android Studio to deal with some issues that were worse for our repo. (especially around module loading)
- We also worked with JetBrains by pushing some fixes and they fixed a lot of the issues over time.
- We do a lot of work as async jobs that run on the repo without you waiting for them, so you don't have to wait for such tools.
I don’t know about this area in particular but almost all FB code lives in a handful of very large monorepos.
Have you released the source code for the following (primarily running AS in headless mode). It's something I've wanted to look into adding into our CI:> As part of this step, we also apply our autocorrecting linters and apply various Android Studio suggestions in headless mode.
No. It's pretty coupled with a bunch of our pipelines.I'll check again with the people who built it and see if it's doable to open source it.
Thanks! If you manage to get it out in the open, could you send me a ping (email is on my profile). Happy to put in the effort to get it usable.
What's the share of React Native in your apps and where it is used? Also, what about Obj-C/Swift?
I'm not the right person to comment on the React Native part. (There's definitely quite a bunch of React Native in the app on top of the Kotlin)Other people are also working on Obj-J/Swift, but from my superficial knowledge I think it's a much harder migration to do. I really think the Kotlin team did amazing language and tool design which makes Java to Kotlin migration easier than almost any other language migration I could think off. Kudos to them.
Why does meta have 10millionlines of code just for Android?
There's many reasons, so I'll give it a try:- There's a few apps here. Plus a bunch of tools.- The Facebook app is huge in terms of features. Just look at the menu with more things. I use very few of them, yet they're all pretty popular and justify themselves.- Instagram is smaller than Facebook, but still has a lot in it.- A lot of our code was optimized over time in many ways that add a lot of edge cases: internationalization, accessibility, optimizations for dealing with media, loading and data. It's can be easy to write something with much less code that looks pretty good at first sight, but all those extras really make the experience better and pay off for users.- We build new features all the time, some code may be unreleased, some is in A/B testing and so you can have two or more pieces of code that do the same.- A lot of test code.- Not that much dead code. Trust me. I love deleting code! And I will happily spend time removing bloat. There's definitely a lot of dead code to remove, but it won't change those top line numbers by much.(Also, it's 10M Kotlin lines of code, we have much more)(I would love to know how many lines of code the other really big companies with big mobile apps have for comparison)
Please see The Thirty Million Line Problemhttps://www.youtube.com/watch?v=kZRE7HIO3vk
> justWhere did this come from?
> Today, our Android apps for Facebook, Messenger, and Instagram each have more than 1 million lines of Kotlin code, and the rate of conversion is increasing. In total, our Android codebase has more than 10 millions lines of Kotlin code.Probably 1000 engineers working on an app with each writing 1000 lines of code.  I am not surprised Facebook app has >1 million lines of code.  The app is bloated with features that it's userunfriendly.
I have parents that are pretty not tech literate (they didn't how to save contact or send SMS) but they have no trouble navigating Facebook app for the core set of features they use.
I would like to know your arguments against it. How would you define a maximum count of LOC, why would you set that particular limit, and how would you address the "problem" if your team were to hit that limit?
We're transitioning to Kotlin. And our main problem with it is slow compilation.With only Java is was <2mins and we're touching 10mins now.I'm not sure what exactly the problem is as we still have to investigate. Our use of Kotlinx.html (which we absolutely LOVE as HTML templating tech) seems to be a part of the problem, but we have not gone to the bottom of it yet.Nothing against the language, everyone on the team loves it (when Java is what we consider normal). The extra type safety we get out-of-the-box or have put some effort into (using KFunction all over the place) is really paying off.
I wanted to post that ktfmt, the FB Kotlin formatter, is much less well-known than ktlint.IMO, it produces the most (subjectively) readable code, and is the only one that doesn't leave room for you to inject personal style in certain places. (ktlint will let you get away with one of several ways of formatting code, so long as it falls within some guidelines, which can lead to inconsistent formatting).It's a superior formatting tool IMO.https://github.com/facebook/ktfmt
These two formatters both suffer from the flaw that what intellij does when it autoformats is different from what either of those two do and can only be controlled through plugins. Especially when it comes to controlling imports this stuff is just broken in Intellij. The settings for this are not actually part of the code formatting settings.Most sane code formatters & code standards: "don't use import wild cards!" Intellij's default since forever: "wildcards all over the place; please jump through hoops to get rid of them".I've given up on having code formatters in my kotlin builds for this reason. Just not worth the hassle of trying to make both sides just do the same thing by default so I don't have to think about it. And then having to explain to every new team member how they have to customize their intellij setup so it isn't broken. I just gave up on it. These days I tell people, auto format your code, leave the settings alone. Try to only format the code you modified to avoid endless formatting related diffs.The fix would be for Jetbrains to finally fix their IDE to have proper formatting that includes the behavior of organize imports and is perfectly in sync with whatever your build file says is the code style rather than whatever manual or built in stuff. Any IDE settings for this should IMHO just be removed as they are completely and utterly wrong in the presence of a build file that says how things should be formatted. Just default to whatever your build file says is the code standard with some sane default that just comes with the kotlin compiler. This should not be optional. You want to override it: do it in your build file.Auto format on save in intellij. CI build verifies that nothing is mis-formatted because the IDE did it right because it does whatever the build file specifies needs doing without second guessing that. Have a githook to format before commit (optional). Zero manual fixing of anything ever related to formatting. It should not have a chance to go wrong and break the build unless somebody forgot to format or have a commit hook to do so. Just import the project and everything does the right thing. That would be the goal. IMHO it's not technically hard but it would require addressing what is likely to be quite a bit of technical debt related to this in intellij. And it's about time they did that.
Not sure what's preventing you from setting up Intellij to do what you want, even without .editorconfig.  I setup intellij editor format preferences to follow the formatting I setup with my build-based linter/formatter.  I just change the IDE settings so that they match my formatter, use it as the project setting, and then commit the codestyle files in .idea folder so that it's always there when I import or open a project.  Never have to touch it again, autoformat in the IDE works and is 100% compatible with my ktfmt, ktlint, checkstyle, spotless or whatever.  Imports, order, line wraps, indentation, etc...  it 'just works' for me.Yes, it's a minor additional step at first, but it's like 15 minutes tops, and after the first time you do it, you simply copy the xml from project to project if you want to use the same settings.
What you are suggesting here is a lot of manual work. What I'm complaining about is that there is no sane/easy way to avoid having to do all of that and getting everybody on the team to do the exact same things.This should be as simple as "import the project". Done. There should not be any extra steps. No settings fiddling. No magic files to copy. No plugin installations to intellij. Etc.
You wrote this entire comment but ktlint can generate a .editorconfig (and in fact used to generate a IntelliJ specific config file) which is a universal way of solving this exact problem.Pretty sure the FB equivalent also has a matching .editorconfigAlso you could just setup a prepush hook so they run before your CI does which afaik both give you examples of.
I use pre-commit/pre-push hooks to apply formatters like Spotless/ktfmt etc, it's too much work to try to fight Intellij's formatting.There's a ktfmt IntelliJ plugin that does work most of the time IME, if you're willing to give it a shot.
My auto-generated config has been pretty solidThe only time the pre-push hook fails is if a line is too longandthere's no "canonical" way to fix it (so it'll create a method chain for example, but it won't do string concatenation since there's N ways to break a string across lines)
I had it act generally "weird" when adding it to our codebase and ripped it out.Sometimes it'd hang for several minutes, memory usage would spike from time to time.Didn't have time to bother debugging when ktlint just worked immediately.
When was that? IS that a big codebase? I fixed a memory leak issue a few months ago that would have a big effect when running over hundreds of files at once.
More than a few months ago, and a fairly large codebase (~1000 files).I might give it another try for some personal projects since I did like the anti-bikeshedding angle with respect to configuration, but yeah linting can be a hard sell once build performance starts to suffer for it
Most likely this fix would make a big difference then:https://github.com/facebook/ktfmt/commit/6ea9e8f461853c32177...
One thing that Kotlin got going for it is the tooling. I mean, the creator of Kotlin creates some of the best programming tools out there so I'd imagine (without actual experience of Kotlin) that it has great tooling.Sometimes, the tooling is even more important than language features IMO. It makes developers move quicker, find bugs easier and so on. I like the idea of Kotlin, that it can compile to jvm bytecode, javascript and native.So in essence, I can use the same language everywhere in the true meaning of the word.
> Sometimes, the tooling is even more important than language features IMO. It makes developers move quicker, find bugs easier and so on. I like the idea of Kotlin, that it can compile to jvm bytecode, javascript and native.The only thing I'd worry about is Java overtaking it.Do you remember Coffeescript? There was a point in time where it had impressive adoption, and quite a bit of buzz. But then Javascript added features, and all of a sudden the tooling burden associated with Coffeescript just didn't make sense any more.With Oracle's 6 month release schedule, that's a distinct possibility. Especially since Java can no longer rest on its laurels as a language (if Oracle doesn't want it to become Cobol 2).
Kotlin is plenty safe for now.* Android is a massive platform, and Android is basically stuck on JDK8 (or JDK11 with desugaring, wooo).* iOS compatibility-ish. KMM is not ideal and mostly generates ObjC compatible objects (so generics are mostly screwed for Swift and writing iOS code is not ideal, but even being able to define common and enforced contracts is cool. iOS benefiting from projects like SQLDelight is super cool)* Jetbrains hedged their bets, and Kotlin/Multiplatform is a solid option. Coupled with Jetbrains Compose for UIs as well as having the entire Java ecosystem available is very solid. Compilation for so many platforms, directly to native executables is cool.* Java is still very slow to evolve. Kotlin has had data classes for a long time, Java recently added records. Inline classes offer some nice type safety at basically zero costs. Coroutines and structured concurrency are a beautiful way to work, and Project Loom would only build the foundations of that. Context extensions (while terrifying in the potential for spaghetti code they offer) are a useful feature, reified generics have some great potential.Now, Kotlin has its disadvantages too. Compilation times are not that great (hopefully K2 fixes this partly), but it's relatively safe and is kind of more than just a JVM language by now.)
I agree with everything you said except for "Java is still very slow to evolve."New Java versions are cut every six months since 2017 and since then has added a significant amount of new features, syntactical sugar, APIs, et cetera. Not only that, but they've also have been pretty aggressive IMO in deprecating and removing legacy. Very very different than the Java I remember working in years ago.
> New Java versions are cut every six months since 2017 and since then has added a significant amount of new featuresAnd yet, the overwhelming majority of the Java community are still using JRE8 with none of these new features.There are some that love this new pace of language development, but very few are actually using new features in production code.
The hesitancy in jumping beyond JRE8 is the large backwards compatibility road bumps in JDK9-11, and now again with 17/JavaEE->Jakarta. I wish Java would continue to add new features but be a lot more considerate of avoiding, completely, migration headaches.We are migrating Java 8 -> 17 now and it’s been a right royal pain. I’m glad we didn’t jump to 11 LTS, and instead make one big leap. It might be a very long time before we do another LTS upgrade if they keep making poor migration choices.
The only relatively bumby migration was 8->9. After that it is a very smooth ride, and that bumpiness was the price for the accumulated tech debt/slow down from the end of the Sun era.
Well, my understanding is (but I have yet to personally experience) the migration from 17 -> 18+ is rough because of all the javax.* packages being renamed jakarta.*Which likely means touching a pretty significant portion of your codebase for the upgrade, and then who knows what 3rd party libraries you depend on are expecting...So it may be as simple as Find/Replace for some folks, for others, it might be a deep dark rabbit hole.Not breaking things used to be Java's MO. Yes, that means a ton of legacy cruft built up over the years... but we used to be able to depend on Java to "Just Work".Perhaps some of this is necessary. After all, the C# folks seem to have no problem breaking everything to add new features... but I'd assert the Java community as a whole is much less tolerant of breaking changes and rapid deployment of features.
There are entire segments of the industry that has never touched any javax package - while no doubt widespread, I do believe that it is still a very fair price to pay, and none of these changes were even half as problematic as for example the python 2->3 migration. So I don’t know, I’m fairly sure it is impossible to keep a platform alive with even less/smaller impact breaking changes.
javax -> jakarta is entirely dependent on your dependencies not the vm.There’s plenty of dependencies that provide javax implementations as well as jakarta.
8 -> 9 wasn’t that hard for me personally. For our applications it was just adding things to the build to make sure javax.xml was present.The real difficulty for us was upgrading the Play framework since the Scala community likes to make breaking changes with every release.
In HN a while back, an Oracle dev pointed out that the evolution is slow for a reason. Which confirmed slow. New releases every 6 months, but not that much in the way of changes.
This isn't criticism of the fact of it or going into why it is or whether it should be that way. It's just a statement of fact.
You're correct of course, but to back up the parents comment, they do have a habit of implementing things other than the low hanging fruit that developers are frustrated not having, leading the drive towards other jvm langs
What are some examples of those low hanging fruits?
Functional/SAM interfaces (transforming interfaces with a single method into a simple lambda), pleasant usage of lambdas (last lambda parameter can be put outside of the call like(this) { ... }, leading to a language that lends itself really well to building a DSL, coroutines were not a low hanging fruit but absolutely are infinitely more pleasant to use than RxJava, operator overload including invoke(), ranges that are pleasant to use (0 .. 10).forEach { }, or when (floatVariable) { in 0.0f .. 1.0f -> ... }, pattern-ish matching with when (not quite full on functional language powerful, and I believe that Java is not only catching up to it but making their switch quite a bit better), a standard lib that is packed full of extremely useful and consistently named methods, extension functions, delegation (if you inherited a SDK that has a piss poor interface, you can simply make a SDKWrapper(val internalSdk: SDK): SDK by internalSdk, which means that it will automatically implement it, and you can then have your wrapper do whatever around it (logging, better functions, DI, etc.)))Kotlin is truly a pleasant language, both when you don't know it (although it can look a bit symbol soup-y at times for juniors), and when you fully know it.
Just browse through the Kotlin standard library. It's basically just a set of mappings to the Java standard library with a whole lot of extension functions to make it easier to use.
> iOS compatibility-ishI don’t know how well it works, but we have seen these kinds of projects, and they seldom work as is. Not sure how well Scala Native works, even though it predates Kotlin’s try. (Though scala.js is surprisingly good!)But do you really think that a relatively young language like Kotlin with minuscule adoption (compared to java) will be better at this game then Java?Java has averygood compiler to Js maintained and used heavily by Google (j2cl, part of their closure compiler toolkit), which can also output obj-c code. These are/were used heavily for porting their shared libs between basically all platforms.For native, Graal is a very cool way forward benefiting all JVM languages (as well as scripting languages, its polyglot features are insane).> Java is still very slow to evolveIs it a problem? The majority of developers don’t like running after the language, even though it may seem so based on online hype circles.
>I don’t know how well it works,Well enough, provided you stay within the known bounds. Hell, some people at Touchlab even went as far as porting Jetpack Compose to work on iOS (which, uh, I would not recommend in its current state), and it technically works. I probably wouldn't recommend writing all of your app logic in Kotlin, but being able to share the data layer is amazing.>But do you really think that a relatively young language like Kotlin with minuscule adoption (compared to java) will be better at this game then Java?It depends on where you're looking. Most modern android development will most likely be done in Kotlin. Backend work, for things started relatively recently, Kotlin is not surprising. But mostly, Java does not make iOS compatibility a goal. Java tell you "get a JVM and run our shit" (or get GraalVM and have basically an embedded JVM). Kotlin has two sides, and Kotlin/Native does not depend on the JVM.>Java has a very good compiler to Js maintained and used heavily by Google (j2cl, part of their closure compiler toolkit), which can also output obj-c code. These are/were used heavily for porting their shared libs between basically all platforms.j2cl still brings in a light JVM to the Web. Kotlin does not. It provides interop to the JS APIs as well as its own tech, but it's not meant to take your Kotlin code and immediately run it on the web (which is an awful, awful idea). You're still meant to write your browser specific code, your android specific code, your x86 specific code, etc. In any language you want, even! Write it in Kotlin/JS, or let your typescript consume the Kotlin/JS bindings. However, you can have a common base that'll work everywhere.> For native, Graal is a very cool way forward benefiting all JVM languages (as well as scripting languages, its polyglot features are insane).Graal is an extremely cool project, but with different goals. Write once, run everywhere is a lofty goal, but it only works on very similar platforms (Windows/Linux/OSX). Kotlin has taken a Write once, specialize what is needed approach.
>  even went as far as porting Jetpack Compose to work on iOSWell, Gluon promises the same for JavaFX apps and there is a sample app actually downloadable from the AppStore.> j2cl still brings in a light JVM to the WebNot at all, it compiles toveryoptimized Javascript. Oh, and I forgot to mention that there is also teavm, which is not a VM contrary to its name -- this latter transforms java byte code so it works with guest languages as well.
> but being able to share the data layer is amazing.why not just use swagger/openapi + auto generated models?adding kotlin native adds huge depenencies relative to the tiny benefit of a datamodel that can be auto generated to native code imo
Swagger + OpenAPI generates data classes for you, and maybe a Retrofit/Ktor/Whatever interface. It does not handle repositories, data fetching, caching and combining, it does not handle a SQLite database.Which dependencies ? If you already have Android devs, on the iOS side it adds a single swift package, and similarly so on Android.
> It does not handle repositories, data fetching, caching and combining, it does not handle a SQLite database.right, but you can use that to autogenerate all those things (have done it before) with a few additional tools (code templates) and have it all (repositories, fetching, caching etc) automated (there is a limit of course, combining might be a bit hard in that case)this is really useful though because now you can deploy to more platforms in their native languages using idiomatic code, and switching to newer techniques, e.g async/await can be done instantly just by updating the source template which any team can download and compile themselves> Which dependencies ? If you already have Android devs, on the iOS side it adds a single swift package, and similarly so on Android.for ios, its including basically the whole kotlin runtime and additional support (kotlinx-datetime, etc) in that single package (xcframework), then add a lot of data classes and things start to add up... for us its one of the biggest single dependencies on our ios app
Do languages really need new features every N months to stay relevant?
Depends. Is stuff like context receivers (https://nomisrev.github.io/context-receivers/) needed ? No, although it's a fun experiment. Are multiple receivers needed (https://youtrack.jetbrains.com/issue/KT-10468/Multiple-recei...) ? Not really, but when you are dealing with the JVM, nested class hell is a very common thing, and cleaning up your code is always pleasant. Implicit namespacing ? (https://youtrack.jetbrains.com/issue/KT-11968/Research-and-p...) Fun thing to get.The thing is, they're all optional. You're never going to use any of these features if you don't need them. Your code can stay as a nested list of calls. But put them all together, and you can have code that is super explicit about what it needs to do, without having to re-pass things that are already there.
> Do languages really need new features every N months to stay relevant?I think a fixed N month release schedule is much healthier than what Java did before, which was wait until everyone was on the bus in order to ship, which resulted in multi-year delays.
No, but fortunately Java doesn’t do that. They have long running projects, when one is nearing completion it will be put in preview in the upcoming release. No rush to make it into anything, it’s ready when it’s ready. (Which should be copied by the rest of the industry as well)
Depends.  Are the features making things better, or just more complicated?Even if it makes things better only for, say, 10% of users, but doesn't make it worse for the other 90%... the users will take that every N months for as long as the language authors can do it.
I’m not a Kotlin user, but this struck me as ambitious:> having the entire Java ecosystem availableand, in the same point:> Compilation for so many platforms, directly to native executablesDoes this mean you can compile pretty much any Java libraries to non-JVM executables?
No, if you are targeting a different platform you can't use JVM libraries.If your target is JavaScript, you can use JavaScript dependencies (sort of: they won't have any type bindings so you will need to code then yourself) but you can't use any JVM libraries on it.
As other said, yep, you do not get the Java ecosystem if your target is native executables (or JS). there are alternatives like kotlinx-datetime, kotlinx-serialization, the kotlin stdlib. However, if you know you're going to stay on a JVMable target, feel free to not use Kotlin/Multiplatform, but regular JVM Kotlin libraries
No, if you use Kotlin native you do not get access to Java libs.
Slow to evolve and long-term backwards compatibility are selling points.
Wasn't it Typescript that made CoffeeScript obsolete? Not better JS
IIRC the main appeal of CoffeeScript was syntactic sugar like lambda expressions etc that were missing in ECMAScript 5. 
I think ECMAScript 6 made most of the appeal of CoffeeScript obsolete
When CoffeeScript came out, I vowed never to write plain Javascript again. I kept to that vow for a couple years, but eventually broke it when ECMA 6 came out. Really the only thing that put real technical justification behind CoffeeScript was the double arrow function, and maybe the neat class syntax. Beyond that CoffeeScript is just prettier. Even though I was in charge of choosing the technologies, you got to skate where the puck is going, and the puck was clearly not staying with CoffeeScript.ECMA 6 copied all the good parts out of both CoffeeScript and jQuery, effectively obsoleting both. Modern JavaScript is almost unrecognisably different from what it used to be, and that's a very good thing.
The availability of lodash made us dump any ideas our shop had about widespread coffeescript use.
"Our codebase is in CoffeeScript" tended to draw grimaces for years before Typescript came around.And no, they serve totally different purposes. Coffeescript tried to make JS syntax and variable scoping behavior non-shit, while Typescript adds static typing while changing very little about the core language syntax.
CoffeeScript never became popular in the first place. I stopped seeing it anywhere even before TypeScript caught on.
It was a thing for a hot minute in the early 2010s, before ES6, TypeScript, and the React/Angular/Vue trifecta came along and solidified what JavaScript would be from ~2015 onwards.
I ran into Coffeescript code on GitHub for the first time in years last week. Oh, Coffeescript, I remember that used to be a thing.
It was the default for a while for Rails apps and Wiki tells me GitHub & Dropbox adopted it before moving to Typescript.  I think for Rails shops it was popular and there was a brief time where it looked like it might become the thing to do on the front end.  But I don't think it ever got the interop with existing JS right.Ultimately, improvements to JS came along and took the wind out of CoffeeScript's sails.  Then TypeScript came along and killed whatever interest remained.
Really, it was a combination of both.
Don't forget about WASM as another platform; it's coming as well. An experimental version actually ships with 1.7; it's just a bit unstable and under documented and very much a work in progress.I think Oracle is catching up slower than Kotlin has been evolving in terms of new language features. Most of the stuff they add to Java (including most of the stuff they are talking about adding), Kotlin has been doing for quite some time.  Kotlin is pushing out minor releases about every 3-4 months and major ones pretty much every year. Basically, they do 2-3 minor versions in between major ones. The pace is relentless.If anything, Kotlin could use an LTS release because it's actually getting hard to keep up with the ecosystem.A slower pace might be helpful with that. The main issue with frequent releases is that many libraries take weeks or even months to update and don't necessarily work well (or at all) with newer Kotlin versions. I've had repeated issues with e.g. code generation plugins requiring specific version of Kotlin breaking because some other library suddenly requiring something newer. So that then starts blocking a lot of library updates. We've actually put some effort in unblocking some of this for some of the dependencies we have by creating pull requests.But I'm excited about the next 1-2 years. I expect Kotlin native to stabilize and grow beyond just being a thing for IOS. I also expect wasm support will become usable in that time frame. I hope to be able to use it with WASI for edge networking or serverless stuff. And maybe even some command line tools. IMHO Kotlin has potential for data engineering as well. There is actually jupyter support for Kotlin. And some machine learning frameworks. It's becoming a proper full stack language.
Yes that's right. In fact, Kotlin really works well with the IDE. But they didn't spend as much time in creating a language with a good and sound theoretical foundation. This works in the short time but shows its flaws later. Java is a bit better here (but quite slow though).So yeah, I can see Java potentially overtaking Kotlin.
I don't know about that comparison. CoffeeScript transpiled to JavaScript- Kotlin doesn't transpile to Java, it compiles to JVM bytecode.So in a sense, from a tooling and compiler perspective, they're orthogonal products, similar (I guess) to C# and F# on the .NET CLR VM.
This kind of happened to Groovy, but I think Kotlin was the killer in that case.
Groovy was too much of a "scripting feel" to it, maybe because the primary project was Gradle.Scala had a massive much more prominent project to rely on - Spark.Kotlin is getting traction because of Android.
> Kotlin is getting traction because of Android.Kotlin is seeing major adoption on the server.
Obviously kotlin has great tooling, coming from an IDE company.But I think the main strength of Kotlin is it being so damn developer-friendly compared to Java and Scala.
Do you know of any good backend web frameworks for Kotlin? I would wish for something like FastAPI for python. Kotlin may actually be a great fit for a service I want to build and I hadn't really thought of it as an option until now.
If you want something old and battle-tested, Spring Boot works just fine in Kotlin. I found the extreme OO design kinda off-putting, but once I got over it I had a great time with it.KTor [0] is the 'native' web framework for Kotlin, and there's also a full-stack framework built around it that just hit version 1.0, KWeb [1].[0]https://ktor.io[1]https://kweb.io
Well I care more about simplicity and easy to develop in rather than battle-tested. Something like the Javalin or http4k would probably suit me the best.Of course, I have checked Ktor before, but I don't know if I particularly fancy the way they are structuring stuff.My main issue with the java ecosystem is that it's way to enterprisy for my taste. Everything is so unnecessary complex and hard to reason about, but I will take a good hard look at Kotlin before making my decision. The thing is that I am really interested in the native compilation that Kotlin offers that would be very beneficial for me and the only reason behind picking Python otherwise would be that it is a nice language and already installed on the linux environments it will run in.Basically I will have a big api and drop (preferrably) a single binary to some machines that will talk to the api. These machines will generally be outside of my control. I have looked a bit on Rust but it seems a bit too low level and hard to work with. I have looked at Deno because it can compile down to a binary but using javascript for this project seems like a bad choice. So I chose Python at first because it seemed easy to get going with, had great tooling and is already installed in the environments I will be dropping a script in.
Hard to imagine anything less "enterprisy" than http4k. Zero dependencies, totally modular, and can easily produce a single binary that contains your web app and the web server itself. No Spring, no Tomcat, no app servers necessary. Install a reverse proxy in front to handle HTTPS. Same goes for ktor.
Ktorhttps://ktor.io/
A few years ago, I used dropwizard for both a service that ran locally and for the cloud backend at a startup. Kotlin meshed very well and we never encountered any issues with either.  Also just worked on a project that used micronaut which was less mature and not very intuitive, but did support Scala and Kotlin (a goal in that project).
Javalinhttps://javalin.io/
Micronaut, http4k
Nobody mentioned this yet: Vert.xIt has great Kotlin support, including Coroutines. I've introduced it into our team for a major rewrite and we are very happy about 18 months in.
Personally, I like that I have lots of options available. Compare it to .NET and it's "Microsoft way or the high way".
Both approaches have pros and consI prefer having one decent tool thats used across almost all projects like asp net for webinstead of 5 things with their own quirks and pros consIts annoying to have to relearn boring things on company changeLike orms, web frameworks, etc.When you need custom solutions then you gotta put effort anyway
Well, spring is pretty much exactly that, and is probably used more than all the other mentioned projects combined.
Agreed. Having to the ability to make those decisions is a feature of Java development, not a bug. YMMV.
Spring Web MVC
There's been a lot of work in Scala land to improve tooling, see Mill as an SBT replacement.
If only Kotlin had Scala's frameworks.
As for me the greatest appeal of Kotlin is that it doesn't need its own tooling that bad, it feels like just syntactic sugar over Java.Both Scala and Kotlin can reuse Java tools, but with Scala it's awkward (and some tricky generics simply don't compile with Scala).E.g. if I need to parse something, I search for "how to parse that in Java", not "... in Kotlin".
> and some tricky generics simply don't compile with ScalaWhat? Do you have any example that wasn't fixed years ago?Any non-trivial Scala app will consume dozens if not hundreds of Java libraries, without any issue.
I filed an issue for Scala in 2009, that was answered like "sorry, this particular Java code cannot be used in Scala". In 2012 it still wasn't fixed.I cannot find the issue now, but I remember I was trying to use gae-mapreduce-java library (built on top of Hadoop interfaces). It couldn't compile with Scala.
That's eons ago in Scala world. If you can, give it another try.I would assume such a bug was fixed in Scala 2.x given the prevalence of the language in the hadoop ecosystem and big data frameworks.Moreover Scala 3, was the opportunity to fix many previously-unfixable corner cases.
The biggest advantage of a statically typed language over a dynamic one is the tooling. Refactoring statically typed code, after working with JavaScript for a few years, feels like magic because the tools just make it work
> Sometimes, the tooling is even more important than language features IMO.That would be always. Tooling makes or breaks pretty much every language. Language itself is just a syntax that you write in.
Have you ever actually tried kotlin native? Compiling a "Hello World" program takes at least 5 seconds. That's absolutely absurd.
I've found that migrating all your trunk code (data and infrastructure classes) to kotlin is the biggest win, and you can leave your old leafs (fragments and view models) in java if you want do a low risk migration. If a view isn't broken, you don't need to fix it, but getting nullability annotations in your data models and REST commands is a huge win for newer views and business logic going forward.
I'm currently working on a project which has both Java and Kotlin and I really have to say that I like working on the Java parts much better than on the Kotlin parts. I find coroutines a really strange and leaky abstraction (and the prevalence of suspend methods in libraries which you have to wrap all the time just to call them synchronously is really annoying).With streams and the var keyword, Java is also not that much more verbose anymore than Kotlin and the code completion, error detection and refactoring capabilities are much better in Java. In Java I can also be sure that if I directly access a property on a class, there will be no side effects or expensive operation while if I use a getter, there might (and I dont have to write them either due to code generation or Lombok). So the parts where Java is still more verbose actually add clarity (and again, due to the IDE, you rarely have to type any of it): I dont really get why I would leave out the explicit types in the source code, only to be added again as non-editable, weirdly positioned text by the IDE (which is not there if just wanna have a quick look at the code on GitHub).
Sure, but the one thing Kotlin has that makes me never look back is null-safety. Java has optional and non-null annotations and whatnot, but you have to be vigilant and put the right annotations everywhere. Kotlin you get this for free.The extra sugar on top is super nice too - listOf, mapOf, x to y, apply… I think it just makes code that much cleaner. None of these are make or breaks but together they work amazing. A lot of what I work on professionally is still on Java 8 or 11 so I don’t get any of the cool features like record types.Most of the OSS I do is Kotlin bedsheets I just enjoy writing Kotlin. I don’t feel that way with the older versions of Java (I’m starting to with the newer ones).
While I also love many things about Kotlin, the one thing that always sticks out like a sour thumb is error handling.While Javas checked exceptions had a lot of problems, at least there was a way to declare the output (errors are ouput) of a function on a type system level.With Kotlin, that's just gone. You can fiddle with Result type (or make your own), but you lose a lot of the ease of "bubbling up" errors.How do you handle errors? (I wished Kotlin had error handling like Rust, which is the best that exists, imho)
You might like Scala (possibly enhanced by something like Monadless or Each , but personally I find the explicit for/yield approach very worthwhile).
How does this work in a SOA situation?  Like do you have null checks + default values at every HTTP boundary for your application?
Most frameworks give 400 bad inputs. If the client gives a null but null is not allowed in the type, it will auto respond with 400 before it ever invoked the handler.Java spring does the same thing: if you use an unboxed type (int instead of Integer) and the client passes in null, the handler will never be invoked.
But if you have an evolving API, you are back to what was asked.  Either you are a bit of a jerk to all of your existing clients, or you have default values at the boundary.I've found myself with this a lot on "progress" data classes where I will be building up a set of data over several expensive calls.  I /could/ make a new type per current state of that, such that I never have nulls.  I /could/ make it so that every field is Optional.  Or, I could work on a convention that fields are filled out in order, and after the first null, nothing is available.  In many years, this has not been where null pointers hit me.
To add to this I had a specific scenario in mind.  At @current_job they bolted on a immutable struct library and wrote validations.  We are responsible for sending out renewal notices and we get the renewal price from another system.  In certain scenarios we were getting back a null price and our validations dutifully caught the null and threw an exception.Theoretically everything worked.  However, the end result is (1) the customer didn't get their renewal notice and (2) we got a validation error instead of (maybe) a NPE somewhere.  So what exactly are we accomplishing here is my broader point.
To be honest, this is more of a question about how best to handle errors in asynchronous event handlers (not handlers marked as async, I mean like send an email at xyz time). Imo best way to solve this is to get notified of an error in sentry, be it an NPE or validation error.In a case where the client expects an immediate response (http GET) getting “400 validation error: foo is not allowed to be null” is a lot more meaningful than “500 Null pointer”.In general I try not to model invalid states - less mental overhead (no one has to tell you xyz can’t be null it just cannot be null).Ofc this is a matter of opinion and the lines get blurred as soon ad you move stuff to runtime.
I believe the standard practice (as popularized by Google) is that all fields are optional. This allows you to deprecate fields in the future while still support older (non-updated) clients.
Yeah, my question is more about what you do as a consumer.  How do you get back null safety if every field in the response is optional?  Even moreso, in a SOA situation where 90% of what you work with comes across a HTTP boundary.
I'm not sure I understand the question. If you have only Optionals and Null does not exist, a NPE is impossible. The Optional type forces you to handle the empty case, so null safety is enforced by the type system.
The question is how do you handle the empty case for the hundreds of fields you pull from other systems.
You handle it how you would have handled fixing a NPE which shows up in production. Except now you handle itbeforean NPE ever shows up because the type system forces you to.
I think coroutines is probably the best implementation of cooperative multitasking (async/await) that is is available in any language: They build on structured concurrency and thereby allow to prevent a few common concurrency problems like runaway tasks. You can run them on different threading systems, like UI threads, threadpools, etc. And they default to run the continuation on the correct thread.However as any async/await implementation it will obviously still have challenges. The "colored" world of functions means users need to know the differences between suspend functions and other functions, and using something wrong can lead to performance issues.One thing to note is that with the upcoming of virtual threads (Project Loom) in Java itself, the need for using coroutines might become much smaller. You might just end up using them for UI work, and everything else could use virtual threads. That could simplify a lot of things.
Loom will just slot into co-routines without requiring many (if any) code changes. It's still going to be nicer to use co-routines from an API point of view and they'll just use the loom stuff underneath pretty much transparently when it is available. A virtual thread is basically just yet another thing that you can wrap with a co-routine. There are many such things across the jvm, js, and ios-native platforms that are supported via Kotlin already.And since it is API compatible with things that are already supported by co-routines, pretty much all you need to do is change your custom co-routine contexts to be backed by virtual threads rather than actual threads. This should just work even without explicit support for this in the co-routines library (it's just another thread pool). But they obviously will add explicit Loom support as well as it makes sense to make co-routines be virtual threads pretty much always.When that ships, all current kotlin code that uses co-routines will be using virtual thread on a Loom capable jvm. It already has structured concurrency and all the rest so all of that will continue to work. And some of the blocking Java stuff that you currently need thread backed co-routine contexts for, will stop being blocking so you can stop doing that. But it will still work of course.
I guess you could "slot loom into co-routines", but the niceness of loom is that you don't even have to use coroutines. It could just be regular "blocking" Kotlin functions which run on virtual threads.If you already use Kotlin coroutines - fine to continue to use them. But I imagine for a new project you might want to opt to build on virtual threads instead of coroutines.
> With streams and the var keyword, Java is also not that much more verbose anymore than KotlinI have no experience with Kotlin yet, but I recently did some Java after years of js/ts, and was nearly driven mad by constantly having to convert different kinds of collection. String[], Array, List, Iterable, Stream... and every library expects or returns something else, so you're constantly converting these things.Any of them would have been perfect if only it had been supported by everything, but because of Java's long history of constantly inventing newer and better ways of doing things, libraries written at different times support different kinds of collections and you constantly have to convert them.
I agree to some extent, however, IDEA often helps you with that (e.g. by converting arrays with Arrays.asList(array)). And I have to disagree: Any of them would not have been perfect. An array is sometimes significantly more performant and requires less memory than a list.In the different collections, you see a history of 20 years of developer experience improvements coupled with an almost religious emphasis on backwards compatibility in the language and standard library.In every (long term) JS/TS project I worked on, about 20% - 50% of the development time went into upgrading libraries and keeping everything running on the current node version. It was maddening. Stuff like the different types of collections are a very small price to pay, IMHO, if you can be sure that your current Java project will with very high probability also run on a current JVM 10 years from now.
> Any of them would not have been perfect. An array is sometimes significantly more performant and requires less memory than a list.That's actually why I prefer List, because a List is an interface and can be an ArrayList or another type of List and I don't care about the implementation, as long as it's a List. But Array is an array that's not a List, and Iterable is also an interface, and I think a List is also an Iterable, but I'm not sure, and I suspect not every Iterable is a List. And then there's Stream which should have been a set of convenient functions that are part of List or Iterable right from the start, but they're not. And what the hell is a Spliterator and why do I need one to turn an Iterator into a Stream?I understand that there are reasons for this, and I totally agree that the js/ts dependency situation is far from ideal, but it's still maddening to have so many different collection types, when js/ts just has an array that's not even an actual array, but it still works fine, and all the new stuff just gets added on top of it.One of these days someone should invent a new programming language that finally gets all of this right once and for all, but I bet people will find ways to improve it again.
> I understand that there are reasons for this, and I totally agree that the js/ts dependency situation is far from ideal, but it's still maddening to have so many different collection types, when js/ts just has an array that's not even an actual array, but it still works fine, and all the new stuff just gets added on top of it.It "works fine" for basic cases but it doesn't give you anything like the same capabilities. JS/TS have no easy equivalent of array or stream, anything you could write in js/ts you could write in Java by only using ArrayList. Java's collections library is big and complex but almost everything that's in there is there because it has a use case, and while it's showing its age now it was well designed for its time.> One of these days someone should invent a new programming language that finally gets all of this right once and for all, but I bet people will find ways to improve it again.Your best hope is a language with Haskell-style typeclasses where you can not only add new implementations of existing interfaces, but also retrofit new interfaces onto existing implementations. No library is going to be perfect from day 1, and a big part of the reason why Java Stream is awkward is that it had to be retrofitted into the existing collection library.
I'm curious what libraries you are dealing with that are so opinionated on what collection type you send to them?  In my years of working with Java, I think I see List.  And... yeah List.  That is about it.I have had some internal teams try to use Iterable or arrays, thinking they needed to be optimized.  Almost without fail, those are from teams that stall out and never actually finished what they were doing.I have seen case studies of giants that actually needed to optimize down to arrays or buffers, but this is often not the case.  I'd imagine unless you are trading or gaming, you can get more than enough mileage out of List.  (Specifically ArrayList.  LinkedList is usually a sign of premature optimization without having actually benchmarked what was running.)
In your own code you should always use one of collection classes, usually Iterable, Collection or List, depending on which features you need.Stream usually is not used other than for call chains. Like list.stream().map(...).toList();I write Java for many years and I can't really say that this was source of pain for me. I agree that streams could be implemented with better ergonomics, but Java designers wanted to provide us means to use parallel computations with one extra word, so here we are. I've yet to find a place where I'd want to use that.I used collection classes in Java 1.4 and I'm using them in Java 19 and I don't think that anything changed in that regard. Collections are the same.
> In your own code you should always use one of collection classes, usually Iterable, Collection or List, depending on which features you need.Yes, but every library I use requires or returns a different one.> list.stream().map(...).toList()But why not list.map(...)?
In this specific case I think it is because stream operations can be implemented lazily - they only run once you call toList()
This sounds like you are trying to shoehorn asynchronous kotlin code into synchronous Java code. Which would be doing it wrong. The problem is trying to make asynchronous code synchronous: don't do that. The whole point of asynchronous is to do it end to end and isolate the remaining synchronous bits and pieces that you have on separate threads so they don't end up blocking all the asynchronous bits and pieces that you have.Use a proper asynchronous framework and then the only thing you need to worry about is avoiding calling synchronous code on your main thread (i.e. dispatch it to some thread pool backed co-routine context). Not that hard. And you can get rid of a lot of that stuff by gradually switching to non blocking versions of whatever you are using.If you are exposing class properties without accessors in Java, that's not necessarily a great thing. Especially if your state is non final (i.e. mutable). In Kotlin, you'd use vals (or vars if you really have to) and by default they just behave like they have getters/setters. But you don't have to spell it out. And you can override the getters and setters. Just like you would in Java. It's just the distinction is not there. It's basically a less hacky Lombok.The weirdly positioned text that your IDE adds are called hints and you can turn them on or off as you please. They are there to help you. Type inference is a nice thing: it means you can read the hints without having to spell out what is what. Java has type inference too but it's a bit more limited and more verbose. There is no uncertainty about what the type of anything is in either language: exactly what you specified (but just once in Kotlin's case).
> I find coroutines a really strange and leaky abstraction.I've only used Kotlin on Android, but from what I remember co-routines are not necessary to use. If you don't like them, then don't use them.Kotlin has a number of advantages over Java. The biggest of which is built-in optional typing. It's also really nice that everything is expression instead of a statement. Library functions like `let` also make code a little nicer to write. And stuff like data classes and better property initialization are icing on the cake. In my opinion, you can write Kotlinexactlyas you would Java, but the development experience is much more polished.
>  built-in optional typingTyping is not optional, everything in Kotlin is typed. What the language has is  type inference. The following lines have the exactly same types:val teens = people.filter { it.age < 20 }.map { it.name }
  val teens: List<String> = people.filter { p: Person -> p.age < 20 }.map { p: Person -> p.name }
Just for comparison’s sake, java is not significantly more verbose.final var teens = people.stream().filter(p -> p.age < 20).map(People::name).toList()
Keep in mind, you can use Kotlin in any JDK8 project and instantly get all those features. What you're proposing requires upgrading to a new JDK.
Upgrading to a new JDK is significantly less work than upgrading all your tools to support a new language.
JDK 8 came out in 2014 - Internet Explorer was still widespread at the time.
Well, the new Android UI framework (Compose) is fully based on Kotlin and coroutines.
> With streams and the var keyword, Java is also not that much more verbose anymore than KotlinIn general Kotlin is more concise, checkout these comparative examples:https://stackoverflow.com/questions/34642254/what-java-8-str...
Those examples seem very biased; often the Java version does not use a more concise method that's available, or bloats the code by not importing a static method.
The Java examples are quoted from a Java stream tutorial.
Sure, which was probably optimised for explicitness (e.g. showing where everything is imported from) rather than concision.
>I dont really get why I would leave out the explicit types in the source codeOne my pet peeves, shit like this sucks :var f = MyStupidMethod();
In practice, the return type is often obvious. You can write:val foo = new MyReallyLongUglyFactoryClass()instead of:MyReallyLongUglyFactoryClass foo = new MyReallyLongUglyFactoryClass()And you neverhaveto use type inference. If you have a method where the return type isn't as obvious, you can always annotate it explicitly:val foo: Int = doSomeThing()Do people exercise judgement about when to make the type explicit? Eh, depends on the team. But if you combine type inference with established conventions in a particular codebase (e.g. I/O calls always return IO[Foo]), you will rarely be left wondering what the type of something is.
Yes but that isn't real code. If you see something like:> var conn = openDatabaseConnection();Are you actually confused about what conn represents? Does it matter what the exact type is, if you already know what it is and what you can do with it?
Yeah it does, I don't really know what I can do with it. A type annotation would be useful to search for.
I mean, you could just search for the method called, if you're REAAALLLLLYYY averse to using any IDE or editor of the last 10 years. Which would be an odd choice to base language decisions on.
I'm using Intellij, VSCode and Code Search for searching, why would I use GitHub for it?
Why? The compiler knows what the type is, the ide can tell you the type if you need to know - it’s redundant for you to have to type it out.
Now do the code review in GitHub. Ooops!
Never have this issue. I'm not being hyperbolic either. I review Kotlin PRs every day and am never lost for context on a type.
I do code review on GitLab all the time, what’s the issue?
No compiler there so the compiler can't tell you the type. No IDE there so the IDE can't tell you the type. You're at the mercy of colleague(s) not to write code like var request = service.call() or, worse, var b = getResult().
nonsensethis line has zero readabilityyou're not writing code for compilers, you're writing code for people
I prefer inferred types when available. Then an IDE and compiler can get together to provide further details when needed. Honestly f: MyStupidInterface = myStupidMethod(); doesn't tell me much more.
The era of strong vs weak typing debate has passed. Adopt strong typing, like a professional, or fade into the 90s web. Harsh but fair.
practically all modern strongly typed languages are adopting or already had type inference from day one, allowing you to do things like var. They give up nothing in terms of strong typing to do so.  Forcing people to write manual boilerplate does not equal professional, what a strange take.
The engineering trade-offs are paid somewhere, better in an objective space than a subjective one.
i dont know what you mean by this?Fundamentally, this is a story of technology getting better (type inference in compilers) so humans can do less work. We're not pushing the work to some other human place. We're not losing anything in safety, and we're gaining in readability, boilerplate and expressiveness. Its progress!
Noone is arguing for weak typing. They're arguing for type inference. They're not even slightly the same thing
The era of not knowing the difference between static typing, strong typing, and type inference is past. I'm the sort of professional who likes to learn computer science.
> you're not writing code for compilers, you're writing code for peoplei agree, thats why i don't want to clutter my code with annotations designed for the compiler, not humans. Type inference is a _good_ thing for readability.
You can just the type hints in the IDE for bad code like the above example. But glancing through my code, that is never an issue in practice because code reviews should have caught the poorly named variable and method.Since the actual size of the code base isn't an issue in the modern world, I personally like that the Kotlin ecosystem discourages the use of esoteric names and non obvious abbreviations. Once you write and read enough of it you stop making poor choices.
Nonsense is doing compiler work yourself, even bigger nonsense is duplicating for zero reason.
> One my pet peeves, shit like this sucks :> var f = MyStupidMethod();Yeh, but so does:List<MyWeirdoFooClass> myWeirdoFoos = new ArrayList<MyWeirdoFooClass>();Sometimes it's clear what it is. Sometimes you don't really care. Sometimes you do. You can still make it explicit when you need it to be explicit.
I don't find coroutines that helpful, but the syntax sugar and standard library in Kotlin is pretty awesome.  The Elvis operator alone is worth the switch.  Say you have some container with 3 levels of nesting.  In Java, you have to null-check every level vs. 3 "?." dereferences.In theory this is possible to approach with annotations but I found it hard to keep up in a large codebase.
If you need 3 levels of null-checks that's a red flag though
And with records you mostly don't need Lombok (unless you really like builders and can't wait for withers in Java).
JPA requires mutable classes.Records ergonomics is terrible if you want to replace data classes with records, even if immutable is OK. You need to write builders. You can't really write code likenew Person(id, null, null, null, lastName, firstName, null, null, null, null, null, null, null, age);Withers can help with that, but they're not even in any kind of experimental shape right now, so we have many years to wait for it.Right now records are only fine for very simple use-cases like Point(x, y). Or if you want to write or generate builders. But at this time you don't really save anything, if you can generate a builder, you can generate a class as well.
Yeah, I don't like JPA because of lack of support of immutable types (records or my own classes that don't have setters, only constructor).If you have data class with more than 5 fields then you have it wrong. Builders are like lombok and like field injection: hide poor class design.If using a class hurts, it is badly designed and should hurt until it is refactored/split up into consumable parts.I use records extensively, but those are in most cases converted classes which were small and immutable. JPA being one of the exceptions (a stuck in the past spec)
Some of database tables I worked with had over 100 columns.
I don't think you need to map all of them to a single object - projections work well here.There are very few cases where you need to work simultaneously on that many columns.
I can't imagine other way of dealing with database rather than using a single class per table. Projections are a way to optimize some niche queries which are too slow otherwise.
A 100 column table will be slow either way.
Why not have it like new Person(name, new Address(…))? Nesting is allowed.
Records not being extend(able) is the reason why Lombok is still mostly needed...
Why would you need extend over implements? I found sealed interfaces with records really cool.
Is it? Seems to me that most instructions are naturally async or can be refactored as such. I’m probably wrong, just a feeling.
Interesting that they were able to quantify the reduction in source code length very precisely (11%), but when it came to the regression in build times ... nada ... just talk about how they plan to mitigate the issue.
We don't have numbers around this because the numbers are actually really hard to make sense of.This probably sounds a bit weird, and it surprised me at first.Unfortunately measuring build times is extremely noisy: different people build different things. They do so at different times. On top of it we have incremental builds (so only some part, depending on the modularity and some external and in-house optimizations, gets rebuilt). The incremental builds depend on cached artifacts that need to be downloaded, and many more complications.The result is that if you look at the graphs the values jump up and down based on time, days, moods, network, and many more causes, plenty of which we have no idea what they are.I have not yet seen a successful attempt at cleaning this data up so that some number would be worth publishing. We could try building some toy example that we separated. But that won't be useful to guide our work on build times, nor do I think that it will be valuable to share with the community.
> the numbers are actually really hard to make sense of.1. Then how do you know builds are slower?2. How will you know that the things you are doing to improve build times are working?> jump up and down based on time, days, moods, network, and many more causes, plenty of which we have no idea what they are.3. Performance being highly inconsistent is actually a (significant) performance problem itself and worthy of reporting, analysing and quantifying.  (ranges, averages etc.)> not yet seen a successful attempt at cleaning this data up so that some number would be worth publishing.4. Not sure why you think they need to be "cleaned".  Again, numbers being all over the place is likely an important data point in itself, an even if it isn't the raw data would be valuable.> We could try building some toy example that we separated.Why?  Just do a clean build on a local machine.  Report real and user+system time.  (man time).  Repeat.
1. There's some trend lines, or you can see a Kotlin module during build taking a lot of time. However, we can't tell how much of it is due to Kotlin and how much as an artifact of optimizations such as [1] that we work for Java and not Kotlin for now.2. We have more specific metrics for parts of the build that we know would improve. For example, migrating annotation processors to use KSP instead of KAPT makes modules build faster. (This doesn't mean we can easily expect a different trend line in the top level graphs since in the meantime the amount of Kotlin code is changing.)3. I'm not sure what your experience is, but according to mine it will be a "nice to have" but un attainable or at a cost of real user improvement. For example, if a lot of people build at once network caches might be slower. How does one remove that noise? Up the caches - that's more money and other updating issues; try to take it into account in data? maybe, but that's one of many issues (going back to the next point)4. The commenter asked for numbers on builds. I don't think a graph that's jumping up and down due to the complexities and optimizations of Meta' build architecture is useful to anyone outside Meta. I think deducing results about Kotlin build times from it would be deceiving.> Why? Just do a clean build on a local machine. Report real and user+system time. (man time). Repeat.This number is not stable. Even if you shut off network caches and other similar things. But more importantly - this number is not useful. Our users rarely have that experience. One of the common sub goals we have when dealing with build times is to minimize the times someone will have to do a clean build.[1]https://engineering.fb.com/2017/11/09/android/rethinking-and...
Same thought. We can only speculate but I'm guessing the compile time is much worse.
“Shorter code: Kotlin’s modern design makes its code shorter.”How much shorter?  How large would the code be in pure Java?
We actually made this number public in the post. It just appears laters around the conclusions sections.> On average, we’ve seen a reduction of 11 percent in the number of lines of code from this migration.
I was hoping for more but 11% is still significant.So that’s an extra million lines of code that didn’t need to be debugged.
An extra million lines of {, @NotNull, .stream(), .toList().Hardly any code that would actually have bugs.
We have a consistent braces style, so the lines that are removed are rarely those.A lot of the saves come from `?.` replacing null check chains. Many more from the shorter constructor and field initialization syntax (you can get a bunch of things in one short statement). A bunch more from usage of standard library lambda taking functions (`first`, `single`, etc.). Some more just comes from shorter lines due to less explicit types. These are all more some guesses due to conversions I've seen, and not the result of accurate analysis.We also use very little Java streams. A combination of Java 8 arriving late to Android code, and the preference to avoid extra allocations and inefficiencies streams can cause for shorter lists.
I wonder how much of this could be reduced if they used records in Java.
There's also the line length to consider.I've seen the same on my own converted Java code. Less lines of code. But you also get lots of a really short lines. And some formatting actually spreads things out over multiple lines for readability. E.g. I use intellij's build in "put arguments on separate lines" a lot. Especially with named arguments, this is just nicer to look at. It's the same or less code but more lines. But less dense code.A more interesting metric might be simply the byte size of the source files. I would expect that to be slightly better than 11percent. Maybe closer to 20-25%.
A nice, simple kotlin left-to-right access deep into a nullable nested object tree can quickly be four lines of java for each and every ´?.something´, for as many of them as fit into your preferred line width. In java, this often leads to either skipping more null checks than you really want to skip, or calling getters more often than necessary.Kotlin might seem a little weak to someone returning from a scala deep dive, but where it really shines is in creating a large overlay between the convenient path and the pedantic path. It removes many "in the small" tradeoffs that you just take as a given in java. It's the "better java" that groovy was not.
> Kotlin might seem a little weak to someone returning from a scala deep diveI dismissed Kotlin for this very reason years ago. But after seeing bad Scala codebases, Kotlin feels like a breath of fresh air.
If you have more than 2 levels of nested null-checks I would wager you are doing something fishy. You should probably go with mapstruct or similar libs (which are absolutely cool and a must for data conversions).
On my fishy scale, requiring translation between different data models would by pretty high up. And how would it help anyways? Absence can be a perfectly valid state and alternative representations of absence like scala's Option seem pointlessly ceremonous once you've worked with a syntax that does not completely suck at dealing with null.
They should switch to Perl and replace 80% of the code with punctuation
Expect a 10-30% reduction with J2K, maybe another 5% once manual refactorings are made.
What’s pure Java?
It's too bad other IDEs (like VSCode) have only a primitive support for it. That means Kotlin is only ever usable with an IntelliJ license, and forces one to use this particular IDE.
If i were to do JVM related stuff, it'd use Kotlin without hesitationThat language, just like with Swift and Haxe, they remind me of the good old Flash/ActionScript 3, i loved that language so muchIt's imo the best form of a programming language one can come up with, very easy to learn, read and writeI wish kotlin-native story was better, it's a shit show, super slow to compile, and they decided to go with Gradle... it is on the same level of confusion and bloat as CMake, a pure mistake
I thought that they were using react native. Isn't that true now?
The native modules still need to be written against Android (these are typically either Java or Kotlin, plus maybe some native code).
No the entire app is not react native. Only parts of it.
What's the story with Android and iOS cross development using Kotlin? Any major benefit over Java (which used to be a thing at least in the days of j2objc)?
KMM (kotlin multiplatform mobile) just hit Beta status. Its a really unique value proposition compared to other cross platform options in that it doesnt run via a VM (either Javascript or e.g. Mono for Xamarin). It compiles to native LLVM on ios, and as such you can write your UI natively if you want.I was holding off on KMM before, but I've started looking lately and its extremely promising. There is still a lot of ecosystem that needs to be built out (e.g. you need to find cross platform / pure kotlin implementations of URI or Color), but it is shaping up to be the leader in the space IMO.
Why would anyone use it if you can’t take advantage of the vast Java ecosystem? Why would I choose it over Graal for example, which has much bigger backing, stable and is language-agnostic.
You can take advantage of Java in the next layer up, but you lose out on sharing that portion of code/logic then.There are actually 3 layers in play for each platform: The pure kotlin shared layer, the "native" kotlin shared layer, and the native-native layer. That second layer (the native kotlin shared layer) is platform-specific kotlin. So on JVM platforms thats the normal Kotlin you are used to, and as such it has access to Java. On iOS that second layer is Kotlin/Native, and you actually have access to native _bindings_ to the native layer (i.e. I can call into UIKit, but in Kotlin code). If you put your "native" code in the second layer instead of the native-native layer (which on iOS is Swift/objective-c), then you can move that into the innermost layer if/when it makes sense over time, and the frontend is none the wiser.Here is a good visual and explanation (the rest of the presentation is a good overview as well, but I think this slide is the best part of the video):https://youtu.be/2yd6rVJdICU?t=1749EDIT: I should also note that nothing prevents you from creating "glue" bindings in the pure kotlin layer using either expect/actual or an interface, and then reifying that using some JVM thing in the second layer, and writing the other platforms more from scratch to fulfill the contract.
> I can call into UIKit, but in Kotlin codejust a note for those who've never used kotlin native: its generating obj-c code when compiling for ios, so you cant use any swift-based apis that arent exposed to objc from appleuikit isnt going anywhere for a long time probably, but its an important caveat
Right, I forget to mention that. But if you are in the cross platform space thats just how they all work (that I've encountered at least). The difficulty of consuming Swift in Objc vs the other way around means that lots of iOS libraries are Objc based, but Apple is starting to signal that it might be over sooner than later as they begin to introduce new Swift/SwiftUI-only subsystems. Or maybe they have an ace up their sleeve with exposing those in the Objc space. Doubt it.EDIT: and a nitpick. Its not generating any objc code. Its generating a binary which is exposed to swift using the same mechanisms that objc libraries use. I.e. it compiles to a native binary (an xcframework or framework, I forget which). It doesnt transpile.
> Its generating a binary which is exposed to swift using the same mechanisms that objc libraries use. I.e. it compiles to a native binary (an xcframework or framework, I forget which). It doesnt transpile.right, though the native library (xcframework) exposes its interface as objc objects (.h header files), since swift only knows how to read c and objective-c modules afaik...
Well there is kotlin-native which allows you to write kotlin libraries that compile to IOS and Android. Which you can than link to objective C or flutter based UIs. Or even react native. That allows you to share a lot of code between different platforms. A growing number of Kotlin libraries are multi platform meaning you can use them on IOS, the JVM, and in browsers.Java doesn't have that and it's kind of an increasingly dead language for mobile development. Some older android projects still use it. But Meta is late to the game of migrating away from it. Many companies did that years ago and the vast majority of new Android applications is using either Kotlin or Flutter/Dart.I have good hopes for Jetbrains extending the jetpack compose/compose desktop/compose web ecosystem to IOS at some point as well. That would create some interesting possibilities in terms of targeting just about any platform with kotlin from a single code base. It's a logical next move for them and they've been laying the groundwork with their multi platform compiler strategy for a while now.
can someone explain how Meta's code is so large?the tradeoff for high level languages issupposed to bethat you gain a lot of expressivity (requiring fewer lines for a developer to express their intent) and you lose performance because of the multiple layers of abstraction required.10 million lines of code for an Android app, or family of apps, feels like the tradeoff has definitely not born fruit.operating systems written in Assembly have far fewer lines of code than this.
Past discussion on why Uber's app is so big, many of the points are relevant:https://news.ycombinator.com/item?id=25376346
This comment is a gem. Every HNer who has thought 'why do they need 100 engineers, I could do that in a weekend' should go read this now.
> why do they need 100 engineersYou're off by an order of magnitude. Hundreds of developers? Sure. But Uber hasthousandsof developers.
I think the point stands: the amount of complexity involved in each little piece of app is huge when taking into account dozens of countries and customizations by city.If it still doesn't seem worthy of 'thousands of engs', imagine breaking down every point in the list to the level of detail the author broke down payments. And then apply the logic in the top comment mentioning backend systems + teams to support other processes (and internal tools needed).Edit: sorry too much caffeine got me edgy.
interesting how much of this is glue -- like if mobile had better support for inter-app handoff, these flows could be entirely delegated to external provider's app (paypal, venmo, support saas)(though hard to generalize to other parts of the app, bc payments is inherently glue-y)constantly wonder what kind of support layer would make UX integration user-friendly, but also developer-friendly
I feel like 10 million lines is still massive, given all of the points mentioned in that comment.UI pages must be immense in terms of lines of code.
Whoa. At first I didn't blink at 10M lines of code, but you're right they're talking strictly about Android.You have to factor in Instagram and WhatsApp, but still...that's a lot of code.
Good idea, I learnt Kolin to avoid having to use Java for android development.
Only for one app it was still worth it
I'm interested in exploring Kotlin for backend development.
But, most Kotlin projects, articles and anecdotes center around mobile apps.
I imagine companies hiring Kotlin developers would mostly get applications from people with mobile dev experience
There's very mature and widely used Kotlin support for Spring Boot. They've been actively supporting Kotlin for years and it's a well documented and well supported option in that space. Same for many other Java frameworks (e.g. Quarkus, Vertx, etc.). The reason is that it's so easy to integrate just about any Java framework from Kotlin and make it nicer by adding a few extension functions, turning builder soup into more readable Kotlin DSLs, getting rid of all the getter/setter madness or silly hacks like Lombok. I've converted a fair bit of Java code to Kotlin. You almost always end up with better code. Certainly less of it.The notion of Kotlin being a mobile only thing emerged out of the happy accident that the need to get rid of Java was simply felt so deeply in Android that developers were all over Kotlin even before it was released properly. Backend developers waited a bit longer.As a drop in replacement for Java it made a lot of sense there. Google at the time had the whole platform stuck on Java 1.6 while they were engaging with Oracle in the courts. So a lot of the nice stuff in 1.7 an d 1.8 was not usable and forget about all the stuff that was added to Java and still is being added. Most of that you could get with Kotlin right then and there. So, people jumped on it.For the same reason, people have been using Kotlin with Spring since about the same time. Google and Spring made it official around the same time as well with Google outright labeling it as the preferred language for Android (while not cutting off Java) and Spring just adding an enormous amount of Kotlin specific features and extensions starting with Spring 5 and Spring Boot 2. At this point both have documentation for both Java and Kotlin. There are really no downsides to using Kotlin on the server. You can do everything you could do with Java and you gain access to a lot of easier to use stuff than the Java equivalent.I've been using it since before Spring supported any of Kotlin. Worked fine then and it only got better since. The language alone is worth switching and once Spring started actively supporting it, it only got better. I write asynchronous co-routine code with Spring by default. Mostly it just looks exactly like synchronous code. The only way you can tell is that my controller functions are suspend functions. Spring takes care of the rest. That makes everything easier: more readable logic, error handling, etc.
Maybe it's the wrong circles? Pretty much all the Kotlin developers I know (like four) do backend work.
The only thing that prevents me from using it is the license that shows up during installation. Has anyone read the license? The same applies to Dart (Flutter).
Every time I think I maintain large code bases I just need to remember that someone else has a LOT bigger one. Wow, that is a LOT of Kotlin code.
More likely a big in Firefox... But sure just imagine it's whatever nefarious thing you want.
“In recent years, Kotlin has become a popular language for Android development. So it only makes sense that we would shift our Android development at Meta to Kotlin as we work to make our development workflows more efficient.”I like Kotlin, but this was pretty funny to me: I imagined walking into a meeting and trying to tell colleagues we needed to move to X because it was popular, then yeet out the ole “efficient”, mic drop & moonwalk out
Happens so much more often than you think. Have actually seen it with the exact same language (Java->kotlin) on an existing service. I don’t really recall any valid reasons being given for the switch (better support for concurrency etc). I think often times managers allow this bc they don’t want certain engineers to get bored and leave, which is odd to me since who knows why/when they will leave and they won’t take the services with them.
It happens all the time. I remember when AWS wall all the rage my boss came up and told me we need to use S3. Why? "Because everybody is using it!" I tried to reason, I did a cost analysis - all for no avail. The same boss a few years later: "Why are we paying so much for storage?!" He apparently forgot he insisted on it in the first place.
I'm 100% sure there's a Dilbert strip with exactly this scenario.
I read it more as they now have kotlin and want to simplify new project decisions to just kotlin.I find this similar to how rust is being added to the Linux kernel.
Off-topic, but how the Facebook, Messenger or Instagram-app needa millionlines of code is absolutely beyond me.I had a few encounters with facebook's opensource code (mostly around react-native) and it is generally subpar in my opinion.
Facebook is primarily a message and photo sharing application but it also has group boards, dating, live video streaming, a marketplace, browser games and probably more features. Then there are all the features for targeted ads, tracking, payment and so on. All of this is available almost all around the world.How do you implement these features for more than a billion active users in less than a million lines of code? Even 100 million sounds like a low estimate.Why does the Linux kernel have more than 30 million lines of code?You could ask if these features make sense. But in the end it is their business decision to make.
how does the number of active users affect the size of the application?
You need to support a huge range of devices and cultures.
My guess is that it's an extreme case of Conway's law, with many teams that produce mountains of code hidden behind some API. Not to mention codebases provided by external firms, which could amount to a large % of all those KLOC.I'm interested in how they avoid "Roman empire syndrome", as in owning more software than they can maintain while actively expanding it.
Rome held on to its land for a while. More like napoleon or Alexander syndrome
This happens with "everything" apps that have hundreds of features you have never seen, each serving a tiny fraction of the userbase who somehow stumbles on them and justifying the PM/eng resources to keep them chugging along, or abandoned and left to rot until these migrations come along.
That app needs to go on diet.iOS 310.6 MBAndroid 367.7 MB
How much is kotlin vs high res assets or shipping every experiment to turn them on/off with feature flags? I suspect the language contribution is actually pretty minimal
Ye still use good ol' PHP on yer backend?
According to them[0], Facebook's primary languages are C++, Java, and Python, and they're even embracing Rust now. In general, teams have the freedom to choose what languages and technologies they want to use. (quoting from the linked video)They might've started with PHP, but even that stopped being a thing once they switched to Hack, their home-grown language, ~10 years ago.[0]:https://engineering.fb.com/2021/04/29/developer-tools/rust/
Not quite. According to a more recent article, Facebook's PHP, Hack, is still a primary language:> For business logic and relatively stateless applications, the Hack ecosystem has the highest level of automation and support at Meta and is the recommended language.On a related note, their Rust usage has grown significantly:> For performance-sensitive back-end services, we encourage C++ and Rust. Rust is a new addition to this list. There’s a rapidly increasing Rust footprint in our products and services, and we’re committing to Rust long-term and welcome early adopters. For CLI tools, we recommend Rust. This is a new recommendation for this year.https://engineering.fb.com/2022/07/27/developer-tools/progra...
~~Microsoft's Java~~Jetbrains' C#
