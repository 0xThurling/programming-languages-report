While job postings are generally not permitted, there are regular monthly "Job Fair" sticky posts where we encourage job postings or people looking for jobs to comment in.
This includes downloads, tools, help, discussions, or anything related to creation, use, or distribution of malicious, piracy-related software, or software designed to violate a service's terms of use or equivalent policies, or the distribution of pirated material. This also includes posting links to pre-compiled binaries or executables of your code as they cannot be validated or trusted to be non-malicious.
Make sure any code is properly formatted, explain what you have tried, and where applicable try to create aMinimal, Complete, and Verifiable Example. Be clear and courteous. If a question that could have been easily Googled is asked without indicating what and why those typical results didn't work, it will be removed. Help posts that have had little effort put into them will be removed at the discretion of the moderators.
Everyone was novice at some point. Always be courteous in your interactions with others. Just because you feel someone is incorrect/misinformed/misguided does not permit you to be an ass. Being unnecessarily cantankerous or derailing discussions may warrant removal. This rule reaffirms the Reddit site-wide rule of practicing basic Reddiquette. Snidely telling people to use Google, LMGTFY, or AI tools may be removed. Insulting or mocking people for using AI tools may also be removed.
Posting of development tools and libraries are generally allowed. But if the post is basically an advertisement-disguised-as-a-blog, or the post is designed to promote your own product or company, the post will likely be removed. The basic litmus test asks is the post fundamentally made to sell something you're affiliated with, or is it made to benefit the subscribers ofr/csharp? In addition, use of affiliate links or referral URLs in submissions is also prohibited.
Blogs, tutorials, videos, or other content must be of passable quality and effort, and not be blogspam or content rehosting. At minimum: code snippets indented and readable, writing clear and easy to follow, free of plagiarism, content relatively current (i.e., not terribly obsolete or outdated), and sufficient content to be worthwhile to readers. Submissions that are largely AI-generated may be removed. For greater clarity, articles about AI tools/APIs are fine; AI-generated articles are not.
While the use of AI generation tools is not prohibited, when using them you must acknowledge that the code or description or content is AI generated. This empowers readers to scrutinize the result as it may be confidently incorrect, omit critical information, or be out-of-date. It also treads on plagiarism concerns. AI content should not be automatically posted via bots as it should be manually reviewed before posting. Such bots and posts may be removed as spam.
Is this really the case? Correct me I’m wrong but I would expect a C# developer to have a better grasp of low level concepts than a Python one.
Based purely on the language’s characteristics.
Would also love to know your thoughts
As a Python dev, I agree. Python is way too abstracted and top level. Nowadays, I try to only use Python for simple scripting stuff because I really don’t like how it handles things as a language anymore. My new preferred languages are C# and Rust.
Over the years I have encountered a lot of 'snobbery' / anti-Microsoft sentiment from lecturers at Universities, etc, The kind of people who still write Micro$oft, who haven't looked at .Net in 10 years, and don't know it is open source.
Unfortunately that affects curriculums, leads to less knowledge of what .Net / C# can do, and that cascades out from the academic world into the business world.
The same with industry 'journalists'; quite a few still have that legacy "It's Micro$oft" attitude.
Startups also tend not to use .Net / C#; they tend to have an opinionated CTO (who is really only a Senior Dev), who will choose whatever is a new stack to have it on their CV, for when the startup inevitably fails.
A bit cynical, I know, but I have been doing this for 3 decades, and have encountered the above multiple times.
I’m sorry but I just don’t see this. There are .NET houses and there are places where if you say you do C# you may as well be telling the interviewer that you write in Pascal. This idea that you “learn more” writing Python or whatever is absurd. I do understand why garbage collection, etc. is more important from a little bit of writing in C, but that’s as far as that goes TBH. Once you get into the real world, people understand that by and large, most of the differences between languages are syntax and if anything they want to know how many of those you can utilize.
I’m a .NET person myself but I also use JS and Angular a ton because I do frontend development, and out of that a fair amount of Node and other things. If I worked in data science I imagine I’d use a lot more R and Python. If I worked at a non .NET house, perhaps I’d use Java for the backend instead of C#. This is really the extent to which professionals care if you know C# or not; only an idiot will actually disqualify you for knowing it.
I believe that people that put too much emphasis on the language/technology you know are not good developers. These can be learned quite fast. Problem solving, on the other hand, is what takes time to master and some never really master it.
I personally never got bad feedback from C#. It's may just be not as trendy as before compared to some new technology but it is, in my opinion, one of the best language for production. For me, Python is for short scripts, internal command line tools, and prototypes. That may be why it's popular for teaching and coding challenges.
C# is fantastic from top to bottom, very mature.
Yea, c# is arguably one of the best languages out there bc you can do like everything with it desktop/mobile applications, websites, games, and a whole lot of other stuff and it's not that hard to learn
Edit : I dont understand why people think bc you know 1 specific language makes you worse or something bc it will just make you better in other languages aswell
I think it comes from anti-microsoft sentiment. People that don't keep up with C# often think it still requires special tooling and can only run in Windows. The Windows bit was true with .Net framework but that went away with core.
Despite .NET Core/.NET 5+, dotnet still has a reputation for Microsoft's proprietary technology
Yes but the people who belive that will often use Google's golang or flutter, oracle's java, JS with meta's react/react native.
For a long time C# was pretty much Windows only. (Yes there was Mono, but I don’t think it ever had feature parity).
That ruled it out for a lot of companies, because if you write server side code, you probably want to run it on Linux. Small startups don’t want to pay Microsoft a license fee for every server they spin up, and neither does Google or Facebook.
So C# got a decent amount of traction for internal enterprise apps, and if you’re a company that’s all in on Windows already, you’ll probably use it, but for most of the tech companies it just wasn’t an option.
Microsoft has changed their strategies quite a bit under Satya Nadella, and I think the C# support for Linux is much better these days, but it’s hard to regain the mindshare that they lost for a decade or more.
It's kinda unfortunate that C# got hobbled because of the Microsoft-only strategy.
Pre-university, I used to actually extensively program in C# in the hobby space with the then .NET framework and quite liked the language.
For that time, it had some really nice language features that others did not and felt like a more ordered and better documented Java clone.
Anders Hejlsberg who co-developed it has now also been involved in TypeScript so I guess the C# influence goes on.
Microsoft also alienated lots of smaller software companies for decades.  Right around the time that Azure was launching I ended up on a few calls with them for our “SQL Server support” that we were supposedly getting for paying a license.
They kept me on hold for hours multiple days in a row and charged my employer $100s/hour to do it.  I ended up explaining to them what the issue was, not the other way around.  My employer was over it at that point and we became a PostgreSQL shop.
I always found it odd that C# (and .NET in general) was designed to run in a virtual machine like Java, but Microsoft made it Windows-only for a long time.  It looked like Microsoft was probably going to make a .NET runtime for other operating systems too.  I don't really understand why they went to the trouble of making a runtime virtual machine like Java and made it Windows-only.
Because C# just sits there in the corner with its great documentation and IDE and does its job. It's neither boring, exciting, fantastic or crap.
It's beige and it gets the job done.
There's also only so many times you can tell the "Why did C start wearing glasses?" joke.
Not much to talk about.
This, to me, is the best answer, at least from my experience.
Why does C# get almost no attention online
Your premise is wrong. I get a lot of C# exposure. Be aware of the bubbles you reside in while on the internet
But do you mind your own bubble?
C# has often new things and articles for those that follows it. I am too.
But if you look out for a proportion on general channels, C# is less seen than other languages. The main comment on this post (at the time writing) states that the strategy of Microsoft has reduce the impact of C# on the whole community.
Yes
C# can be used to make... Pretty much anything, websites, mobile apps, desktop apps, embedded software, server software. It can also run on most platforms (certainly all that I have encountered) and on all operating systems I have tried as well.
It is also supported by Microsoft so it's not going away any time soon.
It's worth having some knowledge of because you are almost certainly going to run into it at some point.
I've programmed primarily in c# for almost my entire career and plan on doing so until I retire. I love it.
Have a look at the features of ML.NET. it rapidly growing to compete with Python for ML.
I think C# does anything Java can but better.
I'd say it's worth knowing several languages to a moderate level just so you can pick the right tool for the job at hand.
This also meams you have more professional prospects as you'll be well rounded with any language. You should as always have something you are very strong at so you can learn the more advanced concepts. Those can then most likely be transferred to any other language as well so a win win really.
C# is a great language, I use it in my current role after being a Java dev for a decade and a half and there’s a lot to love about it.  Java’s recent inclusion of virtual threads has tilted the scales back in Java’s favor.
I’m not saying C# isn’t a fantastic language, just that not that clear that it’s Java but better anymore.
As for ML, C# will have a really tough time supplanting Python.
This question gets asked a lot and I seriously consider suggesting those that ask it to take up knitting or some other pastime requiring even less brain power. If you're unable to do the necessary research (not Reddit, not Wikipedia) yourself, it's probably not for you.
I consider c# to be workhorse. While it might not be fast to include every last tech shiny thingy, it does what it should be doing well And in decently thought out manner. Considering other languages i worked with (C, C++, Python, Matlab) it felt easiest to learn And i never ran into paralysis analysis while researching a decent package library to use (at least from core .net libs).
Im still fairly new to c# myself but what interests me the most is that it is cross-platform for mobile, mac and windows and also fully supported for web-based applications with frameworks like blazor. Because it is built on .net, it also has access to a multitude of UI frameworks as well, like WPF, WinUI3 and MAUI. From what I can garner, it is a very versatile language that can do a lot practically wherever you need it.
This is probably one of these responses that people are going to use to demonstrate how hostile Reddit is. But here it comes, some “tough love”
Learn to ask questions. Your examples for other languages are all platitudes. Nothing of substance there. And all the answers you get (got) are “ C# is great.”
What are you trying to get from your post? Are you basing your (life/career/…) decisions on a few random opinions on Reddit? How are you going to make different decisions based on potential answers here? What do you need to know specifically? Lastly, do your research. The question has been answered here many times. Read the subreddit before you write a post. Or google.
I’ll pick C# over every other language for ‘native’ development… JS PHP and Sql for web, but C# over Java all day. I fucked with Java for school, but that was the extent. Landed a job in a C# shop and said ‘fuck Java’. I stand by that. I learned C# in about 4 hours, wrote a multithreaded app that nobody has pulled off in a decade, and became a senior in about six months. It’s the real deal man…
I'm a full-time C#/.NET developer, and have been for about five years. Here are a few observations:1) As time goes on, C# is increasingly just F# with different syntax. LINQ, closures, records/immutable structures, and so on - you can write code in C# that is more functional than it is object oriented these days. This is mostly a good thing; it also means that (to my eyes) the language has become much more elegant over time.2) The level of cross-platform compatibility you can get if you're using .NET Core or .NET 5/6 is pretty fantastic. Performance has also improved dramatically. C# is in no way limited to Windows as an environment anymore - unless you have a dependency on .NET Framework.3) Everybody has dependencies on .NET Framework. Those who don't have dependencies on unmanaged Windows DLLs.4) Great debugging/developer tools, as others have mentioned. VS and Rider are both top-of-the-line IDEs.5) C# is not and will never be cool, sexy, or the thing of the moment. It is a language for getting things done in an easy-to-comprehend way and that's just about all it is. I like it very much.
How realistic or common is it to mix C# and F# in one code base? As an example, even though Java and Scala run on the same JVM their ecosystems have mostly diverged. In contrast to the Scala situation F# has been officially supported by MSFT for years so it's probably different on the .NET.
The compiler won't build a project using multiple languages, it doesn't understand. For a long time, VB code and C# code were 100% interchangeable, and they of course, both compile down to IL. (Identical IL code, in theory, if literally the same code reflected in different languages.) In theory, you would imagine that you could include .cs and .vb files in a single project, and the compiler could link them, but alas, it is not possible.There's no issues using a library written in one .NET language from another .NET language though, so if you can break the project up a bit more, you can work in multiple .NET languages.
The way to get around this is just to have multiple projects - at my employer, we regularly have projects written in C# and F# in the same solution, and depending on one another. That will work just fine.
You can also build a module instead of assembly (=default output of a project) but IDE support for modules is limited. After the modules are generated, an single assembly can be made from them.
I can't comment on the ASP/web side of things, but C# matches up with my atypical use cases extremely well. The high points:1. Fast compile times for most of development. I'm fine with waiting a while to do a special highly optimized deployment, but getting 95-100% of optimal performance with 0-3 second build times isreallynice.2. Controllable memory access through value types. Nothing getting in the way of C-like contiguous buffers and managing cache line or load alignment.3. GC that gets out of the way. C# has a GC, but in most of my applications the GC never has to run because I rarely allocate GC-managed instances. It's definitely a nonidiomatic use of C#, but the fact that it's pretty still pretty easy to do is nice. And when I don't have to care about the GC's overhead, the presence of the GC just makes everything easier developmentally.4. Ability to actually make use of the hardware. The compiler's improved massively in the last several years, and the way vectorization is exposed actually feels a lot nicer than my experiences in C++-land.And less relevant to my own needs, but still interesting, nowadays you can directly link a C# library into a C/C++/Rust application just like any C library. Among other things.Almost a decade ago, I was considering exiting the ecosystem in favor of C++/D/not-yet-even-1.0 Rust/etc, but the open source push and a sudden focus on performance basically made the jump unnecessary. C# occupies a really nice sweet spot.
Yes! I suspect (but I don't know for sure) that C# has the highest performance sealing of all the VM-based languages with a tracing garbage collector. structs, Span<T> and ReadOnlySpan<T> for type-safe access to contiguous regions of memory allow us to do a lot without touching the heap. C# also has hardware intrinsics for non-cross platform SIMD instructions if you're interested in that kind of thing.
Perhaps it can be manually optimized the best indeed, but the JVM still has a better GC if I’m not mistaken.Value types are indeed very cool, and I really hope they will get implemented sooner on the Java side as well. Just as a note, Java recently got a SIMD API as well.
You're right; Java has ZGC, a best-in-class garbage collector with average pause times of 50 microseconds while still having great throughput.https://malloc.se/blog/zgc-jdk16#:~:text=With%20concurrent%2...
Can you recommend any resource on how to get into writing high-performant C#?
Pretty much all the standard performance advice from other languages like C/C++/Rust applies. The concepts driving "data oriented design" will get you a long way. The biggest difference is learning how to play nice with the GC- avoiding allocations where necessary, keeping the heap simple so that collections are cheap, or just setting things up so the GC never has to run.I wrote a bit of stuff a few years ago:https://www.bepuentertainment.com/blog/2018/8/30/modern-spee...Some of the implementation details (like the operator codegen) are surprisingly outdated now given the speed at which the runtime has moved (and the library is now ~4x faster or something silly like that), but the fundamentals are still there.Since I wrote that, codegen has improved a lot, the hardware intrinsic vector APIs have offered a way to optimize critical codepaths further, additional cross platform vectorization helpers have made it even easier, NativeAOT is getting close, and all sorts of other stuff. The C# discord #allow-unsafe-blocks channel contains a variety of denizens who might be able to offer more resources.
Thanks! That link especially contains some really helpful write-ups.
I never really needed to think much about performance, as my C# usage always was constrained to simple CRUD stuff in server backends, which is a shame really, as it is such a nice language.
> Thoughts on modern C# and .NETPros:- Excellent documentation and widely used (not just modern btw, MS documentation is world-class and has been for the ~8 years I've been exposed to .NET API documentation)- Excellent code structure, supports very large/enterprise type code bases- Mostly sane improvements, with regular rollouts- Now cross-platform (although ref [0] for what it's like to develop in a non-Windows environment)- IDE support is 5-star. MS own IDE is at least 4 star, and Rider (JetBrains) seems to be very popular as well. I've used three versions (pre-2019, 2019, and now 2022) at different paid levels, no big gripes. You get great debugging, profiling, REPL, etc.- Mostly opinion/experience: Allows for a range of styles, while IMHO balancing correctly with consistency that is easy to pick up and collaborate with. It is possible to write confusing code, but not as much as other languages (ref [1]).Cons:- It is cross-platform according to the docs, but in reality it comes from and is relied on mostly in a Windows world.- Testability - if you like unit testing, you will need to make everything testable also exposable - if not publicly, at least within the same assembly.> If you have experience with ASP.NET Core...Yes. It's pretty good. Apart from a question specific to the language or framework, you will need to quickly become familiar with how stuff works behind the scenes. It might also be beneficial to look into how deployment works, depending on your target (IIS, Azure, AWS, etc).> Did you enjoy developing...Yes, for larger projects that need collaboration.
Otherwise I use Ruby.[0]:https://news.ycombinator.com/item?id=31520399[1]:https://www.ioccc.org/* edited for formatting
Quibbles:- Documentation: is ALL over the place. I do not find it excellent.  There is LOTS of documentation but due to naming (.NET framework != .NET Core != .NET Standard != .NET [current]) you can find solutions that just don't work in the version you're in.  Blogs are often the best source of details, but you have to have great search-foo to find the right one, and like stack overflow these won't age well (especially with the new rapid release cycle).  Thereisdocumentation, and lots of it. *Warning*: On the MS official docs you can set the .NET version (with a drop down in the top left).. however if you try and visit something outside of that version, it will take you there and silently switch you to the last version where it was valid.- Improvements: are great, they see what's happening in other languages and incorporate it.  .NET might not be the first to have (although sometimes it is: `async`) but eventually gets the best solution to a problem (`Span` is rather like `slice` in golang).- Cross platform: is very strong.  Doing it the cross platform way is completely subject to the documentation trap above.  A lot of the docs out there are for .NET Framework (the OG, which is not cross-platform) so you start off down the wrong path not realizing there's a cross platform way.  This compounds pretty quickly.. if you're building cross platform, setup automated cross platform CI early.- Testability: It seems you have not discovered `InternalsVisibleTo`[0], available as both a class-decorator or a project assembly attribute.  It's been around since .NET Framework 2.0 (2005).  Very much like the C++ `friend` declaration.  You can allow a test assembly (only) to see private/protected/internal pieces of your assembly, if you desire.- .NET (formerly .NET Core): Is great.  Faster, leaner, and their future.  Subject to the documentation trap above.  Because of their rapid releases (and good comparability guarantees not forcing upgrades), it can be really hard to find good examples/docs of the newer releases.[0]:https://docs.microsoft.com/en-us/dotnet/api/system.runtime.c...
" It is cross-platform according to the docs, but in reality it comes from and is relied on mostly in a Windows world."Not my experience at all, everything I do at work is c# on containers running Linux.
Just on your point on Testability, I don’t believe this is the issue you make it out to be: my standard approach is to make all the types/methods I need to test ‘internal’ and then expose them to my unit test assembly using this assembly level attribute,https://docs.microsoft.com/en-us/dotnet/api/system.runtime.c...
Because all of our projects use Microsoft.Extensions.DependencyInjection, I make all our service classes internalThe way other projects can access these services is by using the project's helper to register them all in the DI container by their interface. That way I can be sure no one is directly using the classes and make breaking changes to the constructors (like swapping loggers or api clients), but still access them from tests.
And if you have two different DLLs that offer this pattern, but they overlap in the interfaces they register? The downstream consumer has no way of saying "I want my IFoo to be a FooA from assembly A, and my IBar to be a BarB from assembly B". And this may depend on a configuration setting! Real example: we have a bunch of useful Azure functionality in one DLL and a bunch of general useful web functionality in another; they implement many common interfaces and are alternative services you can pick depending on your deployment. But it's not as simple as "when on Azure, pick all the Azure stuff" -- it depends on which Azure services you've configured for that individual project.If they overwrite each other, youmightbe able to get away with calling the god-registration-functions in the correct order (which you can determine only byreading the source codeof the two functions, which are probably in different solutions), but if you really have a well mixed set of needs from A and B, this is probably not possible.So you say: "okay, well, inthis casemaybe those concrete services should be public instead of internal. Obviously inthis casewe'd go back and do that." So your logic is: use "internal", except when it turns out we shouldn't have used it, then don't. So what purpose was it serving to begin with? None. The last lesson is that if you find yourself saying "inthis case", you're actually talking aboutevery case. That is to say: "special cases" are a symptom of a weak mental model. Good models don't have special cases.So indeed we've identified several ways to improve, all stemming from the fact that you are using the "internal" keyword!
Wow, there really are people who just drive-by downvote anything that doesn't a-priori agree with their cargo cult mentality instead of stopping to think about it for 30 seconds? Of course they can't leave a comment, because that would require them to actually consider my point, which would put them in danger of actually learning something.Downvoter, the problem with your downvote is that I am correct. DLL dependency/deployment is a completely separate concern from code contracts and visibility; therefore "internal" is always a mistake and should never have been added to the language. If you use "internal", we've identified that you have gaps in your understanding of software development that you have the opportunity to fill. But instead, go ahead and just downvote me again without comment. That's a lot easier than improving.
> if you like unit testing, you will need to make everything testable also exposable - if not publicly, at least within the same assembly.One of us is doing testing very wrong then. Maybe I don't like "unit testing", if that means reaching into the internals of every class. Just test that your code is following the contract it says it's following.The idea that you need to test private methods by running them out of context sounds to me like someone saying "A downside of this language is that you can't jump into the middle of a function to test individual lines of code. You can only run functions from the beginning." Yikes!
> Just test that your code is following the contract it says it's followingUsually testing output from a contract implementation works just fine. But sometimes my implementation contains bits abstracting parts of the whole. Those bits needs to be tested too, even though from an outside perspective there's no need to expose each bit. The consumer is only interested in the whole result.A consumer of the contract may want to pass in a Dog object, and get a result that tells if it (the dog not the consumer) has fleas. My implementation will result in true or false, but I'd like to abstract and separately test the parts that checks if the dog itches, if it has tiny animals flying in a cloud around its head, etc.I like good sane code coverage, but I also want it to be clear what is expected to be publicly consumed to drive the business logic, and what's just me making things tidy behind the scenes.How did I end up in another conversation about unit testing?
Why test that seperately? You should be able to test any code from the public API.Otherwise that code is unreachable and should be deleted.
After a long, intentional break break from the Microsoft ecosystem (more on this below), I recently kicked off a side project and was faced with the tech stack decision. After agonizing over Python vs Elixir, I landed on C#, unexpectedly. Reasons: static + strong typing is better for long-term maintenance IMO, extensive core library, solid database management, LINQ, excellent IDE, cross-platform support.The stack is ASP.NET Core with .NET 6 on the backend, React on the frontend, Postgres as the database. Not in production yet, but planning to make a lot of use of AWS, particularly Lambda. I'm loving it, feeling very productive and trying to take advantage of many of the new language and framework features.The biggest downside I've run into is that so much of the documentation and online material is geared towards older versions and older patterns. It makes sense given .NET's long history, but it's definitely been a journey trying to figure out modern best practices without ending up in an overarchitected mess (repository pattern everywhere!). The other thing I would say about C# is that I would never again interview with it, unless it was for a .NET position specifically. All the typing benefits work against it in a timed interview environment. Long time ago I picked Python up for interviews specifically and it was a much better tool for the "job".Now for some context. I developed in .NET exclusively for ten years, from 1.1 to 3.5. The development environment was great, but over time the Microsoft ecosystem began to feel stifling. Everything had to be done the Microsoft way, if you step off the rails, you'd be in a world of pain. It was a mega monoculture spanning the entire stack, with high tolerance for throwing away previous standards (so much churn with Webforms/MVC, LinqToSQL/various Entity Framework versions, all the WPF/WCF stuff, and I'm sure much more since then). In the mean time the open-source world was moving fast, developing new patterns and technologies, with Microsoft attempting to follow, slowly. I left the ecosystem in 2014 vowing never to return. Yet... the .NET Core cross-platform push intrigued me and the ability to write C# purely for backend APIs that can be deployed outside of Windows felt like a win-win. Time will tell, but so far so good.
I love using C# to create games in unity as a way of keeping my love for programming alive. I dont know if its because its different from my daily job where i mostly write typescript and python as a dataengineer but I just really just enjoy the feeling of writing code in C# right now its just so refreshing.Its refreshing to have types and have to say what the return type is without it being some type of pseudo enforced type as mypy or typescript. But as others have said, c# in the wild is most likely for big enterprise software which is not always the most fun thing to work on.
I have used C# for almost 21 years, so far. Written for .NET Compact Framework, ASP.NET 1.1+, WinForms, MSMQ, back-end server code, you name it.Nothing beats this language for getting REAL work done in my books.Tooling - Visual Studio absolutely unmatched.
Core Lib/Type System - one of the best.
ASP.NET Core - great rewrite of the old ASP.NET. Very fast. Runs everywhere.C# as a language has evolved very, very nicely and I try to use the new feature whenever it makes sense.
I think the language is great, if you can tolerate windows, it's a great way to write in the same language desktop applications, CLI and websites, and with wasm even web clients. It's the right mix of performance and high level language for my taste, and the tooling (visual studio) is fantastic. The integration with Windows makes a lot of things easy within a windows ecosystem. Also the self contained nature of the binaries makes deployment a lot easier than say python (everything is xcopy compatible with little dependencies on the client).However in term of recent evolution, I feel that under Anders Helsberg there was a focus on simplicity. Then Anders moved on, and anarchy followed, with multiple frameworks, multiple attempts to combine them into one framework, and ultimately the greatest of all sins for a language: breaking backward compatibility (.net 4.8 vs 6). And it feels everything is getting complicated, command line first, async everywhere which makes everything multithreaded, prone to deadlocks and hard to debug.The original c# had a great set of core libraries, however it has now fossilised. I think the owners of C# feel it is not their job to "update the batteries". So for instance their drawing library still doesn't support HEIC and might never do, they only added a json serialiser recently (yaml probably never). Instead you need to rely on a myriad of third party libraries with version conflicts, dozens of assemblies, and god knows if they will be available or maintained 10 years from now.So while I am heavily invested in C# myself, probably too much to switch now, if I had to start from scratch now, I don't know that C# would be my first choice. But the need to rewrite everything for .net 6 might give me the opportunity to do that however I really don't have the time for that now.
>I think the language is great, if you can tolerate windowsI do most of my C# development on Linux.  Not sure why you need to tolerate Windows to enjoy C#.
Because you are missing out on the desktop UI capabilities of the language which is a great feature at least if you use it as a hobbyist like me.And Visual Studio. To me the IDE matters as much as the syntax of the language. And when I was a beginner having an IDE that can interact with my code as I type it is a massive help to progressing.
VS Code, while not a fully-fledged IDE, is really good at suggesting code completions across platforms. As others have mentioned, Rider is also a wonderful fully cross-platform IDE (better than Visual Studio at some things).
Rider runs on Linux too
I worked on a (failed, explanation follows) project to trial port a large system from .NET Framework 4.6 or 4.8 to I think .NET Core 2.1 or 3.0. I was most annoyed at having to recreate project files, but it was quite straightforward and easy, even for us, where we had complications like numerous sub-projects, some generated code (luckily, I quickly found the correct arcane incantation embedded in some GitHub issue), etc. We also had to rewrite a C# API wrapper for a C library we used for reliable multicast, because our vendor had disappeared, and their wrapper was shipped as a Windows-only Framework-only DLL (and honestly, the code quality was relatively poor, with a lot of needless complexity in their wrapper). But we had already consciously chosen to only use sensible slices of that library’s functionality, so writing our own wrapper was quite trivial, even though I hadn’t used C#’s DllImport stuff before. It was easy to port the slice needed for most publishers first, before having to port the slice for receivers, etc.All in all, I’d say the port for our large suite of server apps, with lots of different CPU/memory bound and network I/O bound apps, it was quite straightforward and easy.What killed it in the end for us, was that our testing showed our CPU/memory bound apps ran 0.9x as fast on Linux .NET Core 3.0 vs. Windows .NET Framework 4.6/4.8 OR .NET Core 3.0, using near-identical hardware. The Linux port just wasn’t there yet, so we decided not to go through with any port to .NET Core for any part of our system, since Linux would have been the main benefit (we were using fancy network cards and stacks, and the Linux support for those was far more advanced and reliable compared to Windows, where multicast groups would spontaneously fail to be joined, etc.).Another elephant in the room, is that GUI support on .NET Core was limited at the time, so we may not have been able to do a Big Bang for that reason also. We had a few WPF apps, and some Forms stuff, but I have no clue about what .NET Core support was/is for that stuff, as I rarely worked on GUI things (I would create a GUI as a necessary part of an experiment and hand it off to more experience people, or modify/simplify GUI logic as part of my evolution of our server stack, but that’s all).So obviously YMMV and it seemingly does vary, but my experience on server apps that weren’t using lots of Windows/MS specific technologies (I’m not a fan of them generally), our porting was really quite easy. Still a failure though :-)
The performance improvements between .NET Core (any version) and (just) .NET 5+ have been pretty astounding. I've seen some incredible micro-benchmarks where the same code running in .NET 5+ hugely outperforms anything running in a version <= 4 (both .NET Core and the old .NET Framework). Factor in what you can do in memory-bound code by rewriting it to use .NET 5+ things like Span<T> and stackalloc there's no question that at this point you should be able to get much better performance out of .NET 5+. If performance was your bottleneck in .NET Core, the latest .NET versions (6 [LTS] or 7 [Preview]) may be worth checking out.GUI stuff is also what happened in .NET 5+. WinForms and WPF were both added to .NET 5. There's some porting that needs to happen and not all old WinForms/WPF code will be happy on .NET 5+. The biggest remaining "missing piece" from a GUI perspective is that a lot of old WinForms/WPF code used WCF for service code. I think porting WCF to use simpler REST services is easy enough and there's lots of people doing that with gRPC services in .NET 5+ too. There's also the Open Source CoreWCF project that is trying to hit compatibility with the most used bindings in WCF on top of .NET 5+.
The relevant part were our model calculations and it was already heavily optimized (no allocations, etc.), so none of the new library stuff would help at all. We just found that Linux .NET Core underperformed compared to Windows .NET anything (Framework or Core). Maybe our methodology was wrong, but we had a few people look at it, made the comparison in several ways, and generally tried to be quite thorough. We always found Linux (only .NET Core) had ~0.9x the performance of Windows (any .NET) — and we were a mostly Linux shop, running C/C++ apps, so our Linux build was appropriately tuned. Given .NET Core was relatively new at the time, and Framework still had some legs, we didn’t dig down as far as looking at IR or JIT output, because we could afford to wait. After all, one of the draws was to reduce problems due to using our fancy network cards+stack in Windows, so there was no point in adding complexity from a new Linux .NET runtime, including complexity from having to troubleshoot performance.I’ve been saying “we”, but I left that job a couple years ago so I won’t be trying any new .NET versions myself :-)
One of the issues I ran into when I looked at porting to .net core 3 was the crypto library. They didn't implement all .net framework classes, the ones related to public/private keys in particular. Perhaps they do now. I don't know how many edge cases I will find like that.On the recreating project files, I don't think you can copy-paste winform code like that, you need to recreate it using the UI, which is a pain. Also they had this weird concept that an assembly had to be set to be a "winform" or "wpf" assembly, you couldn't simply reference system.windows.forms, which basically prevented you from creating a helper winform assembly, and you certainly couldn't create an assembly that referenced both winforms and wpf DLLs. They perhaps also fixed that since.In any case, it's not a complete rewrite to migrate to .net 6, but it is far far from a simple lift and shift.
I’m not picking on you specifically, it sounds like you do a lot of desktop .NET development and there are legitimate complaints there.However, “too invested to switch now” reminds me of .NET/C# developers that don’t embrace change and/or don’t swim in other waters.Some folks with a traditional Microsoft/Windows/.NET Framework mindset have real trouble with these things:>“Windows and Visual Studio”Rider, Linux, Docker, bash terminals, and MacOS are all things that can improve your ability to solve problems with .NET.  I’ve met dozens of people that refused to even try a different OS/IDE and fail to gain the benefits of those tools and the broadening effect they have on your perspective.>”too many frameworks”This complaint sometimes stems from an unwillingness to learn web/mobile frontend technologies.  On the server-side, ASP.NET continues to simplify— you can write an API now in one file with a handful of lines of code. [1]>“limited core libraries”The first party support in .NET is already pretty comprehensive.  Some folks have an aversion to using open source packages, but this is exactly how you get things like YAML parsing in most other languages.  Microsoft’s move to open source has been awesome.  You can literally interact & contribute with the team’s that make the framework.>”command line first”This sounds like a feature to me.  This allows for automation and is easier to document without a series of screenshots.  Having a common CLI allows a team to mix their preferences of IDEs/tools.>”async everywhere which makes everything multithreaded, prone to deadlocks and hard to debug”I disagree. async/await makes it easier to write readable code without deadlocks or many of the other pitfalls of multithreaded programming.  It is not inherently multithreaded either [2].Since it’s ‘everywhere’ and thus fundamental to writing C#, it’s my first interview screening question.  A large number of candidates, with a lengthy .NET background fail to articulate any issues with calling “.Result” or “async void FunctionHere()”.  IMO, you have to deliberately avoid understanding such a ubiquitous language feature.[1]https://docs.microsoft.com/en-us/aspnet/core/fundamentals/mi...[2]https://blog.stephencleary.com/2013/11/there-is-no-thread.ht...
>However, “too invested to switch now” reminds me of .NET/C# developers that don’t embrace change and/or don’t swim in other waters.Or I have other things to do and I don't want to have to relearn and rebuild everything for no obvious benefit. I have no fascination for the tool, I am keen on what I can do with the tool. Having to rewrite something I already did because someone decided to change the internal architecture of a core part of the framework is a waste of my time. The .net team used to understand that.>This complaint sometimes stems from an unwillingness to learn web/mobile frontend technologies. On the server-side, ASP.NET continues to simplify— you can write an API now in one file with a handful of lines of code.that may be but compare the amount of time it takes to drag and drop a button on a winform, double click on it and write your code vs doing the same thing web based. I also do websites, but the time invested to do a simple UI is an order of magnitude what it takes with a desktop app, so I need to have a really good reason to go web based for a home or internal project (and now I need to deal with a server with certificates, etc). And there are many applications where it is simply not possible. Interacting with files, or visualising non h264/aac videos, selenium, etc.>This sounds like a feature to meI am not saying it is not intended, I am saying it is more complicated.>It is not inherently multithreaded eitherYes it is. You need to constantly think whether you are going to come back on the same thread or not. Something that works fine on a console application or within an exceldna formula will deadlock on a asp.net or wpf application. And it breaks the call stack when you get an exception, making it harder to debug. I think I understand this feature reasonably well, thank you.And not just multithreaded, asynchronous also. That means if a user clicks a button and that button has async code, the user can do more interactions with the UI while the original method is running. Now you need to handle many more UI states than you had without async.
I’ve been a C# developer since the beta. I started off mostly WinForms, then moved along to asp.net, then MVC, now Blazor. I don’t have anything specific to say. It’s a perfectly reasonable language, standard library, community, etc. I have never been frustrated by it, and have enjoyed 15+ years of continual improvements. I think knowing what your specific questions are would be helpful.
C# is great and improving.  A well designed and very pragmatic language.  The dotnet core changes cleaned things up and made it feasible to build and deploy cross platform apps.  I mostly use it for Unity and server code.I hope the AOT story continues to evolve and come down in size so I can start writing small utilities in it.
.NET Core and C# are an awesome way to program a plethora of apps and services.The bloat is a bit much, but once you get used to it, its a damn good eco-system.Bloat is also being rapidly shed with many improvements. .NET 7 (the upcoming version) is going to be even better.The programming and architecture practices recommended by MS are great for most apps.
I had an internship where we worked with C# and .NET, and recently i inherited and application written on this stack. I would say I much rather would develop in Rails.Why?Currently, I don't have a ton of time to maintain the app and I was hoping to migrate it off of aws (since I don't have a ton of aws experience and mostly don't want to mess with it/ manage it) so I was looking to deploy on heroku which doesn't support C# as of now. -https://help.heroku.com/PAT3YEDU/does-heroku-support-net-app...If you get past my gripe, I think it's much harder for new developer to pick up.I think Ruby/Rails and Python/Django were created specifically for developer happiness and ease respectively.I don't think it's going to be easy to manage this asp app (even though it isn't a large code base) Simply due to the fact that there is a lot of stuff I feel like I'll need to catch up on. When I look at other apps written for the web I find them to be "easier", whatever that means.
The third party buildpacks work totally fine.
Oh sweet, thanks bpicolo, I hadn't thought about that! I'll check that out.
Working with ASP.NET Core full time (on a Mac with Rider), for me it is the most productive language/framework that I ever used.
The bad:- Web framework is not quite on-par with Django/Rails. Particularly with auth/OIDC.- Job market is very sector dependent. Startups just don't seem to use C# whereas big enterprises do.- Some design decisions in the early days seem to prevent some features being added, e.g. structural typing or union types (not certain this is the reason).- Some days, like yesterday, your IDE updates and gets messed up and then it's back to writing full variable names like a medieval monk.- .NET is not really viable for non-server work. There is embedded/desktop stuff but you're going to have a headache outside of servers.The good:- When it's working properly the developer experience is like those dreams where you're flying. Rider or VS + Resharper make typing anything seems an incredibly antiquated way of developing. Intellisense means you barely ever need to type more than 2 characters to express your intent. Unlike my experience in Go or Python I just think about intent/data shapes and the tools fill in the rest. No language I've ever worked in comes close to reducing the ideas -> implementation effort barrier.- Type system. This is non-negotiable for me, plenty of syntactic sugar to make overhead of typing lower but because it's compulsory, types save so much mental effort and our production systems never wake us up, feeds into the above. You don't just have to reimplement a compiler badly through unit testing saving a lot of time.- Tooling, full framework used to be hell and very tied to the (paid) tools. Now with Core the tooling is great and Linux support is fantastic.Overall I don't want to work in any other language if I can stick to C# but the fact startups don't use it mean I might have to enter scripting language hell, again.
>- Web framework is not quite on-par with Django/Rails. Particularly with auth/OIDC.Completely wrong. Not only does Auth work particularly well out of the box, but microsoft documentation is top tier with both c# and asp net core.https://docs.microsoft.com/en-us/aspnet/core/security/authen...asp net core is the single best framework for backend web at this time, but yes, won't be as fast to ship as django/rails. If you like to maintain code, I'd consider it a worthy tradeoff.
Ah, fair criticism, thanks for educating me. To be honest I'm repeating barely-remembered experience from years ago now, time flies. I just always found documentation pushing to Azure AD, or the now paid IdentityServer stuff, when it comes to SSO.The other thing that works against me in having a Django-like experience with web is I always switch away from EntityFramework as early as possible in favour of handwritten SQl. I think a fair comparison probably puts EF level with or ahead of Django.But this auth documentation looks interesting and definitely an improvement.
Their offical "SPA API Auth" involves paying for a third party OAuth server (called Duende IdentityServer, the ASP.NET Core built-in auth solution on the other hand is called ASP.NET Core Identity) and Microsoft refused to ship their own server because that would be "competing with the open source community" (there are multiple long Github threads on this which Microsoft product people would lock and mute). I wonder which PM got kickbacks for that decision. Originally Duende IdentityServer was free under Apache, and then they immediately turned into a paid solution after they became the "official" solution for API Auth. Microsoft also claims that standard cookie auth cannot be used for API Auth in a SPA scenario (their security engineers insist that you use JWTs), if you look through their Github issue threads, the ASP.NET Core engineers seem to believe that the default ASP.NET Core Identity generic cookie auth is for MVC only and it is "not recommended" for use with SPAs.https://docs.microsoft.com/en-us/aspnet/core/security/authen...https://duendesoftware.com/products/identityserverThey like to hide their dirty laundry behind clever developer advocacy teams and drowning it in Github bureaucracy but here are some examples:https://github.com/dotnet/AspNetCore.Docs/issues/25832https://github.com/dotnet/AspNetCore.Docs/issues/7644#issuec...https://github.com/dotnet/AspNetCore.Docs/issues/24157https://github.com/dotnet/AspNetCore.Docs/issues/18524Their PMs are not building an open source product in good faith. As far as they are concerned, ASP.NET Core primarily exists as a funnel to send customers into Azure or buy stuff from Microsoft partner companies. Imagine if Vercel one day removes the standalone server hosting option and requires you to pay for their serverless cloud to use important features. This is what Microsoft is doing here right now with ASP.NET Core. If you lock your stack into their ecosystem, then be prepared to spend money either on redundant cloud subscriptions or developers reinventing the wheel on core features
It's not Microsoft's fault that Duende took their ball and went home, becoming a closed source operation after years of open source work. That's on Duende for being bad Open Source community members.I somewhat sympathize that Duende's unpaid support costs went up once Microsoft pointed a lot of heat their way by including it in official samples, and theyshouldget paid for support. I also somewhat sympathize that closing their source was seen as the easiest option to redirect the community to paid support plans.But it's still a jerk move in the Open Source community to have code be open source for more than a decade and then close it simply because it was used in one tutorial/sample too many.Sure, Microsoft could have offered sponsorships or other help,hadDuende asked. Supposedly Duende didn't ask, their first public response was when they immediately went closed sourced because apparently they never really cared about Open Source.There are people not building an open source product in good faith in this story, but it doesn't seem to be Microsoft (surprisingly).Microsoft probably should replace IdentityServer with something that actuallywantsto be good Open Source in the samples again. They are between a rock and a hard place because if they fork the last Apache versions of IdentityServer they look like the bad guy for "stealing" Duende's work at that point, and they can't resurrect their old code because it was bad. They probably have to wait for some third party fed up enough with paying Duende for bad faith Open Source to make their own fork.
They don't have to fork anything, they can just add a built-in OAuth to ASP.NET Core Identity. They did that with JSON and created an in-house alternative to Newtonsoft's fast JSON library once it became popular enough. I didn't hear any PMs whining about "competing with the open source community" then.
OAuth is too (stupidly) complicated for "just add a built-in OAuth to ASP.NET Core Identity". Theyhadthat in previous samples (which you can still find online if you look) and it was bad code that suffered from code rot and stopped being "OAuth compliant" especially with respect to even more (stupidly) complicated OIDC, so they looked for someone to maintain that and IdentityServeralreadyexisted and was OAuth compliant/audited. That's why it needs to be forked. Someone has to do the OAuth/OIDC hard work. Microsoftispaid to do that in other divisions of the company, of course, but it's all in Azure and they want you to pay for Azure AD alphabet soup that pays the bills for their OAuth/OIDC compatibility auditing.> They did that with JSON and created an in-house alternative to Newtonsoft's fast JSON library once it became popular enough. I didn't hear any PMs whining about "competing with the open source community" then.James Newton-King, the "Newton of Newtonsoft", was one of thedevelopersinvolved in that project that decided a clean compatibility break with JSON.NET (which has been showing its age, but also has far too many users to easily break API compatibility) was necessary to achieve the performance goals that System.Text.Json was created to meet. That's not so much competition as it is cooperation.
Cookies work great for SPAs and I highly recommend the path for first party auth. Setting up CSRF tokens on the frontend is a lot easier than setting up OIDC.
That's correct. And if you have configuredSameSitecorrrectly and your GET request handlers are locked down, you don't event need CSRF tokens. Unfortunately Microsoft ASP.NET Core security engineers' careers seem to depend on have differing opinions on how to secure SPAs and APIs.
> Intellisense means you barely ever need to type more than 2 characters to express your intent.Agreed Intellisense is pretty good. Not excellent - it never suggests using statements as a first option, and in unit tests I have to always type "Asser" to bring up "Assert" (using 2022 expensive version). But it pretty good.From atoolingperspective, this a positive. From alanguageperspective, well there are other languages that allow flow-of-thought without needing the tooling to autofill [0]. There are tradeoffs, and practically speaking you'll need to eventually look at someone else's flow of thought and expect them to understand yours.[0]https://www.wisdomandwonder.com/article/10231/if-you-like-li..."...by and large, I find that
the language allows me to express myself, in the language, about the things
I’m dealing with. I find that a very precious property of a programming
language."
> - .NET is not really viable for non-server work. There is embedded/desktop stuff but you're going to have a headache outside of servers.As an outsider to this ecosystem, desktop development is one of the things that has me interested in C# at all (built in windows stuff + Avalonia + Xamarin and the like).Can you elaborate this?
MAUI is the continuation/rebrand of Xamarin, most especially Xamarin Forms (as some of what used to be Xamarin is now just baked into .NET at lower levels). It's still more cross-platform mobile focused (iOS and Android seem to be the best tested platforms), though with support for full WinUI 3 and macOS Catalyst the lines are blurrier than ever between mobile and desktop development, especially if you are trying to write a cross-platform app. The biggest missing link for cross-platform desktop development in MAUI is Linux. (There's at least one open source fork working on a GtkSharp implementation/backend for Linux, but I don't know the ETA on that shipping.)
IMHO, you only know a .NET platform is there to stay when they finally get around to adding VB support to it. WinForms? Solid. WPF? Here forever. UWP? Never going to go away..NET MAUI? Who the heck knows, it's still C# only.
MAUIonWindows desktop isjusta cross-platform wrapper around WinUI 3 (UWP's UI replacement) on top of WPF. Worst case, if you are building Windows Desktop apps, you eject back to WPF. [0] For the rest of the platforms you could switch to Avalonia or Uno perhaps.[0] Though of course the question then is that if you are building WinUI 3 apps and don't need cross-platform why you don't just use WPF directly, and I don't have a good answer there. I think MAUI might be slightly more appealing if there was a stronger bridge from "start with a WPF app then expand it to MAUI". (You can do it, in some ways it is straightforward, but it's not an official garden path.)(ETA: Though I get you on the VB.NET as gate idea. It's a big reason I still don't entirely trust Razor much less all the hype around Blazor. Blazor more than anything feels way too much "for people that missed Silverlight, here's a worse ASP.NET Core Silverlight" with shades of ASP Classic runat="server" full circle)
The entire cross-platform path is extremely rocky. Let me give you an example:My home automation system runs as a .NET Framework WinForms app written in VB. I'm interested in moving it into two directions: I would rather run it as a service, and I would like to be able to run it on Linux. VB .NET works on .NET Core in Linux environments, without a UI framework like MAUI, this should be trivial to accomplish both... right? RIGHT?Visual Studio happily provides a .NET Framework template for building a Windows Service (for C# or VB), which my app could work under pretty easily. Or there's a Worker Service template which is cross-platform .NET Core (for C# or F# only... for no technical reason whatsoever, Microsoft just didn't want to bother)The Windows Service template provides basically the scaffolding entry points for every way you interact with a Windows Service, you can pretty much just paste the code in for what happens when the service starts and stops. This is straightforward and easy and you can tell was designed by the same sort of people who came up with the WinForms editor: It's simple, it's obvious, and anyone can do it. I wrote my first practical Windows service one day, and it was done that day.There's instructions for turning a Worker Service into a Windows Service here:https://docs.microsoft.com/en-us/dotnet/core/extensions/wind...I think it's safe to say, this is not simple or straightforward in any way (especially since "Rewrite the entire worker class" is a step here...And that gets you back to... a Windows-only service? What the actual heck?So here's what I am mind-boggled hasn't happened here: Microsoft should have a cross-platform service template (in all supported languages, please and thank you), and it should give you entry points for starting and stopping the service and such which areall pretty much the same between operating systems, and then it should handle the scaffolding to translate it to the appropriate OS out of the box.
That's a very different can of worms. I've used third party libraries for Windows Services since forever because the .NET Framework templates were never great and Windows Services are a bad idea that are dumb to create and I think awful to maintain/manage.At this point, personally, given the choice, I'd rather just create boring CLI applications that I can stick in cron jobs (or Windows Scheduled Tasks) than ever create another Windows Service if I can avoid it.Given how dumb it is to create Windows Services and how dumb it is getting to create systemd-style services for Linux I can't possibly imagine how anyone could abstract that well cross-platform. That sounds like an awful minefield to create lowest common denominators that no one likes.I think we already have such a cross-platform abstraction: it's classic CLI apps and whatever task runners you can find/stomach. .NET Core/.NET 5+ isgreatat cross-platform CLI apps.
Lowest common denominators work great though, arguably nearly every classic Visual Studio template is a lowest common denominator. Here's one WinForm the starts when you press run. And there's a dozen ways that the way that comes out of the box needs to be changed, but itworks out of the box.I think the .NET Core templates are really demonstrating a lack of understanding of why Visual Studio has thrived for this long.
This is poetry! Spot on.
Early comment in the thread but I wonder if the overall “zeitgeist” opinion of C#/.NET/Microsoft has changed. Used to be in /. days that a lot of people stayed away from Microsoft stuff, preferring Python, Ruby. Then Stack Overflow came and things slowly started shifting.I do internal dev tooling in C#. It’s one of the best languages out there for raw “get shit done” prowess. I’ve used many languages throughout the decades, some more elegant than others. Like others, I’m a bit wary of the explosion of syntax shortcuts and alternatives, but whatever, its no big deal. It’s a great all-around, general purpose language. I would love to use F# more but I don’t think some decisions they’ve made would go over well with many people.
At least looking at job boards, there's a problem with .NET mostly being stuck in its own stack with little overlap while many jobs existing scoff at the idea of e.g. letting Java and .NET devs jump from one to another. Which leaves .NET in a weird position of having to go all-in, even if it has a high market share.Without that stigma it's fine, .NET has a lot of answers to various things even if you have to deal with the Microsoft flavor. Similar to Java which still dominates most of the market in the same space.
>  I don’t think some decisions they’ve made would go over well with many peopleI'd love to know more about what you think and are referring to.
I've been developing with C# professionally since 2012. I'm using dotnet core since the 3.1 release.Pros:- Superb IDE. Nowadays even without Resharper, which was a must have in my early C# days.- Massive standard library and extensive documentation makes for a very productive development experience (especially backends).- dotnet core was a huge leap forward in terms of dev tooling (sane cli, 3rd party integration) and framework flexibility (configurability in general, config by code instead of XML)- Microsoft keeps adding language features copied from functional programming languages.Cons:- Enterprise culture is very pattern-centric and produces much boiler plate code. That's the main reason I want to move away from dotnet.- Desktop apps are not cross-platform and I don't trust their newer stuff to deliver on that promise. The older WPF is outdated (e.g. no inbuilt support for "newer" features like async/await) because of their focus on Xamarin and MAUI or whatever new fad they come up with.- Microsoft seems to swallow open source libs by integrating them or copies of them (e.g. Newtonsoft.Json) into the standard lib. I'm not sure if this is a good thing. I know I'm contradicting the "massive standard lib" pro from above. But here I'm thinking long-term.- New language features are sometimes done half-assed for backwards compatibility. E.g. nullable reference types that are just syntax sugar instead of a proper maybe monad with language integration.
I think the absorbing into .NET behavior of their standard library is the standout reason to use .NET: You aren't going to have to shim basic functionality out to some random third party who might or might not abandon the code, and could inject malware or telemetry down the road without telling you.The .NET approach of ensuring you can do nearly everything an app might need basic functionality-wise in the standard library probably sets .NET as one of the most secure platforms to develop with.It's the anti-NPM, and NPM is terrible for security.
It's really hard to get an objective view of a lang asking for a random thought :-) C# has a decent number of fans acquired because of Intellisense mostly, there's also not an insignificant amount of people who find it "meh" (boring, Microsoft etc.) If you are asking to evaluate it as an investment - it seems to be a pretty solid choice, though employability of a C# dev differs between locations. If it's just for fun/pet project, then it's better just to give it a try.
I love it, but then I've been doing C# since the beginning.  The language does appear to show its age though.  I recently tried teaching it to my kid and realized that it has grown quite a bit of cruft.There are a ridiculous amounts of ways to declare a variable.Employee employee = new Employee();
    var employee = new Employee();
    Employee employee = new();And that doesn't even count the initializers {}, records, dynamic, etc...  All this makes it difficult for a new develop to jump into it.
The first two are not necessarily equivalent. If your class implements an interface you can type the variable as this interface and have different behavior if the interface methods were declared explicitly [1]. You can also use it to interact with for-each loops and some legacy (2.0 and prior) APIs and save yourself an explicit cast.The last one is a very recently added shorthand which, honestly, I think was just implemented because an intern needed a feature on master to get hired or something like that... I don't get it either.1:https://docs.microsoft.com/en-us/dotnet/csharp/programming-g...
The last one is great for field initializers where you can't use var.
The first way is no longer recommended. You are encouraged to only use the latter two for readability (except for the interface object type situation mentioned in the other thread).>The language does appear to show its age though.Come to Java land. It takes decades to add a single feature. Grass is always greener.
Just wanted to add... C# being strongly typed language, some times can be a pain.
Just spent an hour trying to parse a JSON String; changing its parts and again de-serializing it... working with JObject, JToken, etc..so on; Though i'm just getting familiar with it.
This is where the C# `dynamic` keyword sometimes shines. It's a lesser known feature from a project called the DLR that tried to shake up the CLR to better support more languages like IronPython and IronRuby. Both IronPython and IronRuby kind of got scrapped/pushed aside, and the DLR never quite got the love it deserved, but what remains is still sometimes useful. If you are still using JSON.NET (Newtonsoft.JSON) (which you did mention its JSON LINQ JObject/JToken, etc.), it still supports the `dynamic` operator for working with JSON "more naturally":dynamic jsonObject = JObject.Parse(someJsonString);
  jsonObject.some.deep[1].propertyName = "Updated string";
  return jsonObject.ToString(); // re-serialize the updated JSONYou don't get much IntelliSense when using dynamic, but it makes it much easier to write what you want/expect to write with a JSON object than if you were navigating the JSON LINQ (JObject/JToken/etc) objects by hand.The documentation still includes pages on dynamic, even though dynamic has become a mostly forgotten feature and there are still developers that would never use dynamic. For example:https://www.newtonsoft.com/json/help/html/QueryJsonDynamic.h...I appreciate that dynamic exists in C#. I've done some wild things with dynamic over the years. It sometimes makes me sad how under-appreciated a tool it can be.ETA: Obviously dynamic is not type-safe, it's a great escape hatch from type safety for small cases where "just do what I want" is nicer/more natural than type safety. As the sibling comment points out, if you still prefer type safety there are type deserializers that can be easier to use. These days with records in C# 9+ writing quick types to deserialize to is even relatively painless.
You should be able to simply use Json.Deserialize<T>() ?The beauty of types in this case is that the JSON structure has a natural way to be expressed in C#… we just need to utilize itOr a JsonNode if you don’t know the structure
If you are using VS try the JSON to Class converter that's built in.https://www.howtosolutions.net/2020/07/visual-studio-creatin...
Modern C# is a decent language.But legacy projects are still everywhere, and not only are they frustrating because outdated language version, but Microsoft is actively removing downloads for old .NET versions I need to maintain those legacy projects.
Comfortable language, great ecosystem. But it’s Microsoft Java, so to make a career out of C# inevitably means boring enterprise work.There are exceptions like Game Development of course.
I also think that C# and .NET are awesome. Especially latest releases dotnet 6 and upcoming 7 have a ton of new things to be even more productive.I like the fact, that you can develop command line apps, Web APIs, Desktop Apps and smartphone apps all with the same toolset, including the fact that deployment is possible on nearly every major platform for every major platform (except iOS and macOS Apps, as always only on macOS). Even systems programming and AOT is doable or full featured static deployment is possible integrating a small runtime into a single binary.And boy is .NET fast...This facts made Golang pretty interesting to me, but what I did not like here is the lack of a usable cross platform Plugin-Loader technology, most of the stuff has to be monolithic, then the module management and some of the missing concepts (like generics, which is also now available in go).The sheer amount of concepts in C# is overwhelming (from basics like Generics to less common ones like Extension-Methods, operator overloading, etc.).I don't like Visual Studio as IDE, but VS Code is an acceptable alternative tool, although I personally prefer the non-free JetBrains Rider.Nuget package manager also has it's caveats, e.g. that the official repo can only "unlist" packages, not delete them or that the publish times sometimes have horrible delays, but that's also still acceptable, since you can use the github package registry or bring your own to overcome these issues.Technologies on my todo list include getting into MAUI (a cross platform UI stack) combined with Blazor[1], which can use Web Components in native UI apps and develop TRULY cross platform (Web, Desktop AND Mobile with the same codebase). Like electron, but without the browser dependency due to native integration.Although everything is tied pretty tight to Microsoft, there is a huge open source community developing cross platform libraries, that are easy to use. Even though i find that microsoft has often made strange decisions in the past, the current state is clearly a recommendation to have a look.https://www.youtube.com/watch?v=2eIsQ3Pm2bE
I've been a .NET developer professionally for seven and a half years. Rider is the way to go. Visual Studio has improved dramatically over the last decade or so, but Rider is still way ahead of it on code search/discovery, performance, and general user experience. I did a tech talk at my company where I demoed Rider vs Visual Studio 2019 performance on our bigger projects... it was embarrassing for VS. VS 2022 was substantially better on performance, but also crashed during the demo.
I'd love to watch that talk if you're comfortable posting a link
Unfortunately, because it contains proprietary source, I cannot :(.
I'd love to use Rider on Linux or even Windows. Sadly the lack of .NET hot reload on Linux and Rider's issues with hot reload on Windows are what keep me on Visual Studio. (Rider's implementation of hot reload doesn't support assemblies loaded at runtime yet, which my application depends on).It's sad that the time saved with Visual Studio's hot reload alone seems to outweigh the (massive) performance gains from using Rider, given that I have to restart VS from its memory leaks multiple times a day or it will slow to a crawl. Omnisharp isn't performant or reliable enough for daily use, either. The current state of .NET tooling leaves me unsatisfied.
I’m amazed hot reload works consistently enough for you to be able to use it.
Visual Studio is great, but also one of the most broken bits of software I've had to use.
Rider does not have a community edition unlike IDEA. It was created due to a combined threat of VS Code and Roslyn and is the reason ReSharper is almost neglected these days.
ReSharper isn't a heavy focus because it's not worth it anymore. To get the same performance as other tools they'd need to throw out a ton of work and rewrite it for Roslyn. With Rider, they get to continue to use their existing ReSharper codebase to power it.
Was that comparison both with or without ReSharper? Were you comparing fresh installs with no plugins on both sides?
And...how do both companies compare in what telemetry they're sucking out of devs?
Opt out is ridiculous for a programming language. Do you really want to play security whack-a-mole with your development environment?There are countless, better privacy respecting tools.
About the 'dependency problem':It's not as bad as in npm with node_modules, because .NET provides a lot of base functionality in the standard library.But when you start to use multiple nuget packages, sooner or later you will also enter dependency hell, where managing versions and updates of nuget packages gets very painful.All in all we have to reference about 10 external libraries. The visual studio nuget package manager started to be frustrating if you need to manage those dependencies in multiple solutions. We therefore switched to Central Package Management [1], but then you realize, that you're just shifting the problem around. Now we have to put the whole dependency tree into the file 'Directory.Packages.props' and have to manage the version of 140 libraries. If there are version conflicts, we force nuget to use the latest version and just hope for the best.Managing versions of dependencies and dependencies of dependencies is a major pain, but it's an ubiquous pain all programming environments share. And no, .NET won't relieve you from that.[1]https://docs.microsoft.com/en-us/nuget/consume-packages/cent...
I'm not sure if it will help in your scenario, but faced with a similar problem (~80 project solution, mixed c#/f#, with varying dependencies), I found success with Paket (https://github.com/fsprojects/Paket)It is much more prevalent in the f# community (at this point `dotnet restore` is a perfectly fine default until you hit trouble), but isn't limited to just being applied there.
Yeah this is probably one of the biggest pain points, but modern tooling is really helping to the tide on this. Dependency management is never fun in any language, and .NET has some quirks which make it a challenge as you say. I switched to .NET from java about 5 years ago now and I'm pretty I !are the switch as .NET just keeps getting better. Dependency management is one of the last pieces of the puzzle to really solve for in terms of getting a much better experience. That said if you're starting a brand new .NET project today you can set up your CI/CD pipelines to do Continuous Deployment and use Renovate to automatically upgrade your dependencies and merge if your tests are green. In addition the trend is for smaller codebases these days which makes it far easier to upgrade major versions of dependencies due to much smaller scope of breaking changes. I think those two things in combination eliminate some of the pain we've all felt with not being able to upgrade several years out of date dependencies in huge monolithic codebases. I'm pretty excited for the future of .NET to be honest.
Did you really mean only 10 external libraries? If you'd said 100 I could understand - I hit a version conflict issue in a recent project on adding what was probably package #60 or so, but solved it easily enough after a bit of googling. And we knew we were using a lot of quite old packages (including .NET 2.1 EF, because of a rare breaking change they introduced with 3.0 that we didn't have a good solution for).
Technically just 2 libs are enough to produce the issue...
Our dev loop playbook at work has an advice to never touch Visual Studio's nuget package manager haha.Instead, dotnet CLI + VS Codes find+replace does a very good job at managing dependencies. It has never been a pain and on project build, all imported version will be consolidated to a single one anyway.
> I don't like Visual Studio as IDE, but VS Code is an acceptable alternative tool, although I personally prefer the non-free JetBrains Rider.I've used Visual Studio for 20 years now, and while the tooling has come a long way, I'm starting to feel like MS and the community are abandoning it for VS Code.  I don't mind VS code, but unfortunately the stack I'm working in (Dynamics 365) requires plugins for Visual Studio that tend to lag behind the release cycle of Visual Studio versions by a few years.  I use Rider for .net core projects on my mac and it's fantastic.In fact my biggest criticism of my day to day job is Microsoft's support for this incredibly enterprisey framework I have to work in.
Hey fellow Dynamics 365 (CRM?) developer.I see they move in VSCode direction with tools like Power Platform CLI [1], power platform tools extension [2]. PCF (PowerAps Component framework) enabling to develop UI components in frontend framework-of-choice... however none of that is available (yet?) for On-Premise deployment so we're 2nd class citizens. Because of that, haven't been able to play with this and try out so don't know how far that tooling goes.As a platform, I really like it. Sane, consistent (except some very early stuff there), the backend extensibility - thumbs up for that.[1]https://docs.microsoft.com/en-us/power-platform/developer/cl...[2]https://marketplace.visualstudio.com/items?itemName=microsof...
F&O, sadly...
F&O would be former AX? That seems highly rewarded field. I know it only from SQL point of view - It helped grow my SQL skills when SQL would be brought to it's knees (along with the business) due to skewed data distribution and occasional query plan invalidation.
Yep, it's the replacement for AX.  I can't say I love working in it, but the clients are massive and as such, it can be a rewarding financial choice.  The tooling is poor and the APIs are a bit difficult but it's made for some fun workarounds :)
> The sheer amount of concepts in C# is overwhelmingAgreed. But F# is one of the best designed languages around.
I don't disagree, and I love F# but I think it owes a lot of that to OCaml. That said, since we're talking about C#, F# and VS Code I'm gonna vent a little about something that arises when you use all three :DIf you open a C# project in VS Code when the "Ionide" extension (basicallytheF# extension for VS Code) is installed then the extension thinks it's a F# project and will open some F# stuff after a few seconds (or prompt you to setup some F# stuff in its gitignore). The root cause has been identified (plugin activates when it sees a ".sln" file), a PR has been opened and rejected with no mention as to why (https://github.com/ionide/ionide-vscode-fsharp/pull/1401) and the developers behind it are frustratingly non-communicative about it, closing issues about it (https://github.com/ionide/ionide-vscode-fsharp/issues/1701), they're not present in the discussion (https://github.com/ionide/ionide-vscode-fsharp/discussions/1...). Usual rules about OSS maintainers apply, they don't technically owe us users anything, we should be patient and respectful etc ... but man it is truly bizarre to be ignored or ghosted like this.
I still need to get into OCaml. I of course know bits by virtue of having used F# and SML, but OCaml definitely has its own unique features. For F#, I appreciate how well it sits upon the host VM for the CLR and .NET. It just integrates almost seamlessly while still being a functional-first ML. When I use F#, it's by far the easiest code I write. I find myself just writing out the domain and boom, I got a working program. Recently, I wrote some bindings for a C/C++ DLL, and F# really made that easy. It's the easiest time I've ever had creating such bindings in a language.For the Ionide stuff, I agree. I don't use it, even though I use Visual Studio Code for other languages, and am happy enough with Visual Studio on Windows and Visual Studio for Mac on macOS.
>  that the official repo can only "unlist" packages, not delete them or that the publish times sometimes have horrible delaysIt's to avoid the npm left-pad problem. nuget.org packages are idempotent.For the publish times, I found out you can cut it in more than half if you tell nuget to ignore caches.
I know... but sometimes it is a bad thing for indie hackers testing around :-)Draft releases would be awesome.
You don't have to use Nuget.org, it's just the public community version of a Nuget package repo.You can use your own private repos like MyGet[1] or Github Packages [2].1.https://www.myget.org/2.https://docs.github.com/en/packages/working-with-a-github-pa...
Yeah I know all this, you can even use BaGet[1] symbol server to cache or manage private dependencies in an enterprise network. That is not the point... I think that the most used tool / platform should provide more flexibility for non-enterprise or less expierienced developers.No offense, I like nuget, but I recently made a typo and checked in 0.0.23 instead of 0.0.2. Now, everytime I add a dependency that is < 0.0.23 to a project, that has not been synchronized / validated yet (the other problem I described), it automatically takes the best match, which is 0.0.23 assuming to be the newest package, even if unlisted.I also burned a 1.0.0 because of a failing script like that... not really bad, but annoying...https://github.com/loic-sharma/BaGet
FYI Nuget also work with folders.Drop nupkg in a folder, use it as a source, you now have a "feed".
Why not just setup a local feed?
Idempotent, in which way? Do you perhaps mean immutable?
Yes, sorry, I meant immutable, not idempotent.
Just developed something using MAUI's predecessor Xamarin.FormsIt was perfect and exactly what I wanted. I had experience with XAML and MVVM thanks to Silverlight and WPF, so that explains at least some of why it was such a breeze. But it is way nicer than coding for the web, and I've done my fair share of that.I was able to port over most of the code to MAUI easily, except for the missing controls. But MAUI is very exciting overall, and I look forward to using it more. After a map control is released I will fully port my app.
I tried writing a simple crud api with asp.net, which should parse and respond json. It was the worst development experience I ever had while writing json apis.
Validation? Not existent. OpenAPI/swagger documentation generation? Not existent.
Then it also tried to force me into using MVC, while acting that it is express with its middlewares.I switched back to node.js with fastify and wrote my app in an hour.I really like C# for cli and windows desktop applications, but I probably won’t touch it for the web in the next few years.
As a C# developer I could say the same about my experience dealing with my first foray into [insert random language] and my attempt to develop [something with a non-trivial framework].The issues you had could be attacked by navigating through this section of documentation, diving into the tutorial referenced in the beginning of the Overview section and the subsequent sections:https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=a.... This is not necessarily in defense of c# and dotnet, but this reads like you barely spent any time trying to digest the documentation.
I’ve been a C# developer for a decade and I still think it’s hopelessly convoluted for getting very simple things up and running. Maybe there is something wrong with me, but it’s just not intuitive to me and it has frankly never been. I do think the move to core and then core to .net has improved things, but it’s still a really weird and way of doing things compared to other languages that I have worked with, and most of the “boiler plate projects” are very rarely useful, so why are they there?Then once you need to go beyond the standard libraries it becomes a nightmare to deal with. In some cases, like extending the AD libraries, it’s sort of easy to extend classes with methods but the documentation on how to do so tends to assume a lot of domain knowledge. In other cases like if EF’s standard functionality isn’t enough for you, or you need to deal with weirdly formatted XML or non standard SOAP requests (don’t ask) it can be such a nightmare that it’s sometimes easier to write a micro-service in another language to do the “translation”.I think it speaks of a language that doesn’t see too much use by its own creators. I may be wrong on that, but having build a lot of things for Azure, Typescript has often felt more like a first class citizen than C#. Obviously not for everything, far from it, but sometimes and those sometimes are enough to make C# troublesome because unlike things like typescript that are great second class citizens in the Microsoft ecosystem, C# isn’t. It either fits really well or you have to fight it.
I wholly disagree as a person who worked in C#/.NET for over 15 years and recently waded into Node/JS/TS dev. C# and .NET are hands down the easiest platform to start on.
In my decade around management that was not my experience with onboarding new people.Maybe that is because we didn’t have a fascist linter for C# the way we do with Typescript, but it’s always been much, much, harder to get people to make “good” C# code in my experience. It hasn’t been hard to have the build things in C#, but it’s been hard to get people to build things the same way so that they can work on each others code flawlessly. So hard that I would never again consider using resources on it until developers drop significantly in pay, which isn’t likely to happen until I’m retired, if  ever.I wonder if it has to do with regional differences. I’m Danish, everyone (there are odd cases, but it’s more “everyone” than “almost everyone”) here has a CS degree and often they’ve been taught Java, sometimes C# but poorly, while obtaining it.
> I’ve been a C# developer for a decade and I still think it’s hopelessly convoluted for getting very simple things up and running.For me, fsharp interactive is one of the best prototyping experience I have ever experienced.
You are actually right. Today I opened the documentation again:https://docs.microsoft.com/en-us/aspnet/core/web-api/route-t...And it says right at the bottom, that OpenAPI and model binding is not supported in their route to code feature.I initially googled how to create a simple json api, and that’s the documentation which I found. Looks really easy in the beginning, but after you’re done with your routes, you’ll read at the end of the documentation, that OpenAPI generation, model binding etc is not supported. I blame that the guide‘s title is misleading and - of course - that I should’ve read till the end before actually following any step of that tutorial.
That's true (and minimal APIs help a lot) but ASP.NET still has a real problem with too much magic.For example, the secret incantations required to output a mere string as raw json mimetype or log incoming deserialization errors* are unintuitive and very labourious - see InvalidModelStateResponseFactory. Or that I had to create a custom output formatter to output raw json. Why? Sometimes I just want ASP.NET to get out of my way and it's not trivial to tell it to let go.* For example, url?parameter=1 for a boolean parameter, which would have worked with .NET Framework but won't for .NET Core/.NET.
I think that's the barrier with C# in general - the framework nature of it means there's a lot of "I don't know what I don't know" especially with ASP.NET which is quite large in scope. Don't get me wrong - that's the usual dev reaction when switching from their familiar language/tools to a new one but I don't think, at least historically, C#/ASP.NET made it as easy as it could of been. Which namespace do I open to import the right extension method to register swagger generation? How do I configure it? All that stuff IS existent actually and having worked with both in my current role the .NET version eventually ends up being a "just works" experience. Its just hard to approach and integrate if you don't already know the "patterns" and the libraries. Sadly there's a lot to learn compared to say Fastify for a basic working app. However it is very configurable and flexible. I've seen the same reaction from dev's to the Spring Framework as well - its just feels bloated for a lack of a better term to people coming from JS.As per another comment after having seen JS devs switch to F# for very large professional application and not wanting to go back I feel its fine for web. YMMV.
> Which namespace do I open to import the right extension method to register swagger generationIf you use the templates provided by .NET Command Line Interface or Visual Studio, you'll get this all baked in & setup.VS also added a very nice feature where it suggests & imports popular packages if you type a method on a type that's well known. If you already have it added to your project but need a using statement in this file, it'll pick that up fast as well.They've also improved their docs quite a bit from years ago with lots of good examples for common things.
These are nice but:- Templates are no substitute for intuitive and minimal code for a number of reasons. (e.g. how to extend, how to customize, confidence that it isn't brittle if I change one thing, etc etc). If a template doesn't have the exact variation you want (e.g. a faster logging library) the learning curve is very high for a newcomer .NET dev. NOTE: I think this applies to some other OO languages too.- Suggesting popular packages and namespaces is a great tooling improvement. But it could also imply a closed wall garden. The fact that other non C#/Java like languages don't have this problem even with something as minimal as VS Code as your IDE shows that the tooling is trying to cover over a language and/or library problem. With the Java/C#/other old OO lang workflow you need the knowledge you need to use the library itself (convention based, which class, which extension method, which namespace for that object to configure this feature, startup class conventions, etc). It isn't discoverable even with the packages imported. Remember just getting Serilog working in new ASP.Core and it taking a day or so with all the packages, config, etc etc if you don't already know what you are doing.I like the improved docs. But fundamentally simplification/minimization is better. I think the dev workflow that means I don't need these tooling improvements is still a better experience. I like .NET, but I do understand when using other languages they seem to not have these issues despite not having the uber tooling that C# has. They don't have package suggestions, they barely even have auto complete yet the library design feels a lot more intuitive.I can look up say a Fastify, Golang, even some F# examples with something like Giraffe and get a web app quickly with little code and no convention magic with everything being explicit yet concise. No fancy attributes I need to remember, no conventions in my startup classes I need to understand if any customisation, even dep injection is something to learn from people coming from some other platforms rather than just standard library calls composed together.I actually like the .NET platform, don't get me wrong, I do think it is one of the best web platforms right now. Its more intuitive than Spring/Java as a comparison but that isn't saying much IMO. For newcomers I think the user experience to newcomers who are used to a lot less ceremony could be improved further. My first suggestion would be less "developer headspace required" to get started. On a personal note I think natural F# code tends to favor this from the teams I've been in but can't put my exact finger on a reason as to why - it feels more like coding Go/JS to me at least than C#.
I'm curious who does this well? I've personally not found any specific language or framework that is better than others unless you're using their preferred libraries. At that point it depends more on the library authors than the base framework.For newcomers, I would say the best user experience (no matter language/framework) is provided by code hinting such as GitHub GitLens & competitors do. If I'm using an unfamiliar framework/language it's great at suggesting what I might want without me having to search.You might really like the new .NET minimal APIs that are being built for web development. They're very similar to a Node.JS style of API.In regards to logging specifically, I've found swapping logging tools fairly easy & straightforward as far as adding the logging in the code base. If there has been anything challenging it's been outside the code base & setting up the infrastructure or learning the logging's reporting tools. I'm curious what was challenging for .NET with you. It's usually as simple as using Ilogger no matter the tool & writing a few lines in the program.cs file.
Validation and Swagger/OpenAPI have been available for a long time and well documented. I don't know what resources you used to learn ASP.NET, but they failed you.
Looks like I was using the wrong ASP.NET features!
Route-to-code does not support OpenAPI.https://docs.microsoft.com/en-us/aspnet/core/web-api/route-t...
All the way back to .NET Framework 4.5 at very least (2012).
Well, while I understand, what you are trying to say (a simple crud web api should be easy to accomplish), I think that you were just overwhelmed by amount of possibilities, tutorials and outdated information, because C# / .NET is evolving fast.That said, you may take a look at my small very early state pet project `tonehub`[1], which can be seen as pretty modern CRUD Web API in 2022, utilizing swashbuckle for OpenAPI, JsonApiDotNet for CRUD, Entity Framework 6 for Database, HostedServices for background tasks and some other nice concepts (DI / IoC, Options Pattern, FileStreams, etc.). I could also use SignalR for WebSockets / Realtime, integrated OpenID/OAUTH2 Authentication, FluentValidation for validation, Api Versioning and much more.I've never accompilished something like this with this small amount of code...[1]https://github.com/sandreas/tonehub
The issue here is that you didn't know what you were doing (which is completely normal when trying a new language)
FluentValidation and Swashbuckle are two great libraries for the tasks you referenced. This is a good enough reference repository should your curiosity be piqued again in the future:https://github.com/jasontaylordev/CleanArchitecture
Yep. The problem that the parent commenter had is distinguishing between "Not existent" i.e. the tool that I am trying out sucks; and "I don't know how to use this tool yet" - a completely normal part of the learning experience.Failing to find the differences between them will impede learning in general.
I'm not sure which learning material you used back then but this seems more like an unfortunate accident.With .NET 6 SDK, 'dotnet new webapi' will give you a template project that does everything you listed save for extended validation logic which you can easily add with 'FluentValidation'.In addition, to run ASP.NET Core nowadays you only need:var builder = WebApplication.CreateBuilder();
  var app = builder.Build();
  app.MapGet("/posts/{name}", ([FromRoute] string name) => /* controller logic, classes will be serialized as JSON */);
  await app.RunAsync("http://localhost:8080");
You did something wrong.dotnet new webapi -minimalThis will scaffold a project which is more or less the exact same as Flask, Express, or any other "easy" framework.OpenAPI output is built-in, but tooling for development does require a bit of knowledge (agree that Microsoft would benefit from making this work out of the box).A small repo here showing how to connect OpenAPI and front-end TypeScript client generation:https://github.com/CharlieDigital/dotnet6-openapi
I think for  swagger documentation you install the swashbuckle nuget package and then add these three linesservices.AddSwaggerGen();app.UseSwagger();app.UseSwaggerUI();
ASP.NET configuration is one of the most arcane parts of .NET that I don't like. You have to perform the incantation thrice: add package reference, add service reference, invoke the builder extension. And there's the right order and the wrong order of invocations, and if you pick the wrong one, your app silently won't work correctly.
Arcane? What did you expect? Add a package and magically everything works? If you make it work by just adding a reference its “too much magic”, if you  make it so people write everything “it’s boilerplate” and if you do something in between “its arcane”.
Personally, I'd rather generate documentation at compile time.
I do it during tests.Since I'm already spawning a TestHost and trying out various API calls, one of these tests basically does "curl $host/openapi/openapi.json | diff ./docs/openapi.json". If it spots a change and fails the test, I check that the difference is expected, and if so I temporarily enable and run a different "test" which actually writes the updated file.
Which you can do, by adding a post build step.
> It was the worst development experience I ever had while writing json apis. Validation? Not existent. OpenAPI/swagger documentation generation? Not existent.They are existent and good.
Totally opposite experience for me.  C# + .NET ASP core Web Api framework + Swashbuckle + FluentValidation does out of the box what I still haven't seen a good solution for in the NodeJs world (which is the one I'm in now).
NestJS seems to hit the sweet spot for these. I'd add a proper Result type (from fp-ts) to get better error handling (than try-catch everywhere) and you're good to go.
We've just started looking into that, but the amount of existing raw JS+express we have means adopting something like NestJS is going to be a huge undertaking. What slightly baffles me is that at no point did anyone seem to stop and think if there shouldn't be a better way...
You don’t need to use MVC either since minimal APIs are a thing now
What do you actually mean by "non-existent"? The asp.net framework includes more functionality by default with its standard libraries than just about anything else.
But Node.js doesn't ship with those features built-in either?
This thread shows there is still a large amount of FUD around .NET and it’s community.Folks here still think it’s Windows-only and comparable to Java. Yet latest TechEmpower benchmarks shows .net running on Linux and being faster than Go, Python, Node, and Rust.
The performance really is astonishing in many areas now.The part that keeps me hooked is the fact that I can stand up something capable of producing those numbers in 30 lines of code using 1st party dependencies only. I can then have a full prototype to demo by late afternoon, again having antagonized over exactly zero 3rd parties.For me, the performance numbers aren’t just about speed while in production. It’s also about speedtoproduction. Having the confidence that it’s almost certainly going to be fast enough by default keeps me from worrying about optimizing random bullshit throughout.I still haven’t seen anything that comes remotely close to the combination of speed and stability offered here. I do some pretty nasty things with the runtime and it just copes.  GC seems like pure magic now too. I continue to avoid things like LOH allocations with streams, but I don’t worry about it like I used to in the 4.x days.
If you like the productivity, just wait till you try Rails.
>If you like the productivity, just wait till you try Rails.I like Rails (vintage, Rails 5).  Unfortunately DotNet and EF combined now have virtually the same productivity but with massively better performance.  Which is a shame as Ruby is a great language.
I’ve tried very hard to use EF. If you think it’s equivalent to the productivity of ActiveRecord, well… more power to you, I guess.
And that's why there are so many ecosystems - to cover the variety of tastes and preferences.I think the end game may be one unique ecosystem per developer (like with JS frameworks).
Rails is still a thing in 2022?
Old habits die hard I guess. Some languages just need to buy a coffin already
LOL. That's good. Thanks for that.
PHP is still a thing since time immemorial… And will remain there for a long time to come. (Seems like they made quite some improvements in the latest iterations as well.)
.NET core can run on any platform it wants, but as long as it's from Microsoft, the company as we know it, I won't even write "Hello, World!" with it.A language can't be the fastest at everything in today's mature language ecosystem. OTOH, Debian's "Programming Language Games" benchmarks shows it's on par with Java (which is not slow in any means), and not as fast as you claim [0].In the page I shared, some C# benchmarks are impressively fast, because they are written with explicit hand crafted SSE3/AVX vectors, which a run of the mill programmer won't want to touch (for most of the time, anyway).Comparing .NET Core, which is a hybrid JIT language with purely interpreted ones like NodeJS and Python also makes no sense at all, considering Python Compiler does not do any optimizations whatsoever, and is still confined to a single core per process unless you pull some tricks.Choosing horses for courses is fine, and we all shall do it, but claiming a language as winner over a single benchmark suite, including the one I referenced is wrong.Choose what works best for you.[0]:https://benchmarksgame-team.pages.debian.net/benchmarksgame/...
The difference between the shootout microbenchmarks and the TechEmpower benchmarks is that the former test computation-intensive tasks and the latter test an end-to-end web backend example. It tests how good the compiler is, how good the DB drivers are, how good the HTTP stack is.What's so good about MS ranking in the TechEmpower benchmarks is that it's the fastest full-featured "enterprise" framework. Frameworks like drogon or just-js are impressive feats of engineering, but the only reason they exist is so that their authors can mention that on their resume. If you run them in production, you are on your own.There's equally fast Vert.x, which you can buy support from Red Hat for, but most Java shops use Spring Boot (vmware or Red Hat support available), which is easier, but hopelessly slow in comparison.
> The difference between the shootout microbenchmarks and the TechEmpower benchmarks is that the former test computation-intensive tasks and the latter test an end-to-end web backend example.That proves my point even further, because I don't develop anything remotely web-related, hence that performance scenario is completely moot for me.> What's so good about MS ranking in the TechEmpower benchmarks is that it's the fastest full-featured "enterprise" framework.Again, the same because the software I develop is not "Enterprise" either.What I develop is scientific software, and needs to be extremely performant. In my case C++ is the best language, but it's not the best for every case. This is why I also learn Go and use Python for other tasks.In my case, Debian's benchmarks are directly related to my use cases, however even that's not a definitive measurement for my case. It's just a bunch of data to keep in mind.
> That proves my point even further, because I don't develop anything remotely web-related, hence that performance scenario is completely moot for me.I hope you realize non-web development is a niche nowadays. So it's perfectly reasonable to prioritize .NET benchmarks that target ASP.NET Core web apps/APIs.
I hope you realize that web-development in my discipline is a niche nowadays. So, it's perfectly reasonable to prioritize bare metal and micro performance benchmarks that target naked performance, OS and GPU apps/APIs.Our vantage points are different, and these different vantage points need not to see the complete ecosystem as a whole. It's too big to generalize from a single vantage point, and just because our view reveal us a little of something doesn't mean it is, in fact, little.There's a whole invisible world out there, from DBs themselves to OS kernels to embedded platforms, and everything in between.IOW, horses for courses.
And that's fine. Your niche is valid. Just no need to point out that a benchmark targeted at web frameworks focuses on... web use cases.
> I hope you realize non-web development is a niche nowadays.That's a terrible attitude. If you want a certain ecosystem to get a better rep, you have to be ready to talk with different communities, and accept their feedback.Python is what it is largely because it can cater to a large number of these very different communities, which has ensured its long-term success. Compare with Ruby, which became effectively a web-only language and has since struggled to go anywhere.
> If you want a certain ecosystem to get a better rep, you have to be ready to talk with different communities, and accept their feedback.Hard disagree. I prefer specialized tools over jack-of-all-trades. Otherwise we would be coding web applications in assembly.Your example, Ruby, wouldn't even be a blip in history radar if it wasn't for Ruby on Rails, a specialized and very productive toolkit.Just because RoR now has more competition doesn't mean it isn't/wasn't awesome.
> Otherwise we would be coding web applications in assemblySome people write web-apps in C. Just because you don't like something, it doesn't mean the world agrees.>Ruby, wouldn't even be a blip in history radar if it wasn't for Ruby on RailsHard disagree. Ruby was getting traction on its own, as "the purest OOP language you can use in the real world", around the same time Python was starting to get traction (early 2000s). Then RoR blew up, effectively coopting the entire ecosystem. Since then, Python has slowly gone from strength to strength in so many different fields, whereas Ruby died on its ass as soon as people moved on to other tools for web.
Curious, what is it with Microsoft that makes it so poisonous for you that you won't touch anything they make with a ten foot pole? As an example, I'd say Facebook (Meta) is a way more toxic company but I've never heard of a developer have moral arguments against using React
I'm using Linux for 20 years, and witnessing what Microsoft is doing for more than 25. Being openly hostile towards Linux and plotting ways to lock it out of hardware platforms and tech ecosystems is enough of a motivation for me.It's not only their stance against Linux only, but everything competing with them.I believe hardware and software should be open and platforms shall compete openly. I don't use any vendor which openly kills this interoperability and try to corner market with underhanded tactics.It's not limited to Microsoft, though. I use Java because there's OpenJDK, Go because there's gcc-go toolchain, etc. Similarly I don't use Rust because it's LLVM only for now.However, this doesn't mean that I want these to disappear. I want them to compete fairly, so we can improve. I'm not a web-dev so I have no need for this frameworks, but I'd make similar choices if I enter to that arena, too.
> I use Java because there's OpenJDKWhich is mostly (~95%) developed by Oracle and is about the same in its openness and community participation ashttps://github.com/dotnet/runtime/is.Or maybe you meant OpenJ9?FWIW I also use Linux exclusively, develop (and host) dotnet applications on it, and have my own gripes with it (mostly with Linux still being treated as a second-tier platform which is only good for servers as far as MS is concerned — I'm not talking about the abomination that VS is — try to compare the official profiling & debugging tooling).
There's an important distinction: License. OpenJDK is GPL2.0, .NET runtime is MIT. They may be same in terms of openness, but not in freedom sense.As a result, OpenJDK is much more sustainable in the long term, since it can't be closed down and crippled as easily.While I am no enemy of MIT/BSD style licenses, the "freedoms" they provide to corporations are damaging to open source ecosystem in my eyes.OpenJ9 looks like EPL licensed, and indeed interesting. It's worth a look.I'm not writing Java with any considerable volume for some time (because, I didn't need that), hence I was just keeping that in my peripheral vision without paying much attention. However, I'm using Eclipse because it's a great IDE for my needs, and comes with OpenJ9 embedded.Thanks for bringing this to my attention, will look deeper.
> I believe hardware and software should be open and platforms shall compete openly. I don't use any vendor which openly kills this interoperability and try to corner market with underhanded tactics. [..] Similarly I don't use Rust because it's LLVM only for now.I'm curious, what do you have against LLVM? I'm sure it supports fewer backends than GCC, no surprise given their relative ages, but it's still got quite a few and it's open enough that it has documented support for adding new backends.
I'm not strictly against LLVM. My objections are the license, and how companies use it against GCC/GNU.I open everything I can, and strictly with GNU/GPLv3+. I want this code can be built and improved upon, even after I abandon it voluntarily or involuntarily. Hence I choose GPL licensed (or close as much as possible) toolchains and tools as much as possible.For example, I use Eclipse, and include .project files in the repositories, so one can import the project as is, and continue playing, or maintaining the code. I'm improving my Eclipse knowledge to use agnostic paths, so anyone cloning the repo can directly import to Eclipse, and just click build.I also plan to make my Eclipse and toolchain settings available to make my development environment completely reproducible.On the case of the Rust, I'm waiting gccrs, which is arriving as an unofficial language in gcc-13. This will both provide an alternative and GPL licensed implementation of the language, and I can be sure that the code I leave behind can be built with the public version of the GCC.Moreover, I use no compiler specific extensions, because I'm not trying to lock anyone to any toolchain. I'm just trying to make sure that the repo is buildable. I may even add a LLVM (or go-gc) test path to make sure that I don't break anything between implementations.IOW, I have strong opinions about software freedom, and I apply them to my code, but not force people to obey them (except the license, because I need to underpin it). It's a strong stance, yet there's no insistence. I just set an example, and try to make it a very good one, to show it can be done.
I think the point was not against LLVM itself, but rather against languages for which only a single implementation is available, which is a pretty strong argument IMHO.
us old farts remember Microsoft (and Gates) as true villains. Things have changed but those wounds run deep and the scars remain. Every time i see the Bill and Melinda Gates foundation in the news all i can see is Bill trying to buy his way into heaven.
I never considered Microsoft as villains in the 90s. They were the only company making computers usable, and thanks to them I didn't have to use the archaic Unix systems that were prevalent at the time. Microsoft was being unfairly punished for things that are commonplace today, like integrating browsers with operating systems.
Same, except I don't still trust him or his foundation.
The foundation is a tax dodge to push their unelected will on the population.In proper society, the population would get to vote on the initiatives they care about.
I only looked at the binary example and it’s some of the worst C# code I’ve ever seen. It’s synchronizing every task in a loop instead of waiting for the tasks to complete like the Java example. It’s returning a result instead of using an array like the Java example. The 2 examples are not equivalent.
I know no C#, but you can contribute a better one if you prefer. Some of the languages have multiple implementations in the games and their performance vary a lot.
Small nitpick, Nodejs has a JIT (via V8) and you will be surprised at its performance when compared to Python.
I know, I've written NodeJS for a very short time, and remember liking it. However I can't position it into my current ecosystem where code is probably be seen by multiple people and need to understand/improve it.Thanks for reminding, BTW. :)
Whats wrong with comparisons to Java, and why the need for you and the article author to throw shade at Java while singing the praises of C#?Java and C# are very similar languages.
Shitting on Java is part of .NET ethos (I've worked in a couple of .NET shops)
I recently worked with some .Net developers who wanted a primarily Java based company to let them work with .Net. In their opinion .Net was so much better (faster, larger ecosystem, more developers) that it would pay off quickly. When I asked them for documentation, they pointed to some microbenchmarks that had no significance to the type of work they would do. They also complained that Java was more "corporate" than ".Net", which is ridiculous in my opinion. Even if that was the case, the differences would be a "rounding error"
I think that's part of every other language's ethos.
In the Java dev teams I haven't noticed any common target that would be consistently shat on.
> Yet latest TechEmpower benchmarks shows .net running on Linux and being faster than Go, Python, Node, and Rust.That's not true atm.At time of writing (TechEmpower 21) Rust frameworks have top 3 out ouf 5 slots (#2, #3 and #5) in composite rankings.https://www.techempower.com/benchmarks/#section=data-r21&tes...Which goes to show, benchmarks change and depend on use case. And Rust is very competitive (in league with C/C++).
> If you want to write C# just write goI don't get this. If you want to write C#, write C#. If you want to write Go, just write Go.Go is a great language because of its simplicity and ecosystem, has lots of useful things in the standard library, has pretty good runtime performance and also compiles to static executables easily (which is especially useful for projects like Nomad). It's both a good fit for web development, as well as writing smaller or larger utilities. Honestly, its packaging situation is leaps and bounds ahead of something like Python, so I predict great future for it in DevOps too.C# is a more advanced language with a rich history and a lot of the functionality for web development in particular coming as first party packages. Some of that historical baggage weighs it down and the complexity can be annoying, but ASP.NET Core, EF Core, Kestrel and many other components are great. Plus, running on *nix is good, even though the single executable/runtime/deployment situation isn't quite as easy as with Go.Write code in whatever technologies work for you. My caveat to add would be that I'd (almost) always develop front end and back end separately, since the React/Angular/Vue webapp really shouldn't care much about what technologies are behind the APIs. Of course, being able to use a single language for both FE and BE development is also a worthwhile approach!
> I don’t get thisThat’s because my argument has nothing to do with the language itself but you still felt compelled to write an essay. I’m saying the modern Linux-based tooling, ecosystem, and devex of C# is inferior to so many other choices.
I don't get it because the claim that "If you want to write code in language X, just use language Y" doesn't vibe well with me. It feels needlessly dismissive somehow.Hence the exploration of the good things about each of the languages and genuine reasons why people might enjoy using them for slightly different use cases.At the end of the day, everyone can make that choice for themselves, unless their org makes it for them.
Ok
I use Rider on my Ubuntu machine and the dev experience for me, is even better than using VS2022 on Windows.
VS Code has a C# debugger on Linux. There are certainly limitations to the open source C# support in VS Code, but for students it should be easily sufficient.If you want a language where not only the core and main libraries are open source, but also all the tools then C# is probably not the right choice. If free (but not open) tools for most use cases and paid tools for larger companies or higher-level demands are okay, then C# fits.
OmniSharp (VS Code extension for C#) has been discontinued and there is no replacement yet. Besides, Microsoft purpusefully sabotaged OmniSharp to make it so unusable that it forces people to use Visual Studio, so even if a beginner on Linux would decide to try C# with a discontinued product they would only face difficulties and a basically horrendous mostly broken experience. .NET on Linux is non existent without Rider and there is no way to sugarcoat this fact. It's sad how ignorant some people are about this and keep peddling untruths about C# that it is well supported on Linux when it isn't.
It is not discontinued, it is regularly updated, and all the interesting parts are coming straight out of the compiler project (Roslyn) which will be the source for all future alternative extensions. Surely, they have different interest and do not put too much money into OmniSharp.Do I like that some part of the stack is closed source (like the debugger andin futurethe extension host): No! Does it lead to a broken or discontinued future: No!Compared to my experiences with PHP, Java and JavaScript, C# on Linux is just fine.
I use vscode on Linux without any problems. Can debug and do all I need to do without any problems. Omnisharp may not be perfect but it works. It will be interesting to see what is going to replace it but short of the closed source concerns I’m fairly sure it will still work.
https://github.com/OmniSharp/omnisharp-vscode/commits/master
This is terribly ignorant
For non-students, first 30 days are $0 (maybe that's enough "to see if they even like C#"), then it's less than $15 per month after.Perhaps not truly free, but within reach for most people.Also, the EAP is $0 (although it's pre-release and not always guaranteed to be available)
Rider is free for students and that is how I started using it.Also, VS Code with OmniSharp isn't that bad for smaller projects for development and is pretty good for debugging for apps of all sizes (my 2 year experience with it).So to claim that you cannot debug C# on Linux for free is false.
Rider is free for students.
> dead to students or any new users because nobody is going to fork out a couple hundred $As all JetBrains products, it's free for students, open source projects, and classroom assistance, and training courses.https://www.jetbrains.com/rider/buy/#discountsAnd it includes an excellent debugger.
Only forsomestudents. If you don't have an .edu address and your college or university is not in their pre-approved list, it's difficult to get a free license. It's a pretty typical attitude towards us coming from third-world countries though, and we developed our own ways of dealing with this.
Also, there's I ItelliJ Community Edition which omits some but not all language integrations.But "we developed our own ways of dealing with this" is so very true :)
.NET student (aka newbie) <> student in schoolAnd please stop this fake reality bullshit. NOBODY, not a single freaking person who wants to learn a new language will start off by searching the internet for an IDE and debugger where they can apply for a free license and then wait a few days so they can try it out. That is just ridiculous to even suggest.If one wants to learn a language they download the SDK, open VS Code and look for an extension. If there is none or the one that exists doesn't work they basically say "WHAT THE FUCK IS THIS SHIT", close it and walk away with the conclusion that it's not well supported. Let's stay real please okay.
> NET student (aka newbie) <> student in schoolThen you should say: "a person who just starts with .Net".> And please stop this fake reality bullshit. NOBODY, not a single freaking person who wants to learn a new language will start off by searching the internet for an IDE and debuggerI started with .net only 4 years ago. I went ahead and got myself Rider because I dislike VS Code and I already had 6 years experience with other JetBrains IDEs.Oh look. I'm that "no single person" who went ahead and looked for an IDE. Andboughtit> Let's stay real please okay.Screaming nonsense at the top of your lungs doesn't make you any closer to reality.
> And please stop this fake reality [...]. NOBODY, not a single freaking person who wants to learn a new language will start off by searching the internet for an IDE and debugger where they can apply for a free license and then wait a few days so they can try it out. That is just ridiculous to even suggest.I actually did. JetBrains products were really nice to try out whilst studying in university and eventually lead to me purchasing the ultimate tools package for any personal or professional projects that I might want to do.It's really amazing to have the same set of tools for almost all of the languages that you might want to work with, that work consistently across all of the OSes that you might use. Normally I avoid paid software because of the vendor lock in, but a lot of the time it feels like JetBrains are just the company that you should reach for to avoid headaches, for better or worse.For comparison, in the Java ecosystem, you also have Eclipse which has performance problems and an odd/unstable plugin ecosystem (though some swear by it) and NetBeans which has been handed over to Apache but doesn't really get much love or attention towards its development at all. Of course, some might use Visual Studio Code or another text editor with plugins but not being able to do refactoring across a project with 4000+ source files makes that approach dead on arrival for me, for all but the smallest projects.The situation is pretty similar in regards to C#: you have Visual Studio which limits the platforms, JetBrains Rider which is a paid project, Visual Studio Code plugins which are insufficient and also something like MonoDevelop, which has pretty much been abandoned.
Every benchmark is a cheat and not a real-world problem.I also thought their benchmark is a cheat. But it is not. It is testing exactly what the benchmark was testing in that scenario. That is why TechEmpower Benchmark suite is so powerful. It uses different web server scenarios (connection, JSON parsing, database connections, ...). The different test case implementation .NET and others have are making sure no other factor is influencing this. For example: when you benchmark connections why dealing with MVC, validation and database connections.It is not .NET who cheats, it is the others who do not properly isolate the tested performance aspect.And to make the comparison a bit more real and day-to-day applicable, you need to pick the right framework configuration (like aspcore-mw @ 80% / aspcore-mvc @ 37%) and compare with other reasonable scenarios (like express @ 1% / spring @ 2% / quarkus @ 8%). Both are then far of the top 10 ten list but still comparable. The top 10 combinations are for cases where developer productivity does not matter but throughput is the key (e.g. a DoH resolver or a system like a Cache / Database).
So, either way, the benchmark is not an apples-to-apples comparison between frameworks?
How are collections in C# worse than in Go? In C# you have LINQ, in Go you're writing for loops around array slices.
Maybe I was using it wrong? As I recall, "the usual" APIs present in most other OO languages were not available when I tried to help a friend with a project 3 montjs ago.
Which collection APIs were you missing? Between the standard interfaces and their default implementations[1] and the extension methods to IEnumerable[2] you can do quite a lot in my experience.[1]:https://docs.microsoft.com/en-us/dotnet/api/system.collectio...[2]:https://docs.microsoft.com/en-us/dotnet/api/system.collectio...
You might've forgotten to reference LINQ and Collections.Generic in your project? Because C# definitely has good collection APIs that influenced many languages including Java Streams.
C# has very comprehensive collection API. More so than those languages.Most languages copy c#
Which APIs were those?
Just use F# instead and you will have Rust, typescript, Javascript, dart, python all at oncehttps://twitter.com/FableCompiler/status/1550429007443017729...
Unfortunely not with same tooling level as C# and VB enjoy.
I used to use Visual Studio and VSMac for my F# experimentation. Over the past couple of years, Ionide has got so much better that I've switched completely over to it from VS for all my F# work.  The new 7.0 release a couple of days ago looks to have continued this trend.
Try to do a GUI or EF data model design in Ionide, hot code reload while changing a GUI design, or using annotations from code generators.
My view: F#, or to be honest a cross-platform IDE like VS Code isn't probably appropriate for many of these apps or rather the dev workflow that Microsoft promote in those frameworks feels like old .NET to me. The frameworks themselves weren't designed for a minimal IDE, and language first development initially often assuming dev is in full Visual Studio with GUI XAML editors, EF designers, etc. To be bluntly honest with my opinion it isn't a dev workflow that would fly/got started in other more open languages including F# which should be develop-able and maintainable with a lot less tooling support.F# feels like a different dev workflow than C#, which IMO is a very good thing in F#'s favor. It feels more like coding JS, Go, etc to me with static typing and richer features. I also think EF, as it is designed, doesn't lean to the FP approach that well.I personally don't like EF - I'm happy with something in .NET like DbUp for migrations and straight SQL. Normally I get better performance anyway doing this and in the age of microservices I feel this pattern actually makes it easier to change DB's if you need to (but I still assert you probably never will without a rewrite most of the time) - just use the different query language and port your data access layer. Move to Redis? Just port your F# module that queries the DB in SQL to Redis code. In F# it also allows a richer data modelling experience doing it this way (e.g use of DU's for modelling cases in your domain) since db logic is decoupled from your domain types.I never believed my domain model had to look similar to my DB table design which is what EF typically encourages. Especially with the modern features of DB's like Postgres you are leaving more and more performance on the table. In the apps I've written doing that leads to lower DB performance than otherwise, sometimes for some quite trivial apps.TL;DR: Tooling like Resharper, designers, etc is nice but often is there IMO because the language itself is bloated and not expressive enough to just state your original intent there succinctly. If the code is enough then F# can express pretty much what C# can.
Languages alone are worthless what matters is the whole development experience.When F# came out in 2010, it appeared it would be made to share the podium with C#, VB and C++/CLI (even that black swan has better tooling on VS).Instead what we have witness is that management doesn't really know where to F#, and naturally they cannot take it from the box.More recently they are positioning to go against Python in data science, when .NET lacks the library ecosystem (ML.NET is still half way there and favours C# anyway), and the Microsoft was able to convince Guido come out of his early requirement with the purpose to improve CPython's performance on the top of the already existing ecosystem.Meanwhile Intel and NVidia are also on the race to improve Python for GPU compute.So in the end that leaves F# as a nicer ML derived language that happens to have access to the .NET libraries, with a community that kind of re-invents what .NET already offers, and a master that to this way is wondering what to do with it, other than a laboratory for C# features.
Rider has pretty decent F# support. Maybe not that many refactorings available, but it's IMHO worth it for the better language ;)
Only if we consider the language in itself, without the .NET ecosystem for GUI, databases, code generators,...Where it is pretty much DYI.
Depending on what code generation you are doing you have alternatives. Biggest one being Type Providers which are arguably better than anything I've seen from source generators so far (which I found incredibly buggy when I used them, and at one point I had to reinstall visual studio it bugged out my environment so much when messing with writing my own).And see above for database, Type Providers are great at least for SQL server, I think the sql one also works for PostGres but I never used it so not certain.GUI is a mess last I knew though I agree.
You mean the traditional World Data Bank example that we got to see at each F# conference with little relevance for .NET shops?What I care about are the code generation libraries that get served alongside NuGet packages with attributes, e.g. the ones used by MVVM, MAUI or Blazor.
Just use a mixed solution then i.e. why not both? You're picking one thing that F# isn't great at - generated code tooling which IMO isn't in the spirit of many modern languages anyway. I don't get why some C# devs tend to be antagonistic to F#. Not suited to what you use? That's fine but that doesn't mean it isn't good for others. I've seen dev's coming from other languages to F# and thinking its brilliant that would of never approached C#. I agree that each language has its sweet spot. Looking at their feature sets I think:- Domain modelling, algorithm, business logic, etc is easier with F# in general. C# is getting better than this, but F# is there and has been there for a long time.- Integrating with build tooling and generation tends to be C# because these tools were designed for that target (i.e not the language itself). The value is in the tooling and the engineering in that - C# just happens to be the target.Personally with the above I've found most of the logic tends to be in F# with some C# projects for where the packages needs that build tooling support (i.e. not the language or syntax, but for the tooling or other features of Roslyn). An example would be Grpc.Tools. Most of the time these projects can use generated code anyway so the writing of C# can be kept to a minimum - i.e. not one single C# file in the C# project. Besides I think the learning curve/barrier for a language isn't really syntax, or language features - its the libraries to use, the patterns, the ecosystem, package manager, CI/CD settings, etc. Using F# isn't a large cost once you've learnt all those things that are shared which is way more than isn't.
Mixing languages increases the code complexity and hiring requirements for anyone that has to touch the code.Everyone on the project has to learn two languages, two ecosystems, because naturally F# folks either reinvent or create idiomatic wrappers for what .NET already offers, a typical side effect in guest languages.And then there are the enterprise support teams that explicitly only give support if the issues are reproducible with C# when giving example on  tickets, increasing the costs to submit support tickets.
Most F# devs know some C# anyway, I don't think this is a big problem. It might be a problem if you mix C# and, IDK, Lua, but C# and F# are just good friends
The point was the other way around, how to justify the adoption of F# in Microsoft shops, when Microsoft itself isn't sure where to go with it, doesn't invest in better VS tooling for it, and recently behaves as the C in CLR stands for C# instead of Common.
I think this is a problem with many languages - e.g. Scala, Kotlin, etc. The easier justification really is: Does it fit your problem space? Will you save dev time overall, is it more maintainable using this tool? Do your staff prefer working with one tool over the other? Does it meet business objectives?I don't think F# will ever be more than niche; that I can agree with you. Not because of any technical reason though; perception and marketing unfortunately does matter. Your points around "investment", etc are to me impressions/metrics around that.In the end these things are just tools. I'm personally in a team that is doing a lot of generic math, and in our .NET based projects F# seems easier and quicker to get that performance. I know C# preview adds some improvements here but it seems more complicated than the F# approach.
I have never used a code generator for C#, which one do you have in mind? Pretty much all other .NET things can be used from F# equally well as in C#
Rosylin code generators, the modern way to use compile time reflection in C# and VB.You can bind them to code attributes, no more INotifyProperty by hand or by having common base classes.
> For the front-end, JavaScript is unavoidable (for now)Author really needs to give Blazor a try. I wrote some comments last week speculating that I'd use Dart or TypeScript with C# .NET on the client because WebAssembly doesn't do DOM manipulation, but turns out I should have waited to learn it better before making a comment.I've learned I can add events and event handlers to elements without ever leaving C#. Then when I need to use a JavaScript library, I can load it just in time for my component. Once I got the hang of it I really felt like I've found the sweet spot for front end development.Blazor is in development and will only get better. I believe it will eventually be recognized for what it is, but it's still early.
Have you actually tried Blazor ? Just  the schism between WASM and Server and the feature matrix there, and generally shit quality of early stage Microsoft product - I wouldn't touch it with a 10 foot pole, likewise for MAUI - I've seen coworkers prototype both for some greenfield projects in last month or two and both projects gave up on it because it just isn't there yet for mainstream development.I mean .NET core was pretty much in this boat pre v3, it took them years to move past the .NET standard mess, Xamarin never cleaned up and they are hoping MAUI will eventually just sweep it under the rug.I wouldn't bet on any Microsoft stack that hasn't had 3+ years of successful use in the wild - I've been burned too many times. You might say the same is true for any other project/stack - but even when they moved to OSS .NET projects have this Microsoft level of complexity and boilerplate that makes diagnosing trivial things a slog. And Microsoft likes to put "stable" label on a lot of things these days with the pressure to ship. Good rule of thumb - not worth my time until v3.
I've tried Blazor.  I built and deployed 3 apps for clients 
over the last 3 years while consulting and was able to deliver the projects for 33% what it would have cost to deliver them with react or angular.Clients have been very happy with the results.Then I built my own startup with it, and we have a solution that 3 devs have been working on for 2 years.I can't recommend Blazor enough.  I love it.I have run into a fuck ton of problems with MAUI though. It's a fucking dumpster fire of a technology.* Blazor server side I have very limited experience with client side.
The problem I have with Blazor Server side is that it requires a stable internet connection otherwise client socket connection drops and the browser issues a full page reload.Or at least those were my findings last time I tried. I would be very happy if that isn't the case currently.For intranet web apps it looks amazing though.
> was able to deliver the projects for 33% what it would have cost to deliver them with react or angular.That’s a pretty extraordinary claim.I know single stack can be more productive, but that sounds very impressive. Could  you perhaps talk details of:- styling blazor (eg. Bootstrap, tailwind); is it just drop in? How do you use it, eg. Without the tailwind preprocessor npm package?- interactive front end components (eg drag and drop) that lag badly when using SS blazor in examples.- bridging to native js (which is ultimately unavoidable in situations where you need integration like maps as far as I know)- scaling load on concurrent users (one ws per user right? Are you using the signalr service & functions? I tried this and found the long running azure functions are quite expensive to run. Do you have advice?
Sorry I misspoke I meant a 33% reduction in the size of the projects.  So projects that would have taken 6 weeks in React took 4 Blazor server side.1. We just dropped in a wrapbootstrap template.2. We wrote some javascript for interactive front end components like drag and drop or rich text editors. It was a little more work than it would have been in React but not much and everything else more than made up for it.3. We found it wasn't particularly difficult. We'd just put JSRuntime.InvokeAsync in a C# method. Used it for things like popups and initializing some js libraries.4. We're only using Azure App Service and Azure SQL database. Our long running functions we just run as a scheduled service on the app service. (though eventually we'll to do some refactoring when we need to scale horizontally).  We're a B2B SaaS company so our revenue is quite high compared to our compute usage. By our back of the envelope calculations we won't have to add another server until we're somewhere between 5 and 15 million ARR.  We think we'll need to do about 2-3 months of refactoring at that point to allow for horizontal scaling.I wouldn't recommend Blazor-Server Side for B2C typical applications that have a low ARPU.The big advantage in development speed is we got the functionality of a SPA but at the development cost of a classic multi-page application.
>* Blazor server side I have very limited experience with client side.That's part of my problem with it - from what I see they are pushing two independent tech stacks (WASM and dynamic server rendering/JS updates) under the same name - but the APIs underneath and the architecture is very different.
Definitely agree with you. Blazor is absolutely amazing and makes development extremely fast. Makes me wonder if people commenting have even tried it.
They should really just dump MAUI..calling it a dumpster fire is being polite. Rather let their devs spend some time on Avalonia.
>"Have you actually tried Blazor? "Yes. Server-side Blazor is incredibly productive and fantastic for complex UIs, especially for B2B and other SaaS products.
Server side Blazor is really like webforms in terms of client state management and scalability. I am not sure I would really use it for anything.
> Blazor is in development and will only get better.How good can it get though?
Blazor WASM suffers from the huge initial, multi-megabyte download of the .NET runtime. How is that expected to come down to something in the range of 50-500kb what we have with most JS frameworks now? I just cannot do that on public-facing parts of an application. It is unusable when accessed from a slow mobile network. Company-internal stuff sure, who cares.I really wanted to love Blazor, and evaluated replacing some of the complex frontend UIs at work which are a JS nightmare with either Blazor Serverside or WASM.
But serverside seems like an afterthought to me. I recently learned about Phoenix Liveview here on HN, and according to what I read, it seems like a much better option if you want that server-side rendering stream model. With Blazor-server, I get the feeling it is only a makeshift-solution until WASM takes off, and that makes me even more reluctant to use it.
The vast majority of complex JS SPAs are also multi-megabyte payloads. You can also prerender components the same was SSR is used to mitigate JS initialization.As far server-side Blazor - itseemslike an afterthought because youreadabout Phoenix Liveview? How is that a serious evaluation? Blazor is a core part of the framework now and the server-side model is always going to be a serious option because it enables functionality that can be done with the disconnected client/WASM mode (like direct DB access without the serialization + API overhead).
> The vast majority of complex JS SPAs are also multi-megabyte payloadsI suspect you're talking about full apps that include third party deps. The majority of SPAs are < 1MB unzipped and <150KB zipped. Source:https://gist.github.com/Restuta/cda69e50a853aa64912dYou can't look at some site that has 10MB of third party deps and compare that to what Blazor is doing. You'll still need third party deps with Blazor as well.The sites that have a large 10MB bundle would have had 100's of 100KB scripts pre-spa days.
I know I'm coming across ad a blazor fanboy, but I'm curious what made you feel like server side was an afterthought?The biggest way server side fucked us was originally db contexts are bound to scope via IOC in asp.net similar to MVC or razor pages.Which is fine when your scope is a single request, but when the scope is a circuit you get so many weird fucking errors. We worked around this by disabling tracking.  But the right fix is we should have used factories, but we didn't figure this out until it was too late and we had written a fuck ton of code.This is such an obvious issue and should have been in the docs but wasn't.But other than that it seemed fined.
While the total download size is unlikely to go below 2MB with Blazor due to .NET Framework binaries, they are working hard on AOT and binary stripping, meaning your app could consist of a base framework download, served from a CDN, and subsequently cached, and a small app specific library that's comparable to a bundled JS lib in size.
>...served from a CDN, and subsequently cachedDue to cache partioning in browsers now, this will still be a big issue for all clients. Don't also forget that many clients are in poor internet speed zones.A 2MB "buy in" will be unacceptably high for lots of projects (but not all, obviously).
I know that newer frameworks are slim but in practice bundles still seem pretty huge. Maybe that’s just asset bundling going on but I feel like people are still able to get away with.a lot
I was really excited for Blazor, until I tried developing for it. The DX is not really there yet and in the mean time I stumbled up HTMX (https://htmx.org/) and now I'm having an even harder time being excited for Blazor. And don't get me started on Blazor Server vs Blazor WASM...The thing is, Blazor will become the lingua franca of (web) UI development for bigcorps, so I just need to suck it up and learn it (I'm a .NET consultant geared towards finance & insurance)
Its funny, after considering Blazor serverside and WASM, I also opted for HTMX + Alpine.js (when needed) + ViewComponents. Considering how nice server-side rendering story is in ASP.NET, I feel like this is a setup that really works well in a lot of situations, from low-interactivity pages to really complex UIs. It is lightweight on the client side (just load the small htmx and alpine scripts), lets me do much of rendering server-side in .cshtml views, and which needs no JS build pipeline of any kind.
This my exact setup and the only thing I’m missing is Blazor-style component syntax instead of the fairly convoluted way with <vc:*>
Man, I tried out Blazor over the last few days. I really wanted to love it (I love C#), and it looks like it might be good one day, but I found it sadly lacking. I couldn't even add a mouse event to a canvas element. I had to install an extension package to even use a canvas (BECanvas), and then that extension package didn't even have mouse events. I have to say, thats so absurdly basic of a thing to be missing that it made me call the entire library into question: what other extremely basic things could it be missing as well?
Anything with canvas, or a very interactive experience I think Blazor is a bad fit for.  I'd do just straight JavaScript or typescript.But so much of the world is user clicks a button, run server side code, update html, and blazor is an amazing fit for that.Like I'd never build a Google sheets, Microsoft word, or outlook replacement in Blazor.But I'd totally build a hub spot, Salesforce, Facebook, reddit or hacker news clone with it.
Author here.I tried Blazor.  We used it for one mission critical project.We found that the development cycle is too long and it has too much friction compared to Node for front-end development.Back to Node for frontend (Vue)!
I'm a huge fan of C#, but I didn't really like Blazor when I tried it. I had expected to love it too. I found much of Blazor's boilerplate to be very ugly, I didn't like the complication involved in referencing npm libraries or backend code, and I couldn't figure out where several magical authentication related pages in the example app were coming from. I switched back to Typescript and Vue 3 (almost went with Svelte). I'm investigating the HotChocolate GraphQL library this week to see if I can marry the frontend and backend that way. I was hoping Blazor would give me a nice productivity boost, but native frontend development is hard to compete with. I'll likely try again in a few years.
The thing is in .NET 7, they are going to decouple the WebAssembly toolchain from Blazor.This will allow people to write competing frontend frameworks, or mix and match their JS framework of choice while calling into .NET app logic.The latter already possible, though a bit hacky with the official tooling at the moment, since Mono can compile regular .NET code to WASM no problem (a fact already extensively used by game engines like Godot or Unity).
> I found much of Blazor's boilerplate to be very uglyI call that bureaucratic software because it reminds me of doing taxes. It's put me off from trying a lot of Microsoft tools, but with Blazor I decided to push through the pain. Once I did, I could see the logic of it and it became less of an annoyance
Blazor server was not executed on well. It's a poor react clone before react had hooks. The ecosystem is also small and not flexible. I would choose javascript over it, unless I already had a large investment in C#/.NET.
What? It's Razor templating on the frontend. It's also an MVVM framework, and has much more in common with Angular than React.
If you're willing to go down the f# rabbit hole there's also Fable which I need to try but I've heard very good things about.
Fable is pretty nice to work with.
Writing bindings is fairly trivial given typescripts influence on the front-end library landscape, and you can just yolo call things dynamically if you want.Here's a small gist where I use fable-py to use the python prettymaps project that was posted a week ago on HN:https://gist.github.com/Banashek/1cc3d8435843bcff230906fb037...
Yeah, but F# is even worse than C# in the sense that you need really talented developers to get anywhere. Which is not a problem on personal projects, but can be for the majority of companies.
Building a company based on Fable/F# now. We're in process of taking folks with 2-3 years of react exp and teaching them Fable - it's a pretty quick transition. F# tends to attract some pretty talented developers as well.
In theory, blazor is really neat. But last I checked you have to either go fully thin-client (server side blazor) or have an annoyingly large initial download (client side blazor). Which is probably fine if everyone's wired to the company network, but maybe less so if there's mobile involved or the general public needs access from the local coffee shop.
I'm currently playing around with server side Blazor and it works well.  It's definitely not for general public applications but it seems great for internal corporate apps.The issue that I have is since it is a thin-client re-deploys kick everyone off immediately.  Where the web is totally stateless this is 100% state full.  I'm used to being able to deploy production fixes rapidly without disturbing anyone's work but with Blazor server that's impossible.  I've started to look into load-balancing solutions or something but not being able to roll out fixes throughout the day is almost a deal breaker for me.
It's a pain, but there are some optimizations to shrink the large download size.This person was able to get it from 14.4MB to 4.4MB:https://www.michielpost.nl/posts/reducing-blazor-webassembly...Whether that's acceptable is up for debate but it is in line with most SPAs/websites these days.
With blazor you need to choose Client or Server Blazor. Client will give you 10MB+ page downloads, Server will require stable and low-latency internet connection. It's fine for intranet systems, but not for general webdev
Blazor WASM is promising but it really lacks some like MobX. There is a Weave based project that's sim to MobX, but hasn't gotten a ton of traction.Then there is a Redux-like option and.. No thanks :D
Can confirm, we’re developing in Blazor now and it’s fine. Not as loosey goosey as js, but makes as much sense as any other js framework. And having such tight integration with Entity Framework makes development a breeze.
Blazor server or wasm?
Server. From an ergonomic standpoint, the development is basically identical to WASM ASFAICT. This is all internal though, so ymmv if you're developing stuff for the open Internet. I guess it depends heavily on how married your org is or isn't to c#, which we very much are. I vastly prefer this to serving up a separate UI for what we do.
The thing I miss the most with C# and dotnet is offline documentation. With Java, I can install the java-17-openjdk-javadoc package and have the full API reference (at /usr/share/javadoc/java/index.html), and download a couple of PDF files to have also the full language and bytecode specification. With Rust, I can install the rust-doc package and have the full API and language reference (at /usr/share/doc/rust/html/index.html). But so far, I haven't found an equivalent for dotnet, unless you're running Visual Studio on Windows. When you want to learn by leisurely browsing the API documentation and language reference, the speed difference is massive: the online documentation takes a bit of time to switch from one page to another, while with offline documentation it's nearly instant.
Most topics on docs.microsoft.com have links to pdf, e.g.https://docs.microsoft.com/en-us/dotnet/csharp/have "Download PDF" in bottom left corner which links to 2756 pages of C# documentation:https://docs.microsoft.com/en-us/dotnet/opbuildpdf/csharp/to...
could you clone the docs repo?https://github.com/dotnet/docs
You might be able to do something with this:https://github.com/dotnet/docsThe browsy bits might not work without a server (not sure), but the documents themselves are markdown.
I use Zeal documentation browser and it has most of .NET docs available offline
I wouldn't lose a second to C# or any MS platform unless required for employment reasons.https://github.com/OmniSharp/omnisharp-vscode/issues/5276
Sorry, but OmniSharp sucks, and this is not a controversial opinion even among Microsoft employees. I am all for the .NET experience in VS Code improving greatly from where it is with OmniSharp. This will actually help increase adoption of .NET, which, I remind you, is open source.
> Sorry, but OmniSharp sucksI agree. This appears more like an attempt to get the most value (integration of proprietary Visual Studio features that devs want) into the VSCode extension as quickly as possible.Said proprietary libraries are likely not able to be easily open sourced for a variety of possible reasons, so a closed source LSP bridge was the compromise the teams came to.
The directly related fight here is Microsoft's pylance on the Python side. pyright still exists and many of the components in pylance are still open source, but pylance itself is closed source and bundles closed source tools. (That is pylance is not just a pyright fork, but closed source LSP bridge for pyright + proprietary parts.)It's not without controversy on the Python side as well.At some point it simply becomes questions of stewardship and transparency: How good are they at pointing out the open source parts wrapped inside the closed source LSP bridge? What cadence do they upstream fixes to the open source parts?So far Microsoft's stewardship on the Python side seems strong: pylance has a lot of transparent documentation of all the open source bits. There seems to be a steady upstream flow to pyright for users that prefer to stay entirely with an open source LSP. Microsoft isn't treating it like a competition to "win" and encourages users to make their own choice among the options.Of course, Microsoft doesn't "own" Python in the same way it "owns" .NET so I can definitely understand why there's increased fear that Microsoft won't be as good of a steward with respect to this "competition" with OmniSharp simply because of .NET's past. But in .NET's past this controversy would be happeningafterMicrosoft did all the work in building the closed source LSP replacement. The fact that we're having this discussion now in only an "architectural discussion" state says a lot already about how Microsoft's stewardship and transparency have changed today.
Yes, but it works and it's open source. All the other languages have open source tooling (LSP or similar), why can't we have one for C#?
Why would you ever waste time using VSCode for C# when VS and JetBrains Rider exist?
Maybe it's good to have an open ecosystem for using the language that doesn't rely on paying for an IDE? I personally soured on Kotlin for this same reason!
Why do people feel they are absoultely entitled to having best-in-class IDEs for free? Don't the developers of those IDEs have the right to, you know,eat?ALso, JetBrains' IDEs are:- free for students, startups and opensource projects- cost aninsane"two/three beers a month" for individual licenses (yeah, it's more expensive than two beers in many countries, but as a developer I could easily afford it even in the shithole that is Moldova)
I'm not entitled to a best-in-class IDE experience, I'm just happy using one of the dozens of equivalent languages that do have them with an open community.
No language has been tied to an IDE since at least early 2000s. Microsofts own compilers are free to use.So no idea what you're talking about when you talk about "a language that doesn't rely on paying for an IDE".And the tools for most of the languages supported by the open community? The top, best-of-breed of these tools can barely do the bare minimum of refactoring and maybe symbol lookups. Even to this day you can read things like "X is amazing for refactoring because you change something, and the compiler will tell you all the places where it can't compile".Good tools are expensive. And, surprisingly, Jetbrains' IDEs are not expensive at all. And are several orders of magnitude more powerful than anything the "open community" has come up with.And, to re-iterate, no language is dependent on an IDE these days. Go grab Kotlin's CLI compiler,https://kotlinlang.org/docs/command-line.htmlfire up your vi/emacs/gedit and code to your heart's content if you're so set against commercial IDEs.
On the other hand,Ihave no idea what you're arguing about any more. The context is about using VS Code (or something else) with OmniSharp instead of VS and Rider; what does thebare minimumof being able to compile code have to do with it? It's almost like you're making my point: if you want to be productive with C#, youhaveto use proprietary tools; otherwise, all you can do is just compile your code!> And, surprisingly, Jetbrains' IDEs are not expensive at all. And are several orders of magnitude more powerful than anything the "open community" has come up with.This says more about the languages and ecosystems you're used to. Try out rust-analyzer and say that again!
> The context is about using VS Code (or something else) with OmniSharp instead of VS and RiderThis is what you said, in it's entirety: "Maybe it's good to have an open ecosystem for using the language that doesn't rely on paying for an IDE? I personally soured on Kotlin for this same reason!"And then you go ahead and praise a tool that implements LSP...Do you realise that "open ecosystem" literally couldn't produce anything of note for any language until the megacorporation you love to hate came along and provided a solution? It wasn't "open ecosystem" that gave you the language server protocol. It was Microsoft that designed it and implemented it for their own VS Code. And the "open ecosystem" that sat on its ass for decades flocked to it and to the protocol like kids to the Pied Piper of Hameln.And again with "you need paid IDE to develop this and that". No. You don't. There's LSP for C#. There's LSP for Kotlin. You'd know that if you went ahead and looked just slightly beyond your blind hate of commercial IDEs.
Honestly, you've been attacking me personally for quite some time now for no reason (I've done the courtesy of not attacking you, perhaps you could try to do the same?) so I'll not bother responding after this. At any rate,> You'd know that if you went ahead and looked just slightly beyond your blind hate of commercial IDEs.Maybe you missed me saying I use IntelliJ professionally in the previous comment? I'm a happy, paying user of JetBrains IDEs, I've defended them several times on HN myself. I don't hate commercial IDEs; I hate beingforcedto use them.It's extremely bizarre that you assume I'm trying to cheap when I'm trying to be principled: I believe the presence offree(as in speech) solutions are essential for me to seriously consider a language. Being tied to a corporation's whims to efficiently use it is ridiculous; I was a happy F# hacker myself until I saw the more recent moves MS has been making. I think what they're doing - replacing omnisharp with a closed source solution and the debacle with trying to make hot reload a paid VS feature being two major, recent issues - show that MS simply cannot be trusted to run a language ecosystem without trying to force its users into behaving astheywant them to. There's simply no reason to invest any time into the dotnet ecosystem when there's very comparable languages with comparable performance and ecosystems which don't have this issue.> And then you go ahead and praise a tool that implements LSP...What? I'm afraid you've completely lost me here. It doesn't matter that MS came up with LSP, so long as the protocol is open and people can implement and use it without MS's approval. Dozens of editors that have nothing to do with MS implement LSP, the fact that it was made by them is almost incidental.
Those are not best-in-class. Pretty much the entire industry is now VS Code by default - which is very good but not a full IDE like VS or Rider/IntelliJ series.
I'm extremely happy writing Rust with neovim and rust-analyzer. There are plenty of long time rust users who will absolutely tell you that rust-analyzer beats IntelliJ Rust, and I find it very much comparable to writing Java in IntelliJ, which I do professionally. Likewise, Elixir's open source and community developed LSP is incredible and easily an IDE-class experience with neovim or VSCode.
VS is free though.
That sure isn't my understanding if you work for a large enough business.  It is very explicitly NOT free.https://visualstudio.microsoft.com/license-terms/mlt031819/This is the rare post where I would be fucking ecstatic to be proven wrong but sadly I believe I'm correct.
Yes, VS is free for individual devs, and for five users in a small business. Does it matter though? If you're too cheap to pay for developer tools, you're probably a terrible place to work at.
Why is it assumed that you're only ever professionally working on code? Do none of you work on side projects, or open source projects?
Did you read what you replied to?It's free for individual developers, small businesses, and work on open source projects (no matter the size of the organisation).https://visualstudio.microsoft.com/vs/pricing/
Yeah but it's terrible?It's slow, it's bloated, it's loaded with way too many configuration options and yet still doesn't have a lot of config I like from other editors. It has plenty of plugins and still manages to be missing extensions that I find important.Development with Visual Studio just doesn't feel very good compared to other environments these days.
You mean lack of GUI tooling, no proper debugger, no parallel code debugging, no GPGPU debugging, no hotcode reload, no REPL, no mixed language debugging, no lifecycle management,... yeah those environments rock.
...and doesn't on Linux
I work at Microsoft as a SWE and use VS Code for c# and js. I've been using VS and Rider a bit as well, but after years of doing python and everything else in VS Code, it's just so familiar and it works just fine for everything my team does so far.
Obviously everyone's preferences are different, so this isn't a direct response but just another anecdote.I tried VS Code and couldn't get used to it. So now I use Rider for C# and Webstorm for JS. Sometimes I open Visual Studio, though:> There are some custom plugins someone in my org wrote that help accomplish some team-specific tasks
> When I need to work on stored procedures in our SQL databases. Rider doesn't know how to parse the schema from the sql project files, instead it wants me to connect to a live database or it will color everything with little red underlines and give me no autocompleteI think it's nice that my employer is willing to pay for my Jetbrains licenses despite the fact that it is selling a proprietary competitor and also simultaneously pushing an open source alternative. I appreciate it.
Licensing costs, licensing costs, and the fact that you often don't need to go through corporate approvals to download VSCode and the C# extension particularly if you are an employee who isn't nominally a "software developer".VSCode with the C# extension is the preferred C# development environment of corporate shadow IT.
Can they develop remotely on a linux server? Last I checked VSC is the only one that can.
They have a thin client in beta:https://www.jetbrains.com/remote-development/gateway/
Because people will use whatever tool works for themEdit: I love vscode for c#
They are replacing an open source extension with a closed source extension. Makes people nervous given the embrace, extend, extinguish paradigm that they previously employed.
Seehttps://www.isdotnetopen.com/
> They are EEE'ing a VSCode extension, so you're going to avoid that and the language, and the entire ecosystem?Sounds like a pretty good reason to me?
I grew up on C# and tried server side JS recently, and my god, the decision fatigue of picking every little library to do every little thing! C# is just so batteries-included. I'm not sure Blazor is ready for prime time but I like the promise of being able to use C# everywhere.
The article makes a case against using Node.js but doesn't bother to provide a comparison of C# and its actual competitors: Java and Go.
Or Kotlin, since it's IMO a slightly better language than C# in terms of ergonomics and features.I understand that 90% of Kotlin's audience is mobile devs and server-side Kotlin is rare, but as a .NET developer, a few years ago I did a small production Spring Boot webservice in Kotlin and the experience was really good.
If you are looking at server side stuff, here you gohttps://www.techempower.com/benchmarks/#section=data-r21
Python, Ruby.
Obviously there is some degree of subjectivity as what a given language's competitors are. In some sense all languages compete with one another but I do think there is some natural clumping of languages/ecosystems.In my view Python and Ruby are not natural competitors to C# as they are dynamically typed and (in Python's case) interpreted. Similarly Rust, C, and C++ are not natural competitors to C# as they do not have a GC. Java, C# and Go, on the other hand, are pretty similar.
This obsession of dynamically typing vs static typing is not useful. ASP.net is used to develop web applications. C# does have better performance than Python, but I highly doubt most applications will ever need or care about that. Choosing C# over Python (or Ruby, JS etc) for performance reasons is premature optimization at best.Maybe you have some legacy codebase in C# that you need to leverage.All other reasons to chose C# over something else for web applications seem to lack evidence but certainly not conviction. So yes, Python is a direct competitor to C#, as in there are many more Python web projects out there than C# ASP.net ones.
I certainly hope that the Python language maintainers do not see C#,Go or Java as their competition. I like Python as is.
They definitely see Go as direct competition, or did at various points. Some of the work that was done in Python 15 years ago is now done in Go, mostly because of its superior support for highly-parallel workloads; so Python developers have reacted and improved the parallelization story in various ways (yes, it's still not as good as it could be, but it's undoubtedly better than it was when Go took a significant bite off the ecosystem).As for Java and C#, it is a fact that all of them joustle for the backend market together with Python. Java and C# were there first and have massive commercial backing pushing them, but Python has slowly carved a larger and larger role on the back of technical merit. As long as it continues to do that, I don't think you need to worry.
I don’t see Python having a lot to offer in terms of technical merit really. Python’s strength is language ergonomics and fun factor. I hope they keep it that way.
Python often seems to be the status quo that "technical merit" has to beat. Python only slowly beats itself but then becomes the status quo again.
Language ergonomic is a technical merit, as opposed tocommercialmerit (how many companies push it, how many developers are available, etc).
Those don't really compete with C#, except in the most generic sense (as is true for all PLs).
> My hope is that .NET and C# have a resurgence as .NET 6 rounds the corner. With .NET 6, C# 10, and minimal APIs, the language feels more modern than ever and is the perfect gateway from TypeScript/JavaScript on the server to .NET.Oh please please please let this come true so I can write c# on the backend again. I love typescript because it made JavaScript (i.e. front end web) so much less shit to work on, and I’d prefer it over ruby or python backends still, but c# hits such a sweet spot of ease to write, while still remaining relatively performant.Go and rust are probably better for certain applications, but c# would be light years ahead of things like ruby or python.
It must be one old article, because what rounds the corner is .NET 7, while .NET 6 and minimal APIs have been available for a better part of a year already
This seems more like Yet Another Medium Article shooting fish in a barrel by describing problems with the JS ecosystem rather than an actual case for C# and .NET.
> This seems more like Yet Another Medium Article shooting fish in a barrel by describing problems with the JS ecosystem rather than an actual case for C# and .NET.It's the very definition of blog spam.
... with large gifs in the middle.
He already said “medium article”
The data this article quotes doesn't smell right.The tables and graphs in "The Performance Problem" section should at leastfeela little strange. Looking at the original article[1], we can see the source code for JavaScript [2], Python [3], and .Net [4] shows that...there just isn't much going on here. This isn't a comparison of how fast these are. It's a comparison of how fast this AWS setup could do its thing, and how fast this DynamoDB client library is.In the "So Why/Not .NET?", there's the "Advisories by package ecosystem and severity"[5] graph. So it doesn't feel alittlestrange that NuGet is the pinnacle of software engineering, and programs there just have no security vulnerabilities? Or maybe...there's some bias going on here, and NuGet isn't as interesting to look at as PyPI, so there are fewer advisories being published? That's another way to look at it.When things look too good to be true, maybe they are. I don't care if the author (or anyone else) wants to use .Net, have fun. I do care that we sometimes approach technological issues with hostility and rivalry, accepting random data which seem to support us without looking them through.[1]https://filia-aleks.medium.com/aws-lambda-battle-2021-perfor...[2]https://github.com/Aleksandr-Filichkin/aws-lambda-runtimes-p...[3]https://github.com/Aleksandr-Filichkin/aws-lambda-runtimes-p...[4]https://github.com/Aleksandr-Filichkin/aws-lambda-runtimes-p...[5]https://octoverse.github.com/static/github-octoverse-2020-se...
Mostly agree with the author. But just wanted to point out that if we're doing C#/Java style OO patterns in JS (as in the Repository example shown), the value of using JS diminishes to almost nothing. JS works better without classes (and interfaces against them if using TypeScript).
If you look at how major backend projects structure their code, it's almost always object-oriented TypeScript.I submit for the record:- Apollo Client:https://github.com/apollographql/apollo-client/blob/main/src...- Storybook:https://github.com/storybookjs/storybook/blob/next/lib/chann...- Nest:https://github.com/nestjs/nest/blob/master/packages/core/nes...- MongoDB Driver:https://github.com/mongodb/node-mongodb-native/blob/main/src...- Prisma:https://github.com/prisma/prisma/blob/main/packages/engine-c...
My understanding is that with .NET Core, the experience of developing and running on Linux is on-par with Windows(?). However, my impression is that once it comes to building web services, ASP.NET has more "windows-specific" assumptions/moving parts - can someone knowledgeable on this correct me if I'm wrong?
Any .NET NuGet packages targeting .NET Core/.NET 5+ without the -windows TFM will run on any platform that CoreCLR runs on. ASP.NET 6 is no exception. There is nothing Windows-specific in there any longer, and there hasn't been for quite some time. ASP.NET now runs by default on Kestrel, Microsoft's cross-platform web server.
> Any .NET NuGet packages targeting .NET Core/.NET 5+ without the -windows TFM will run on any platform that CoreCLR runs on.I got sleepy just reading this. There's just so much fragmentation and frameworks and different versions of frameworks and web-servers... can't Microsoft just let the .NET be and let them do their thing? They have certainly pumped out loads of amazing software that seemed to get a knee on the guts by higher management.
In fairness that is what they have done. .NET Framework is dead, .NET Core is "dead" (to clarify: .NET Framework dies with .NET 4 and .NET Core/CoreCLR is .NET 5 and above).Mono is a cross-platform (ish) implementation of .NET Framework, but its future is (eventually) to be replaced with the main .NET which is now based on the cross-platform version (.NET 5 and above, which is currently distinguished from Framework by continuing to call it ".NET Core"). Mono and .NET Framework will fade away once Unity gets their act together and moves on from it.tl;dr: .NET 5 and above are, for all intents and purposes, the only future path for .NET, but we're in a transitionary period right now.
Note that Mono, the framework, is indeed dying. But Mono, the runtime, is now part of .Net and it's an alternative to CoreCLR, used for things like Xamarin/MAUI and Blazor.Though most of the time, you don't need to know any of this, you just use .Net and it works on Windows, Linux, Android, Apple and in the browser.
You can also use the .NET CrossCore assemblies (available since .NET Framework Core 4.777.2.1) and do multi-targeting for ASP.NET Core (the Framework version of ASP.NET Core, not the Core version which since version 5.0 is incompatible). Using ASP.NET Core 6 (the new name of ASP.NET 4.2) you can also target Linux if you compile with the flag /fuckallthatshit
I have ton of experience with ASP.NET Core and have not had that impression in the slightest.
You're wrong. Everywhere I've worked the general pattern is to build using Windows/Linux and deploy entirely on Linux (or Docker).
The only parts that are noticeably Windows-centric are some of the tools around .NET. The older tools are Windows-only, you can't get Visual Studio on Linux.For ASP.NET there is nothing Windows-specific in there I've noticed.
- Ignore all the DotNet version names and numbers unless you're working on legacy stuff.- If you're starting from scratch all you need to know is that you should use DotNet 6+ and you'll be on the mainstream track with full cross-platform support.- Nothing is Windows-specific unless you're actually wanting to target Windows stuff specifically.- If you're doing desktop dev MAUI is the way forward, but personally I don't trust Microsoft with desktop stuff any more (too much switching and deprecation over the years).
Thanks - I was actually more confused by the comments as I'm a total beginner to .NET (just interested to learn). This sounds like a more simple/distilled advice in my context.
There's no issues with Windows specifics in /ASP\.NET( Core)?/ version >= 5.0.There's some issues if you need to use an older version of ASP.NET and whether or not it has "Core" in the name, but after .NET 5 and ASP.NET 6 there's no longer that fork to confuse things and it's back to much simpler version numbers/checks and no longer needing to worry about the word "Core".
I wouldn't call it on par. But it has been getting better. Developing on Linux still isn't great (I vastly prefer Visual Studio over VSCode for .NET), but might be good with the Rider IDE, which I haven't used. Running it has come a long way, but there are still some annoyances left. I'd still say that it is good, though
FWIW, I’m on Windows and still prefer Rider over VS
I run all my .NET core apps containerised in Linux. Works the exact same as on windows
There is nothing in ASP NET that is more “windows specific”. Since its inception, I have used these scenarios and they all worked without flaws:Windows -> LinuxWSL -> LinuxWSL2 -> Linux (Its real Linux)macOS -> LinuxAll of the scenarios were deployed to AWS.
I have been teaching myself C# for the last two or three months (with the fantastic C# Player's Guide by RB Whitaker) and I have come to really enjoy working with the language. Discovering Properties, which combine fields and their accessor methods and can be auto-implemented and initialized, was the first moment I realized it might make my life a whole lot easier.I'm not entirely sold on its use for desktop GUI development yet (will watch MAUI closely) but I am eager to jump into Blazor and see if I can start to remove JavaScript from my stack.
C# and TypeScript seem to be far and away the most popular programming languages today.At least from the perspective of recruiting in Australia.Python is on the way up and third most popular but well behind C# and TypeScript.Golang is on the way up but very small in terms of number of developers.Java is on the way down but will never vanish, it's just not super popular any more.Ruby is small enough to just be a footnote.There's lots of other languages that make up the long tail.The message is that if recruiting matters then you should be using C# and TypeScript.
C# vs Java seems to be very country-dependendt. Certain countries are huge C# shops, while in others it is barely existing.
In others, consulting shops do both, including on the same project.
Perhaps in Australia, but certainly not worldwide. C# is way smaller than even Go in total, and Java is a lumbering giant. Slow perhaps, but there's no David around at the moment.
My instincts tell me that there’s no way Go is larger than C# worldwide. Large enterprises are still predominantly on C# and Java… Tiobe index, whatever you may think of it, does not support that… What’s your source?
>C# is way smaller than even Go in totalTIOBE has C# much larger than Go and growing, and it also has Go slightly shrinking over the past year.https://www.tiobe.com/tiobe-index/Same results on Stackoverflowhttps://insights.stackoverflow.com/survey/2021Same results on IEEE Spectrumhttps://spectrum.ieee.org/top-programming-languages/Same for PYPLhttps://pypl.github.io/PYPL.htmlI cannot find a single place that looks at a large dataset and a decent number of languages that gives the result you claim.Care to list where you got your data to support this claim?
Source for "C# is way smaller than even Go"? It's possible that there are more shops that use some Go (esp. for DevOps) than there are ones that use some C#, but that's not quite the same as C# being "way smaller".
Right now if I type the following keywords in Seek this is what I get (in order):SQL - 11,425 jobs
  Java - 7,390 jobs
  Python - 6,777 jobs
  C# - 4,995 jobs
  JavaScript - 4,208 jobs
  TypeScript - 758 jobs
  Ruby - 252 jobs
  Golang - 206 jobs
Did you enclose the search terms in quotes?
the biggest python codebase I'm personally aware of is JP Morgan's Athena and is about ~30 million LOC. Google, Youtube and Dropbox use Python extensively etc. Python being a scripting language stopped being a correct statement probably over a decade ago.
Keep telling yourself that and it will become true.
You said about yourself:> just my own observations (probably wrong).I am currently in the process of learning C#. I did a deep but brief dive into every language feature in C# 10. Being proficient in Python, absolutelynothingsurprised me. All the same concepts, save for a handful, exist in either language, sometimes down to the exact keyword usage. LINQ is a big differentiator in favor of C#, but modern (that is, typed) Python looks very similar to C# (C# left, Python right):ABCs -- ABCsInterfaces -- Protocols/ABCsLINQ -- ??Enumerable/Enumerator -- Iterable/Iteratorclass -- classstatic -- staticmethodforeach -- forfor -- for(range(...))try/catch -- try/exceptbreak/continue -- break/continueenum -- Enumstruct -- dataclass, perhapsnamespace -- automatic on the file levelout -- pass by referenceswitch/case -- match/case (both dostructuralpattern matching)throw -- excepttypeof -- typeoverloaded methods -- singledispatch (only works for a single argument sadly, no stdlib multidispatch)inheritance (single) -- inheritance (multiple)object -- object (root of the type hierarchy)generics -- generics as well (via typing, runtime never cared anyway of course)lambda -- lambdanullability -- None (C# can have nullable reference types, Python types arenotnullable, None exists as a first-class type, not a subtype of all other types; similar ergonomics but different structurally)extension methods -- just go wild in Python (although binding methods after class definition is cumbersome)tuples -- tuples (both can do unpacking, multiple returns etc.)operator overloading -- operator overloadingreflection -- reflection (arguably a Python strong-point)async/await -- async/awaitdecorators (exist as a pattern) -- decorators (supported on the syntax level)?? -- top-level/first-class-citizens functionsI probably got a couple wrong, but you get the idea: apart from LINQ, nullability handling and some others, the languages are incredibly similar in their feature set on paper. This is not talking about DX etc. though.
Instagram
> from the perspective of recruiting in Australia.Even accounting for that line from the comment?
Even more so. Python is huge in Australia. Can't count front-end as Python is not applicable there.
There's no reason to discount front-end work from "programming languages". You choose python over typescript for machine learning because the ecosystem is there.You choose typescript over python because Brython and JavaScripthon and Transcrypt have no ecosystem that makes more sense than using NPM, and the people who like to program in python prefer the challenges of other domains than what's in the web browser.That just makes "most popular programming language" a silly metric. It doesn't mean that nobody uses the language because you ignore all the people who use it for things you aren't interested in.
The article mentions it, but I'll reiterate: the .NET CLR is fantastic. C# is a great language for the backend: GC'd, lots of libraries, fast runtime, and expressive enough. Do I wish it was more functional? Absolutely. But it doesn't aspire to be that.The ecosystem deserves mention. There are some high-quality libraries that work well, even if they aren't the most popular. Take objectional relational mappers, for instance. You can go whole hog and have an ultra-coupled, er, cough, "batteries-included" ORM much like every other ecosystem, or experiment with a multitude of options between writing your own SQL but letting the ORM handle hydration, and a full-blown ORM.Tooling support has always been top of the line, too. It is only in the past few years that other languages have caught up with the quality there (Eclipse/IntelliJ excepted).
> Do I wish it was more functional? Absolutely. But it doesn't aspire to be that.I somewhat disagree about the aspirations. Have you tried out things like switch expressions and LINQ? You can apply functional concepts almost everywhere these days. Complex state machines can be modeled using 100% functional techniques.
> ...objectional relational mappers...love this typo.will useobjectionable-relational mappersfrom now on.- objectionable - adjective, arousing distaste or opposition; unpleasant or offensive (definition source: Oxford Languages)
Where to start. Comparing advisories per package isn't a good metric. It assumes the usage and visibility is the same. Assuming the much smaller community around nuget packages won't bite you just as hard as bigger communities in terms of supply-chain attacks is a fallacy. Provided you can even meet your supply chain needs, and that's not a given in dotnet.And not comparing ASP.net to more mature web frameworks is also a strange choice. At the very least, you need very capable developers not to shoot yourself in the food with the enterprisy dependency injection magic. In my opinion much more so than with other frameworks. I mean, if you have a steady supply of highly-qualified dotnet engineers, go for it...
It's a pity the author doesn't mention F#.
I like C# but I've really come to dislike the idea of exceptions and null after working with Rust.I think C# would benefit from a Result/Option addition.
For null, there are nullable reference types now.Exceptions are here to stay though. I don't see how you could retrofit something like Rust's Result on top of .Net. (Also, .Net has a pattern that's an alternative to exceptions: `bool TrySomething(out T result)`. But it's quite limited, in several ways.)
Are you suggesting a Result type and Exceptions are mutually exclusive? Scala bolted `Either` (a Result type) on top of Java, and it worked exceptionally well in my experience.
It should be a simple wrapper Func<> with a generic Option<T>. I’m sure there is a library out there doing it already.
Why did you not include Go in your analysis?
The speed comparison is fascinating. Ruby often takes a hit in these parts for being slow, and the inference is usually versus Java, but hose numbers suggest they’re about the same? (Though I’m a big fan of Rails, it’s a criticism I acknowledge, as I came to it from PHP.) And people blithely never refer to JavaScript’s speed, but this is suggesting that it’s 50% slower than EITHER. My point is that the usual conversation about speed of languages seems to need some adjustment.
This article seems to be a lot focused on why you should be careful about using JavaScript for backend development. C#/.NET is one valid alternative, but many others surely also provide similar benefits and also avoid the pitfalls of JS. I agree that .NET is really solid and seems often unfairly seen in a negative light though.
Hot reload for ASP.NET works fine nowadays in VS and even with older versions of .NET.Dependency handling is still a large problem with .NET. Especially since current is often used instead of LTS. There is also no good way of sharing code between applications.Arrow functions, btw, solves the this/that problem in JS making React development easier etc.
What do you mean when you say there is no good way to share code between applications?
What I see a lot is private Nuget packages with common functionality used within several applications at companies. These are often binaries (one can place code in a Nuget packages but it won’t update, at least not last time I tested it). In the world pre GIT it was common to link in these files and build them along with the solution. Meaning, one did not have to try to align every .NET version or keep adding build targets to the Nuget packages.
That's what I'm used to too.  Shared code in Nuget packages in an internal Nuget feed. But definitelynotbinaries, as I've never had issues with Nuget packages not updating.YMMV - maybe you've been especially unlucky.
wake me up when it is really open source
This.https://isdotnetopen.com/
The page is 100% accurate but so FUDy ;). Not helpful.If Microsoft would only clearly and trustworthy communicate.
Microsoft and trustworthy communication can't me mentioned rationally in the same sentence. I've been working with them as a customer and partner for 30 years and have been screwed over and over again. They are the worst company I've ever worked with or for or with their technology.
Reading this post, it seems like the author never tried Typescript which seems to be heavily influenced by C#. I hate JavaScript as a language, but Typescript is very palatable. Like it or not JavaScript and Typescript are the franca lingua of programming for now
The problem with TypeScript is that because it's compiled to JavaScript eventually, it's broken whether it wants to be or not. TS might make sense on its own, but the medium is the message. You can't escape the bizarre stuff JS does when it's right there, under the hood, waiting for you...
That is true, but its strengths tend to outweigh its weaknesses.Nothing is as universal as typescript / JavaScript. Unlike other languages you also don’t have to context change when you’re transitioning from working on the backend to the front end. Everything also tends to be rewritten for node eventually.
It does seem like the author doesn't have much experience outside dotnet and node.
Source of some images:https://docs.microsoft.com/en-us/nuget/concepts/security-bes...
I think they are exactly seeing this and acting on it. IMHO they will start offering on VS Code a basic free product (a stable omnisharp equivalent) good enough for coding, debugging, etc. and then pricy options like visual designers, intellitrace, AI-guided coding, hot reload, etc. IMHO they will do the same for Python, PHP and others.They head of the dev division needs to protect the revenue. Simple as that.However, I completely agree with your sentiment: "Microsoft doesn't see what's good for them" ... because "free" is not "open source" and trust does not come from "free" but from "open source".
Totally get the bigger point, but I have to say the latest VS Mac is actually shaping up quite well and I like it.Though of course in retrospect itdoesdepend upon which workloads you're working on - and I mostly do command line tooling, web apps, and APIs, none of which require a design surface so maybe that's why my opinion differs as I've no informed idea how good/bad the layout aspect is.
C# is good, but not good enough to convince me overcoming the hurdle to onboard with its ecosystem. The deal isn't sweet enough.Language isn't important unless it is business critical. And successful businesses are scarce.
What hurdle?
Until .NET has the equivalent of Zod, I'm not that interested.Being able to write a validation schema and deriving types from it automatically - that I can share on client and server - is just too big an advantage.
Zod is really cool.Similar in F# land ishttps://github.com/Zaid-Ajaj/Fable.RemotingWhile both client and server are designed to be used from F#, they should be able to be used from js/ts as well as c# if desired, though I have not tested that.
Perhaps you should look into the .NET implementation of gRPC. It works really well in my experience.
The thing with zod is that by reusing schemas on server and client, I get extra client side validation for free.gRPC seems like it's just for the server.
Kind of an aside, but any one have a clue why those Haskell benchmarks are so slow? In my experience Haskell is relatively fast, so there must be some caveat that these test cases are hitting.
The problem is not with .NET itself, it's Microsoft. I don't even consider using VsCode as main editor because it's from MS.
There are genuine people behind these tools. Awesome people.
Sure, but they work for Microsoft. Who tried to own the industry in the 1990s.
.Net suffers from the same problem as computer science in the popular joke - names for things.
No mention of leftpad?  Kids these days don't study history.
Shhhhh, you're giving away my precious secrets!
Will you tire of posting about this stupidity?https://news.ycombinator.com/item?id=32117175
You don't think something being hard to input can be blamed on the OS at all?The only built-in way to type a sharp outside wordpad is to have a special registry key set then hold alt and type +266F, isn't it?  That sounds to me like it falls under "dreadful support for Unicode".
Oh I do hope not.  As Dr Johnson said, "when a man is tired of mocking Microsoft, he is tired of life".
Because even microsoft doesn't call it C♯, they call it C#.See:https://docs.microsoft.com/en-us/dotnet/csharp/
If you’re a JavaScript dev, it’s worth noting that NPM is owned by Microsoft. The mistrust angle is real, but I think it’s moot when specifically talking .NET vs. JS.
Microsoft has first-party support for .NET on linux and it's open source. Their commitment to non-windows and non-.NET platforms has only increased over time.
They also have a history of randomly deciding to dump a technology (including full languages) too, leaving those invested in it holding the bag.I like F# too, but I'll stick with one of it's non-MS controlled alternatives.
Not with their core languages. For example, Windows still comes bundled with the old VB6 runtimes and Microsoft still supports the language even if they no longer add features to it. I'm not really sure of any major Microsoft languages that Microsoft has just dumped, unless you count their smaller more esoteric ones.Also keep in mind that .NET Core is not only open source, but comes with complete protection from any patents Microsoft might have. The only thing Microsoft can sue people over is the .NET Core trademark itself.
>still supports the language even if they no longer add features to itThis is what I assumed the parent post was referring to. Mostly because it mirrors complaints I've heard (and maybe had) about the .net gui story. WinForms -> WPF -> whatever the windows store app framework was called -> I think MAUI now?
That's hardly a fault with Microsoft though. WinForms is fundamentally flawed and far better alternatives now exist, it'd be foolish to continue investing in WinForms. You can still use WinForms and .NET Framework on Windows 11, just don't expect new features, which is okay.
J# is one that comes to mind.  Spent some time learning this only to have it dropped the next year.
Wasn't J# designed to be a transitional language for Java devs  migrating to .NET/C#? (Wikipedia calls it a transitional language, too) Sure it wouldn't last long.
any software project or language can die, but I honestly struggle to think of a company that has a better history of long term support than Microsoft. You can fault Microsoft for quite a few things but their ability to maintain software and provide stable interfaces for devs is second to none.
MS discontinues a UI library project and then hypes up a new one every few years. Today Blazor and Maui are hot, but there's a lot of abandonware that came before.You can see it in Windows too, where you can burrow deeper and deeper into progressively older settings dialogs, because they reshuffle the Control Panel every few years.
OTOH even stuff as old as Windows Forms (which literally shipped with .NET 1.0 - that's 2001!) still works and it actually has maintainers. You don'thaveto chase the shiny new stuff.
To be fair. Creating a good cross UI framework is hard. Winforms wouldn’t cross over to OS X / linux. WPF was too heavily tied to Windows. Silver light was a compeditor to flash and both of those died. Now we are up to Maui and Avalion? Blazor is more silverlight replacement imo.
Also, Winforms and WPF were designed before Microsoft embraced Linux and started making .NET truly cross-platform. Starting over with a new cross-platform UI framework sounds like a reasonable thing to do.
I hear some of IBM's stuff has a pretty long history to it.
For running, yes. For developing, no.
What? I do occasional dotnet development on Linux. Using the dotnet SDK which is from Microsoft, and VS Code which is also from Microsoft.
Their support for VSCode is pretty considerable and reached the point where I'm comfortable working on non-GUI applications in C# in it a while ago, and from a UI perspective prefer it to Visual Studio.
What part of the .NET SDK isn't supported on Linux?
I think they are referring to visual studio support which doesn’t exist on linux.But if you wanna use VSCode or Rider then the support is 100%
Maybe, but the discussion itself was about Microsoft's commitment to open-source. Open-sourcing VS Professional, traditionally (and still) an enterprise tool, would be a bridge too far. The commenter that started this debate called the article a straw man, which is ironic.
Huh?
I've been working in .NET for the last year using intel Mac for the first 6 months exclusively and recently switching between Windows desktop and Mac (performance of desktop machine mostly, not willing to be early adopter with M1/2)I also use Rider exclusively and going to Visual Studio on Windows now and then I'm not missing much (visual studio did have some nice plugin for debugging compiler plugins, had to hack around than in Rider)I can't comment on Unity part.F# for me overpromises and underdelivers - it all sounds amazing in theory but it's been 3 times over the last decade where I've tried to use it (last time just a few months ago) and it never just works - I've spent diagnosing "why isn't this F# feature working as advertised" than solving my problem (from tooling like F# projects breaking autocomplete in VS solution - even for C# projects, to language features like type providers just being a nightmare to work with and integrate into CI/CD)
Honestly I've found F# pretty OK to use compared to some other languages, especially when not using Visual Studio on a non-Windows machine where F# IMO is the better choice. Given a cross-development experience in some of the more recent .NET teams I've been in (great that this is finally occurring btw) especially the Mac developers using VS Code prefer F#. After using it the feedback is that the experience on F#, especially since with F# Resharper is not necessary to function/develop, is preferable over C# (i.e. "its more of a scripting language").My observation is that the ex JS/Ruby/etc devs learning curve's seem to favor F# over C# as it is more like these languages. There's just a lot less to learn, and the coding style (e.g. modules, function first, etc) is more synonymous with langs like JS than heavy OO languages. I've recently inherited a team that moved to .NET from JS, and getting them to try C# has been painful especially when using things like ASP.NET. There's a lot of knowledge I just took for granted - we don't realise how much knowledge is required to use standard Java/C# OO in a production like setting that many dev's stumbled on when they were junior but have long forgotten the learning curve they went through. They tend to be framework heavy/dependent and require much more experience. From patterns (what's a strategy, repository, etc etc), to dep injection frameworks, to which refactoring tools I need, etc, etc - where in F# in my recent experience the experience is more, but still not quite "just code and work it out as you go".The pit of success favors F# over C# in my experience with these teams especially if you keep it simple with the features used.My experience has been that F# appeals to coders who are using the .NET platform coming from languages like JS/Go/etc but also has static typing who usually at least in the jobs I've been in are often on a Mac. C# dev's typically come from Java/C# enterprise kind of shops. Not one is better than the other and I will work in whatever space has interesting problems to solve - I think the difference is more cultural than technical.
Nulls, exceptions, and no discriminated unions. I use C# professionally and those traits completely ruin the language. And, no, the nullable stuff doesn't cut it. It has some pretty awkward quirks.Also, almost nobody writes code that is fast. Sure, aspnetcore might be optimized to the teeth, but drop EF in and that's all wiped out and then, not some, a ton.Idiomatic C# has also become what I call abstraction infatuation. It's impossible to tell what actually happens in that perfect 5 line method that uses 30 different interfaces and 10 different factories. Better have a good debugger handy (you won't: they all barf on async code). Aspnetcore and EF take abstraction to such academic levels that the most hardcore of Java EE devs would blush.I started learning it months after it launched, I am a truly seasoned C# veteran. I thought it was the best thing since sliced bread. But hear-you-me, I have had one too many exception in my time, and C# ismassivelyoverated.
I've never used a language without null, besides C# nullables (which I also find perfectly fine, though agreed to be somewhat awkward). What is the alternative and its benefit? Null fits so many issues perfectly naturally, like a database entry without a value. And I find the C# '?' syntax to be amazing. For those unfamiliar with it:string foo = someDb.GetRow(id)?.Valuefoo is null when the row is null or the value is null, with 0 null pointer exceptions possible. If you wanted to allow someDb to possible be null, instead of intentionally crashing out, you could also add another ? after that reference.Reallywish C++ had this. But in general I find null pointer exceptions to be desirable, because more often than not they indicate a failure of assumptions.
F# doesn’t have nulls by default and can completely interact with C# bybusi by Option types with the value set to None in case of null and Some<T> when it actually has a value.This is so much more explicit and composes so much better than C#’s null.If I declare a variable with a certain type in C#, its type is implicitly set to that type and null. I am allowed to call every operation that is supported by that type on the variable, and yet, it’s actually a lie because if the variable is set to null the purportedly supported operation won’t run and will throw an exception.In F#, however, if I declare something of a certain type, it’s guaranteed to be of that type. Any operations on that variable supported by that type are guaranteed to run.And if something might indeed not have a value (say a database result) I have to explicitly declare it as an option type so there is a None option for the value. This way the F# compiler will ensure I’m handling the None scenario properly and don’t end up calling unsupported operations on Null.This is a much better design. I in fact struggle to understand why anyone thought it was a good idea to allow someone to declare a certain type but create an object which is not actually that type but is implicitly Type | null.It makes sense in an unmanaged language like C, but makes no sense whatsoever in advanced languages like Java or C#.
I much prefer languages without Null (Rust being a personal favorite). I'll speak to that because I have a bit of experience with both C# w/ Nullable and Rust.In Rust, you express types using the Option syntax. Its basically saying "This value could be None". It behaves similarly to nulls, but instead of Option being implicit (like C# nulls) its explicit. You can't do `let foo: String = None` because its an invalid type assertion. Whereas you can do `let foo: Option<String> = None`. In C#, you can't express "This is a string that cannot be null" (even with nullables if I recall correctly).
Sibling comments mentioned Option types, which are assumed the currently best approach. I agree, but would like to add Python as a different example.Null handling in Python is actually sane, despite there being no Option type.Its Null is called None, which is of type NoneType, which sits at the very top of the type hierarchy (inherits from object). That’s it. Everything else is separate from it. You perform a check for None, and after passing, you are guaranteed no null reference. Dereferencing cannot blow up.A variable of type “Union of None and SomeClass” is safe to use after a None check. Type checkers will flag missing checks as errors. This is in contrast to C# or Java, where any reference type can end up in a rug pull and cause a null dereference.In Python, assuming a type checker, checks are mandatory and cannot be forgotten (quite similar to Option types actually). In the other languages they’re not mandatory and can be forgotten (by default).
There's actually still plenty of insane things about None in Python.https://peps.python.org/pep-0661/is a great example of that.> Sibling comments mentioned Option types, which are assumed the currently best approachOption types are actually just the tip of the iceberg though. The real power is in languages that support algebraic data types. Option is just one common example, used to distinguish between just Some and None, but it's reasonable to have an enum with other states, each optionally with its own associated data.
Imagine if Nullable<T> allowed ref (class) types, and then disallow ref types from actually ever being null, and you have an approximation of the alternative: option/maybe types.https://en.wikipedia.org/wiki/Option_typeI absolutely did not get it until I really used it. It's 10x the sensation of fearlessness that C# non-nullable ref types give you. For example, you can't do something like this:var customers = new Customer[10];(If I'm remembering correctly, C# in nullable mode allows this - and it's incorrect). You actually have to give it 10 instantiated Customer, or do:var customers = new Option<Customer>[10];Then, once you've filled it:var filled_customers = customers.Select(x => x.Unwrap());Now what's especially cool is that these are often treated like Lists with a maximum count of 1. What does that mean?var customer = new Nullable(new Customer());
    customer.Select(x => Console.WriteLine(x));
    customer = Nullable.Empty;
    customer.Select(x => Console.WriteLine(x));That only does something in the first Select, the second is like an empty list. When you start thinking this way, you can do stuff like:customers.SelectMany(x => x);So, keeping in mind what SelectMany does (it essentially flattens a list of lists into a single list), you'd filter out all the unallocated customers. Think about all the stuff you do with Linq (including the Linq syntax), and how nice your code would get if you could just treat null as a list of length 0. It's super-neat, ? on steroids (? does win in the brevity department though) and once you learn the mindset [generally good] code just flows out of you. It's like the Matrix, you have to see it for yourself to understand it. It teaches you a new way of thinking.
Please go take a look at Rust and/or Swift to see how nice a language without null feels like.
It’s not that there’s no way to model nullability/optionality. It’s just that there’s a much better way to do it. Simple, obvious, composable, no quirks.
I remember C# being great a few years back when I used it. I am surprised that it doesn't have better discriminated unions since languages like TypeScript, and F# have them.Is the interop between C# and F# not good? I've never used it myself, but I remember (and this is validated by a quick web search) that it's possible to just directly call F# code.
TypeScript only has "discriminated unions" in an extremely busted form. While they are encoded in its type system, there is little support in control flow. Exhaustiveness checking is essentially optional: it's enabled in switch statements by either `assertNever` in the `default` case, or by limiting your function return from within switch cases with the `strictNullChecks` option enabled.Without a match expression and first-class exhaustiveness checking, discriminated unions are far less useful. Of course, this is because they don't want the TypeScript compiler to actually generate code, so they can't add runtime features. While TypeScript is better than no TypeScript, it seems like a massive waste to build a compiler and then shy away from making people's lives easier when possible.
> it's enabled in switch statements by either `assertNever` in the `default` case, or by limiting your function return from within switch cases with the `strictNullChecks` option enabled.What's wrong with using if statements?```if(shape.key === 'rectangle'){}else if (shape.key === 'circle') {}else {x: never = shape} // todo: use exhaustiveCheck(x: never)```That's pretty clear and easy.
F# discriminated unions are always heap-allocated - the .Net runtime doesn't currently support address punning (having a single memory location possibly be a heap value or a stack value is UB). That may (always profile) put you at odds with writing fast code - and probably will: remember that significant portions of aspnetcore's recently skyrocketing performance have come down to eliminating allocations.
F# does have [<Struct>] DUs now but I believe because of the runtime limitations you mention, it ends up as sizeof(fields of case 1 + fields of case 2 + ...). They might reuse fields of the same type so if your DU cases can carry an A of string or B of string*int, the underlying struct is sizeof(string+int) not sizeof(string+string+int), but I'm not sure.Regardless F#'s biggest downfall is that to use it you basically have to be a C# expert already and learn the F# syntax and additional features on top of that. Otherwise it's a baffling standalone language because you're left wondering why there are two ways to do almost everything -- Task vs Async, struct ("tup", "les") vs ("regular", "tuples"), two kinds of extension methods for classes, Nullable<T> vs Option<T>, it goes on and on.
I don't like nulls and I definitely appreciate discriminated unions.But WTF is wrong exceptions?!  And by that I mean try/catch/finally.I wouldn't use a language that doesn't have them.The lack of exceptions in GO is just one of the reasons I hate it.Go is a good example of what life would be without exceptions, code polluted with error handing.
Exceptions are invisible control flow. You have no guarantees about what piece of code will execute anywhere in your codebase. I agreed with you maybe 2-3 years ago but have since done a hard 180 in that opinion after seriously using a language with no exceptions. I'm too stupid to reason about exception control flow, just like I am too stupid to do manual memory management.There are also huge differences between exception alternatives, and I definitely think more progress is possible.  I also dislike how Go approaches exceptionless, but Rust does a far better job. Hare seems like it could have one of the best approaches (so far) but I haven't actually used it.Erlang/Elixir/Gleam are also something I want to try out. Allowing things to just crash and restart is definitely a different perspective worth learning about.
Y'know what, I just took a look and I think I would like Rust-style error handling.It reminded me about one thing that Idislikeabout exception handing in C#, that methods don't have to declare the exceptions that they throw, unlike Java.And the thing I disliked about the Java way was declaring exceptions that would be panics in Rust.I also like that ? Rust operator for propagating errors.I've done some Erlang and I definitely like Erlang monitors.Maybe the Rust way combined with monitors would be the ultimate in error handling :-)
What if there was syntax that was built into a language that required annotating exceptions functions that threw exceptions. That way at least you would know that an exception was possible to be thrown in a function and could handle it appropriately
Could you share the stuff that you're working with which make feel that the issues you mentioned are completely ruining the language? It sounds quite intriguing. I have mostly used in the last decade for basic JSON APIs and desktop application where I haven't really encountered those.
Have a look at the codebase for OHM (Open Hardware Monitor).  It's fairly clean C#, and I found it refreshingly easy to grasp.  I know what you mean about all the abstraction but you can use the language without all of that.
Good C# is certainly possible, XNA was a thing of beauty. There are still fundamental issues with the language. Another example (beyond nulls etc.): why do C# switch statements require break? Fall-through isn't supported, so it's just dangling there as an artifact of a previous language and not, oh I don't know, doing something useful like breaking out of the loop that contains the switch. When was the last time you took advantage of the variable scoping in switch, vs. when was the last time you had to figure out what to call a variable because of the scoping rules.Ignoring the big issues, it's paper cut after paper cut.It's infuriating after you've used a language with thoughtful ergonomics.
Blame C/C++ for the switch complaint. C#'s design was to avoid a lot of those nasty pitfalls by making you be explicit about your intent. You don't have to use a break, but you do have to explicitly exit out of the switch, so a return, or throw, or (gasp) goto works also. This means forgetting a break is a compiler error, not the silent execution of subsequent cases, which is probably a trick employed purposefully in C++ like 5% of the time and a nasty bug for every other instance.
Switch in C# is pretty much Rust's 'match' (aside from Rust having unit type and being expression oriented which gives it an advantage). It support list pattern matching, object type and member pattern matching, inline slice patterns, etc. You don't need to use switch statements for that either, switch expressions is the recommended syntax today and IDE is likely to even suggest to auto-fix some of the idioms it can recognize.Seehttps://learn.microsoft.com/en-us/dotnet/csharp/language-ref...
> why do C# switch statements require break? Fall-through isn't supportedYes it is. I've got it in my game right now. It totally supports fall-through.
... by using a goto case, which you can put anywhere in a case. The break remains non-functional.
> printf/console.log aren’t debugging, peasantYoumighthave missed the bit where I said the tools barf on async code - something a printf debugger wouldn't care about. It logically follows that I am indeed a user of a debugging tool, and not a "peasant".  Though primitive tools like printf and memory dumps do have their advantages. Notably, printf is resilient in the face of async code.You were also practically forced to use VS for C# 1.0, and by consequence a debugger.VS loses track of where the async stack is (the parallel stacks view sometimes saves the day), the Rider debugger outright crashes and takes the process with it - and if it doesn't, completely fails to step into async methods.
I haven't found the async call stack in VS to be bad unless I'm doing stuff like firing off "async void" calls or firing off "Task.Run"s. It sure does make the stack trace on Exception.ToString() ugly but the call stack in the debugger is ordinarily quite navigable.Now what can be annoying is when your problem is in some ASP.NET core middleware and you can't find it debugging your controller methods.Also I don't love the "fluent API" configuration style they've adopted. I always have to Google what my chain of services.AddMvc(options => ...) and app.UseMvc(...) is supposed to look like. These APIs seem like they should be very discoverable through intellisense but since you can't "see" extension methods until you open their namespace, sometimes you have to already know exactly what you're looking for to find it. But then again, the old way of configuring a lot of those same things was via web.config and even less discoverable, so that's kind of a wash.Edit: one other thing about the modern style of C# library design is the total rejection of statics in favor of dependency injection. Which I think is done with good intentions but somewhat overzealous. We no longer use HttpContext.Current, we have an IHttpContextAccessor that needs to be injected. We no longer use ConfigurationManager.AppSettings["foo"] we have an IConfiguration which again, needs to be injected. I get why this was done but I feel it trades convenience in the 99%-of-the-time case where those things reallyarequite reasonable to treat as static, for elegance in the 1% of cases where they are not.
I find Chrome JS debugging pretty awesome. What features it lacks so it’s utter trash?
Yes, it is. The comment section here is the proof of the overarching problem. People just don’t want nice things and would rather act on their tribal stereotypes instead.Read through - you will see developers who unfortunately use either outdated platform that is Unity (it uses Boehm GC, in 2023!) until Unity 6 comes around. Or developers who don’t use C# at all, or the ones that had bad experience with some non-corelib library back in 2016 and then go onto crusade.There are some for whom the actual state of affairs does not matter at all, and no amount of improvement throughout the years is sufficient.
OSS C# was a day late and a dollar short. Fundamentally, why would you ever pick it over Java? Theoretically it has a nicer IDE and some usability improvements, and better reflection. But that nice tooling was only ever available on Windows, recent revisions of Java have closed the usability gap, and people are finally realising what a bad idea reflection was (other than the Spring Boot nutters). Meanwhile library availability and general platform/tooling support for Java is orders of magnitude ahead.It's kind of a shame, because in isolation C# is a pretty well-designed language. But people don't switch to better-designed languages, they switch to languages that have a killer feature that their previous language was missing. C# never managed that.
> OSS C# was a day late and a dollar short. Fundamentally, why would you ever pick it over Java?While I do have major criticisms of C#, this is an often repeated criticism that doesn't hold much water. C# is Open Source (with capitals) regardless of how or when it happened, Oracle is notoriously litigious.
Neither needs C#. You can require runtime at a host, you can package it with your binary (which Go does, and C++ effectively too if you link statically).But then again, Java can’t even dothat. Its build and packaging systems are a tedious joke. If you want to package a C# binary, you simply invoke either of the two (one is JIT, one is AOT):dotnet publish -o {dest} -p:PublishSingleFile=true -p:PublishTrimmed=true
    dotnet publish -o {dest} -p:PublishAot=trueDone. No runtime required.Also, most applications use ASP.NET Core and EF Core in back-end (which are platform-agnostic) and a selection of libraries for desktop and user facing applications on front-end: Avalonia, Uno, now MAUI, Xamarin (all of these are cross-platform) and historically WPF, Windows Forms, UWP and WinUI as their successor.
> Done. No runtime required.But the part that matters is that you can ship a single file to people who are on any platform and be confident it will work. Yes the file is .jar and using a runtime, but those details are mostly irrelevant - everyone has Java installed somewhere.Whereas with C#, sure you've got your nice binary, but if I try to run it on FreeBSD or Sparc is it going to work? From bitter experience, probably not - as GP said, probably for reasons that are more bad code and culture than a bad language, but the fact that several of those major (even if they're now considered "historic") GUI libraries are Windows-only and almost-but-not-quite work outside Windows sets the tone for the whole community culture.
> Sparc> Presence of platform-specific GUI libraries makesdifferentcross-platform libraries worse> Supportingbothself-contained and runtime-dependent lean binaries is badHopefully this reply is a bait, otherwise I give the exercise in mental gymnastics a solid 7/10.
In Java-land, someone puts a jar on their website, and it will work on whatever OS, on whatever architecture, even if it's a GUI program.In C#-land, that doesn't seem to be how it works. If it's a GUI program it'll probably depend on WinForms and fundamentally not work on official .net core for non-windows. It might work on Mono if you're lucky, but often it won't. And whether or not the program "could" work on your OS/architecture, most of the time what they'll put up on the website is a single-platform binary. Whatever the theoretical advantages, as someone just trying to actually use the thing on my computer, that's worse.
Thisalmostmakes me feel like we're back in 2007. Everything is so much simpler, my mother just finished cooking borscht and is calling me to kitchen. Life is good.
Oracle is indeed probably even less trustworthy than MS. But Java had a good enough release first, and a fully open source release first, and a decent crossplatform develompent story first.
Congratulation for spreading a disease in PL design. Await is controversial at best and should not be considered a pro.
Then why Swift, Rust, TS/JS and Python went with it as well?
Yes I literally called it a disease. Just look up “what color is your function”, I’m hardly the only person who thinks so.There are more languages without async await that ones that have. The language that’s known most for massive concurrency, go, does not have it. None of the functional programming languages needs it either.
Oh no. Not the function coloring debate again (congratulations, with 1/100 of the talent, the author of that article is now inflicting similar damage as misquoting Donald Knuth on performance).But if we have to do this, all functions in Go are colored but you simply can't do anything about it. Not allowing a method call to represent a delayed operation that produces a result (Promise/Future/Task) is the major mistake, and a reason why Go is surprisingly limited at concurrency even if it not seems that way if you come from a language which had even worse UX.
Why do you need to know what/what not is a delayed operation? Seem like the worse languages are ones you have to do that, instead of just caring about the computation. Polluting your function signatures with some abstraction that has nothing to do with the domain is pretty lame too.
"The group I belong to is obviously right and the other group is obviously wrong"Forcibly hiding away the nature of the call shifts the priorities from easy concurrency especially when there are multiple calls in-flight to only logically sequential code being convenient to write with all other options requiring significantly more boilerplate (which is the case for both Go and Java).It is a tradeoff, and I think it is a bad one for the domain that both Java and Go are usually applied to. Java had to retrofit a GT approach because async/await would be unfeasible at this point. It was a good choice in the context, but maybe not so if one were to reinvent it from the ground up.On the other hand, Go took a similar route but for completely different reasons - it was specifically tailor made to first and foremost solve Google issues with internal dev culture and scaling of the organization (e.g. syntax styling being the function visibility modifier) and strictly prioritized being as quick to on-board as possible.It resulted in Go being a language that is, as someone neatly put it here on HN, "Newbie friendly but professional unfriendly". This is further evidenced by the amount of surrounding code generation tooling and code written in DSL required to maintain an average complex project written in Golang (remember the HN post on a multi-million dollar project in dev hours to just work around Go's issues with nils?), something that is often a sign of inherent language limitations or its overall inadequacy (e.g. the criticism regarding C#'s source generators/interceptors or Java Lombok is valid because they exist for the same reason).
That's because Java has "java.util.concurrent" which kickseverybody'sass at concurrent programming.Seriously.  Any of the GC languages would be several orders of magnitude better simply by doing nothing but copying "java.util.concurrent" into their language.
Have you tried PLINQ? Much better than Java streams like LINQ which is a common knowledge but can easily parallelize arbitrary list comprehensions.
I have used some C# with Unity and Mono, so I can't comment too much on C# on the server compared to Java, Go, etc. It's an okay language but isn't bad.That said, F# is afantasticlanguage. F# is Ocaml but a bit more simpler, better concurrency, and on the C# runtime (or to javascript with Fable).
It's a good language, better and safer than C/C++.However, Microsoft has messed it up in multiple ways:- It was great for Windows desktop applications, then they came out with Silverlight which then got abandoned.- It has its own version of DLL hell. Users almost always need to download the .NET runtime. Windows 10 originally shipped without the most popular version, which made the runtime the most popular download.- MS could not come up with a consistent naming and numbering conventions for their versions, Core, Framework and now just .NET- Visual Studio Code doesn't properly support it, yes there are plugins, but to do anything useful you need Visual Studio proper.
I've used C# quite a bit due to the Unity game engine. Moment to moment, it's pretty enjoyable to code in and easy to read. The cross-platform nature is usually really nice too (C# DLLs typically work on all platforms without issue).However, I do have a few complaints:We spend a lot of time fighting the garbage collector. This leads to awkward situations where certain variables that would ideally be function-local need to be made into member variables so we can reuse the memory each frame. This makes our code more complex and less local.The choice to make "class" vs "struct" dictate whether memory is allocated on the heap or stack is annoying. I think there are a lot of problems with this: overloading keywords borrowed from C/C++, not being sure where memory will be allocated unless you go check the type definition, not having the option to instantiate a single type in both memory areas.At first glance, you think C# doesn't have to deal with pointers. But in reality, just about everything IS a pointer, just with no syntax to indicate it. The fact that (almost) everything can be null makes code more complex.I also find some of the syntax introduced in newer C# versions hard to read - but I guess I also feel that way about C++!Ultimately, I still really enjoy/prefer C or C++. Despite their flaws, they give you a lot of options and a lot of control that I sometimes wish I had in C#.
> We spend a lot of time fighting the garbage collector.Have you considered object pools? Getting objects into an older generation will eliminate their impact on regular collections.https://learn.microsoft.com/en-us/dotnet/api/microsoft.exten...You want to be intentional about how long objects hang about. In C# game dev it starts becoming an architectural concern.That being said, allocation problems aren't unique to managed languages. You'll definitely see at least one pool somewhere in a large-scale C++ game. It's always costly.
GC and nullability issues are an unfortunate result of Unity using forked flavour of Mono runtime (that is significantly behind feature-wise and uses Boehm GC). When Unity 6 comes out, all of these will hopefully become a thing of the past.The larger .NET ecosystem does not have much issues with GC performance nor with nulls since most new code written is with enabled nullable reference types so you pretty much always know if a reference is nullable or not.
You see issues with stack allocated variables in a function? There should be negligible cost to that.The recent introduction of Span (or Memory for heap) has met most of my needs for fighting the GC and pseudo pointers without being 'unsafe'
I never touched it myself, because it's 'Microsoft's version of Java', so double-plus-ungood.But my 14yo son has been trying all the languages the last year or so (from lisps to lua to rust, to C, to icon, vale, to, etc, etc), and out of all of them he's most impressed by C#. According to him, it's just really well designed, all just fits together beautifully ... (his opinion on Rust - it's just not complete yet).So I think C# probably is under-hyped, and I'll be taking a look myself. That's if I can even download it; I guess I'll have to wrestle through a microsoft account login, app store, or family permissions, or whatever other user hell they've concocted lately.
SDKhttps://dot.net/downloadVSC extensionhttps://marketplace.visualstudio.com/items?itemName=ms-dotne...Or if you prefer VShttps://visualstudio.microsoft.com/vs/community/
When I was that age I had a high opinion of C# too. Over the years less so. Your statement relating to Microsoft sums it up well. It's overhyped.
In my mind a Java is the main language that shares the same niche as C#, and I think for a long time C# came out ahead while Java stagnated, but in many ways I think Java has now pulled ahead imo.
Swift, C#, Scala: the top languages for having a bloated design and make people choose between a gazillian ways of doing things for every single coding decision.
Well, for a C-based language that needs to keep compatibility, I'd say it's one of the best. I'd love to see a breaking change (under a pragma or something) in order to have public modifier as default, everything as expressions instead of statements and so on -- get closer to Kotlin.
I understand the meaning of the question but "hype" isn't going to encourage the best answers.
Even Microsoft is moving towards Rust.
Honestly, this thread is kinda low quality. OP seems to be taking criticism of C# personally and going full defensive mode. And the question itself is too vague to answer properly. Is this post just seeking validation of one's own preferred language?
No. C# is not Rust and therefore is not relevant. Microsoft is rewriting core Windows components in Rust, not C#.
So Rust is better than C# for systems or OS programming… I don’t think anyone is going to argue with you on that.
Rust is also better than C# for fullstack web development. I don't give a remote s** if anyone wants to argue with me on that.
What are you talking about?
Radar and sonarr are .net projects that work alright on linux
> I don't have a single mono/dotnet application or service installed on Linux, and I can't think of a popular one.I don't have market share data, but dotnet is used a lot to develop ASP.NET Core services, which also target Linux and whose developer experience is delightful and provides top performance out of the box. I'd pick ASP.NET Core on Linux over any Java-based framework any day of the week.
Let me add toxic developers to my list of complaints. I don't think this is a well reasoned response to my comment. Is this reddit now?Edit: It's weird you called me a nazi, but I am not banned from Reddit, nor have ever supported the radical right. Please keep your ad-hominem attacks to other platforms, I am mainly on HN because it has less ridiculous noise like this.
They are a new account, seems to have been made just to trash talk/defend C#.
I worked with C# for a decade, and I think it’s never been better than it is now. I also think it’s a language that’s mostly meant to be sold by Microsoft in 2023 where it’s sort of outlived its usefulness compared to something like Go, or even Java.I live in a very Microsoft happy region of the world, but not a single company that’s managed actual growth is using C#, and the language sort of lives in this “stagnated semi-large company that’s not going anywhere and hasn’t for a long time” space. Which might not have anything to do with C#, but more that the choices over all at those companies (which includes going too heavy in on the Microsoft tech stack) seem to hinder them from growing beyond 100-300 employees. Which on one hand is unimportant for the developers who work there, but often leads to a lot of those developers to “stagnate” as well, which sometimes lead to them having a rough time if they for some reason have to enter the job market at 50+.So in many ways I think C# is very overhyped. Mostly because, why would you ever chose it? I don’t think it really compared with Rust. Rust can compete in the same space as C#, but you’d mostly pick Rust instead of C++, and I see things like Java, Python, Go and Typescript as its main competitors. Java mainly being there because large “boring” enterprise organisations like banks are going to use Java until all of us retire. But if you’d chose between Python, Typescript, Go and C# you just wouldn’t ever pick C#. Even against Java, I’d question why you would ever pick C#? Java is so far ahead of C# on concurrency that it’s painful to watch how C# developers are still stuck using things like await.Yes it’s faster than Typescript and Python, but with Python being capable of powering the web-back ends at Instagram and OpenAI that is sort of a silly point. And Python is just soooo much more efficient in terms of producing things fast. It’s also telling that even Microsoft’s own C# developers pick Python over C# for things like prototyping and smaller applications they need to build fast. Go is king of concurrency and Microservices and you can see stories like Lunar who’ve gone from a Node backend to a Java backend to Go and now can’t imagine not using Go. Then there is Typescript, which today is basically what C# wants to be, and probably will be as the two languages influence each other more and more, but allows you to “full stack” in one language (except for the parts that run on Python and C++/Rust but you’ll have those regardless as some things require the efficiency of C++/Rust and the ML/BI/AI crowd aren’t going away from Python until the moon leaves our orbit). With companies like LEGO running most of their software on Typescript and Node, leaving C# behind, it’s also hard to talk too much about its inefficiency.You can also look in my history and see my ranting about a range of the issues you’re eventually going to run into with the “magic” C# comes with, because a lot of their automatic handling of complexity can break in various ways when you need to use it in ways Microsoft hasn’t build it to support, and sometimes that’s simply using two different Microsoft libraries for C#. Which has nothing to do with the language itself, but let’s not pretend you aren’t going to use EF, Blazor, WebApi or similar if you use C# so it does impact you even if it has nothing to do with the language.I don’t think there is anything wrong with C# though, it’s just that there isn’t really anything “right” with it either. It’s a language that doesn’t do anything other languages doesn’t do better, which includes being a jack-of-all-trades language where it’s also flat out losing to Typescript. If that last statement makes little sense to you, I fully understand, because a good Node development requires and opinionated CI/CD environment where as C# kind of doesn’t. But this is partly also why you’ll find so many C# developers get trapped by the language and end up making glaring mistakes like using IEnumerable instead of IQuerable. Or making what is going to execute as 9 table joins in linq but not wonder why it takes 4 minutes to execute. Which because you can get away with some pretty bad CI/CD pipeline in C# (for a while) ends up going to production.
Syntax is one thing, but C#'s ecosystem is probably the most sane that I have ever witnessedA lot of well designed "standard" librariesCLI with all things needed like compiler, package manager, test runner, publish for various archs/oses out of the boxReally strong IDEs like VS and Rider with really good debuggersSmall fragmentation, so jumping between companies and projects is not hard (at least from web dev perspective)
I just wish the de facto standard framework, ASP.net core, was more of a batteries included kind of thing.Diving into an ASP.net application not written by you is frustrating because it’s almost like its own framework you need to learn.
As someone who has picked up several languages through out my career - I found c# to have one of the lowest barrier to entry.  IMHO, really well documented by Microsoft.
Go does this really well, too.
Any libraries that you would recommend? I always see a few libraries for any particular problem but it's hard to know the tradeoffs.
Yes, I also consider this experience as part of the learning curve. Java and Go have given me a poor development experience because I have to personally test many libraries (which takes time) before choosing one. It really wastes a lot of the company's resources (since people's work time equals company expenses).
Could you give an example? Compared to many other languages (e.g. C++, Java) which don't even have JSON parsing in the standard library (Go does), Go's standard library is very complete.
C# certainly deserves that recognition. With its regular updates and support from .NET, it has become easier to use and offers a rich set of features to achieve goals more effortlessly. I always tell my friends that today's .NET offers the fast performance of Golang, the easy learning curve of Python, and the rich features of Java.
Still tied up to windows though? Or does the Linux build work on par now?
In my experience .NET core works great on Linux.It has actually been fantastic for writing small jobs that run in Linux docker containers.
It works on Linux. But you'll notice every now and then how it just doesn't quite want to fit in, especially the developer tooling around it. It's not that it doesn't work, you just stumble over minor annoyances that don't happen on Windows and VSCode (with the proprietary plugin). Quite a contrast to developing in Rust on Linux, for example.
No, developing C# on Linux has been exactly the same as on windows for a very long time. Not since Framework and Core were separate things.The modern C# Linux experience is indistinguishable from Windows.When I'm in the office, I use Windows, when I work from home it's on Linux. Same projects, no problems.
Try to do GUI stuff, or debugging parallel code in VSCode on Linux.
Rider works fine for me.
After paying for it.Meanwhile other FOSS ecosystems, get everything as free beer, including InteliJ stuff.
That's really not relevant.Your problem is that VSCode is broken, not C#.
It certainly is, Community edition, available in macOS, Linux and Windows, contrary to VS Community that is Windows only.What the hell has Go, Rust or C++ to do with C# and .NET code?
C# hasn't been tied to Windows for a very long time. It works just the same on Linux.
So the problem with .NET is that you only have community-maintained GUI frameworks, opposed to other ecosystems where you have community-maintained GUI frameworks.
Their language of the year award seems like it's solely based on increase in popularity this year (wouldn't that be biased against more popular languages?).> For the first time in the history of the TIOBE index, C# has won the programming language of the year award. Congratulations! C# has been a top 10 player for more than 2 decades and now that it is catching up with the big 4 languages, it won the well-deserved award by being the language with the biggest uptick in one year (+1.43%). Runners up are Scratch (+0.83%) and Fortran (+0.64%).Still, well deserved. C# has been steadily innovating for a long time while Python, Go and Java move relatively slowly. In terms of syntax innovation only JavaScript has been at a similar pace it seems.
Top 3 is C#, Scratch and Fortran according to this article ? What kind of ranking is that ?I think ranking programming languages is dubious in general but this goes to another level.
>it won the well-deserved award by being the language with the biggest uptick in one year (+1.43%). Runners up are Scratch (+0.83%) and Fortran (+0.64%).They are the top three of the language of the year award not the index as such.In the index it's Python, C and C++
Sounds like an award for the highest statistical error of the year.
Tiobe index is just bad, I used to put more faith in Stackoverflow questions, now I just look at subreddit subscription totals or job postings.
They are not too three. They are the three languages with the biggest uptick.
>C# is eating market share from Java and is getting more and more popular in domains such as web application back ends and games (thanks to Unity).What is this based on? Presumably nothing. What a weird PR piece.Claiming anything is eating market share from Java is like saying a toddler is catching up to an Olympic athlete.
It's actually based on several different sources, though I know you're not interested in the constructive conversation or else you would have provided some type of support for the article, instead just merely deflecting the standards the article SHOULD have used towards my own personal comment. Which I'm sure you thought was clever, but it's not.Good luck.
If you're interested in popularity, versus change in popularity, see the "Very Long Term History" section of the website.  The consistent winner is C, which was the ranked number 1 or 2 in each of the eight report pentads.  C# seems to be settling into the number 5 or 6 spot.Working with differences can be tricky.  So can working with ranks. Luckily, the site provides an interactive graph of index versus time for various languages, so readers can make their own decisions.I'm not sure I care what is popular to the general community.  I use multiple languages in my work, different ones for different things.  Fortran and Scratch are like hammers and screw drivers: they are both handy, just for different things. The same for many of the languages in the listing.
When I'm managing a team of good developers, I trust their feedback on what the best tool for the job is.  My lead developer is real strong in C#, so that's generally what we use for back-end development.  On mobile we did C#/Xamarin just so we could "write once" for both Android and iOS.  I would have been happy with flutter too, but the best guys I could hire locally were C# so we did that.  It was a nice bonus to be able to share code between back-end and front-end though.We've been happily using C# for damn near 20 years, even through rough patches like the transition to .Net Core or when Silverlight got abandoned by surprise.
According to the rating javascript is 5th. I find that quite suspicious considering that it powers the web
God damn! R is below F# and....D? What the hell is D?
https://en.m.wikipedia.org/wiki/Walter_Bright
>What the hell is D?I hope this is a joke, in that case it would have been better with XD or /s.
I use it daily
Install the dotnet SDK.dotnet new console -o Test
    cd Test
    dotnet runDone.Complaining about GUI development is misleading; GUI development with any toolkit is more difficult than console apps.
I would say it depends on your objective.If you are looking for something that will maximize your capability as a professional developer, absolutely yes. If you are looking for something to dabble in just for fun, I'd say its a much less important thing to worry about.For me, the magic of C#/.NET (when used appropriately) is that the language can fall away and allow you to think almost directly in business terms. Features like LINQ are a major part of this experience. When I am working with a complex business domain, I really don't like the idea of playing code golf with my tools. Making the customer happy is far more rewarding to me than anything I could do on my computer.Also, being able to minimize your vendor footprint to just "Microsoft" helps out a ton at due diligence time if you are selling software to other businesses.
What about the developers tools and the developer environment? Since C# is cross-platform, it would be easy to develop software also in a UNIX-like setting, right?
It is easy. You can write C# in anything these days, Rider becoming a favorite pretty quickly for many. Everything like dotnet CLI just works on Linux too.
I'd saycloseto just works. I've spent the last 6 months developing with Rider on Arch and it hasn't been a completely smooth ride. Admittedly, a lot of my pain just came from inexperience. I screwed up permissions; it took me ages to setup the right .net packages due to the nomenclature (which, when I installed Visual Studio on Windows, is easily glossed over); function apps took a while to get working.But it really is satisfying once you've got everything working.
For Linux, the best way by far to install jetbrains products is to use the toolbox.I had the same issues you had until someone recommended installing through the toolbox, and it's worked flawlessly in multiple PCs since then.
Yes. Without a doubt. More so, if dynamically typed languages are the only ones you know.I've been avoiding them as they were Windows only early days, and Entity Framework Core was too immature at the beginning after the open source wave.Some points, from my PoV of developing business/CRUD type applications;- .NET framework is well engineered solutions to most of the standard requirements in software development. I've spent countless hours looking for solutions in Python for common things like structured logging, validation, websockets, datetime utilities, cryptography, cli, unit conversions etc. when working with Python.- There are a lot of features for reducing boilerplate. Getting better with every release.- Static typing doesn't get in your way. Just the opposite. Eagerly waiting for discriminated unions.- LINQ, especially when combined with EF Core, is godsend.
To follow on a bit, I've been using .NET since 1.0 (yes, literally. Not 1.1).  C# and .NET in the current form are spectacular!There are a handful of projects I still have going that are in .NET 3.5 (there are still users out there on Windows XP), but the vast majority of my server-side stuff has been moved over to .NET Standard and newer.  Most are running in K8S.Aside from the old stuff that I still have to support, most of it can be run on my M1 MBP
My experience, so far, has just been in Python developing with FastAPI. Next, I would like to learn a statically typed language, but I am not sure what. I was wondering about Go and C# of course.
Both has it's advantages and disadvantages depending on the use case.If you primarily develop user facing applications (web applications, line of business applications etc.) C# is a good choice. There are a lot of companies (including Microsoft) using it for these use cases, so there are good ready made solutions, tutorials, documentations for the common features that you'll require.If you primarily develop "system" level software (Docker, Hashicorp products etc), Go is a good choice for the same reasons.This is a bit of a generalization as both languages can be used for both use cases, and you need to take a lot of different things into account on deciding which one to focus your attention on (familiarity, job availability and many other things). As always, it's about the tradeoffs you are willing to make.Keeping that in mind, it would be a safe bet for me to say the a Docker alternative in the future won't be developed in C#, and the some big business application won't be developed in Go.Another thing I want to add: The decision to learn a language doesn't need to be an 'OR' decision. Learn both, and use the one that fits your requirements best.
Coming from a lot of python knowledge, including deep language junk draw trickery and being able to do all sorts of interesting tricks with it… and having looked into go to do a bunch of things where Go is basically the only supported language (kubernetes operators and some other niche stuff like that) … and now diving into .Net 6 with c# for a few new projects after some past experiments with Unity.c# all the way…Go is like hunt and peck typing with my nose while I’m strapped into a strait jacket. It’sdeliberately designedto make it hard to be clever, hard to deepen your knowledge, and for me this makes it hard for me to be efficient… Other than small edits of other peoples code I have never once found Go enjoyable. It’s intuitive to a fault because it’s so minimal and restrained. Like a set of Duplo blocks compared to a set of Lego blocks. It’s really hard to convey this feeling of mental abrasion I have while using it… if I’m not fixing/extending something else where there’s likely only one good way to do something and I’m not in a position to change anything outside the little bit I’m working with… every time I use Go I am constantly ignoring the part of my brain that sees how inefficient this language is formy timeI have to sit there typing out so much god damn useless shitty boilerplate that every other language gives you tools to avoid by way of better syntax, syntactic sugar for more advanced patterns, tools for polymorphism and meta programming and all the other things go rejects… hell until very recently it didn’t have generics (I haven’t been forced back to using it since this so maybe it’s slightly better now)C# has a powerful type system, good enough and growing ecosystem of language level packages to empower you to work well. But it does have one big negative, it’s rather IDE dependent, and the package/module/import system is very “implicit” as opposed to the explicit Pythonic way of doing things. So it takes a while to get used to (still doesn’t feel right but my brain no longer bristles at the sight of it anymore) how everything is imported an entire package or module at once and the compiler just takes care of optimising out unused stuff. It also makes it harder to read peoples code samples which cycles back to how much you have to learn to let the IDE do the work, because it’s often the only antidote to tersely referenced object names that have been pulled in from a large package namespace. I’ve gotten rather used to just asking JetBrains Rider to add the necessary using statements.For all the downsides C# doesn’t feel like sandpapering my brain while using it, it’s more employable, .Net 6 is a real boom time for new open source code as they have finally unified the weird .Net Framework vs .Net Core mess, it’s one target and everything lives here now. And Microsoft are supporting cool new technology like gRPC/Web and Blazor which might get us back to the days where you could just design a UI around a push/pull function call model and deploy to desktops which could perform RPC via the LAN to the back office server. Exciting times!
Agreed on all the points.Re: IDE, I see this as an advantage. As a lifelong user of editors (emacs, Sublime Text, VS Code) other than checking some IDE out here and there, I've committed to using an IDE (Rider) for the first time while working with C#. When the platform and the language you are using allows good IDE support (static typing and friends), the experience is leaps and bounds ahead of using an editor in a dynamically typed languages.I was also using all kinds of meta programming magic to bend Python to my will, so an IDE had nothing more to offer.I'm also employing the same ideas with C#, but this time they are encapsulated to a few input/output locations and supplemented by design-time code generation where possible, resulting in nearly everything is type safe. Now Rider can work as a partner, instead of being a hindrance.Always embrace the powers of the platform you are using. If it's a statically typed language, learn to work with the IDE, don't fight with it.
> Always embrace the powers of the platform you are using. If it's a statically typed language, learn to work with the IDE, don't fight with it.Very much agree! For me as a big fan of IDEs for all my work, my biggest adjustments have been learning all the .Net specific things, how to do them in the otherwise familiar JetBrains Rider (I use PyCharm for my python work), and a slow acceptance that while there are ways to "work more explicitly" (fully specifying names and not touching the "using statements") the IDE does indeed have all the power it needs to understand what I cant see because of the powerful type system and all the .Net machinery under the hood that I don't yet know to the level of my deep python knowledge.
Yes. C# is an excellent language, and it has frequent updates that make it more concise and flexible (as well as improving the type system).The ecosystem is mature and there tends to be a C# version of every SDK.It's very refreshing to use a modern language without spending much (or any!) time searching through hundreds of libraries and trying to pick the not-dead ones.I currently have a large, mature C# code base that has about 12 dependencies. I have a Node code base in the same domain that has 78, and I spent hours selecting many of them.
It's all about what you're interested in. If that's gaming or app development, C# is a fine language.Just don't be a "language guy", my love for C# has kinda boxed me into a lot of enterprise software roles, particularly in desktop legacy and Cloud ERP. If that's what you want, more power to you.People here love to rip on Java for a myriad of reasons, the ecosystem, boring enterprise roles. Well, Microsoft Java isn't too far out of that realm, don't let LINQ and fancy lambdas seduce you into thinking otherwise.When you look at ugly old enterprise legacy code, it doesn't really matter what C-like language it's written in.I know this wasn't asked, but last to say is, companies value employers who have a really good understanding of their products internal details and infrastructure. That's something you can't learn in a book or at school. They absolutely do not care about skills in these languages beyond expected competence. It certainly doesn't hurt, but there are a million other C# programmers who know advanced programming language features.
> Just don't be a "language guy", my love for C# has kinda boxed me into a lot of enterprise software roles, particularly in desktop legacy and Cloud ERP.I'm in a similar situation. I love the language but I hate overall community and environment being all about Microsoft in most cases. It's really hard to get out too since most people will see you as the 'MS .NET guy'. There aren't that many companies that want generalists and good devs, most will look at you through the prism of being '.NET Developer' and having '.NET experience', not just 'developer' and 'experience'. It's a pain point of mine, even though I quite like .NET overall and productivity it comes with.
> There aren't that many companies that want generalists and good devsThat's the brutal honesty, but to be fair it's on us to distinguish ourselves. It's weird, I used to look forward to development in the real world because I wouldn't have to use all the "useless crap" I was forced to learn in College. Now that I finally see the practicality, I can't ever using it without a lengthy debate. The amount of a CS degree that's actually needed to do these jobs is ridiculous. I used to think bootcamps were a joke, but if I had to guess there's a lot more hungry devs out of there that blow grads out the water. While I grumblingly retire to my office chair like Richard Nixon.> It's really hard to get out too since most people will see you as the 'MS .NET 
guy'.Idk if this is regular job hunting behavior, but I get messages on LinkedIn for almost nothing but recruiters telling me about some DoD secret clearance .NET job, they never reveal the company unless you ask which I find weird, and then I shortly find out it's a .NET legacy job with pre generic C# and Visual Fucking Basic. Maybe I take myself far too seriously, but I can't help and feel offended when I get offers like that.The only time recruiters contact me for something outside .NET, it's for C++ embedded systems, which does sound more interesting, but I found the embedded world stressful a lot, to be fair it was my first job so I dont really know.
The enterprise culture is why I left. C# + Visual Studio remains the most productive combo I’ve worked with, though. I just can’t see myself going back, due to the culture. Also, I’m a VIM and Linux guy now, and hope to never run Windows again. .NET was not a first class experience in VIM the last time I tried.
Did you find work in Software Development for Unix?In university, I was the other way around, when I got out I said "time to roll up your sleeves and stop using printf to debug things, VS is where things get done".Little did I realize I'd transition from a chipper, curious regex piper into a jaded highly productive custodian.
I became a web developer, basically. Doing web apps, web services, etc in Ruby, Node, and Go. It was a pretty easy transition. If you know and love programming in C#, my guess is you can pick up just about anything in a short amount of time.
What about web services and REST APIs?
Anything popular like that you're gonna find good support available on .NET, that goes for any corporate backed language ecosystem. I think that's why Node has a reputation for being a mess in terms of reliability, there's just so much sub par crap with no company to be responsible for. .NET has a package community as well, , but on average, the stuff in there is just....better lol.But again, nothing about these languages are distinct or remarkable enough to make career changes, the bigger picture here.
Yes because if there is one thing about it is it's easy to pickup and be productive. So you're investing a little time for a lot of gain.An advantage is it's not opinionated on how you should write your code. Which means there isn't the one true way of doing things you need to learn either. It's not like lisp, or rust with it's borrow checker, or C with it's pit traps for the noob. Or C++ where more people understand quantum mechanics than know all it's features.Most of the things you might want to do there are documents and examples how. And unlike other languages those are usually solid. Microsoft have built a vast and curated library for many many things like import and manipulate an excel file.
> Which means there isn't the one true way of doing things you need to learn either.A nitpick/disagree here. While it’s true that both C# and the framework are pretty lax about things, there’s definitely a “right” way of doing things as recommended by Microsoft. Following that guidance means it’s easier to hop between .NET codebases
Yes. C# is the best OO programming language with good support for functional and procedural programming paradigms. For business applications, it is the best programming language that can be used in both frontend/GUI (MAUI) and backend.
