It doesn’t deserve nearly as much hate as it gets, it’s actually quite good, particularly when you add TypeScript.
You get a nice mix of functional programming and imperative programming. And a lot of the new syntax is very succinct and clean, like the spread operator.
NPM is a fantastic package manager. It has warts here and there and yes, you need to be careful to not pull in a dependency that could get hijacked by someone else. But the CLI for NPM is very intuitive and easy.
I see JavaScript as a language for artists. Most languages require a lot of setup work before you can get anything done. Types, classes, etc... those concepts just make the language more rigid, less fluid. I want to declare a variable now and decide later what it’s going to be. I want to see a rectangle bounce around on a page, not worry about importing the right interface or extend a class so that I can apply the correct method to bla bla bla. If I screwed up, I want to find out through a button that I can’t click, not by some compiler that fails because I don’t have the right interface for whatever object.
JavaScript lets youexperienceyour code with very little friction, in a very forgiving environment (the browser). I have a theory about why English has become the most ubiquitous language, historical factors aside. As far as I know, English is the most breakable and forgiving language. You can destroy the grammar, word order, pronunciation... and still make yourself understood. JavaScript is similar - you can write code that is suboptimal, terrible from a technical point of view, and still get the job done. It’s a democratic, gateway language.
Given all this freedom, when you see a piece of well-written JavaScript code it’s like looking at what Picasso could do with crayons. Anyone can pick up a crayon, but a skilled artist uses it to make something beautiful. As a developer, I appreciate the freedom that JavaScript gives me, but strive to write better, cleaner, more expressive and more inspiring code every time.
As a C/C++ programmer, I like JavaScript quite a lot. First of all, kudos to Mr.Brendan Eichfor the ingenious idea. JS is very flexible and very productive, but it still has some legacy dark corners, since it grew to do things never imagined by its creator. So, as a language, I really enjoy writing JS.
TypeScript is even better, addressing many JS issues.
What I absolutelyhateabout JS is the clunky hellish paraphernalia needed to build applications these days. Compilers to translate JavaScript into JavaScript, millions of dependencies, and the lack of a decent way to develop and deploy proper native applications (Electron? come on...).
And, being such a popular language, there's the side-effect of attracting subpar programmers, script kiddies with zero theory knowledge who regurgitate crappy code (I'm not being pedant, recently I had to fix some horrible things, so I'm pissed).
In the end, JavaScript is a great and serious language, with "great flexibility" as the greatest quality, and "great flexibility" as the worst downside. I just desire a better native support, I really hope it doesn't go Java way (yuck!).
I love it because it's syntax, keywords, and functionalitymostlyseem sensible. It was the second language I learned to use, after Perl, but the first I felt like I could understand almost all of (at the time, around 14-ish years ago) without the need to learn the most complex parts (C family, Java, others with user-facing compilers, need for good memory/data management, etc).
I was stuck with old books and no internet for a long while, so I was stunted in my learning until recent years when I discovered NodeJS/Electron and learned about callbacks, promises, and async/await all at once (along with other new things like web workers), lol. Still don't fully understand them; I particularly hate the callback style even with very minimal nesting, but promises are no easier and async/await in turn has given me more headaches than usefulness.
I've tried to use and sometimes even used many other languages from time to time including PHP/ASP, Python 2 & 3, Basic/QBasic/VB, Java/JavaFX, C, C++, VC++, C#, Swift, x86 or 88 Assembly, Lisp, Pascal + the other that uses it as a base, and more I'm forgetting + the Simpletron project (assembly interpreter, programming language compiler/linker). Now that NodeJS exists I would not choose any of these for anything, because I probably know better how to use JS than all of them combined at this point ("hello world" in many, basically). I guess I really tried most just so I can kind-of understand most human-friendly code I could possibly read, except non-Simpletron assembly. That and I have no life.
This is a really interesting question. I used to really love JavaScript earlier in my career. As time has past, I find myself enjoying it less than I used to.
That doesn't mean that there's anything wrong with the language, of course. Just that as my career has progressed, the kinds of problems I have to solve have changed.
I used to be totally, 100% in the dynamic typing camp. I took the time to learn and understand things like OCaml and Haskell, and I still preferred JS, Ruby, and Python.
But over time, I tried to develop the ability to take on larger and larger projects. And the larger the projects I worked on became, the less fun it became to discover errors at runtime. Unit and integration tests help, of course, but they don't catch everything. When I'm working on business critical code that will cost the company a metric ton of money if it breaks, I want to make my languages and their tooling eliminate as many errors as possible before the code even runs.
I know languages like Java and C# can feel ham-fisted and annoying - although they're a lot better than they used to be. And yes, OCaml and Haskell let me write safer code than I could in C# or Java, while still being as concise as what I could write in JS. But the tooling around Java and C# is nice - realyl nice. Using Java and IntelliJ or C#, VS, and ReSharper feels kind of like pair programming with a psychic. And I appreciate the way these tools extend my reach. I routinely work on projects that contain hundreds of thousands of lines of code. Sometimes, I'll do several hours worth of refactoring, touching dozens of files. And most of the time, when i click run, everything just works.
I guess this circles back around to none of this being JavaScript's fault. I really enjoy writing it, and Iwantit to be the right solution to problems it just isn't the right solution to, and I like it less than I used to as a result.
Sorry for the stream-of-consciousness ramble. But since you asked for a complete and honest opinion as well as a comparison with other languages, I figured I'd do my best to answer.
TL;DR:
I like JS but it is no longer the best solution to all of the problems I need to solve.
A language created quickly for one purpose a long time ago, that has been used since for purposes it was never meant for, resulting in legacy cruft, fragmented runtimes that all support different things, constant sharp edges and pitfalls to make development more difficult, and an ecosystem that is a jungle of dependencies and different tools that reimplement the same things in different ways, all making their own mistakes.
Pick a toolchain that often isn't JavaScript but compiles to it and run with it, but be prepared to rewrite most of it in case you picked the wrong one that the community abandoned after a couple of years.
I really don't like JavaScript, and I really don't like the entire frontend world, but I need to know it since it's the only thing we currently have for browsers. Modern ES and languages on top of JS have made it more bearable, but setting up and maintaining the brittle stacks and toolchains when the ecosystem is in a state of constant flux is not fun.
Some things I wish the language had builtin:
Strong typing
Type annotations
Proper immutability (can useObject.freeze()for now though)
Combinenullandundefined
Symbols that work withObject.keys()andinchecks
I enjoy it. The lack of static typing overhead and relatively easy setup (coming from a game development career) make it a much easier and expressive language than many others I have used. I also enjoy it’s high speed of improvement and experimentation, in spite of the frustrations that often brings about. The ease with which it allows functional style, combined with that style’s relative popularity in JS (as opposed to other popular languages) means that I was able to learn and regularly use the style that, while possible in other languages, is often less practical for various reasons.
I look forward to the day when we get finished with the transition to es modules and a build system that supports all variations of needs (so far, I’ve used browserify, rollup, and webpack, and none of them can do everything I want to achieve with package management).
A way to manage nested dependencies in a secure and automated way would be nice. So I can lock down the source code of my dependencies’ dependencies in a way that prevents the possibility of them disappearing or changing out from under my code.
I dislike the push for more and more OOP syntactic sugar that clutters the language and doesn’t appear to add meaningful functionality.
30+ years in the software development biz.
I've used cobol, fortran, perl, C, C++, python, php, sql, various dialects of shell scripting, java, yada, yada, yada.
Javascript is like anything else—once you grok its idiosyncrasies, it's fine. Every language has something to whine about.
Typescript makes it good and man I can deploy an app to literally everything I own so yeah that's cool. I even have a microprocessor that supports node.
I find JS beautiful. I've coded my share in PHP and it just never grew on me the way JS did. Neither did C when we were coding it in HS for example. I'm also more of a front-end dev, so there's not much besides using JS for me, but I like that I can create back-ends with it and also games with canvas, that's a nice touch. I'm mainly a Vue.js dev (although I'm a Node.js dev at work but I'll never consider myself a BE developer) and I like how I can play during coding. It just makes everything fun and awesome. I miss the days when I was employed to develop apps with Vue.
A lot of people think their lack of knowledge in a subject matter is actually a limitation of a library, framework, etc
It does extend to the tech stack in general, dbs, protocols."Ah, we made a mess out of the last project where we used X,Y,Z, the new project will be on A,B,C. It's surely not our shallow commitment to acquiring knowledge and maintaining quality that bite us."
I wish we’d focus more on toolkits than frameworks, and kept build steps optional if possible.
I like being able to understand the process involved in a web page without having to fully understand the frameworks involved first. Being able to at least start learning with an html file, a css file, and a js file, and not a ton of ancient insecure npm packages is so nice.
I don't know how unpopular this may be in the real world, but it sure is on this subreddit: JS, CSS, Browsers and frameworks are all in the best state they've ever been, and it's a joy to work with them
Learning a 2 weeks udemy react course doesn't make you a web dev at all.
Now that will offen 80% of the sub lol
PHP is still totally relevant.
It has been my main source of income for 10+ years.
I use my own CMS, Flight or build sites myself. I don't use WordPress, Drupal or any other well-known CMS.
React has hit a dead end, and in 5 years we're gonna think about it the same way we think about jQuery today. Doesn't mean it's not capable of making perfectly nice websites, but it is no longer the direction the web is heading.
I think people are a tiny bit too high on this take personally. I agree, I just think the timeline will be a little longer, seeing all the other frameworks have their own growing pains at the moment- there’s really not a clear better choice right now in terms of talent and ecosystem. The quality of libraries is still so much higher than the next closest.
That could change but the buy-in for react is much higher than jquery imo. You have a very large majority of devs who literally call themselves “React developers”. And bootcamps that all they did was push React down people’s throat at all costs.
Front-end moves faster than any other tech but I’ll be shocked if we actually consider React like we do jquery right now in 5 years.
The thing is... what is React? VDOM diffing might be going out of fashion, but the component based model, JSX syntax, suspense/deferred rendering, are all here to stay. Funnily enough, React's reactivity model, the thing that got uni-directional data flow going in all of these frameworks, is the part least likely to survive as-is.
So no, React did not hit a dead end. Every framework just remixed the good features of React, while experimenting, or replacing, others. Of course, React itself did the same to frameworks that predate it, and will likely borrow signals from newer frameworks in the future.
If there's a shift in the industry, it's towards framework inter-op, which is only possible because of how fundamentally similar all of the major frameworks are becoming.
"There are only two kinds of programming languages: the ones people complain about and the ones nobody uses."
Bjarne Stroustrup, inventor of C++
That’s perfect lol
JavaScript certainly has some negatives, however, it's not as bad as people make it out to be.
Most complaints around the language has to do with people trying to do things that you're really shouldn't do in real code anyways. For example, you'll find people laughing how an array plus an array is an empty string. It's silly, it makes no sense, and it's an artifact of how the language was originally designed. These kinds of things are fun to laugh at, but in reality, there's not really an issue. You quickly learn that, in JavaScript, you shouldn't ever try to add arrays together, it's just a nonesense thing to do to begin with. If you want to combine two arrays together, you just use the.concat()function or spread syntax and move on. No biggie.
There are other issues that JavaScript has that aren't ideal but we've come up with various band-aids for them to make them less bad. Hate how JavaScript does type casting? Maybe look into TypeScript, so you get early type errors instead. Hate how accidentally leaving a semicolon out might cause code to silently break? Use a linter. To reiterate, these are all band-aids, they're not perfect, and have their own flaws, but they do the job.
So, people coming from Java or whatever will try to use JavaScript, and bump into these various oddities that just rub them wrong. And they're not wrong. But, if you keep at it a bit, you'll learn about different tools, techniques, and patterns you can use to get around most of JavaScript's issues. JavaScript also has some really, really nice features that I miss every time I work in a different language - here's a few I love.
JavaScript's first class functions and built-in higher order functions are awesome. They enable various patterns that are more complicated or impossible in other languages. For example, to square every element in an array, I just doarray.map(x => x ** 2). In Java, you have to convert the array to a stream, then map, then convert it back, which is extremely verbose. In Python, you can do the same thing, but you're limited to one-liner functions (due to how they give semantic meaning to indentation, and various limitations associated with that).
JavaScript also provides various other syntax features, like destructuring, that allows you to condense a lot of repetitive logic into a small chunk of syntax. In general, I find that it takes maybe half as much code to write something in JavaScript, as it would take to write the same thing in another language like Java, which really helps with readability. (though take that measurement lightly - "half as much" means a smaller line count and less verbose logic, it doesn't mean simpler logic)
I absolutely love JavaScript's asynchronous model and it's event loop. It takes some time to get used to, but once you do, you'll find how powerful it really is - it is extremely easy to write asynchronous-ready code in JavaScript. In other languages, asynchronous programming tends to be an after-though, rather than a core feature of the language, and as a consequence, many libraries, often including the standard library itself aren't asynchronous friendly, which makes it really difficult to write full async-friendly programs - sometimes it's pretty much impossible unless you employ some really ugly hacks (I recall in Python, making synchronous code into asynchronous code by basically starting a new Python process to run a particular function, I really didn't have another choice, since the library being used wasn't async friendly, and we needed it to be).
If you ever decide to learn TypeScript, that is, by far, my favorite type engine I've ever seen. Sure, it could be better if runtime checks were also being done to assert that the types were accurate, but in general, I've never seen a type engine as powerful and flexible as TypeScript. This enables you to use many more coding patterns in a type-safe way, than would otherwise be possible. For example, they have a whole lot of ways to transform one type to another, or extract information from a type, etc, all using fairly simple syntax.
I love JavaScript. I love it because all browsers can run it. I love it because it integrates so well with CSS and HTML.  I love how you can whip up anything you can think of in Codepen and share it.
Sure, there are some weird things about it (which typescript mostly fixes btw), but no other language is so universally present in web development.
For an example, here’s a platforming game concept that I wrote in a few hours this week:https://codepen.io/MorningPants/pen/XWPBWMG
Can I ask how you've decided that JavaScript is the best tool for the project then?
Linear logic?
Does linear logic mean programming where flows are not implicitly split?
The above example violates linear logic, because the input x flows to two outputs without an explicit copying operation. Linear logic, if I understand correctly what it is, would require that every variable have exactly two references, one where it is set and the other where it is read. JS provides no way to enforce such a constraint.
Positives of JS
Javascript supports reactive programming, which is to say solutions that meet soft realtime requirements, with a non-preempting (or cooperative) approach. The support for this includes an opinionated notation (await, Promise,for await) and an alternative that allows more freedom and control (generator functions). So you can take your pick.
Javascript supports, but does not require object-oriented programming. Methods are supported, but so are plain "functions" (imperative procedures) and they do not have to be used as methods; they can be called directly. As in the Self language, inheritance is from object to object and classes are not necessary.
Closures are supported.
Javascript has straightforward syntax.
Javascript has dynamic typing.
Let people who don't like it say what they don't like about it.
The standards writers have carefully curated the evolution of the language so as to put a priority on not breaking existing code. The initial standard left room for adding features (e. g.classwas a reserved word before there was a feature that used it), and features have been added quite conservatively. JS primitives do what is needed or very useful and not much more.
Although Javascript does not enforce referential transparency, it does not stand in the way of a style of programming that would stick to it.
And yes, destructuring syntax is cool and saves on code size.
JavaScript is an incredibly elegant little language built on a very few principles which it adheres to rigidly. It is let down by a few slightly cranky APIs, such as sort, but the bones of the thing are lovely.
Everything is an object, even functions. This lets us pass functions around freely, store them in arrays, call them later, it's really quite lovely.
All objects are sugary hashmaps. You can store any data in an object. The dot syntax is sugar for hashmap access by string. Arrays are objects with numbers for keys. Even functions are hashmaps. Even numbers can be hashmaps if you want them to be, although you seldom will need this. This makes it exceptionally good at representing trees of data, which is what you want when you're dealing with the DOM.
Classes are optional. Inheritance is prototypical, directly from object to object, and can be configured at runtime.
Every function has a closure scope that comes into existence when it is created. This means you can pass functions about and still have access to all the variables that were in scope when it was first declared. Asynchronous coding becomes trivial.
There are warts. A lot of the purity has been obscured by some of the newer ES6 features. These are great if you understand them, but they make life harder for new coders. The legacy APIs are inconsistent. I mentioned sort. Splice is another odd one which doesn't work in the way you would expect.
Overall though, it's a lovely thing, incredibly flexible with very few rules, supporting OOP and functional coding alike. Learn it, you'll like it.
At some point any was or will be done in JavaScript
JavaScript is the de-facto language of the web and comes with a large ecosystem of tooling, that no other language really compares to. There's a buzzing community of open-source and corporate-backed frameworks for all kinds of use-cases and preferences.
It's independant of any hardware. Build once, run anywhere (as long as there's a browser). No matter how much JS-devs complain about Safari, browser support of JS is pretty great nowadays.
It's also not opinionated. Want to build object-oriented code? Use classes. Want to build functional code? Use functions.
It's also way less verbose than other languages.
But this flexibility and eco-system is also its downside. Jack-of-all-trades, master of none. For any use case outside of "has to run in a browser", you probably find a better language. But you won't find any other language that can be used in as many contexts. The eco-system contains many pitfalls to fall into.
There are lots of weird quirks in JavaScript that will make you facepalm, if you encounter them. But during everyday work, these cases are mostly irrelevant.
What I'm missing most is built-in type-based function overloading. Even TypeScript cannot provide this properly.
I'm building full-stack applications at work and a mobile app on the side for fun. I use JS (TS actually) for everything. You cannot say the same for many other languages.
I will always bet on JS (TS).
On July 1st, achange to Reddit's API pricingwill come into effect.Several developersof commercial third-party apps have announced that this change will compel them to shut down their apps. At leastone accessibility-focused non-commercial third party appwill continue to be available free of charge.
If you want to express your strong disagreement with the API pricing change or with Reddit's response to the backlash, you may want to consider the following options:
Limiting your involvement with Reddit, or
Temporarily refraining from using Reddit
Cancelling your subscription of Reddit Premium
as a way to voice your protest.
I am a bot, and this action was performed automatically. Pleasecontact the moderators of this subredditif you have any questions or concerns.
literally anyone can write JavaScript.
it requires reasonable experience to write good JavaScript.
Most people end up writing terrible JavaScript because it's forgiving.
So you have a LOT of terrible code in existence.
Also it changes too fast, which leaves many versions of the code sitting and upgrading cost money.
Soo, all in all, I Believe it's the sheer amount of poor code gives it a bad rep, . Writing terrible code is possible as JS is super forgiving.
Anyway. I am no body so this comment is literally useless.
You're a somebody, don't let anyone tell you different
Anyway. I am no body so this comment is literally useless.
I mean, the legendary cyclops Polyphemus in the Odyssey was defeated by Nobody, so...
The fact that there's so much variance in code quality and versions makes it so hard to self learn. Python Ive seen lots of people pick up and write reasonably readable code. I can't tell you how many different JS repos I've gone into and each time I felt like I didn't understand JS at all.
Frameworks also make this worse. They increase the rate of change to the landscape and can really mess with how JS is learned if introduced too early.
Because Eminen Hasn't made a beat about it!
Because there aren't many rhyming words for javascript
So there are several big reasons why JavaScript is disliked by a large portion of programmers.
1: Dynamic Typing combined with automatic type corescion. This extreme type corescion is why JavaScript has the===operator, among other things, and this feature alone leads to many surprising and unexpected behaviors.
2: Performance concerns: while modern JavaScript engines have gotten pretty performance lately, there's still the issue that different browsers can have different performance characteristics.
Another example of JavaScript not being good for writing performance conscious code is the lack of language level super for basic array types. Because every object is essentially a dictionary with heterogeneous keys, this makes writing fast code harder, because you must be super careful about how you write an object you want to be an array.
Most JavaScript engines have optimizations for the case where you use an object as an array, but there's nothing preventing you from changing it in such a way that the engine can no longer run the fast path while your code is running. This can tank performance while being really difficult to track down.
3: type related gotchas, like typeof and instance of having some odd behavior you must be aware of (example beingtypeof nullisobject, need to use instanceof onArraybecause it's not a primitive type."hello" instanceof Stringisfalse...)
JavaScript just has a lot more of these sort of oddities than most languages.
4: there is no integer type. Fucking really? I shouldn't have to explain why this is a bad idea.
5: null != undefined, and you can redefine undefined.
6: poor scoping rules, and global variables.
7: callback hell.
8:https://wtfjs.com/in its entirety.
JS was not built for what we use it for.
JavaScript has some terrible design decisions which would be mostly fine in a language used sparingly. If we were still writing js like the late 90s or early 2000s where it was used mostly just to make pages slightly interactive, then it wouldn't be such a problem. Instead we have webpages which rely on 10s of thousands of minified lines of JS just to function at all.
We should all agree to collectively dump JavaScript and move on toliterally anything else.
Addendum:
JS is still a capable language, and it can be easy to also stuff together and make things work. The vast majority of the issues I've outlined here don't become serious problems until you are working on large scale software. An example would be frameworks like React.
JavaScript is simply easier to make mistakes in than many languages, and when you do make a mistake, it can be harder to track down. This is the single biggest issue of the language, as it's what most of the individual things I've pointed out above lead to in aggregate.
It's still possible to write large scale, performant code in JavaScript. It's just harder than in many other languages. JS is popular mostly because it's the defacto standard for websites, and sadly everyone seems to be obsessed with writing anything and everything as a website, even applications which absolutely should not be.
Type errors… oh god the horror… debugging other people’s poorly formatted and “unconventional” code… debugging in JavaScript is akin to getting mentally waterboarded for hours straight, or climbing Mount Everest in a wheelchair. Then when you “fix” the problem, 10 other bugs will appear like a new foe in the Smash Bros series. And just like in SSBU, if you don’t win, you gotta start all over again from the beginning. A vicious cycle of pain and misery…
Anyways. This is why I switched to Typescript—permanently—when starting any web applications of my own. Makes it easier for others to read, and easier for your future self as well. It’s not even that much different; it’s still JavaScript, but now you have the option of specifying type when declaring a variable, among other ideal features that make the dev experience more optimal.
You made a good case and I understand that since most things are on the web today, working with JS makes functional sense. I still would start on another language first.
Ok so I’m going to try to answer this in a way that I hope doesn’t prompt a ton of hate, though that may be wishful thinking on my part.
Your instinct not to start with JS is correct. JS is above all else a language that evolved without strong intrinsic organization and top down direction so it’s hard to ground yourself. Main OO languages were designed to handle and structure complex, modular code bases. They were created to fill a need for scalable, modular, moderately fool-proof industrial languages not adequately served by the powerful but accident-prone c++ and the idiot-proof to the point of bad behavior tendencies of VB6. As such, they come with mandatory structure and clear concepts for things like classes, instances, methods, types and have strong opinions on things like memory management and safe typing. That’s a good, clear place to learn to code and ground yourself on what you’re trying to do and what you’re looking at.
JS by contrast was a command scripting language (like powershell or bash) that happened to be inconsistently supported by browsers for DOM manipulation and forms work. Because platforms did not interop well, fat client development was tough to single team and solutions like flash, activex, and applets had significant holes. JS became the default choice and in tour-de-force desperation, some excellent groups of developers grafted frameworks and transcoders onto it to give it optimized, standard DOM manipulation (see JQuery), scalable patterns (see Angular, React), a standard library, and type safety (TypeScript). In parallel, Google added in a real JS compiler in chrome and a stand-alone JS server project with hosting libraries (NodeJS) and suddenly JS had the power to perform at scale as a full language. However, all that is still optional and JS still has a lot of concepts that can be expressed as a function or using functional block shorthand or that let you just skip over flow control and type conversion. And that makes learning JS first hard. If you come to JS from OO and know what good looks like, you can read the pattern documentation in a stack and look for equivalents of what you expect to be there. If you don’t, it’s a bad place to start because you can write the sort of shit code that almost brought down core Facebook before they mandated the flow pattern and Typescript internally and it will work just fine.
Basically, JS is a completely legit language for a lot of work but don’t start there.
By default, it is dependent on the web stack and the HTML/CSS markup languages, so you need to depend on a browser to learn how to code in it. I would rather start out with something that is local and independent from the cloud.
That's both its strength and weakness. It's a client-side language. Which means it can run in a browser without program needing your own backend that's constantly listening. So that's why it's popular. Any other language, say - Go for example - you'd need server to actually run your program 24/7, listen and manage forth-and-back between front- and backend. Which means you either host a server yourself, or rent one that actually supports it. So you couldn't rent some random website space from typical web hosting, upload files and just get your stuff to run on it out of the box. You'd need dedicated server or cloud like AWS.
With JS, you can. And with Node or whatever you can work on backend part as well, if desired, use terminal and more classic ways. And since much of everything runs on web nowadays, JS is popular choice. Also, much of the mobile world runs on JS. But I wouldn't choose JS to develop desktop apps as first choice, anyway.
As for other benefit... just see job openings.
do i not know how much i know?  do you know how to use chatgpt?
you don't even get a comparison for breadth of use.  C / C++ maybe.  Java maybe.  languages are compiled into javascript much like C/C++ used to be.  javascript made the PHP3=>PHP5 shift and then it also accommodated every other functional programming person and java developer with an opinion.  that's crazy.  you can write infrastructure in javascript.  there was a space satellite written in javascript and that was almost ten years ago.
many newer cloud services are written in Node.js first.  if you took a slice of it, I'd suggest 20% are Python first (especially in AI / ML), 30% are written in Go, 40% are JavaScript and 10% in Java.
node.js and linters and typescript are the other answers
I have used many languages in my nearly 40 years as a programmer (Scheme, C++, Java, Python, Haskell, OCaml, Rust, etc.) and still enjoy JavaScript: It’s decent as a language and there is so much you can do with it.Tips:• If you like static typing, you’ll want to use TypeScript. It’s more work to set up, but it catches many bugs, especially subtle ones where JavaScript’s semantics are not intuitive.• I learned a lot about JavaScript (and Node.js) by writing shell scripts in Node.js.My books on JavaScript, TypeScript and Node.js shell scripting are free to read online and target people who already know how to program:https://exploringjs.com
> If you like static typing, you’ll want to use TypeScript. It’s more work to set up, but it catches many bugs, especially subtle ones where JavaScript’s semantics are not intuitive.It’s worth looking at JSDoc as an alternative to regular TypeScript. No compiler to set up, and you’re restricted in a good way - less likely to get over-engineered types.
I find writing it too hard compared to TS, but in terms of functionality it's pretty good.
How does your book Deep Javascript compared to You Don't Know Javascript? I just finished a Eloquent Javascript and looking for something advanced.
>  I learned a lot about JavaScript (and Node.js) by writing shell scripts in Node.js.Totally! This will give you lot of insights into low-level working of JS. Of course, some Node.js specifics too. Reading from STDIN, parsing strings into structured data etc.
For writing shell scripts in Node, there’s a helper library called zx created by Google.I find it a lifesaver for the common occasion when I’m tempted to write a bash script but also know it’s going to need some slightly more advanced features (as in parsing a JSON, or just arrays that are not totally bonkers in syntax).
Yes, I was about to propose this. But then again, the author wants to learn the basics without grappling with abstractions. I think zx can be a bit quirky.
For sure there's an element of magic to zx. The use of tagged template literals doesn't look like plain JavaScript even though it's standard.You need to understand async/wait, promises and tag functions to make sense of this basic zx example:await $`ls -la`
I did a lot of coding with C++ and ended up moving to 100% JavaScript for our game creation tool Construct (www.construct.net).I'm now a huge fan of JavaScript - I think it's a really underrated language. People often still talk about it like it's 2010. The modern language features are amazing, the performance is incredible - including the GC performance - and it's memory safe and no need to worry about allocations. If you want static typing, use TypeScript, which is also very good and is basically a static type layer over JavaScript.My advice is look at the modern language features which now have wide cross-browser support, and be sure to use them. It can significantly change your coding style for the better. By that I mean things like modules, private class fields, nullish coalescing, optional chaining, async/await, map/set - some of which are fairly old now but are still getting new improvements worth knowing about.
If you have plenty of time, start a side project to build out a HTML canvas library (with no dependencies) ... just kidding! I've been building my canvas library for 11 years and there's still a shedload of JS understanding I've not yet poked.More seriously, the MDN documentation is really useful[1]. Some of the advanced topics listed on that page may be a good place for an experienced engineer to start?- Inheritance and the prototype chain -https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inhe...- Memory management -https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memo...- The event loop -https://developer.mozilla.org/en-US/docs/Web/JavaScript/Even...[1] -https://developer.mozilla.org/en-US/docs/Web/JavaScript
Static types are sanity when the people and years keep increasing. It isn't at all important in small one man projects since most of your defined types are in your head in any case.There is nothing wrong with JavaScript as a language beyond it's, originally questionable, foundations that have since been iterated upon (much like PHP).As a massive fan of static typed languages. There is no denying that dynamic typed languages are more fun to develop with in smaller project. It just they often hit a tipping point when they become a horror to deal with. I can still remember my first legacy Python code based where everything was thrice nested dictionaries.
"It isn't at all important in small one man projects since most of your defined types are in your head in any case."Yes, today. Not in 7 days, let alone 3 months.
And if you are working on multiple projects as a freelancer, the brain capacity it occupies seriously hampers productivity.We are creating software to make people more productive, but when it comes to our own productivity many of us interestingly shy away from using software (types, in this case) to enhance our own.I did this mistake for years. Cost me dearly.
I often hear people say this, but in my opinion, static types save a ton of trial and error and help you out even for a 20 LoC script.
And have great discoverability when fully integrated into an IDE.
I would recommend using Typescript and a strict linter if possible. TS is essentially modern Javascript plus static typing (so by learning TS, you also learn JS as a side effect), and strict linting rules will reject outdated Javascript features and nudge you towards the 'good parts'.With those two things (a static type system layer, and strict linting) JS is actually a quite decent language nowawadays, especially in VSCode (e.g. see:https://code.visualstudio.com/docs/languages/typescript).
I would also recommend Typescript. Anything important you need to know about Javascript, you will end up picking up along the way.My main complaint: the default compiler settings are pretty loose, presumably in the interests of erring on the side of letting Javascript code through by default. I'd recommend going through the available project settings carefully and switching on more of the checks. eslint is also a good idea I think - and a similar comment applies. (I activated pretty much everything, and dialled it back as I found myself getting annoyed by things that felt like poor value for moneey.)
My biggest gripe with Typescript is how much more difficult (Except perhaps in Bun/Deno) it is to set up compared to vanilla JS.
npm install ts-nodets-node ./my-typescript.tsdoesn't seem difficult...
Until you have to deal with Jest for testing, or React.
Even easier than that:npx tsx ./file.ts
JavaScript is flexible and simple in a good sense of the word.There not much advanced to learn.Thanks to single threaded design you basically just write whatever you intend to do and it works.With a proper mix of oop and fp there is no place for “advanced patterns” and other over-engineering diseases in a lean js world.The most terrible and ungly js code ive seen are from former .net and java developers.I suggest you unlearn all the “patterns” and keep it as simple ad possible.
> Do you have any tip for learning js at it's fundamentals?I would recommend:-https://eloquentjavascript.net/-https://javascript.info/
When I needed to learn JS above the 'hack it out' level, Eloquent JavaScript was really great. It really focuses on fundamental constructs and is not tied to any 'framework of the day'.I see there's a 2024 edition that I should probably order.Update: Looks like the 2024 version is going to be released in Nov.
I have been using JS for more than 20 years, and I do not like it. There are parts of it I find useful, but I avoid using it as much as I can in any project.The biggest reason for this being that the execution of JS code it down to the browser rendering the page where it’s deployed. As such it’s practically impossible to get any code to run consistently. This is of course only relevant in my day to day work as a web dev.That aside, JS has some funny behavior. If you wish toninderstand JS better you could read up on how null and undefined works.You could also read up on how functions work, they are objects actually.
> the execution of JS code it down to the browser rendering the page where it’s deployed. As such it’s practically impossible to get any code to run consistentlyCan you elaborate on this part? 
I would say one of the strengths of JS is that you can get it to run consistently just about anywhere.
Certainly! Now, I’m no expert and may get some things wrong here, if anyone else knows better I’d be happy to be corrected.Every browser implements a version of ECMAScript (this is a specification declaring what features of the JS language will be available for the JS engine included with the browser).This means that every browser on the planet, and every version of them, support different JS features.For example, let and const are commonly used to define variables, but if someone happens to use an old browser version the use of these would cause an error, which in turn may cause all the rest of JS code to stop executing, resulting in (worst case scenario) your website being rendered useless to that particular person.On top of that different browsers may use different engines. So even if they define the same ES version the code may still execute differently (this was for example a very big issue with Microsoft browsers in the past).This may seem trivial, but new JS features emerge all the time. Granted, this was a much bigger problem before ~2015 something, but it’s by no means none existent today.Thus, you cannot be sure the code you write locally will actually function the same everywhere, and you are unlikely to know how often failures even occur since it all happens client side.
I think with the official deprecation of IE this is mostly a thing of the past since all major browsers are “evergreen” and support a pretty recent standard. This certainly was the case only a couple of years ago, and it’s almost always wise to have a bundler (e.g webpack) that can target a fixed standard as output via transpilation/polyfill just in case you are itching to use the experimental features.
There is a functional core in js, and as such it might be an idea to take a look at common OOP design patterns and how they translate to an FP approach.This is Clojure based, but there is a lot of similarity to js once you get past the syntax:https://mishadoff.com/blog/clojure-design-patterns/
There's JavaScript The Good Parts by Douglas Crockford.I've read the book and watched a similar series on YouTube.
Second this recommendation. There's been a lot of changes to JS recently, but it's still worth reading The Good Parts because I think it's philosophically a good way to approach JavaScript. It can be a good language if you know which parts to avoid, and which quirks to look out for.There's alsohttps://github.com/getify/You-Dont-Know-JSas a good follow-up to The Good Parts.
This book was excellent for the time, but is now quite outdated. Stuff like how he proposes modules is completely irrelevant with ES modules, arrow functions make ‘this’ much easier, and we have block scoped bindings
Seconded. I won't recommend it and no one I know has recommended it for a decade. It's hard for someone who doesn't know JS to know which parts has changed and is no longer the way to do things.https://github.com/getify/You-Dont-Know-JSandhttps://eloquentjavascript.net/are the 2 best source for learning JS.If you don't have time to read both, just go withhttps://eloquentjavascript.net/If one needs to go further, go throughhttp://superherojs.com/, just ignore links that are dead.
He did a marvellous and very entertaining lecture series on JS:https://m.youtube.com/watch?v=JxAXlJEmNMg
Been coding for 30+ years. In the last 5 years I have come around to not hating JavaScript (TypeScript really), but let's be honest, it took 15 years of hearing the JS community tell us "sure JavaScript used to be awful, but now it's finally good" for it to actually be true.I remember clearly the days of callback hell. You didn't change your mind about JavaScript, JavaScript changed it's mind about being a real language.I will give it credit, I don't know of another programming language that has changed so drastically and so much for the better.
I've been doing JS for 18 years. I don't think it particularly deserves to be learned but I think in general you should know a scripting language and JS is very popular (and can be embedded with v8 isolates fairly easily).
If you know python or lua I wouldn't bother. Lua would probably be my first choice.Scripting languages are faster for prototyping but they are a nightmare for maintenance. TypeScript might look like a good middle ground but the many escape hatches really allow you a single bad coder to wreck havoc in your codebase. You can't trust a codebase you don't know in TypeScript the same way you would trust  a Rust codebase.JS is good for job security because the node.js hype cycle brought a lot of JS in enterprise places - it's been used for massive codebases and now there are plenty of microservices nobody wants to touch or know how to debug. The rise of horrible, enterprisey frameworks (eg. NestJS) helped this.
JS could be the COBOL of the next generation, if it weren't for the web, which will likely keep JS alive for a long time.If you really want to learn JS, focus on the good parts.Avoid classes and `this`, avoid prototypal inheritance.Postpone the frontend as much as you can as that changes every 5 minutes.Start with bun (if you have no dependencies on node, it's not really compatible), so you'll have no issues with imports / require and all the tooling / transpiling (which rightly give JS a bad name)
JavaScript is one of my favorite languages. It has the nearly unique design constraints of having multiple implementations and being unwilling to break backwards compatibility, which gives it a lot of warts that are easy to ridicule. But I think the language on the whole is very flexible, very simple, and very usable.I would recommend getting your head around closures. It’s possible to statically determine what variables exist in which scope, and so if you can nail down those rules it makes analyzing code much easier.https://developer.mozilla.org/en-US/docs/Web/JavaScript/Clos...I would recommend a light linter. I see too much new JavaScript code using `var` written by non-JS devs in 2024.But I don’t think you need TypeScript if you’re first learning the language. Instead, revel in the dynamically-typed flexibility, and learn the error messages JS gives. There are only really 4 or 5 things that will cause JS to error, which can make debugging difficult initially, but once you learn those error messages, it makes debugging comparatively easy.
I have a long history developing stuff in strongly typed languages, C, C++, C#, Go, Rust, Java and Kotlin but have always done the "quick and dirty" in Perl, Ruby or more recently Python or Kotlin.I still much prefer strongly typed languages for anything that needs to be maintained, and i've always hated JS with a passion.What finally convinced me that JavaScript might have it's merits was working on an application written in TypeScript. In my opinion (and not everybody elses) TypeScript fixes a lot of "flaws" not only JavaScript but any duck typed language.I've long used type hints in Python, but they rely on the editor/tooling to find stuff that doesn't match, where TypeScript finds it compile time. Sure, it's all javaScript in the end, but considering that JavaScript can compare Apple and Orages and decide they're all tomatoes, having compile time type checking is a god sent.
I have started with a dynamic language with optional typing (BASIC), back in 1986, went through several static and dynamic typing throughout the years.While I lean on the static languages front, I am a big fan of dynamic languages as well, like Smalltalk and anything Lisp.In regards to JavaScript, it isn't the Scheme/SELF we wanted, it is what we got and already quite powerful.Some advanced stuff, how prototype inheritance works, how the new class model is actually mostly syntax sugar on top of prototype inheritance and not really Java like even if it looks similar, how decorators work (not yet fully there but will come), JIT and GC across the various runtimes, if care about server code how to write native extensions for the various runtimes.
I think the best way to understand/appreciate javascript as a language is to A) separate it from the DOM, and B) take a functional programming focusToo many times, when people complain about javascript, what they are really complaining about is the hectic nature of web development. You have three trillion dollar companies (Google/Chrome, Microsoft/Edge, Apple/Safari) actively fighting over agreed upon standards for how the dom is rendered and manipulated. Try and learnanylanguage in that environment, and you'll have a very frustrating timeWhy functional programming? Javascript was one of the earlier mainstream languages to support passing around functions as first class citizens, and it's often an aspect of the language that gets downplayed. By and large, javascript sits at the sweet spot of allowing you to do cool functional programming concepts, without all the strictness and verbosity of a language like Haskell. Is that a good thing? It depends, obviously. But for the sake of "Change my mind", this is where I bet you'll start looking at it in a different lightI'm not saying it's the best/one-true language. It's just another cool tool to have on your tool belt
I'm surprised that Kyle Simpson's, _You Don't Know JS_ hasn't been mentioned in this thread.https://github.com/getify/You-Dont-Know-JSWhen I was beginning to develop a deeper understanding of JS a few years ago, that book, Kyle's talks, and conference presentations by Chrome's V8 team were very helpful for me. It looks like Kyle has expanded the content considerably since then too.
There is honestly not much to learn, and that might be part of the appeal. At its core, JS is a relatively simple dynamic language with a clean syntax. Despite the clean syntax there are quite a few quirks in how some of the internals work (sorting and pervasive string comparison and casting, equality operator, etc). The most interesting thing about it is probably the programming model of free-form objects and closures: rather than using classes, you could write functions that return free-form records containing functions (and getters) that close over the lexical scope of the function. This gives a kind of dynamic object construction flexibility without the additional boilerplate.For the base language I recommend Dr. Axel Rauschmayer's books (https://exploringjs.com/) as they're kept very much up to date.Where things get really interesting is TypeScript, which takes all of this dynamism and manages to model it with a type system that doesn't feel all that constraining. It also ameliorates most of the core language papercuts. I don't really have good recommendations for TypeScript for now, other than browsing typescript issues and pull requests for examples written by Anders HejlsbergYou have to be very careful with the library and tooling ecosystem, however. There are a billion ways to do things, many of them incompatible with each other, and things break all the time. This includes major, popular libraries and frameworks with good looking documentation websites, so it can be difficult to pick something solid and stable. This is where most of the pain of using JS comes from.
I love writing javascript. It behaves like a lisp which really likes hashtables and runs on some of the best compiler tech anyone has shipped. Typescript is an interesting layer I haven't used enough.Most stuff written in javascript makes me nauseous. The entire NPM ecosystem is a parody of software development. But you can ignore essentially all of the libraries and still get work done.
I love JavaScript, been programming for more than 16 years now. Built websites, apps, banking portals, chat bots and customer experience software using Js, React, Redux and TypeScript. Also used Java and currently work on Go lang. Even after using every language I still prefer JS to be my everyday work love language. Its better now and improving too.
> Do you have any tip for learning js at it's fundamentals?Build something you think is fun. Take a static index.html page without any build tooling (just open the file with a browser), link a JS & CSS file to it, and make a cool thing with animations or interactivity. Maybe try to remake some cool interactive thing you saw somewhere
Once you understand the fundamentals, knowing about the newer stuff would be a good step forwards:https://github.com/tc39/proposals/blob/main/finished-proposa...
I strongly suggest TypeScript, which is (as you probably already know) JavaScript with static typing: in other words exactly what you want.TypeScript adoption over plain JS is HUGE in the recent years, I wouldn't be surprised if it becomes the native default in browsers some time in the future.
The industry uses TypeScript these days. If you’re inheriting a project, write the new stuff in TS, and gradually migrate. If you’re using the modern syntax, I’d say JS behaves mostly like every other language, with the exception being the tooling landscape is massive
I started my career with JavaScript and Node.js, but over time I've grown to dislike its design flaws and dynamic nature. If JavaScript had Dart's strengths, I might still be using it; instead, I've moved on to languages I find more respectable.
My (unpopular?) take is that JavaScript should suffice.Once I feel the need for TypeScript, I've done something wrong. For example, built my whole frontend with JavaScript or built my backend in JavaScript.JavaScript's use case for me is sprinkling it where needed in browser. Anything extra and it feels wrong tool for the job.Frankly, I believe whole existence of TypeScript is a mistake – we should've never used JavaScript at a scale where static typing becomes necessary.Having said all that, I'd love to be able to write gradually typed JavaScript (i.e. TypeScript) in the browser. Gradual typing is still greatly beneficial, even in my sprinkles.
How would you not build the whole frontend in JS though? Use another compile-to-JS language?
Render most of the frontend server-side and just use JavaScript for the dynamic bits only, I guess? I personally haven't done it like this since the advent of SPAs, but I'm guessing lots of things are still built like this.
It *should* still be the default.
I urge you to check outhttps://hypermedia.systems/(free to read online).TL;DR: The web platform has evolved (and continues to evolve) so much that I don't see a need to use SPAs for the majority of web applications.
The power of JS is the amount of effort put into its optimization, because of its importance for the web.JS is no longer as slow as people say, especially when developers are cautious about memory allocations and time complexity.
I think TypeScript is a legitimately fantastic language and I've used everything from C++ to Haskell.
Cristian Salcescu‘s books on JavaScript are absolutely marvellous and must-reads.
JS isn’t any more or less broken than every other language under the sun
PHP has a lot of issues in comparision to java and other languages.JS has also missing features and semantic which got added through typescript.I don't want to dismiss langauges because of this but saying 'every other language' is not true and not true in an objective sense either.
agree with this, at this point all my toy projects, even those of a few lines, are in typescript (with bun.js so I don't have the overhead of configuring node for ts)
Yeah I use Deno for the same reason.
It's a little funny that Javascript haters and Javascript influencers meet in their desire to highlight the new and shiny toys of the front-end ecosystem, but if you actually look at the survey results (or work on the front-end) then you know that in the real world, where people are shipping to prod, the story is thestabilityof favored tools.These things won: React, Webpack, Jest.  They've been the dominant tools for years. (Typescript is getting there.)  The ecosystem around them is enormous; a million edge cases have already been handled; they're not going anywhere for a long time.It's not really a surprise that as browsers become more like operating systems, people will experiment and find new ways to leverage the available capabilities, but you don't have to play with the new toys, and you definitely don't have to use them for paying work.  Just say "risk" ten times if anyone suggests them, and your PM will end up agreeing with you.
>The ecosystem around them is enormous; a million edge cases have already been handled; they're not going anywhere for a long time.Sounds like everything that came before them, buttheygot a foothold somehow.>Just say "risk" ten times if anyone suggests them, and your PM will end up agreeing with you.Please don't overuse this, if you get in your groove then ten years down the line you'll end up being a naysayer to something the company actually should adopt.
Yeah, like one of the companies I briefly worked for. An outdated hell of WordPress, with no package.json, no linters, no formatters, copy & pasted / vendored dependencies, lot of NIH home built libraries, no tests, no framework other than jQuery, no automation (we built scss from the CLI because "we don't need to complicate it with scripts", and absolute negationism about any "shiny new tool" if it was less than 20 years old. The only people that stayed there were the ones happy to work in those conditions, or that haven't seen anything better.Those places still exist, sadly.
Did the company make money?That's the reality of it. You don't need shiny frameworks or any of those tools to make money.Are developers happy with it? Maybe! Nothing wrong with spicing up a site with a little jQuery. Heck, I used Alpine.js on a brand new site and it's great. No build step, just works!
Here's my feelings like someone who's not strictly frontend developer but has to deal with it from time to time.Frontend seems to be React, rest is dead, everyone's on React.Build system seems to work. Last time I used vite and didn't tinker with it at all. It just works. That's good. It was a royal pain for in in the past. All those grunts, webpacks, gulps and whatnot. But it doesn't seem like dust is settled yet. I guess more build systems will appear and disappear in the future.State storage: I don't know. Redux was hot in the past. Nowadays it seems to be react-query which is supposed to be wrapper around fetch but apparently its caching is good enough to replace the whole state storage framework. Sounds weird, but here we are.Routing is weird. I don't understand what's with it. There's react-router but there are some fuss with latest version, with react-query compatibility.Code quality tools are not complete. There's prettier which is nice but does not work for everything as they have some weird artificial constraints, like they don't want to insert curly braces automatically, so you need to use eslint. Configuring this stuff still is pain. Deno is awesome in that aspect.What I miss in JS ecosystem is something single which solves all my problems. Like npm which can also build website, which can hot reload it for dev mode, which can autoformat my code with single blessed unconfigurable code style, which can lint it, which can run unit tests and so on. I don't want to spend a single second setting up my environment.
>What I miss in JS ecosystem is something single which solves all my problems. Like npm which can also build website, which can hot reload it for dev mode, which can autoformat my code with single blessed unconfigurable code style, which can lint it, which can run unit tests and so on. I don't want to spend a single second setting up my environment.For this, you have Next.js/SvelteKit/Nuxt.js/whatever framework you prefer. For React in particular, Next.js with the default setup has all of these features but unit testing (there's a template for that, but it isn't as commonplace in frontend as it should be), and more such as server-side rendering, routing, data fetching, etc.
I don’t bother unit testing my front end - I’ve never found it to be worth the time
I get that. Testing components in particular is something I've rarely found to be worth it as well.But often I find myself writing logic in the frontend, say for processing data from the API. That's where I want to create a file and write a unit test because it would actually be easier. Sadly for a small project the effort of configuring and maintaining updates of an external test framework on-top of Next makes no sense.
Yeah sure if there are some pure functions involved then by all means unit test.
When using typescript, unit testing needs are few and far between.
I'm EXTREMELY confused about what's going on with react router, the documentation seems mismatched from versions, and any tips I find online seem to be for some now defunct version.I remember a few months back I was working on a react app with react router and trying to figure out how to hook into all route changes for some reason, and all the documentation centered around "picking a router," of which there was `createBrowserRouter`, `createHashRouter`, etc, all which had different considerations. But I couldn't find an invocation for any of those! Just a single `useRoutes` and that was it lol. And the argument for it was just objects and arrays, with element properties set to JSX. From my understanding, we shouldn't have had history working at all without explicitly setting it to do so, but it all was working, so... who knows?
React Router devs have a history of breaking changes and some spikey behaviour so this doesn’t surprise.
So it's not looking good. After all these years, people stuck with a bloat/slow React (but with all benefits come with being popular alone). State / routing / form, nothing has a decent de facto.
I've use React Router 6 in combination with @tanstack/react-query 4 in a ±2 month old project without issue. I did notice that React Router 6 annoyingly by default returned to an object notation for its routes instead of elements, but with `createRoutesFromElements` the option is still there. I find the object notation less readable and it doesn't follow the React paradigm.One thing that I imagine would cause issues (or make react-query at least partially redundant) is the `loader` prop that React Router now has that allows is to do data fetching and posting in the router. I didn't try that due to time constraints.The biggest pain for me in Javascript is tool configuration, it's something that I'm just not good at and configuring Prettier, eslint, testing library (with mocks), tsc, … and all the rules that inevitably start crashing with each other is hell. That's why for the longest time I kept using CRA which had all these things preconfigured with sane defaults. But CRA development is moving at a crawl and with the lack of SSR NextJS makes much more sense so I'm focussing on that now.
>Frontend seems to be React, rest is dead, everyone's on React.Looking at the "retention, interest, usage, and awareness ratio over time" - Percentages: almost perfectly flat. Rankings: all slowly going down.Relative feelings are in near perfect lock-step.  The only thing to note is people, as always, have ennui and are looking for something new.There is nothing to support your statement, at all.  You are basically lying.
>What I miss in JS ecosystem is something single which solves all my problems. Like npm which can also build website, which can hot reload it for dev mode, which can autoformat my code with single blessed unconfigurable code style, which can lint it, which can run unit tests and so on. I don't want to spend a single second setting up my environment.SvelteKit can do that.
To misquote the author of Solid.js as I remember it:--- start misquote ---There's no wonder react has been popular for all this time. We needed a time of relative stability and gradual evolution. We don't need revolutions every year.It gave time to think about hard problems, and come up with new solutions. There's intensive work being done right now on things like proper partial hydration, SSR, granular reactivity etc.--- end misquote ---This is partly reflected in the graphs as well: react dominates, but "new kids on the block" like Svelte and Solid have insane rates of interest and retention.
To keep beating the same tired old drum: despite literally hundreds of millions of dollars poured into development and promotion of Web Components... the results are at best meh. The two leading frameworks, Lit and Stencil, see very little interest, so-so retention, and barely any usage.None of the major frameworks and barely any of the newcomers use them... well, for anything.(Of course the person responsible for them tries to downplay it because biased etc.https://toot.cafe/@slightlyoff/109669688324474159)
Mainly look at Svelte's... its adoption more or less flatlined this past year compared to previous years :-/https://2022.stateofjs.com/en-US/libraries/front-end-framewo...
SvelteKit isn't there yet, but once it is fully fleshed out (yes, I know it hit 1.0, but it still doesn't support the big three cloud providers out of the box) I think it's going to change the standard for frontend architecture. There is no way to get React to render itself on edge servers.
No-one uses vanilla JavaScript anymore and everyone is on TypeScript?https://2022.stateofjs.com/en-US/other-tools/#javascript_fla...
> Languages that compile to JavaScriptSo that graphic excludes JavaScript itself.But to your point, I get the impression every project is adopting TS in some form. It's now pretty rare for me to find an NPM library that doesn't have typings, and anecdotally I'd say at least half are provided by the project. And I've seen a lot of "migrated to TS" in project changelogs.
There is a second tab for other answers, where you do find both (though few) "Vanilla JavaScript" and "JavaScript" answres.I think they should have had it in the main selection as - at least to me - sounds improbable that really so few use vanilla JS these days.
The new comments section on the frameworks page is nice. It's interesting to see which ones people for apathetic about and which have lots of love.
Wdym real world? Stack overflows 2021 developer survey says broadly it’s 5.31% of respondents identified as women.https://insights.stackoverflow.com/survey/2021#demographics-...
> Wdym real worldMeans that this survey may not be as representative. But with the info you gave, it might be.
I definitely wouldn't consider StackOverflow users to be a representative sample of people working in software development/tech/etc.
I worked for companies/clients where there were teams of all men and, in the case of smaller organizations, literally only men worked there.I don't think it's as extreme as ~5%, though.
My point is "I know it's bad but not this bad". Like, I thought it would be more like 10% or something.And I was not asking for any "magical answer", just wanted to know if this survey is representative enough (others have already answered it, so all good now.)
State of JS but completely leaves out the backend Javascript/Node/Bun/Deno ecosystem.
I'm the lead survey maintainer; I agree that the survey is very front-end oriented, but that's because it was hard to properly cover everything, and we're instead hoping to do a separate "State of Node" (well, or a similar name that also includes Deno, Bun, etc.) survey at some point.
I appreciate the work but it seems like this should be called "State of Javascript Frontend" instead of "State of Javascript".It's missing alot.
Runtimes are here:https://2022.stateofjs.com/en-US/other-tools/#runtimes
Doesn't say much to be honest. Anyone who develops in Javascript must use Node.js because the front-end tooling uses Node.js.I'm interested in a whole breakdown of Javascript in the backend.
“React might not have all the answers after all”Let the newest, slickest, shiniest batch of Javascript web frameworks commence! Oh boy.
On the other side, I wish the babel tower of javascript stacks collapses under its own weight so we can stop normalizing 50mb of download and 2gbs of ram used for a front end.Maybe something that compiles to wasm? Idk
Wasm can’t really do DOM manipulations without JS interop, so that would just further the issue.
It probably won't happen but what I'd really like to see is for browsers to be a bit more "batteries included" when it comes to UI so devs feel it less necessary to build leaning towers of JS. In fact I think it should be a bigger priority than a lot of the things that've been focal points in the web standards space recently… it feels silly that one needs to pull in a third party lib or roll your own for something as basic as a sortable table.
It’s often not worth baking it into the browser; you’ll have to rewrite it anyways to implement the latest design trend or interaction pattern. I think having a “standard library” in userspace, preferably catchable, kinda like we used to have with jquery is as good as it’s going to get, but even then it’s inviting version hell on the “standard library”
High degrees of stylability is a must for these UI components, so design trends should be moot, unless we're talking about technical design trends in which case I don't think web front end is going to see such crazy churn forever. It's already slowed down somewhat from what it was and I believe it's eventually going to hit something of a steady state.Plus even if there's some degree of persistent trendchasing in the web front end space, there's also those who always go for the old "boring" options when making choices of this nature, and better baked-in components would serve these devs well.
>It probably won't happen but what I'd really like to see is for browsers to be a bit more "batteries included" when it comes to UIThis has been happening gradually for the past decade and now jquery is no longer necessary.
Except JQuery had a UI framework which was actually quite nice and is now long relegated to the dustbin of history.
Yeah, it’s definitely in a better place than it was a decade ago, that’s for sure. You can go much further than before with no imports.Even so, I’d like to see it improve further and at a faster pace.
When I work in teams, the FE folks handle whatever they feel like and I just integrate their stuff, when I do my own little side projects, I do vanillajs and keep being an happy fellow.
So now you'll download megabytes of wasm. Because the browser has very little of what you need, and you need to bring all your world with you, all the time:https://news.ycombinator.com/item?id=34218520
Ah yes, you surely won't have to download any tooling to compile some random language to wasm.
Apline.js is pretty nice for that.
I know it's cliche, but there are Rust frontend frameworks that compile down to WASM.
That's a very cautious "may" though — look at the actual results, and React still reigns supreme, and probably won't fall by the wayside anytime soon.
The graphs get worse every year.
Lead survey maintainer here; we are aware of the problem and are working on a new data visualization that will use historical data to highlight how bad the graphs are getting year over year, so we can really narrow down the issue.
I’ve for some reason started reading the headline “the state of X” as a sort of world-weary “the absolutestateof X.”
Libraries -> Changes Over Time is particularly hard to read
It’s a great visualisation but could be 3d with time as depth, not brightness.
This is a weird mindset. If I wanted to “just ship” something, why would I try to relearn technologies I haven’t used in almost ten years over ones I know well today?
I think a lot of people are now used to seamless interaction and realtime data updates. Also, pricing models on cloud service providers increasingly discourage serving from rails or nodejs, and encourage static files that offload as much as possible to the end user's device.
You can have those interactions on Rails just like anywhere else. Cloud compute is also absurdly cheap at scale today compared to the past.
How do you manage page-wide data consistency in Rails without a page refresh?
You make sure you're only trying to do frameworkless development on pages where "data consistency" means "the text box displays the text that's in the text box." :-)
There’s multiple approaches. Since everything is server side rendered, you can for example, stream updates through web sockets
Sounds like a lot of latency, waiting for the backend to render a template and send it over the wire every time the user presses a button.
You don’t re render a template. Only what you need to. If it’s a single div then so be it. Which is why it’s SPA-like experience with server side code
And where does that new div come from? It's not a backend template?
In my understanding template would be the entire page. So while an an individual div re-rendering is also technically a template, it's not really the same thing. It's a tiny re-render compared to a page refresh.Again, this is a different spin on doing things. Rails preaches abandoning the over-complexity of the client-side in the browser and pushing work to the server.I personally love it. I'm sure someone who is as fast in React as I am in Rails is laughing reading this.
You're going back in forth about whether the html re-render that's sent back over the wire is always the entire page or only the specific element needed.
Hotwire
Had the same response, but would have said "Django" not "Rails". Hardly matters tho.And htmx is worth exploring. As is HTML over the wire tools across various languages.
Sometimes it matters a lot. I'm a Pythonista who had to work with Rails just today (because I had to mend some Rails-based API project I had to interop with) and cussed a lot.Rails remind me of Perl's metaprogramming beauty (code is almost literature or even art) but also its worst sides (unique situational DSLs for everything and then some more, with TIMTOWTDI). It takes a lot of research to figure out where things are coming from because everyone seem to really love metaprogramming the whole kitchen sink, magically converting :symbols to ClassNames to autogenerated helped methods to generated attributes. And nothing is ever implicitly imported in the file you're looking at. Surely, it's all pretty simple after you learn how the particularly selected gem is used, but almost incomprehensible before you do. E.g. I just struggled for good 15 minutes before I learned that expose(:foo) is from a `decent_exposure` gem (and read that gem's source to understand how and why it does all its magics) - and there seem to be hundreds if not thousands of such gems in any sufficiently large and old Rails project.Oh, TIL that Rails doesn't implement If-Match at all (only If-None-Match for GET and HEAD through some Rack middleware). Every other toolkit I've used had something for that.
Good luck talking to cloud infrastructure such as Cognito-authorized AWS S3 buckets on the client side with a last century mindset like that.
100%
This is the way. Rails and Hotwire especially really worth a look. Hope it can gain some traction, so tired of the constant “innovation” of JS frameworks
I think Next.js is like the modern rails that can seamlessly bridge server side state over to the client side for interactive applications.
Why would I learn to use Rails when I can write an SPA in React in my sleep?
Can’t write your backend in react. So presumably someone else is writing an API in their sleep that your app will consume.
If you combine together all the static web 1.0 sites in the world with all the backend-as-a-service companies (Commercelayer, Stripe not exactly, the weather ones), and mix in the mostly-just-plumbing backends you can come up with by stitching together AWS offerings, and top it off with all the things you can do by writing less than 100 lines to run a Lambda function, you have covered a huge number of use cases without ever needing to learn Rails.
You can do a lot of things, depends on your goals I suppose. You seem to be really sold on the concept of not learning Rails, so I won’t argue with you further. I personally found Rails much easier to learn and use than React or pretty much anything I use in the JS world.Rails is built with developer happiness in mind. JS though became the answer to all questions for reasons that are beyond me. You can’t escape it entire so I try to limit how much I have to use it.
I don't know if there's a rails-of-js yet, but Svelte is pretty nice.
For me that's Adonis.js. I've been using it for over a year and it's great.Although it's more the "Laravel of js" than the "Rails of js".P.S: Yes, I know Nest.js and I don't like it and don't think it's better or even closer to the developer experience you get with Adonis.
Have you tried Sails.js? Seems like Adonis is not very actively developed?
It is nice. I’m not seeing enough adoption unfortunately which is negative in terms of work opportunities
If I write an SPA in my sleep, and my partner writes a backend using her preferred language/framework in her sleep, we'd be a dream team.
Well, no. But you can write your backend in JS/TS. I find backend code needs much less of a "framework" anyway (depending on use case, I'm thinking of CRUDdy-ish stuff). You just need to nail the API between frontend and backend, and using the same language means you don't have to do anything fancy with your domain model.
You can, sort of, if you write it using next.js. Also presumably if you know react you know node, so you could write an express server or something. I'm assuming this is what OP meant.
Using Next.js for writing your backend is pure masochism. You'll only understand why I say this if you've ever used a real batteries included backend web framework.
Such as I guess you mean like Django or Rails? I have used Django but because I'm more comfortable building pure client software (games and stuff included, where all logic is happening on the client CPU and RAM), I found it a bit uncomfortable. To be fair I also find next.js somewhat comfortable: I prefer a clean delineation between the client and server, and often find myself fighting next.js when I'm thinking "no, i DEFINITELY want this run ONLY on the server, TRUST me!" But I could just be out of date, I hear "running on the edge" is the hot new thing and I probably just don't know yet how to dev that way.Could you expand what you mean?
What I mean is that if you enjoy using React, Next.js is your best option in my opinion and from my experience with similar tools (heavy SPA meta-frameworks...). But that's it, it's there for the *frontend* of your application. And the more your application looks like a landing page with a form than a real full stack application, the better it fits.A lot of problems arise when you want to use it to build a "full stack" application with just Next.js and no "real" backend framework. Many people will tell you Next.js is "full stack" because it can execute JavaScript in the server. For me that's not "full stack"... Maybe when I say "full stack" I'm actually meaning "batteries included" because that's what I need when I'm building a "full stack" application.For any non trivial application, you'll need things such as authentication, authorization, migrations, orm, background jobs, translations, logging, error reporting, rate limiting, security guards (cors, brute force attacks, etc, etc, etc). Most, if not all of these things come out of the box in real "full stack" frameworks such as Laravel, Django, Rails or Adonis.A few months ago I had to deal on a Next.js application which needed server side rendering, internationalization and data validation. Making the error messages from the server show correctly and making the i18n library work together with the authentication, the SSR, the half-assed orm/wrappers around prisma, etc.... it... worked... but you end up looking at the code and asking yourself "Why am I doing this?... Adonis.js or Laravel would do it for me already".Of course some people here will say "but there's a library for each one of those things in the Next.js ecosystem"... yes, but picking the right ones, integrating them so they work in a seamless, secure and battle proven way, keeping it up to date, maintainers abandoning them, trends making them out of fashion, etc, etc it becomes a TON of (business wise) useless work.So Next.js for the frontend? Great. Next.js for a non-trivial full stack application or for your backend? Sure, but you're not using the right tool, it's like trying to put a screw with a hammer. Might work. Just far from ideal.
It's not much overhead?https://dzone.com/articles/rails-creating-modals
So you're adding Bootstrap and jQuery and Popper onto Rails, just to get a modal. What happens when that modal performs an action? If it mutates data, does it require a full page refresh to do so, causing the user to lose their context? Or does it do so without a refresh, but does that mean you've now got multiple frontend and backend ways of saving and loading data in the app? How do you maintain data consistency on the rest of the page after the mutation?
For many cases I think you can refresh the page. The context (the same page) is mostly still there. I think it really depends on what the user is expecting to do next. For example if the modal was “are you sure you want to delete this record” a full refresh and the record appearing deleted might be a fine experience.
It's not a fine experience if the user had scrolled down the page, or had filtered down the table listing, or had set up the UI by opening a panel or whatnot.
Yes if the user must retain their state after the modal closes a full page refresh would not be the right thing. I probably wouldn’t build Figma in Rails, but I probably would build a CRM in Rails.
Hotwire introduced turbo frames and streams, removing the need for the page refresh when data is mutated
Sounds like a lot of extra functionality you have to learn, add, and use that still requires the user to wait for the backend to render a template.
There’s no waiting for the user. It’s an SPA experience without the headaches of client side state management.I suppose what you have to learn and add is relative to what you already know and have, isn’t it?
What headaches? You mark a query as stale and it fetches new data from the backend and rerenders elements as needed automatically.What reason is there to learn Ruby and Rails and Hotwire and streams and turbo frames and whatever the next churn is just to avoid rendering some html with javascript?
That’s rich, I bet there’s 3 new JS frameworks that came out just today lol.
You know you're not required to understand and use every piece of tech ever made, right? Who cares if someone published a hobby project?No one is suggesting the industry immediately adopt some random new library, except for Rails fans who constantly demand everyone abandon a de facto standard like React and use their new toy.
You can post data to API endpoints with vanilla JS fairly easily now. There are a lot of simplifying cases where there's no complexity to state management - like when the data flow is one-way.
Simply posting data isn't an issue. It's just as easy to do that in a 100% client-side JS app.The problem is what happens next. Do you reload the entire page each time the user makes any kind of change?
If your input is just a text box, you can post it whenever it is submitted and put up some kind of status gleaned from the server's response body. In another comment, I point out how easy it is for requirements to end up forcing you out of the stateless happy path of frameworkless frontend, but that doesn't mean there aren't a lot of cases where you can stay in it.
> You can't build a modal with Rails.I must've dreamed up the dozens of times I did.Unless you mean you still need JS to build the modal, which is true but I doubt GP was implying that you shouldn't use JS whatsoever. You don't need a SPA to build a modal.
SPA-like complexity sneaks up on you. You start with clear stages to user interaction that might as well be separate URLs, then you need to add more connections, then you have to add pop-out panels and things that can be open or closed in various combinations, and by the end you have manually re-implemented what most frameworks do.If you know in advance that you will never have complicated combinations of states, then sure, go ahead and use alpine (vanilla DOM element creation makes very unreadable code) or if you won't even need to create elements don't use anything... but the situations where you reallyknowyour application won't evolve that way are very rare next to the situations where you merely don't yet know that it will.
The way I see it, rewrites are inevitable so it's best to start with what's most comfortable right now and then deal with complexity creep when the time comes. Unless the app in question is being written for BigCorp there's a decent chance that it'll never hit that level of complexity during its lifetime anyway. Starting out with an SPA feels a bit like killing a fly with a sledgehammer.
The thing that this article is missing is that we use JavaScript in these places because compatibility is better. We can even use new JavaScript by transpiling, but polyfilling missing CSS and HTML is a lot harder to do and impossible in some cases (not to mention your polyfill will use JavaScript).`appearance` has a lot of caveats on MDN about testing it thoroughly if you're going to use it—even `appearance: none`. This may matter less if you only have to support new browsers, but keep in mind that old versions of Safari stay in circulation longer than you might think.`datalist` does nothing on Firefox Android. It just shows to me as an input box with no functionality at all (not even the suggestions over the keyboard that others report in Chrome Android).The color picker is neat, butextremelynonstandard, which is a dealbreaker for most businesses not just because the designers will complain but because customer support will find it harder to help people. Chromium provides the functionality to pick on a page and pick literally any color, but Firefox Android only gives me the rainbow, a gray, and black and white.The article itself acknowledges the inconsistencies with `details` and `dialog`.I hope we eventually get to a place where browsers that don't support these features (and support them consistently with each other) are no longer used, but in the meantime these elements will only find their way into my side projects, where I have full control of which browsers I support.
> The color picker is neat, but extremely nonstandardWhen I press the button on my iPhone it brings up the actual system native color picker. It’s the same control that appears in dozens of apps because it’s provided by the OS.I much prefer that over some bespoke thing.
You do, but companies don't. A major advantage of a browser app over a native app is having one system that behaves relatively consistently across all platforms. This isn't just cosmetic: providing customer support for a web app that hasexactly oneexpected set of behaviors is far easier than asking your support agents to keep track of the constellation of different features users might have access to depending on their platform.The color picker control is the antithesis of this consistency: not only does it look different across platforms (making it harder for CS to walk customers through something over the phone), it providesdifferent featuresdepending on the platform. Some users will be able to pick an arbitrary hex code, some will be able to pick colors off the page, and still others will be given a tiny set of fixed choices.HN's audience might prefer that because they know the platforms they useextremelywell, but the average caller to a customer support desk doesn't know their own device that well. If we instead write a bespoke control, you (being technical) will be able to figure it out, and the people who call in to customer support for help will all be seeing essentially the same thing.EDIT: And note that when I say "companies don't", I'm not even just talking about the SaaS vendor. Oftentimes thecustomeris also a business that has an internal support desk that prefers consistency.
And that is why I hate web apps. What even is the point of various OSes offering different UX to choose from if the apps completely disregard it and offer their own thing that is 1) different from what the OS does and, 2) usually worse.
Yeah. People will hate me for using it as an example, but there is such a huge difference between native apps and the gunk we’re fed now. I can vividly remember the first time I used a Mac-assed app on a Mac, and it was remarkable. Like, itfeltgood. But now those are going the way of the dinosaur. (Yes, I know, Apple is to blame for that in part by their  iOS-ification of the Mac. That’s not what my comment is about.)
Really? I am trying to put my customer/mum hat on and but is this really true.
How many OS would you need to really support? 4 or 5?
On top of that docs/knowledge would be more standardised. Google/peers/family would help people more.
> Google/peers/family would help people more.Tell me you've never worked in tech support without telling me you've never worked in tech support.My experience in a tech support center for a software company is that, for the kind of person who calls in to customer support, them having made a Google search first is not something that should ever be assumed. And usually whole offices were chronic customer support users or none of them were—peer support, when present, is already sufficient, and in the offices where everyone is clueless having a system-native color picker isn't going to fix it.> On top of that docs/knowledge would be more standardised.If everyone started using the native widgets at once, then maybe external docs would be more helpful, but until that happens yoursoftware-specificdocumentation becomes much harder.How do you take screenshots of the color picking flow for your documentation? If you just pick a browser to screenshot then youwillget calls from people using a different browser who are confused that it looks different for them. If you screenshot every supported browser then your documentation becomes much more expensive to create and maintain.
I hear the know it all customer is the worst.I once had a problem with my laptop, which was a problem with the drive. I pulled it out and duplicated the problem on a different laptop, so I needed to get a replacement.  I kept mum and went through all the steps I was instructed to (reboot with this or that key held down, etc) until finally support said “well sorry, we’ll have send you a box for you to send back the laptop”.  It would have been useless and annoying to the person on the other end of the phone to dry to skip all that.  Like doctors, they must deal with a lot of people who studied at the university of Google and think they know it all.I have a few times sent in bug reports on software I had previously worked on myself.  Again, just file it like any other bug.  Usually the bug just gets fixed (or not) but I did once get mail from a former colleague who said he was assigned my bug and how the hell was I?  Sadly he also told me, “we aren’t going to fix it.”  :-/Of course most of the time I don't know any more than the next schlub.  Otherwise I wouldn't have called.
I'm at a point where I just treat the front-line CS person like a fellow engineer and tell them exactly what's wrong, and why I know that.I've actually had pretty good success with this strategy, though it really depends on the company.  Framework laptops and system76 for example were both phenomenal with this approach.  The first reply I got from them was either an engineer or someone who talked to one, or someoneveryexperienced in CS who would be a good candidate for engineering.Worst case if the CS person has no idea what I'm talking about, then we start from scratch but at least they know I'm not a dumbass they can BS :-)
Most of them have to walk through a decision tree in response to their computer and don’t know about the domain anyway, so I don’t want to waste their time.
In my experience this is, unfortunately, true. I see it from both sides and would prefer the native implementations myself, but I've never worked with a customer who agrees.
I start by saying, your customer who uses an iPhone is never going to use an Android, and vice versa, so there is no need to keep them consistent and identical looks and design wise.  You should use the native items as much as possible because a random user is more likely to understand the common system version than they will understand your bespoke version.  Use the native share icon, don't use the iOS share icon on Android, etc.Also iOS tends to be way more consistent than android, windows, etc, so there could be a case for iOS native and 'company consistent' for everything else, especially if you're in the USA.  iOS people pay more and it could be worth it to have two branches for customer support if it leads to total better conversions and thus more profits.  Your business's core competency is not making UI toolkits, it's selling whatever your making.  Leverage the literal billions of dollars apple and google invest into the core UX toolkits.
What could possibly go wrong with a standard color picker though? Show some grid, spectrum and sliders, remember the last 10 choices, return a hex code back. Done.This is something humanity can solve once and for all then be done with it.Implementing your own will have bugs and generate a lot more support. The dialog I get on my iPhone is magnitudes better than any other home baked pickers I’ve seen.Date pickers on the other hand I agree are more complicated to standardize, due to frequent need of overlaying extra data, like price, together with the dates.
Because as a customer there’s nothing that makes me happier than when I contact customer service and they say “our website is made for Windows so you’ll need to use the exact same OS as us”
That part of the parent comment was about corporate setting.> Oftentimes the customer is also a business that has an internal support deskMaybe I misunderstood something, but if it's a business with internal support desk, surely if they want consistency they want it everywhere, including the work machines (BYOD aside) they provision?
I know at least my company, employees who aren't devs or designers get a Windows laptop, unless they're considered a frequent traveler (i.e. sales role) in which case they get a MacBook Air. Designers get a MBP. Developers can choose between Linux and Mac, or Windows if you can justify it (we have some hardware engineers who actually need certain Windows-only software). We also have some new acquisition every few months and those companies get to keep their previous computers for a couple years before they have to get on the company approved device list.
> So they should use the exact same OS and they'll have the same color picker everywhere, native to that OS. Problem solved.How would that work if the app had to work on both desktop and mobile?And, how easy would it be to make sure all users were using the same model and make of mobile device?
Compatability is only better if you make the assumption that all your users need to be using javascript. I much prefer using the web without javascript, it impacts my laptops battery life by hours.  Some sites, are not compatible with this and render a blank page or complain to me that they require javascript to render some text in windows. Meanwhile Amazon has a javascript free clone of their ecommerce site, showing that such herculean feats are possible without reaching for javascript.
I think that is a pretty good assumption to make. The vast majority of websites are being made for the average person to use, and the average person is using one of the big browsers with more or less standard settings.Youcouldwrite a website that doesn’t use JavaScript, is meant to be accessed primarily through curl, etc but if it’s a business project then you’re going to end up with a product that your users (average people) will view as more janky than otherwise, and you’ll spend more time and money on it too, for the benefit of 0.01% of the population who would be slightly inconvenienced if you didn’t.
> you’ll spend more time and money on it too, for the benefit of 0.01% of the population who would be slightly inconvenienced if you didn’t.The Unreasonable Effectiveness of Simple HTML:https://shkspr.mobi/blog/2021/01/the-unreasonable-effectiven...
> Compatability is only better if you make the assumption that all your users need to be using javascriptAre any companies foolish enough to assume otherwise? I understand there is a minuscule number of users who don't want to run JS in their browsers, but aside form Amazon and their near-unlimited resources, who is catering to that small number of users?
Battery life is the silent victim. Maybe browsers should name and shame websites that are heavy.
I would love to know how many milliwatts a page is using? Any way to find out?
I try to push for making websites without JavaScript but nobody wants to because it requires some forethought. TIL Amazon has a functional no-JS version, amazing!
Sites should work without javascript, but I think it's fine to demand a somewhat up to date browser in that case.For features that have been very widespread for enough time, it's okay to have a javascript polyfill as the only fallback, in general.
The <dialog> element actually hasdeepsupport at this point, and the polyfill for the few percent of your users on 2021-era Firefox or Safari is totally fine. I highly recommend the element if you're making modals; the accessibility gains are fabulous.
> but because customer support will find it harder to help people.This is a big one. At a past job we actively discussed this and instead decided to use JS over things like datalist due to it potentially increasing the CS burden. Datalist specifically was tried, but the inconsistent results meant it had to go.We eventually ceased support for all browsers but Chrome as well due to the inconsistencies.
Nope. Javascript means that if it fails then it completely fails and the content is not there at all. While the HTML examples may not look correct in older browsers, the actual content will be there. With JS it's just nothing. Nothing at all. It completely breaks accessibility. With HTML my screenreader can at least still read it. JS generated content prevents this.No amount of polyfill or other JS can save JS when JS cannot JS. It's terrible for accessibility unless it "works" to start and in that case your point is moot.
None of what you said is an inherent problem with JS.The company I work for has JS app that is resilient against the missing-content problem you refer to. It is alsomore accessiblethan any other web app I've ever seen in my life. There's nothing about JS that breaks screen readers: you just... generate the right HTML with the right attributes.The problems you see with JS apps that don't work are apps written by people whodon't careabout their app working anddon't careabout accessibility. That's orthogonal to whether a JS app maintained by a competent team can have better cross-browser compatibility than one (by the same team) that leans entirely on new HTML and CSS features.
The parent commenter is saying that JavaScript in the browser MUST NOT be a dependency for core functionality because it may be disabled ("when JS cannot JS").If your site is popular over Tor — that is, if it's used for warez or by whistleblowers and journalists who need to browse privately — this may be good advice. If it's not, people who disable a core aspect of the browsing stack are savvy enough to enable JavaScript on a site-by-site basis when necessary.
>more accessible than any other web appWell there's our difficulty communicating. I'm talking about all web sites, not just applications that happen to be run in a browser. A regular HTML page with text in it is far more accessible than any application depending on execution could ever be. Web applications can, in very rare cases be made accessible (assuming you have perfect execution and JS feature support in the browser). But actual web pages always are. 99% of the time if you can do it with just HTML and text/images you should.
So you missed that this whole thread is about TFA, which suggests using HTML for:* Switches* Autocomplete input fields* Color pickers* Accordions* ModalsThe accordion is arguably applicable to both, but with all the others it's pretty clear that TFA is about web apps, not content-heavy web pages.
Sample URL?
I side with you.Sadly, the article itself is of no use and only a rant, since the “you” in “you don’t need” is not defined.Have fun checking for mobile, tablet, desktop, Android, Apple, Chrome, Firefox.It is not that developers rejoice over creating controls all the time. There is still html and css involved.
I briefly contributed to WURFL before I got out of mobile. Being able to figure out limitations based on UA I think has a place in the world because you can generate script tags for polyfills in the head based on which you need.But now that I’m saying this, I think an attribute for script tags that only load if the browser doesn’t support feature X (or any feature in a set, so you can roll up polyfills that tend to be needed together.That could be backward compatible because existing browsers would just load everything, and new ones could negotiate.
Define "gracefully"?The standard behavior of "render unknown elements as if they were a div" isn't viable for more complex elements that aren't just content holders. Alternatives that involve developers specifically coding a backup componentare more expensivethan just writing a bespoke component in the first place.What sort of graceful decay are you imagining for these cases where a whole widget is missing or is implemented differently across browsers?
I was unaware of Datalist, but it does not appear to work on Chrome Android, at least not really.I see the options in the keyboard [0], in the place where autocorrect suggestions appear. But that's the first time I have EVER seen that in a mobile web UI for a page's form control (aside from password auto-fill apps that use that same space).I don't hate it -- it's actually much nicer than trying to awkwardly scroll a poorly built custom JS drop-down. But I have no confidence that all normal users would figure out how to use it. So I think it's DOA for mobile.Also, it is flat-out not supported on Firefox Android [1].[0]https://imgur.com/a/Ecb4503[1]https://caniuse.com/?search=datalist
Hey browser makers, can we please be able to style the datalist dropdown?Also:https://adrianroselli.com/2023/06/under-engineered-comboboxe...
This is why these solutions take so long to catch on.JavaScript is pretty well standardized, html and CSS is less so.
CSS is easier than JavaScript.Here is an example of JavaScript-free CSS motion:https://egbert.net/blog/index.html
CSS may be easier, but that's irrelevant to OP's point—it's less standardized across browsers, so if you have to support a bunch of different browsers of varying ages it'smucheasier to write JavaScript with boring CSS (and even transpile it if you want to use newer features!) than it is to polyfill all the missing CSS features you'd need to use it instead of JavaScript.
I wonder if adding autocomplete="off" to the input element changes the behaviour? It is in any case required for sanely using datalists. Otherwise the value selection history will be appended to the dropdown list (observed in Chromium).Also, datalists still need JS in some cases like when a default value is set. I have the workarounds and browser quirk notes here in the (to-be-launched) new LibreOffice website code:https://git.libreoffice.org/infra/libreofficeorg/+/835a5cc59...Good news is that a Firefox dev plans to look into improving datalist behaviour, so only a single click would be enough to display the list.
Have you looked above the keyboard?For me it shows the options above the keyboard where normally word suggestions are shown.
This thing where the datalist options show in the keyboard is some recent thing, i.e. a few months ago. It used to be "normal" before that, but I guess someone wanted to change things only for the sake of changing things
I really wish data list was better, shipped it on an admin dashboard for something, and while it works fine in safari it’s a bit broken in several ways on chrome and Firefox, leading me to need to replace it with JavaScript
works fine on chrome android
Didn’t work for me either on iOS.
>Native smooth scrolling with scroll-behavior: smoothBut please limit how you use this; it’s not actually a good idea most of the time you might think of using it, and often has undesirable side-effects.>Native carousels with scroll-snap,But carousels are still a bad idea, so scroll-snap is ofextremelylimited legitimate application.>Scroll driven animationsPages that do this are normally improved by removing it.
The point of the article isn’t to dictate what design elements people use, it’s to point out more user friendly ways of achieving those designs.Smooth scrolling is a great example. The native API allows a user to interrupt at any point. Most JS implementations are janky as all hell and users suffer.Scold design choices all you like but don’t expect to be listened to. Especially when you’re not providing any actual reasons why “carousels are still a bad idea”.
>Especially when you’re not providing any actual reasons why “carousels are still a bad idea”.It’s widely understood and documented that carousels are a bad idea, and plenty has been written about it.(I should clarify that the problems are with carousels as a way of presenting diverse widgets; as a way of presenting a collection of pictures about a single item, itcanbe acceptable.)
> The point of the article isn’t to dictate what design elements people use, it’s to point out more user friendly ways of achieving those designs.If your goal is user friendliness, it would behoove you to use a design which is user friendly.Using a design which is user unfriendly and asking "how can I make this unfriendly design seem friendly" seems to be approaching the problem from the wrong direction: the design choice itself is the biggest contributor to user friendliness.Either you care more about yourself and your design choices than user friendliness, or vice versa, and both are totally valid options, but don't pick the former and claim the latter.
Let's not forget the popularity of Instagram and tik tok both of which are basically carousels wrapped in an app. The problem with carousels is the expectation that they deliver more content than a simple visual (links, calls to action, paragraphs of text etc.). They're the content not the navigation.
> But carousels are still a bad ideaI too dislike carousels… But at the same time the Amazon homepage prominently features a carousel, and I know that Amazon ruthlessly A/B tests homepage variants so the carousel presumably tests well… so I’m not sure that they’re actually “bad” in some sort of universal objective way.
BigCompany A/B testing has this unfortunate tendency to demonstrate positive results to whatever you are testing. Like the A/B test that repeatedly demonstrated that after you buy a blender, your most likely purchase is another blender... (which Amazon still hasn't fixed nearly a decade later)
Avoiding triggering buyer’s remorse is something high end consumer business understand and Amazon emphatically does not. I  just bought a kayak, don’t advertise $3000 kayaks to me. Advertise dry bags and paddles and dry suits, you numpties.
It’s because Amazon is an e-commerce store. They only win if you return and buy a more expensive one from another brand on Amazon. Brands however have a brand reputation to preserve, hence the need to avoid triggering buyer’s remorse.
Are you sure that buying another blender isn't common?1. Maybe you didn't like it so returned it, but are still in the market.2. Maybe it was a gift and you now want one yourself (or vice versa)For something relatively expensive it may be the best expected value add even if the chance of repurchase is only 1%. Maybe the repurchase rate is 1% while the base purchase rate is 0.1%.I'm not sure it is, but it seems entirely possible that this is actually a smart move by the ad engine.
> BigCompany A/B testing has this unfortunate tendency to demonstrate positive results to whatever you are testing.No, it doesn't. It tests which one ismorepositive, not which is is positive.> Like the A/B test that repeatedly demonstrated that after you buy a blender, your most likely purchase is another blender... (which Amazon still hasn't fixed nearly a decade later)That isn't an A/B test.
> No, it doesn't. It tests which one is more positive, not which is is positive."positive" in the sense of "always answering questions with 'yes'", not in the sense of "positive numbers". Turns out when you start linking people's compensation to their datascience results, the results start to lean in whatever direction optimises for compensation...> That isn't an A/B test.A series of A/B tests. All the alternatives failed to produce better metrics than the status quo, so everyone became satisfied that their local minima was optimal
I believe you’re significantly overstating how good and thorough a job they do of such things. Also it’s not the sort of thing that’s particularly conducive to A/B testing.
Amazon has one of most ridiculous and terrible UI's that are outdated and difficult to navigate with so I wouldnt take anything from there to follow any standards
There's a big "if" here - IF Amazon is actually using them to maximize profit. There's a ton of reasons they might use them even if suboptimal - vendor agreements, advertising contracts, loss leading, idk who knows
Why is native smooth scrolling not a good idea most of the time? I usually add it at least right after implementing some TOC-style anchors.
I don't like smooth scrolling. Why is the website forcing me to use it?
So you don't need javascript for any of that anyway ;)
Here we are in 2023 still battling with forms (see comments about datalist and color picker) and general UX for users entering data.
It blows my mind.
Why this isn't asolvedspace is beyond me.An attempt was made to tackle this once and for all with XForms, but it never got implemented in browsers.
Instead we have virtually all CSS/JS component frameworks provide their own limited set of form elements with different semantics.
The rejection of XML technology means that the web is condemned to endless reimplement shitty versions of what it provided. We'll still be implementing our own basic UI controls for the rest of our lives.
Maybe this is a little unrelated, but why did our industry collectively pound our fists against the table and scream until XML went away? It's a little ugly and very verbose, but it's highly expressive and it has a proper schema language.I'm too young to know what happened or why. By the time I got my first engineering job, JSON was the standard choice for "stuff you need to serialize."I feel like YAML has also become the default choice in several areas where XML would be flat-out better.
I hesitate to say this, but I believe at the time Web developers just weren't really developers. Attempts to bring grown-up development approaches to the Web had to fail because they pushed  beyond the capabilities of most. Ironically, the longer-term result was JavaScript of great complexity, so that much of computer science has been reinvented -- but in JavaScript, and Web development has become astoundingly complicated.
XML is hard to read and write for humans and not efficient for machines, while the tools are complex.The benefits mentioned above are due to schemas, and not the serialization format or tool scope, all of which could be improved independently.But even if an excellent combo dropped from the sky getting everyone to use it would be very hard due to inertia.That said, some folks with demanding needs use protocol buffers or thrift, etc.  And have for a while.
Don't get me wrong, both formats have their place. I personally find neither to be terribly difficult to read or write, but maybe that's just me. Having used XSD and JSON schema, XSD is a far more complete solution that takes advantage if XML's more sophisticated syntax. I'm not sure how you'd make JSON Schema more expressive without making it hideously difficult to use.I'm not advocating for universal XML use, nor am I advocating for universal JSON use. I'm advocating for standing back and asking yourself "what am I trying to accomplish?" then choosing the right tool for the job.As for protobuf: I've seen entire companies built on it. It's amazing what your engineers can do when they don't spend half their time twiddling bits or arguing about data formats. It's a godsend for embedded developers (like me), because JSON, XML, et al are non-starters in that space.
If you’re a developer type, they aren’t too bad.  But IT and even some business folks could be trusted with editing ini files.Others won’t even try to edit xml/json and constitute the great majority of humans.json is better but the lack of trailing commas dooms it as a more general format.
The tools like XSLT and Xpath are actually very satisfying to use and astoundingly capable, especially when streaming. However, they require deeper learning than most busy Web devs may be comfortable with.
XML is brittle which makes it hard to work with.  One tiny syntax error somewhere and your whole XML pipeline fails.XSLT is powerful but harder to get right than just reshaping JSON.
Because it's ugly and verbose
It really depends on what you are using it for. The hierarchical semantics of XML makes hierarchal data so much easier to read, write, and query than anything you are likely to come up with in json. I’d go as far to argue that the whole reason we don’t have a modern equivalent of Flash is because composability  is busted because of the inadequate hierarchical  semantics of json.
> Here we are in 2023 still battling with forms (see comments about datalist and color picker) and general UX for users entering data. It blows my mind. Why this isn't a solved space is beyond me.It is. You throw it in React and get on with your life. It's only "not solved" because some people have a bizarre fetish for avoiding JavaScript and will find any excuse to wedge in their half-baked alternatives.
Uggh, as a full time React developer I cringe at the thought that React has actually solved anything. It has undoubtably advanced the front-end ecosystem considerably but by god does it feel like a brittle foundation in which to advance further. After 10 years it seems like the only things React really has going for it is that it does forms pretty well, that JSX is a great templating language, and that it is popular. I find myself on a daily basis wishing for more vanilla approaches to the problems React smoothes over.
> It's only "not solved" because some people have a bizarre fetish for avoiding JavaScript and will find any excuse to wedge in their half-baked alternatives.This isn't some "bizarre fetish," it's an issue with implications from performance to code organization to legal compliance. (No, seriously -- Domino's had to deal with an ADA suit a few years ago because their app dispensed with standard elements with default behaviors,like <button>s,in favor of unlabeled <div>s that had effectively no compatibility with screen readers.)This is a core component of alotof problems with modern webdev.Framework fatigue? Yeah, because UI toolkits frequently reimplement basic structural elements, in their own specific dialects.Bloated codebase full of external dependencies, that only workswellon fast internet connections? Well, look at all the overdependence on third-party libs, or evenoreven hand-rolled behaviors in JavaScript taking up dev time, for implementations of things that browsers support natively now.Messycodebase that needs a CSS class for every element, or even style declarations within the CSS classes themselves? You can dolessof that if you use semantic elements and modern language features -- because then you can write unique selectors without having to explicitly name everything.I'm not saying that it's without its own problems -- obviously different orgs will require different levels of support for older browsers, for one thing -- but there's a reasonable argument to be made that the current ecosystem overcomplicates this alot,and that relative to using the platform, sometimes all the extraneous dependenciesarethe half-baked alternatives.
> Domino's had to deal with an ADA suit a few years ago because their app dispensed with standard elements with default behaviors, like <button>s, in favor of unlabeled <div>s that had effectively no compatibility with screen readers.Use of JavaScript has approximately zero correlation with website accessibility. If anything, sticking with a mainstream framework makes you more likely to meet accessibility requirements, not less.> Bloated codebase full of external dependencies, that only works well on fast internet connections? Well, look at all the overdependence on third-party libs, or even or even hand-rolled behaviors in JavaScript taking up dev time, for implementations of things that browsers support natively now.If your concern is dev time then third-party libs are a great thing, and trusting the library generally means less test burden than trying to figure out what each browser supports at the moment and whether that fits with your support matrix. If your concern is performance, you have to actually measure it - often JavaScript performs better than the native browser implementation of a feature.> Messy codebase that needs a CSS class for every element, or even style declarations within the CSS classes themselves? You can do less of that if you use semantic elements and modern language features -- because then you can write unique selectors without having to explicitly name everything.CSS selectors are far more messy than using a CSS class for every element. CSS is a tarpit where everything almost but not quite works, minimising your interaction with it is the only way to stay sane and keep your codebase maintainable.
Forms aren't even a react feature. They are part of some meta frameworks and there are hundreds of packages you can pick from... Doesn't sound like it was solved to me
JavaScript is the main way of delivering attacks because it's the main way of getting a browser to do anything. Actual vulnerabilities tend to be anywhere (image decoding in particular) and you can trigger them from anything, it's just easier to trigger them from JavaScript rather than some absurd spaghetti CSS.
As the OP says, many things can be done without it.
What would it mean for forms to be "solved"? They are solved if you want to stick to boring/vanilla technologies. They are not if you insist on solving them, once again, with React, and then again with React hooks, and again and again, ad infinitum.
There are a few things a person could do that we can’t because of CSRF.Intent is not something you can work out programmatically, so we can’t have nice things in some situations.The last fancy form I worked on, I had to make sure the click event fired the form submit fairly directly so the browser would allow it.
Someone somewhere wants to submit different things with forms is why forms aren't solved. I didn't ask for a way to submit color through a webpage.
It’s not like a handful of form controls looking like Windows 95 and hyper-specific React form fields are the only options. Here’s an entire industry creating millions of components for basic fields; surely we can come up with better extensions and configuration, slots and styling opportunities that make life better for everyone.
A nice thing about using <details> instead of JavaScript is that Ctrl+F can see into the details and open them up whereas it can’t open a JavaScript accordion.
hidden="until-found" will make this possible in JS-based accordions and other hidden content but is unfortunately only in Chromium-based browsers for now:https://developer.chrome.com/articles/hidden-until-found/
MDN compatibility table:https://developer.mozilla.org/en-US/docs/Web/HTML/Global_att...
TIL, thanks for the tip!Do you know if there are other ways to hide but allow search?
Funny we just hit a similar issue while scanning for some docs..
> datalistI agree with most of these (I haven't played with dialog enough to have an opinion) but datalist is not a valid choice IMHO unless it's an internal tool. It's ugly, limited in what you can do, and not style-able. This is the problem with a lot of the "just use the built-ins" (looking at you date picker), not only are the defaults not great but you can't change them even if you want to. As soon as you hit one of the many brick walls when it comes to styling or changing behavior (Oh you want the week to start on Monday? Too bad) then your only choice often is to reach for a full replacement library that, yes, uses JS.I'm all for using the lighter-weight options and agree with HTML > CSS > JS hierarchy but sometimes JS is the only answer if you want to make your UI look nice and have the features you want.
I was implementing a search suggestion box, and thought that datalist could help. It works fine until you want to display options that don't strictly start with what's been typed in, e.g. if the input is misspelled, no options will show. There's no way to force it to display everything, so I opted for an ordered list instead.
Always worth noting that using JS to extend the built-in semantic markup is a future-forward approach. When I started working in web development, changes took up to a decade (IE6 held us all back, but the w3c was also fairly toothless back then). Now they happen quickly. Next year, datalists may be stylable in the big three without prefixing but you'll be beholden to your custom JS solution because business won't pay to rebuild. If you use JS to extend the native functionality you can always remove the JS at lower cost when the support is acceptable. Also with this approach, where the native controls are acceptable you can use it now and just apply the JS as a polyfil
Are you aware of any frameworks that take this approach? For example, if I could import their Datalist and use it, but at build or maybe runtime it decides what to use based on the target environment? We of course have this for tons of things like language features.
I don’t mean to be snarky but: have you ever worked at a company where that would be acceptable?“Hey Boss, I know this looks like shit today and is missing a ton of features but maybe one day we can enhance it”That wouldn’t fly and since I make components to wrap just about anything we use (third party or custom implementations) so I’m not beholden to it, I can always rewrite that component to use data list (or whatever built-in) if and when it grows up. Also some code gets written once and practically never touched again so my chances to go back and enhance data list as browsers progress is kind of a fairy tale, at least at all the companies I’ve worked at,
The parent advocatesextendingfunctionality of native until no longer required, rather than coding your own and having to maintain it indefinitely.Not using native as-is.
The issue is that you literally cannot extend the native functionality in many cases.
> (looking at you date picker), not only are the defaults not great but you can't change them even if you want to. As soon as you hit one of the many brick walls when it comes to styling or changing behavior (Oh you want the week to start on Monday? Too bad)For the start day of the week (and most suggested customizations of input[type=date]), it's a good thing that this is outside of your control.  The appropriate calendar to display should be locale-dependent. The user's platform already has capabilities to configure and display this is a way most likely for the user to be able to effectively use.The platform's date picker is better than whatever weird thing you custom built.
No it's not
That toggley button is so good. The front-end meme developers in this thread are absolutely seething over this post but it's a good point. Why do we have all these stupid sites made in JS? If people just followed one standard like HTML, everything could be consistent and you could easily adapt it for things like accessibility or translation. You go on modern sites and the back button doesn't even work because it dynamically loads things all on a single page.
>If people just followed one standard like HTML, everything could be consistentThat would also require browser creators to be consistent in implementation& you still have the "relying on people to update things" problem where it could be years after a new feature is introduced until it's widely enough supported to be usefulI do tend to agree there are plenty of poor implementations and convoluted JavaScript contraptions. Afaik there's plenty of standardized solutions to keep back button functionality with dynamic content and afaik the popular web frameworks support that out of the box.
Well usually the framework requires a plug-in and the plug-in requires RTFM which not all developers do. Also these frameworks and their plug-ins change and have their own dependency management that can cause code rot in short order that leads to accessibility or functionality falling off quickly. The solution to this becomes smoke testing for these already solved problems. Standardizing on built-in behavior makes testing all of this functionality the responsibility of someone not on your payroll or Jira board. I get that this isn't always going to be the solution, but that doesn't mean our code still needs to follow patterns developed to support Internet Explorer.
>The front-end meme developers in this thread are absolutely seething over this post but it's a good point.Are they actually seething? I've read the top comments on this post and don't see much that I'd describe as seething, just some people who bring up valid points about browser support.
No one is seething. HN is filled with these low quality "js developer bad" comments these days. I have no idea what a "meme developer" is.
I don't see any web developers seething - web development is complex and everything has trade-offs. I for one am eagerly awaiting a universe with excellent native HTML controls. However this golden future is still a long ways over the horizon for variety of reasons. 
This thread feels more like "never-JS" users patting themselves on the back for their choice to always disable JavaScript in 2023. Look, I get it, but we have to build software with real world constraints, and some of those constraints are plain and simple business hubris. Plenty of times I've seen a product owner demand a feature that can only be had with JS, and no amount of arguments to semantic HTML purity will change their mind as to why we can't have that same feature that Gmail has. If I don't build it for them, they'll hire someone who can.Also two separate times in the last year I've had to help a team that's using traditional MVC with no JS at all, and now they have a feature that can only be done with JS. But they have an entire dev team and no one knows JS at all. They don't even know where to start, so they're calling me in to help them retrofit it in at great expense. It would have been cheaper to just use JS from the start, and they have to pay for that mistake.Sadly this is lost on a lot of folks here. We're not using JS out of ignorance, we're using it out of necessity. We don't build react front ends for CRUD because it's inherently better to browse with curl, we do it because it's currently the most effective way to meet the needs of the business. The goals of the business rarely align with the goals of opinionated technologists, but that hardly is grounds for the level of scorn I see from that crowd.
It's a step in the right direction but CSS is another tool of abuse by what Philip Greenspun called "artistes" to make unreadable pages.  I'm not a proponent of Gemini but basically all aspects of layout and typography need to be returned to the browser, which must be controlled by the user.  Designers have endlessly shown that they can't be trusted with it.
I like the sentiment here, and the switch is cool, and summary/details is occasionally handy.  But -- the datalist element is almost never a realistic option for anything more than a toy or prototype.
My favorite "no JS, we have CSS" stuff are side bar (drawer) and carousel. DaisyUI (a TailwindCSS components library) has components readily available too :)1.https://daisyui.com/components/drawer/2.https://daisyui.com/components/carousel/
How do you announce the drawer to the screen readers?For the people down voting: Drawers and other content that appear on the page needs to be announced and needs to have a state aria-expanded next to the controlledby.This is still a genuine question. Maybe there is a way, or maybe developers collectively think that's not important (our auditors would disagree but, anyway).
Every single time I go looking for JavaScript components like this I find myself asking the same question.I really wish component providers would start explicitly documenting this. My dream is to find a component library where each component is accompanied by videos showing how each thing behaves in different accessibility tools.
I believe it is announced as soon as you add it to the DOMandmake it visible. I don’t have a computer near me to test it, but that’s what I remember when testing this stuff out a few years ago.
I’ve had to add a bunch of js to support this in the past when accessibility reports come back saying there’s no announce, mainly around css only dropdown navs.
Do you remember which reader software it was?
I'm not the person you're replying to but we test with NVDA, and we did have problems with some CSS-only solutions.
I don’t, it was a while ago and we just use js now for that sorta stuff even if it’s only for toggling aria attributes.
I'm always initially excited about these frameworks, but like all other frameworks I've tested, DaisyUI has a number of issues in iOS Safari and other browsers.It's as if authors of these frameworks severely underestimate the amount of testing required to make these things actually work across browsers. Once you have that many (themeable, no less!) components, all bets are off you'll still able to fix it without breaking existing themes and applications.
What framework is the best in your testing?
Not OP, but which framework is the best is a very subjective question. Frameworks in general make what you want to do easier to do, at least from a developer experience perspective. Generally this meets the mark for most use-cases, but has proven to be a problem (especially in ORMs) if you want to go outside of the box.
They seek to abstract complex or cumbersome logic into more consumable APIs, and in most cases this ends up being a footgun.Point I am trying to make is: learn all the nitty gritty about CSS (specificity, box layout, selectors, etc...) and really understand how the base language works. Then go play with frameworks, figure out which ones fixes the parts you don't like, and makes the parts you do like better.
Usually these frameworks don't survive a "try to click on each element in their official demo" test in iOS Safari without glaring, visual issues, so I don't see much reason to rank them.
Was this recent? I'm not 100% on the version numbers and dates, but I believe iOS support got better on daisyUI v3 within the last year or so.I remember that dropdowns work a lot better now. Do you remember which components you had issues with?
> link: components/carousel/
>> "Snap to " [start|center|end]This is new to me: What on earth is "snap" and how is it done? My screen certainly does not react to finger clicks.(Btw, I don't think that unknown methods for interaction is an especially good recommendation of an user interface element library)
> *The rule of least power*> It's one of the core principles of web development and it means that you should Choose the least powerful language suitable for a given purpose.> On the web this means preferring HTML over CSS, and then CSS over JS.Ah I totally do this, I never though to put a name to it besides taking the ‘minimal’ approach - if you can do it with just HTML, then by all means, just mark up some content and be done with it.
This was very nice!I will make an important nit. Keep in mind this is a nit. It's text in bold in the page, but this is NOT an attack on anything else in the article, which describes good design practices.There is no principle that one should "Choose the least powerful language suitable for a given purpose."This would, in fact, be an incredibly stupid principle. One want the most powerful language for any purpose. However, "purpose" is broadly defined:1) We want code to be semantic. This allows a11y tools, search engines, and various performance optimizations to understand what's going on.2) We want clean abstractions. In a horizontally-abstracted system, we would like the content designer to be focused on the content, the UX designed to be able to focus on the UX, and the back-end engineer to be focused on the back-end. (Note that, contrary to the beliefs of most people who have only worked on database-backed web applications, vertical abstractions are okay too, and break things up completely differently).3) We want systems to be bug-free and understandable.This can leads to programming paradigms like functional programming + React, where no mutation is allowed. This isn't a random restriction which reduces power; to the contrary, it increases power by allowing predictable state, avoiding a whole class of bugs, and allowing debugging with time travel.In other words, you want good design discipline. However, the point here is much more on "good design" and not "discipline."Every one of the changes proposed can be derived from first principles from the above. But this does not come from some principle of "least power."To make this even simpler: Think of diet discipline. The goal isn't discipline about being hungry and eating yucky food. The point is about being healthy and losing weight. That probably involves being hungry and eating yucky food, but that's not the point. Food should be as tasty as possible and people should not be hungry to the extent goals on weight, heart health, insulin resistance, etc. can be accomplished.Same thing here. Languages should be as powerful as possible, while allowing goals around readability, introspection, a11y, abstraction, etc. to be accomplished. That requires very specific and narrow constraints on what one bans.
> There is no principle that one should "Choose the least powerful language suitable for a given purpose."This is mistaken.https://en.wikipedia.org/wiki/Rule_of_least_power
It’s a stupid rule. Why?In my career there are two types of software projects. Ones that start off using a powerful language and libraries, and those that don’t because “this is just a prototype/small project”. 9 times out of 10 the second type naturally evolves into something more complex and requirements become harder to solve with some “least powerful” language. Inevitably a costly migration is made to a more powerful toolset, be that react, Spring, or whatever.I think it’s a bit different in infrastructure where the core of what you want is a declarative set of requirements and properties. But in SWE you’re a fool to start your project with the least powerful tools.
I think it does make sense if you consider it in terms of actual language power (a la Automata Theory) as opposed to just varying kinds of Turing-complete languages as it seems you're framing it.If what you need is a configuration language, please don't express it in Python.  If what you need is a regular expression matcher, please don't express it in a bespoke recursive-descent parser written in the enclosing language.  If what you need is a SELECT over a large dataset, don't download all rows from the DB and then iterate/filter them on the local host.I think there are many reasons for this, not just for human readability -- also for performance and security.  Berners-Lee is quoted in that wiki article as saying it helps semantic extraction, too, but I personally consider that less convincing.EDIT: automistake/grammar
> If what you need is a configuration language, please don't express it in PythonOh god please express it in  Python more so than anything else. The configuration language file -> templating the configuration language file -> scripting the templates to the configuration language file pipeline has to die.If you're going to use the simplest thing possible make it easy to throw away when the nerds get more complex instead of having to build the complexity on top. Regex is a great example -- if used internally when you need something more you just throw it away. But if you make a single static regex part of your configuration your users are stuck with it.
> make it easy to throw away when the nerds get more complexIronic but true. How often is it actually theneedsgetting more complex, and how often is it thenerdswanting to make it more complex so they can try out some new tech?
It sounds like we just need more thoughtful configuration file design. None of the tools on my computer, save systemd (which is its own whole mess), are as you describe: most of them are using data formats, and only a few are using shell, Tcl or Python scripts.
I'd say Spring and React are less powerful than just plain Java/Javascript, in fact having any framework usually reduces the "power".I believe "power" in this context describes the amount of freedom the language allows. The less powerful the system is, the better you can reason about it and the more external tooling you can add around it without breaking corner cases. A webpage is less powerful than a .exe running on your system, but that is what makes it so useful - you can run it at 144 fps, use it with a screenreader, custom CSS, high DPI (even if the webpage was written in the 90s), etc. and all of this relies on the lack of power of the webpage.
html or css is less total power in exchange for being better at some specific things.If html can reasonably do X then it's probably better at doing X than doing it js. If that rule of thumb isn't true then there's no point for js to exist at all, it would mean js is strictly better in all scenarios.
Funny, until I read this it didn't occur to me that this rule smacks of premature optimization. Odd though that often in optimizing an application after it's written we don't often consider something as high level as switching a tabbed interface to pure HTML/CSS from a JS framework plugin. I would guess this is due to cost, but I've never heard anyone articulate it this way...
Is C more or less powerful than TypeScript?
More. JavaScript is deeply constrained by design.If you're using Deno and run into the limitations of the JavaScript language/ecosystem, you use its FFI to call out to libraries written in languages like C and C++.Similarly you might address a performance issue in your C code by writing assembly code, which is the most powerful language essentially by definition, and which of course has plenty of downsides.
Can we not use language like mistaken and stupid to describe what is clearly a heuristic?
It is mistaken to assert that there is no such principle/heuristic.It's not mistaken todisagreewith the principle, but that's not what the comment you replied to was doing.
As the original poster, I will go on the record:I was mistaken. I appreciated the correction. It was helpful. The language "This is mistaken" was correct, and I took no offense to either being mistaken or being called on it by MaxBarraclough. That was a helpful comment, and it's valuable when people call out mistakes.There is such a principle. I didn't know about that framing. Now I do. Yay!I don't even disagree with the principle. I disagree with the one-liner summary of the principle, as well as the longer summary in the blog post. The principle should be stated in terms of specific design disciplines:* Declarative > imperative, when you don't need imperative* Functional > structured, when you don't need mutationsEtc.On the topic of conversations: I know this wasn't done here, but I don't even mind having my code, comments, or emails called stupid. They often are (yours are too -- aimed at whomever might be reading this -- everyone does stupid things and makes mistakes). I only mind if there's a personal subtext. Although that's not common, high-performing engineering cultures are able to discuss things people do with strong language, and having that not be judgmental of the people themselves. That's a difficult skill and culture to develop, but it's super-nice to be in one if you can get there. You can share things early (when there is a lot of stupid), learn a lot, get a lot of feedback, and give a lot of feedback.Everyone does stupid things, and organizations work better when those are caught and corrected early, when it feeds into learning (and, as prerequisite, when it doesn't feed into ego or performance management).
Thanks. The intended tone of my comment was to be factual and direct, not to be derogatory. Pointing out a mistake is certainly not the equivalent of calling someone stupid.I also agree that sometimes it's a mistake to use a language that may later turn out not to be powerful enough. Consider ugly build-system languages that were once fully declarative but had to evolve imperative features to cope with difficult cases. They would have been better off using something like Python from the start.
I will also admit to misreading the comment. I initially read it as calling the principle mistaken, but I think the word choice is perfectly fine now that I understand the target.
I was not familiar with that, so thank you, but to explain it, you need one more click, to:https://www.w3.org/DesignIssues/Principles.html#PLPIt's not simply about choosing less powerful things over more powerful ones. It's about exactly what I wrote. I'll paste the whole definition:"In choosing computer languages, there are classes of program which range from the plainly descriptive (such as Dublin Core metadata, or the content of most databases, or HTML) though logical languages of limited power (such as access control lists, or conneg content negotiation) which include limited propositional logic, though declarative languages which verge on the Turing Complete (Postscript is, but PDF isn't, I am told) through those which are in fact Turing Complete though one is led not to use them that way (XSLT, SQL) to those which are unashamedly procedural (Java, C).The choice of language is a common design choice. The low power end of the scale is typically simpler to design, implement and use, but the high power end of the scale has all the attraction of being an open-ended hook into which anything can be placed: a door to uses bounded only by the imagination of the programmer.Computer Science in the 1960s to 80s spent a lot of effort making languages which were as powerful as possible. Nowadays we have to appreciate the reasons for picking not the most powerful solution but the least powerful. The reason for this is that the less powerful the language, the more you can do with the data stored in that language. If you write it in a simple declarative from, anyone can write a program to analyze it in many ways. The Semantic Web is an attempt, largely, to map large quantities of existing data onto a common language so that the data can be analyzed in ways never dreamed of by its creators. If, for example, a web page with weather data has RDF describing that data, a user can retrieve it as a table, perhaps average it, plot it, deduce things from it in combination with other information. At the other end of the scale is the weather information portrayed by the cunning Java applet. While this might allow a very cool user interface, it cannot be analyzed at all. The search engine finding the page will have no idea of what the data is or what it is about. This the only way to find out what a Java applet means is to set it running in front of a person.I hope that is a good enough explanation of this principle. There are millions of examples of the choice. I chose HTML not to be a programming language because I wanted different programs to do different things with it: present it differently, extract tables of contents, index it, and so on."The name of the principle is ill-chosen, since it's designed to be provocative rather than informative, and therefore can lead the reader astray. The central core is actually about: "The reason for this is that the less powerful the language" in the specific ways articulated "the more you can do with the data stored in that language."
You put it very diplomatically. In my world I’m a lot more no-nonsense about the anti-react movement: they can go spend their careers making dull static websites with progressive enhancement and I’ll work on the interesting stuff without them.
This is interesting. React / Vue 3 has totally destroyed the creativity involved in webdev for me after working on multiple larger projects.Having just finished a pure JS + Petit Vue project the creativity and fun came back for me, while highlighting some important parts of the larger ecosystems.I'm still anti the newer frameworks though - and i think most are like me because of the ridiculous complexity these days, the sweetspot for me was around Vue 2, Angular 1.The newer frameworks just have too much "magic" going on, way too many files, dependencies, ever changing tooling, and no one seems to understand even small parts of it fully. It becomes about reading manuals and following conventions, instead of being creative and getting things done.Sharing simple data from one div/component to another is a good example of too much complexity; from 1 minute sharing across your app/teams through window.sharedObj, to 40 intermediate steps, 100 files, 100 imports, stores, 10 dependencies, .value.value.data.data, and extremely long nonsensical errors when your data has stranded somewhere.
> The newer frameworks just have too much "magic" going onEither that or they don't have nearly enough magic to separate the developer from all of the paradigms of the web, so they can apply their own idea with any clarity.But yeah, they sit there, at just about the worst possible spot. One can improve them by going either way.
> I'm still anti the newer frameworks though - and i think most are like me because of the ridiculous complexity these days, the sweetspot for me was around Vue 2, Angular 1.But it's the exact opposite? At least if we're talking Vue 3, literally  everything about it is less complex than Vue 2 was, especially with Vite. You're telling me that Webpack islesscomplex than Vite? At my work our 1 Million+ LOC Vue app the Vite config is like 40 lines for Prod, Staging & local dev each, and every single line of the config is dead obvious without even needing to check the docs, especially when you compare it to the monstrosity that Webpack setups usually end up looking like. Plus there's the insane speed at which even gigantic projects get built, whereas Webpack can easily take 100x the time. Hell, even HMR would take around 15 seconds on an uber powerful machine before we made the switch to Vite, where it now takes ~500ms.Sure, there's a small bit of adaptation to be made with refs and calling `.value` outside of templates, but once you grok it it's actually a lot more logical than the magical `this.` you'd see everywhere in Vue 2, since `this` can refer to a LOT of things at any given moment, and it's never 100% clear what it is.> Sharing simple data from one div/component to another is a good example of too much complexity; from 1 minute sharing across your app/teams through window.sharedObj, to 40 intermediate steps, 100 files, 100 imports, stores, 10 dependencies, .value.value.data.data, and extremely long nonsensical errors when your data has stranded somewhere.Again, this is the complete opposite to my experience with Vue 3. In Vue 2 you had to deal with Vuex and the weird getter/mutation/state stuff, whereas with Pinia you just set some state as an object, and you can directly manipulate that state wherever you want, even with excellent devtool support.And I definitely wouldn't call sticking all your state into a random `window.` object less complex than using something like Pinia, if that's your idea of less complex then I'm happy to not be working on the same codebase as you. I'd rather you not becreativewith state management like that, cause every time I've ever had to deal with some monstrosity of an untyped `window.GodObject` I've wanted to throw my laptop against the wall.Not to mention that if you opt for TS (which is like a single line in the Vite config), it's WAY more productive than Vue 2 since you now have properly typed emits and props and can actually have an overview of what data is flowing where. Plus CompAPI in general is just objectively less boilerplate and less code than the old Options API. An identical component will have much less code in 3 vs 2, especially complex ones, and ESPECIALLY once you start talking about mixins.Also, passing props hasn't changed between Vue 2 & 3. You still just pass it in the template via `:myProp="myProp"`, all the same caveats as before still apply, except now it has proper type hinting that your IDE can help out with without having to scan the file itself. If you wanna avoid prop drilling (passing data from a parent to a deeply nested grandchild component), then provide/inject (also typed) or just Pinia (which again, is dead simple in comparison to Vuex or heaven forbid some monstrosity of a `window` object) is there to help.The Vue 3 docs are also the best I've ever had to work with, and if you read through it just a single time you'll have an extremely clear understanding of how the framework actually works. No guesswork needed, and they always outline drawbacks as well as how to work around those drawbacks.
You have a million lines of in-house Vue code or is that inclusive of dependencies?
Disperesed between TS, JS and test suite and Vue files yeah, around a million LOC. Comically massive legacy app with lots of things that need removal, I'd say 30% of the code isn't even used, but who has time for tech debt when there's shitty half-baked AI features to work on eh
Thanks for the hint on Petite-Vue, it's just enough framework to my taste!
You don’t have to support, use or even like React in order to like responsive clients that don’t roundtrip to a server for every little thing. Heck, it doesn’t have to be reactive programming at all for all I care, as long as the result is good. It just happens to be that currently reactive programming is generally the least bad system to program in. But even CSS transitions can do a lot of heavy lifting and degrades well.
I promise you that the majority of React apps are effectively “dull static websites” that happen to be rendered on the client and that you can do a ton of interesting stuff without it. Here’s a full-on Photoshop clone in the browser built without any libraries:https://www.photopea.com/
shrugAnd I won't be visiting. The only thing I care about is useful content well presented. I always disable JS for security reasons (that, and because pages load a hell of a lot faster and with far less memory). Yes, things break but it's a price I'm more than happy to pay.
The interesting stuff tends to be webapps, that people pay for and are often internal to a company.If you just care about sites that are document based, of course you’d prefer the static content stuff!  But he wouldn’t be working on a project you’d be visiting anyway, so who cares if you stop visiting?
You must be the guy that thinks people are excited to use an app
Well the absolute insane amount of component/ux libs say something else. I also can't really differentiate between companies anymore everything is just shadcn with low effort chatgpt copy.
Why do you hate my device lasting long on battery so much? Some sort of tether fetish?
Do any front end developers actually subscribe to the "rule of least power"?I was a frontend dev for a few years but I was stuck at the fringes because I wanted to do things as simply as possible. I always wondered if there existed some secret island of "least javascript possible" front enders, but all I found were "create react app is great, but do you know what would be even better? a tool on top of that to help us!".
An other example of "you don't need js"  carousel :https://www.codepel.com/demo/css-carousel-slider-without-jav...there's an other comment posting a tailwind version , and I thought having a raw version would be helpful toothat's the issue with raw things, as you don't need any library, they are not marketed and it's really hard to find them when libraries take all the first results
This works terribly on mobile and broke my back navigation…
Can you precise what works terribly ? On which mobile browser ?  I m interrested as I plan on replacing our current carousels by this onefor the "it broke the back button"  isn't  because it uses anchor so it works as expected for anchor ,  i.e you get to the previous anchor before going back ? (Which can be overrided by a line of javascript if you dont want that behaviour, but at least you can link to a specific slide of the caroussel )
It scrolls the screen to the carousel on click, and every click adds to page history so you need to click that many time to back out.Just because you use an anchor tag, and anchor tags add to page history, doesn't automatically make it "working as expected". It's unexpected behavior for the user.
Sorry I meant "its working as expected per the spec",  which is not what the user expects I agree with you on that (I may differ that it depends on the context for example  if the caroussel is the full page on mobile ,  in which the fact it scrolls to the carousel are unimportant , which is the use case i intend to use them on)My point is  its different from "it broke the back button" , when you use the table of content links in wikipedia they have the same behaviour and you don't go that it broke the back button
Thank you !  As you may have guessed English is not my first language.
My pleasure. Grammar nitpicking tends to get downvoted (as happened here), but my intent is to help educate. Glad it helped!
This is anecdata but in my experience the way WebDev (esp. HTML and CSS) is being taught in academia is very crusty. I've seen Juniors enter the workforce with a solid understanding of table-based layouts from the 2000s for some reason.
The other end of the spectrum: I’m seeing graduates with great knowledge of frameworks, but no understanding of the fundamentals that these are built on. It’s all fine until they’re trying to debug a problem and don’t know where to turn.glares at Tailwind
That's not a tailwind problem that's an educational one.
I guess it's a sign of the domain expanding (exploding, really). "Software development" is not a single discipline, even though it's still taught as such in many places.
I mean you can't really use Tailwind if you don't understand at least some of the underlying CSS. It's not like it does anything magical for you, it just gets rid of having to give class names to things and has some nice little utility functions as well such as `grid-cols-x`.
I'm ok with window.prompt(), window.confirm() etc
I was disappointed it wasn't there.In my experience, managers will complain but the users don't actually care and just want something that works.
They're mentioned in the dialog section.
Moreover, unlike dialogs they are immediately accessible.Dialog was rushed in without fixing many problems it has because Chrome (and apparently other browser, too) want to remove prompt/confirm/alert.
Removing prompt/confirm/alert breaks the web for all sites making use of it going back to the JS 1.1, so that has to be a no go.
The custom switch was honestly kind of impressive
From the UX point of view I very much prefer the oldschool way of „ticked“/„nonticked“ instead of „left/right“ switch.
To me, they have slightly different semantics: I perceive the checkbox as “passive” form element (i.e., only to have an effect on form submission), whereas the toggle switch I understand as instant action (i.e., effectuated immediately, on click). Unfortunately, it’s not consistently used that way in practice, which makes the situation confusing at times.
I wonder how much the culture you're used to matters for this. What if you grew up with right to left writing system. Should your switches have the off state on the right?
Britain has their light switches operate the opposite way around to the USA.
Edit: my mistake, the first custom-styled switch example isn’t the full example. I realized that after I commented. Original comment below for posterity. It doesn’t apply to this case, but I think it’s still relevant as I’ve encountered the mistake IthoughtI was seeing in “you don’t need JS” contexts pretty frequently. In any case, sorry I misunderstood the example in the article.The custom-styled switch doesn’t work on iOS Safari. It certainly can work without JS, but this kind of mistake is potentially informative in evaluating whether it should.That’s not to say “if you want a custom-styled switch, JS is a better way to achieve that.” But if you’re already starting from the premise that HTML has a functional equivalent, it’s okay to use that for the default behavior and enhance it with JS to ensure it’s interactive when it’s enhanced with CSS to satisfy a non-standard design.
Author here. The first styled example doesn’t have the style to respond to the checked state. I explain that in the article right below the example.
Did you try all of the custom styled switch example? The first one didn't visibly work for me on Safari but the others did - the examples are meant to build up a demonstration of the final pattern.
I was just coming back to edit my comment to acknowledge this. My bad! I think the principle still applies, because I have definitely encountered the mistake I thought I was seeing here. But it doesn’t apply to the example. That’s what I get for commenting before the morning coffee sets in :)
Nice to see encouragement to avoid javascript :).  Dropdowns that require javascript are particularly common (and unnecessary).It seems on Firefox, focus-visible only appears when tabbing, not when using the space key to toggle.  Not sure why that is.
Great article! Very clear. Nice examples.I have some complaints about how Firefox handles these features, though. Closing modal dialogs with the escape key doesn't seem to work, even though it's described in the docs on MDN [0]. It does work in Chromium.Also, the native color picker in Firefox is really weird: The Custom/+ button triggers onmousedown, which feels surprising and disconcerting as a user.[0]https://developer.mozilla.org/en-US/docs/Web/HTML/Element/di...
After a decade of personal exuberance building SPAs, I've been heavily trending towards HTML first/only for several years now. I had to kill my excitement for Web Components in the cradle because they (until recently?) don't support decorative HTML-only uses.In my mind there's a hard separation between website and web app.If you're just a site, you don't need JS and should only use it for progressive enhancement.Web apps I have no problem throwing a "You need JS to use this app" error.Use the right tool for the job. JS is an awesome hammer, but it sucks as a screwdriver.
"It's one of the core principles of web development and it means that you should Choose the least powerful language suitable for a given purpose."That's one of the core principles of web development? Why? I'm prepared to be embarrassed, like a "senior dev" who asks "uh, what's polymorphism?" but... I've never heard this "core principle" before and I've been doing web applications since DHTML displaced java applets.
I think the author might be referring to "Principle of Least Power" or a similar general programming trope which is more or less useful today, depending on who you ask. I.e. see this short write by Tim Berners-Leehttps://www.w3.org/DesignIssues/Principles.html
The datalist element didnt work for me on Mobile Firefox (Fennec)
This has been a known issue for a long time.https://bugzil.la/1535985
Couple items.- input type="checkbox" - It would be nice if this wasn't so janky to have a different look / function to your checkbox.  Like some secondary type you could just apply, such as: subtype="toggle" or subtype="tristate" or subtype="cycle"  Its weird you have to hide all the normal elements and then intercept all their functionality.- HTML "dialog" - I like the element, because of "dialog::backdrop", since applying effects to the background for a dialog helps with UI focus.    "backdrop-filter: blur(4px)" is also pretty cool.It would also be nice if it "actually" behaved like a div.  Tried implementing it on a project [1] with UI popups, and found out it displays different for show() and showModal() [kinda weird], and also has a massive hidden margin.Apparently "backdrop-filter" can be implemented on normal divs though, so gonna try that approach.[1]http://forsako.rf.gd/AmericanCities/LibOfCongressGame.html
The thing is, that sometimes javascript is a lot easier that 40 lines of css.
Yes, but the 40 lines of CSS puts the logic in the right place.The point is that a person reading system logic shouldn't need to be distracted by layout, and a person worried about styling shouldn't need to think about code.Whether that matters depends on the specific system and the types of abstractions used, but it can be very important to making code maintainable, and in some cases, org structures practical (where the team maintaining the CSS might not be the same as the team maintaining the system logic).
The big thing you didn't mention is accessibility. Unless you know exactly what you're doing, just a few lines of javascript will let you break a user interface in so many subtle ways.
All the examples in this blog post use CSS to implement the functionality of the widget, not just appearance of them. By your own reasoning, that should be handled by JS, not CSS
JavaScript on the frontend is not intended for "small changes to the layout without reloading the page", it's intended for changes to content. CSS is one of the tools intended to manage layout and appearance.Is itpossibleto use one for the other? Of course.
> Don’t listen to people who try to tell you how to program.This worked for me:* DO listen to people who tell you how to program* Listen to many types of them (Microsoft programmers, functional programmers, Unix systems wizards, digital logic designers, UX designers, etc.)* Do what they tell you for at least long enough to understand why they're telling you what they're telling you to do. This requires a very open mind. A Unix programmer stepping into a Microsoft shop or vice-versa will find many things which go against their most core values.* Understand the underlying, fundamental, first principles their best practices derive from (keeping in mind some of those first principles are incorrect -- especially within the Microsoft community), and different ways people have figured out how to structure code, the upsides and downsides of each, and how they mix-and-match.* From then on, program from first principles when you have time, from best practices when you don't, and quick-and-dirty hacks when you really don't, or are just having fun.
>> JS for UI is wrongYeah that’s showing an incomplete understanding of web application development.
Yeah, the 90% of web apps whose UI is broken, I don't understand them. Haven't we all seen multimillion $ airline mega web apps that can't present a decent form?
But it's also too often broken, fragile, and the worst sin of all, break default behaviours of browsers. It is the price we pay for html having been stale for 15 years between the late 90s and 2012-ish.
As a mostly backend guy that's the case most of the time for me.I never really got my head around the correct way to think in CSS.I am at the "I can see numerous ways of doing this" but I never really know the standard or best way to do it. It was the same when I started doing web dev / Django stuff, whereas now, with years of experience, I do know the best way to approach a problem, to keep code minimal and clean and readable.(If anyone can suggest some tutorials that get me past that stag with CSS I would  grateful).
https://every-layout.devshows how to leverage CSS properly, from first principles.
Thanks, I'll check it out.
The correct way to think in CSS is to think in HTML, which has the functionality we need (like a checkbox etc) and CSS is an enhancement on top of it. Ditto JS.
Of those 40 lines, many are styling to create the look of the switch in css, it could have been replaced with an image (and needed for a js solution anyway)
In general, good advice.... But the trade-off is lack of control, and that can be a problem. The author notes, but I think under emphasizes, that the color picker, for example, has no standard on how it should be implemented and so browsers are free to choose. The Safari color picker, in particular, is so bad that color picking is the one thing I recommend people absolutely roll a custom widget for, unfortunately.And, in general, if you go this approach you are trading off needing to care and feed for your own widget solution with needing at least a passing understanding of how the browser-implemented widget will operate in every browser that your team will choose to support actively. And the implementation spec for browser widgets is far more open-ended then the constraints placed upon a JavaScript implemented widget with assets you have created from scratch.
> The Safari color picker, in particular, is so badWhat's bad about it? Can't test it on desktop right now, but on iOS it opens all the bells and whistles, including the "pick color from anywhere on the page".What used to be horrible across all browsers is the date picker: tiny buttons, tiny numbers etc.
On desktop, the color picker in Safari has two stages: on first click it presents a 10x10 grid of colors with 10 extra basic colors on top, with a “Show Colors” button on the bottom that opens the macOS system color picker.This is actually a bit better than the picker implementations in other browsers because it gives the user a chance to use any colors they’ve saved in the system picker, as well as any color picker plugins the user may have installed.
Yes, but tell that to my clients who keep telling me "Why can I choose any color in Chrome but in Safari I'm limited to a crayon box?" They either can't use color picker plugins or they can't figure out how to access them.And there's no language in the declarative API to, for example, start the user on the Mac OS system color picker.
Great read. We have been trying our best in the project I work on to rip out as much JS as we can and implement things using the right html tags among other things.Frankly, JS for an open source project used by thousands of users is a nightmare. This was a reason we have done our best to remove it and provide much more stable uses through yaml that then is used to construct the correct html rather than the spaghetti of JS from before.I’ve come to view JS with a lot of skepticism the older I’ve become. People are free to use it, but I do hope web assembly gives more choice in this monopoly, which I believe is the only reason people fundamentally use JS, though they will invent many reasons why “it’s great!”
Do you have a link to the FOSS project? I'd be interested to see the specific JS (and YAML) code that you're referring to.My experience over the years has been that the language and tech stack matter much less than the discipline of the team. Rewrites always feel like a huge improvement for the first few months, but as time wears on they become just as convoluted and bloated, either because the domain is inherently complex or because the team thought that the old tooling was to blame for their own poor coding discipline.I find it particularly interesting thatYAMLof all things is what you've turned to as an improvement. You'll find plenty of people on HN and elsewhere who've learned to avoid YAML like the plague because of bad experiences with it, so it seems clear that it's notobjectivelya better choice than JS for avoiding spaghetti.
If the admins using your project are sys admins, they seem to prefer yaml. Shrug.I hesitated posting just because I had a feeling this would not make sense. The project is for super computers and so it’s niche for the admins since they are overburdened at their centers and don’t have time or sometimes the expertise to role their own JavaScript to do advanced things with a form that is then used on the backend to submit jobs to clusters and apps on HPC systems.But this is a niche. My perception of the web dev space is it’s a mess and often has endless debates that do nothing for users, and much of the mess and debate centers around JS, a language that is the only choice (a monopoly) which then claims to be a great choice (how is that choice? Seriously, I’ve never understood that statement).
>> Choose the least powerful language suitable for a given purpose.No. Choose what you like, what you enjoy, or what the boss told you to use. Ideally the project defines prioritize that give guidance. Otherwise do what feels right.Don’t follow some arbitrary doctrine.
Do this only if you don't care about the people that use (sometimes: have to use) your software. Otherwise,>> Choose the least powerful language suitable for a given purpose.(Don't make me needlessly enable JavaScript to use your site.)
>> Do this only if you don't care about the people that use (sometimes: have to use) your software.Rubbish. Web technologies are way too sophisticated to boil down to some silly rule of thumb that “the least powerful technologies are the” best in some way.As a professional developer, use every technology at your disposal and use it in whatever way you like, including the most advanced techniques.Ridiculous to be given the most one of the most powerful development tools ever made - the web browser - and artificially constrain how you use it for some dogma.And if you’re a junior developer, ignore people who tell you how you should program - do it how you like unless the boss says different.
The article seems to be suggesting to remember to use the power the the web browser already provides instead of needlessly using frameworks.The walkthrough in the article seems to demonstrate pretty effectively that the powerful development tools offered by a modern browser may obviate the need for elaborate frameworks in many cases.Where this is the case, then, relying a framework instead of the tools the browser already provides artificially constrains an application, potentially for dogmatic reasons, and regardless of a developer’s level of advancement.Browsers have rapidly come a long way even just in recent years. Frameworks well and truly have a place, but narrowly relying on frameworks, particularly out of beliefs about browser capability established years ago (like when React was introduced), can neglect browser-native functionality that can provide same-or-better results, with potentially better outcomes in performance, accessibility, maintainability, and more.
> As a professional developerThis qualifier probably applies to >90% of this website’s audience, so I don’t think it’s useful.Using less power if you can get away with it is absolutely sensible. If my implementation is suitably robust without the use of type families, data kinds, singletons, lenses,etc., then that’s a more economic solution.
Sure, I guess. Just act like all of those vision impaired folks don't exist, and put the entire website in JS that their screen reader can’t handle. Nice.
Remember kids, if a minority is a "rounding error" it's okay to ignore, block, and hurt them though your profession. That's what webdevs tell me.
It's even more ridiculous to bring the browser to its knees, destroy performance, and accessibility, because the trendy framework made your dev life easier.
Your web app is most likely rubbish and 20 times as complicated as it needs to be, and probablystillnothing special.A website that requires JavaScript is, and always will be, worse than one that accomplishes the same without JavaScript.
> A website that requires JavaScript is, and always will be, worse than one that accomplishes the same without JavaScript.Are users happy? Is dev speed of improvement good enough? Can you onboard new devs easily enough?That’s it. Nobody cares if you used CSS or JS for a toggle switch.The only people who disable JavaScript in their browsers and expect the 2023 internet to accommodate them are right here in this thread.Just componentize it and move on to solving the next business problem, not the next code elegance problem.
I don’t know exactly where you’re going, (and to be fair the parent comment is rude) but it’s wise to be humble even if you are a professional. Some of the most experienced people in the field frequent these threads, HN is not a monolith of neo-luddites.My 2 cents: native solutions like HTML and CSS are preferable: they are designed to degrade well, they work with screen readers, with increased font size, high contrast, and other less-known or unknown and even future use-cases and needs. No dev team has the time to test their custom JS solution on all possible browser targets, and in reality they frequently fail even basic accessibility needs for no good reason.At least to me, honoring the principles of the web is our responsibility, especially in our current time when they are arguably under attack from well-funded players. I would hate to see the web degrade into a delivery mechanism for opaque executables that work only on corporate blessed mega-browsers.
> they work with screen readers, with increased font size, high contrast, and other less-known or unknown and even future use-cases and needsWhere does this idea come from? I’m seeing it all over these comments, and I strongly suspect this sentiment is coming from people that haven’t actually looked at WCAG or been tasked with creating a compliant accessible website. You can botch the contrast, hard code font sizes in pixels, and leave out pertinent navigation details for screen readers with plain HTML and CSS. Here’s WCAG if you don’t believe me (emphasis mine):> Myth No. 9: Pages With JavaScript Cannot Meet WCAG 2.0: FALSE
WCAG 2.0 was designed to allow many new modern technologies to be used and still provide accessibility. Pages with JavaScript can be made to conform to WCAG 2.0. It is also possible to write pages with JavaScript using the JavaScript in a way that would make the pages not conform.It is also possible to create a page using only HTML which do not conform.[0]There is nothing about using JS that makes a site less accessible, and there is nothing built in to HTML to make a site automatically accessible. Theonlyway you’ll have an accessible site is by testing it manually and bringing in users to find edge cases.[0]:https://www.w3.org/WAI/GL/wiki/WCAG_Myths
> Nobody cares if you used CSS or JS for a toggle switch.Other than the people who have to wait several minutes for your 20MB JavaScript framework to load on their slow metered connection just so you can make an expandable section using a bunch of <div>s rather than the native <details> element. But those people don’t matter because they should just move to a country with unlimited fast internet, am I right?
Vanilla JavaScript is supported natively by all web browsers now.Nobody is suggesting using a 20mb framework to make a toggle switch work on a standalone page that isn’t a web app.If you’re building a web app either way, then choosing between a screen full of CSS or a handful of lines of js is negligible.For expanding sections, you should use native HTML elements when they do the job with less effort/code. You should use JS when they don’t.
> Vanilla JavaScript is supported natively by all web browsers now.What a strange statement. 'Vanilla' JS has been supported 'natively' in browsers since the late 90s.
Or these people are execs on business trips on terrible hotel or remote connections.
Nobody cares because people have been trained on crap software for decades and don't know what it is capable of when optimised well. USP opportunity, anyone?
Sure, maybe if it accomplishesexactlythe same. That’s why I disable JavaScript on most news sites. But in the real world most web apps simply can’t accomplish the same without JavaScript, which is why we use JavaScript.
> (Don't make me needlessly enable JavaScript to use your site.)Only a very small but vocal minority of users disable JavaScript, as it's not a default setting in any of the web browsers with a market share higher than the rounding error.In a lot of cases, designing a no-JS website disadvantages both the service provider and the users:- the service provider has to support a higher load to render the page and process the data on the server,- the user has to endure longer processing times for their data, since their request necessitates a round trip from/to the server adding additional latency.For example, let's think of an image processing web app. All of this can be done on the client side (and this gives the user a higher sense of privacy since their data doesn't need to reach the server). It's much faster there, reduces the server load - allowing the service to be used by more people at once.And there is no value in appeasing the no-JS minority, since either maintaining a no-JS version of the app in parallel, or building the entire app without JS, outweighs the potential ROI from the <1% of users[1].If you disable JavaScript because of tracking and ads:- browser extensions exist to only prevent tracking JS from running without affecting the websites,- you can still be tracked server-side.[1]https://gds.blog.gov.uk/2013/10/21/how-many-people-are-missi...- 0.2% of users of the UK online government services had JavaScript disabled. Based on the research I can find online, most of the no-JS users are using TOR, which isn't a terribly profitable demographic for commercial websites.
Many websites that use JavaScript, particularly news sites, would bemuchfaster without it.
True. As an user, I just don't visit websites that disrespect me, though.I keep JavaScript always on and if I see a website abusing my trust, I just blacklist the entire website from my browser and never visit it again.As a developer, all of my publicly available personal projects feature no tracking, no advertisements, and no third-party JavaScript in general. JavaScript is a really good tool, but as any tool can be, JS can be misused.
> No. Choose what you like, what you enjoy, or what the boss told you to use> Don’t follow some arbitrary doctrineIsn't choosing what the boss told you to use simply because they told you to following arbitrary doctrine?If someone has a reasoned argument for a specific tool they should share it, at which point you're picking it for that reason not because of the boss said toDevelopers, engineers, whatever need to be responsible with the product they make. Part of that means making tool decisions that fit the specific context and pushing back when necessary
Good spirit, I was just recently seeking reference materials about how to execute an accordion style fold in pure html or CSS and discovered the approach you describe - so simple, we should be seeing it more often.
I use them and doing so saves a lot of time developing. Problem is that managers will complain that they are too simple. At least that's my experience working with "enterprise" consultancies
I'd like it so that there's one thing that handles everything.I don't like it where there's react for complex stuff and then another pattern for simple stuff. It's hell either way. Just one thing that is simple and can compose to complex things. Not different patterns to handle different levels of complexity.Any api should be simple and compose-able into complex things. Here we have (react) which is not simple and not de-composable into simple primitives. ANd we have html without JS which isn't composeable into something more complex.
There sure is a lot of positive responses to this, and I get the draw of removing JavaScript. I usually find myself feeling more optimistic than the peanut gallery...But, at least on this device (Brave, iOS) some of the mentioned features just didn't work (e.g. emoji accordion) or were awful experiences.The autocomplete drop-down seemed very broken and both the checkbox and modal especially felt very sluggish. Like I would look for an alternative sluggish.I've had plenty of positive no-js experiences, but this wasn't it.
This is literally the first of these articles where the examples work without JS. Everything else I've ever seen posted here usually has the snippets hosted on some CDN and requires JS to work.
Why is choosing the least powerful language for a given purpose a core principle of web development? If a language has flexible abstractions, it can make hard tasks possible, and ALSO make simpler tasks easier. Whereas a language with clunky mechanics makes simple tasks complicated and hard tasks virtually impossible.
For the same reasons that using fewer moving parts is a principle in engineering more broadly.
A language feature isn't a moving part. I would say that what makes a language "powerful" is the capacity to express complex concepts simply.CSS and HTML are not a languages built for expressing complex concepts at all
I think you’re familiar with metaphors and that this is a display of obstinacy.
"Moving parts" is a metaphor for pieces of a system that add operational complexity, and it's not a useful metaphor in this case because a language just having some feature doesn't add any operational complexity
Well, I have to disagree, and I'm not alone on that.This is the entire premise of Douglas Crockford's book,JavaScript: The Good Parts.
Friction and wear?
KISS.
Actually, for accordion (i.e., details and summary), as I understand it, is not accessible out of the box. It's odd that the spec for that control / UI element / tags isn't accessible. But you can use JS to fix that.A colleague once shared a blog post with me on this but I can't find it atm.
My principle is always: The principle of the most power.I would use that to do simplest thing as possible, or i'm not afraid to do the best thing possible.Let's say you start with pure html, now how to decompose your HTML into multiple components with state ?Start with component-approach instead.Compiling to HTML is just the implementation detail.
Article has a typo, now instead of not. "In contrast to JS, which is imperative, HTML and CSS are declarative. You tell the browser what to do, now how to do it. That means the browser gets to choose how to do it, and it can do it in the most efficient way possible."
I bet you could use the <details> element to implement the show/hide comment behavior on hn
The answer is always: of course you don't. But weaving in clever HTML like this is a pain in the ass to maintain, when you can drop in a reusable, extensible widget for your framework that has already been debugged and is one line of code that everyone understands.
Love this. I make heavy use of dialog elements on WireHub.org, along with bootstrap classes to achieve drop downs that work without JS and still look nice.Only issue is you have to click the summary element to hide the dropdown, and that's where I cheat a little and use JS to hide it.
The detail/summary element is a very common need, I had no idea it was so well implemented.
100% agree that everything doesn't have to be JavaScript. You can do a lot with just HTML and CSS.My company's website is all HTML/CSS -https://neuml.com
Nothing really impressive to be honest, that's just a basic site
The point wasn't for it to be impressive. It's that if you want to keep it simple, you don't need JavaScript.
Some weird issue with <details> in Safari on iOS is that "open" attributes could disappear when iirc overscroll or something, so I was force to use JavaScript or disable overscroll behaviour.
Other good example where no JS is needed: styling internal and external links
The whole JS/npm/react world is a black box to me now. If someone told me I needed to sacrifice a chicken to get a website working I wouldnt be surprised...
But need Javascript for advertising and tracking.  If this is incorrect, I'm interested in any examples where Javascript is not used and what percentange of online advertising this comprises.
Last time I checked, Carbon Ads don't use JavaScript, although it is not atargetedadvertising business. As for analytics, there is a considerable amount of personally identifying information you can collect exclusively with User-Agent headers in your sites' requests, and of course the age-old technique of tracking pixels still works in most cases.
Bear blog uses css for tracking
Why do you need it?
Wish I had read this a month ago before I wasted hours fighting against some of these things in tailwind and JS. That color picker trick is awesome, and the styled toggle switch looks extremely slick.
Notably, many of the features championed by this article just don’t (yet) work on mobile Safari. JavaScript is used because it (usually) works everywhere, unlike niche browser features.
It has to be usable by users with ten-year-old browsers. Now what?
No it doesn't
Your move
Relevant:https://enhance.dev/"The HTML-first full stack web framework"
Well there you go.I've been using dialog a lot but every time I've been hacking some backdrop around/behind it.Had no idea about the property, that's great.
details / summary is an important hack when writing bots that post comments to GitHub PRs or issues, such that the details are hidden unless the user clicks on it, and thus helps keep the comments tidy instead of each comment being really, really long.It does, however, run into the 64Ki character limitation per comment. So HTML5 magic isn't by itself a magic panacea.
You can have modals with pure CSS and HTML though, that is how websites compatible with Tor do it. No need for JavaScript.
> know that [outline: none] not a good ideaWhy recommend a style on summary:focus but not input:focus?Shouldn't we style :focus-visible for both or neither?
I'm sure you can convince some people once "CSS programmer" starts generating hits on job site searches.
This is amazing. I'll be studying all of this and applying it to my site as appropriate.
So the unofficial (?) input:before is safe to use now, what's the consensus?
Really nice. Some elements I wasn't aware of. Will def come back to this.
Designers hate native forms for some reason. (job insecurity?)
Because they look bad and a designer has to make things look good
In other news, you don't need a native app for that.
It is not supposed to, the code is completed in the third example.
they explain that it works but you need the next step to see it
> Of course, designers may not like the way this looks and we want to create a great looking custom switch.The general UI rule is use a switch when toggling has an immediate impact (similar to pressing a light switch) vs a checkbox when there's a submission step before it has an impact (similar to ticking a paper form then mailing it). See:https://www.nngroup.com/articles/toggle-switch-guidelines/.It made sense after learning this but I didn't find the difference that intuitive before. A lot of UIs get it wrong (e.g. switches in forms, checkboxes for settings that immediately change something) but it only bugs me now I know which one to use. It's not only for cosmetics though.
I wish someone came up with a better UI than the toggle. Usually, I understand what it means, but I often find toggles where it isn't clear what the state of the toggle is. Right vs left, color vs no color, just isn't obvious to me. A visible check in a box is crystal clear.
A toggle works fine if it's not treated as boolean, due to the exact problem you mention. What fixes it for me is having the meaning spelled out on both sides of the toggle, e.g. like this:dark (o  ) light
I agree, but it seems like a lot of times you get:(o foo)
    (bar o)And I don't know if I'm supposed to click it to change to `foo`, or if that means it is already in the `foo` mode.
That's definitely much worse, both due to what you describe, and due to the fact that you don't know what the label on the other side says.
Separately, some UI's make it very hard to tell which side is selected. It's a rare problem, but especially anxiety-inducing for me when it does appear.
(o   ) "Do you want to receive marketing emails from our partners?"This is absolutely a dark pattern.
Even worse when there's not even a grammatical structure, like"opt-out options""annoying marketing emails (o )"am i... enabling the thing? opting out of the thing?
It's also a stupid pattern. Privacy and spam laws usually require informed consent. They might as well just not ask for anything, because any consent they get this way doesn't count for shit.
This can be used as a dark pattern. If you want a user to use a particular setting (e.g. “Customize my ad experience.”) you can just make it unclear which they’re choosing.
The worst offender to me is the ambiguous ui around creating a teams meeting for meetings created through whatever we are calling the outlook web thing these days. You don’t find out if you did it right until you have sent an email to your attendees with an erroneous teams link. And yes that is anxiety provoking.Of course part of what makes it ambiguous is that there is a setting somewhere completely different which when set will add a teams link whether the slider is set or not.
> are you using anxiety with a bit of hyperbole here, or is it really making you anxious?Depends on the setting. Sometimes they're for things that have greater than usual effects, like getting locked into a subscription payment or agreeing to additional charges for Spirit Airline flights. Other times they're for things that I have difficulty taking the initiative to address, like notification/unsubscribe settings, for which my ADHD only allows me occasional "windows" of time where I'm able to initiate or follow-through on changing the settings.Sometimes it doesn't really matter and I just scoff at the bad UI and it's not a problem.
(I'm gonna abuse your example to rant about dark mode selection interfaces.)There's a small problem with your example: Dark mode isn't a binary setting.For modern applications, there should be 3 settings: System, Light, and Dark. (I like to use a dropdown menu to select the theme).This makes it work for people whose theme changes automatically between day and night (it's a built-in system setting on macOS, and possibly Windows). LFor a web app, Light and Dark can set a value in localStorage which sets the theme manually, but System should remove the setting.You can detect the correct theme when the page is loaded, and also add an event listener to detect theme changes (so that either the user or the OS can change the current theme). It's actually not too difficult to set up properly.
I think the first widespread use of a toggle was in iOS a long time ago.The core function of a toggle is to - well - toggle.Off (o  ) OnAnd the way it was used wasDark       (o  )or
    Dark       (  o)
Radio buttons would work better.
It depends on the structure of your site. If you have, say, 10 pairs of boolean options in quick succession, toggles work way better than radio buttons.
Switches seems like an innovation that just makes UI worse.Checkboxes are easy to understand.If there is immediate effect then using a checkbox also works perfectly fine.The switch is just always worse (IMO).
> Switches seems like an innovation that just makes UI worseI once visited a site that had a hamburger menu holding the navbar that auto-hid if you clicked away. They also had a switch on the corner of the opposite side of the screen that opened the navbar and kept it openI still sometimes wonder what was going through the UI guy's head when they made that
Total aside: but related to ambiguous true/false designation: A lot of times when people write articles like "Ten Myths About NodeJS", it is unclear in each of the numbered items whether the stance initially described is theincorrectmyth, or thecorrectview as proposed by the author. To make it worse, some writers vary the structure between items!
>  A visible check in a box is crystal clear.For the "off" state though, I've never found an empty square outline being that clear (this looks similar to a button or a text field) or easy to spot, and a cross/X in the square instead can also be confused with "on". Not saying a switch fixes this however.
The most annoying toggle is the Spotify no-repeat/repeat-all/repeat-one button. Is it currently not repeating? When it has the dot, is it repeating one song, or all of them, and will pressing it make it repeat just one?
Agreed. The Spotify UI is bad in general, but this one especially. I’ve been using it for years and I still have no idea what I’m doing there.
The article linked by the commenter above addressed your concern. They mention the toggle should have an _immediate_ state change. I really liked the iOS airplane mode example the article used:> When turning airplane mode on for iOS, Apple provides immediate results by changing the cellular bars in the upper left-hand corner to an airplane icon.To summarize, it sounds like the toggles you've experienced haven't led to an immediate state change, which likely identifies them as better candidates for a checkbox like you mentioned.
Yeah, too often. But that's not the toggle's fault. The majority of the time the design (colors) and the associated label are the root problem. A toggle doesn't have to be ambiguous. Unfortunately, designers / UX'ers seem to think so.
A big offender here is (was?) instagram’s privacy settings. I recall trying to help my mom turn her profile to be private and we were both confused: does the blue mean it is private or not?
Honestly, besides being standard, checkboxes solve all of your problems.That separation between immediate and delayed effect seems quite artificial to me, and doesn't exist at all on other types of inputs. It looks like a bad, post-fact justification created just to placate some masses instead of for good fundamental reasons. (And yeah, I do know who I'm criticizing here.)Anyway, it's a lost battle, so whatever, let's leave with the bad consequences.
I personally had not heard this but it does sound intuitive to me. A checkbox is literally something you would check on a form (i.e. piece of paper) before handing it in. A switch on the other hand, it something that offers immediate feedback in the real world.
It’s a useful distinction but frustrating to apply in practice because we don’t have a similar convention for many other UI elements like input fields and date pickers. You can’t tell at a glance whether these will produce an effect immediately after entering a value, or whether there is a separate submission action.In terms of primitive types and common UI platforms, we have this immediate/deferred distinction for booleans and enums.Booleans are represented by checkboxes vs. switches as already discussed. And enums are represented by radio buttons (the traditional form element) vs. multi-part buttons (which Apple calls segmented controls).
Idk. There are enough switches that don't have an immediately noticeable effect, e.g. when you have to open a panel to turn things on or off, or when you have to go to another room. It's always hard to come up with the perfect definition/metaphor, but perhaps it's more like an operation that has a lasting effect.But like designers shouldn't overdesign, we shouldn't overthink what's "correct" use. If it works and/or feels natural, it's ok. If it doesn't, it's time to consider alternatives, but you shouldn't implement them because some rule says so.
I can absolutely see this. But to share a different perspective since “instantly vs. submit” doesn’t make sense in some of my software that’s constantly applying input changes on change:I use a switch to toggle one specific thing, checkboxes to pick zero, one, or many related things.Eg: switch: “slow mode is active for robots in this zone.” Checkboxes: “this applies to robot types A, C, D.”
Apple can scarcely pretend to adhere to it, but their HIG on checkboxes, radios, and switches is good:https://developer.apple.com/design/human-interface-guideline...
Also worth noting that on macOS (where you’d see checkboxes), things like settings dialogs very rarely have “save” or “apply” buttons, with any settings changes taking effect immediately. Checkbox vs switch has no bearing on immediacy.The only exceptions are cases where partially applied settings can cause problems (like network settings) and the odd holdover that’s survived since the pre-OS-X days (like the settings dialog in Music, previously known as iTunes, previously known as SoundJam MP).
Great addition, thanks.
Not so ironic now - as there aren't really good alternatives to a build step with a static site. But my opinion is that that may change now with the adoption of HTMX for static sites. There doesn't have to be a build step since you don't have to build full pages from their constituting parts.
You do realize that HTMX is a Javascript library?
Of course I do
Nothing ironic here. It's a different domain problem and they're using a different domain solution for it.  The generator might simplify an otherwise much more complex problem down to its essence.
> During the past 5–6 years of my JavaScript experience, every time I wanted to go back to any of my projects—from tiny to big, server-side or front-end—there was always a challenge, a problem to tackle or an obstacle to overcome before I can update or sometimes even just run my program.why i moved mostly from writing node cmd tools to using bash. don't need to go on a bunch of side missions every time i run npm installnot enough pragmatism in the JScommunity(people). more about hot new thing as opposed to boring long term stability. maybe because of web/chrome as a constantly moving platform, and Apple/Jobs app-ification of everything, relative young age of JS community.
It's funny.  The issue described (inability to replicate the conditions to build and/or run the original program using NPM) is something that gets brought up a lot, but people will appear who are downright adamant that it's not a problem.  Not just that it's not prevalent enough to be concerned about, but that they've literally never seen it happen ever.  We're living in completely separate worlds.And let's be clear: this is an *NPMJS* problem, not a *JS* problem.  For folks who have read and written lots of JS before and during NPM's reign over programmers' attention and will continue to do so afterward (when NPM as the dominant culture evaporates) and have kept NPM- and NodeJS-inspired "best practices" at arms length precisely for these reasons and more, it's irksome to see people full-on equate JS with what-the-NPMers-are-doing.
You're right that it's not the language per se, but I'd argue that it's not specifically NPM either - the same problems afflict any rapidly-moving not-yet-fully-mature software ecosystem.  The whole tale definitely reminded me of the pain of trying to build projects in C and C++ from source in the early 2000s, with GNU Autotools everywhere, and before pkg_config was common.  I've had similar "side quest" frustrations (I really like that description from the parent post!) more recently when python's involved.But I guess NPM's particularly prone to it due to the sheer number of interdependent packages.  I can't quite wrap my head around there being one npm package for every 6,100 human beings on the planet.
This article reminded me of my days as a sysadmin in the 90s. It seemed like every new system had a fresh issue with getting some shared library right.
Of course it's a JS problem. "Programs" being replaced by JavaScript apps doesn't mean some custom homegrown LTS framework. It means apps that aim to replace what used to be known as "Programs" have some sort of frontend JS component. frontend JS doesn't mean npm.js sure, but it means whatever flavour of bower is hot today, webpack or the other new kids on the block, react or other stuff. There is a reason why these big companies hire unlimited amounts of frontend devs. If you leave a react apps dependencies half a year and then try to update it none of it will work. It's "less" bad than it was 2 years go, but it's extremely cost-intensive to maintain nonetheless.But it's not like backend js is any better. Most people run express.js in some shape of form, but then people roll their own (or use any of the existing 50) input sanitizing libraries and then half of those projects run into the same authentication bugs that Rails fixed almost a decade ago. There's a reason why people don't ask for JavaScript experience, but instead ask for Node.js experience in resumes.
> Of course it's a JS problem.I've already explained why it isn't, in detail.
A month ago I found a bug in command line utility I wrote in C# and hadn't touched in 8 years. I checked out the project and opened it in Visual Studio. And it compiled. I fixed the bug and it just worked. End to end it took half an hour. I feel like there is an advantage to libraries and tools managed by adults with long term skin in the game.
As a counter point: I have simple node scripts, that serve the same purpose to me. And there was also the need to fix something 2 days ago in an 8 year old script. Opened the file, changed the code and running it again. Took 5 minutes and it just worked.I don't use js because it is the hot new thing, but rather because it is simple. (But I avoid messy and obscure npm repositories wherever possible for example.)
> I don't use js because it is the hot new thing, but ratherbecause it is simple.It infamously isn't.https://www.destroyallsoftware.com/talks/wat
Most of these are 'gotchas' that rarely happen in real code because they're all due to implicit type conversions
Yeah, nothing there affects regular programs even a tenth as bad as say quoting rules and space handling affect average Bash shell scripts.
Wouldn't shellcheck catch most of these?
Hm, video arguments are not my take, I did not watch it (yet), but in either case this seems to be opinion.But of course, javascript is so simple, that it is not suitable for complex problems. No (sane) person would ever claim, that it is the right language for every problem.
Are you familiar with the No True Scotsman logical fallacy?
Yes, but I do not know, what you are trying to tell me.
I am suggesting that you are making exactly this kind of fallacious argument when you say “No (sane) person would ever claim, that it is the right language for every problem.”
"in which one attempts to protect their universal generalization from a falsifying counterexample by excluding the counterexample improperly"This would be the wiki definition.But where is your falsifying counterexample?You mean the video, which says below:"This talk does not represent anyone's actual opinion. For a more serious take on software, try .."?
It's fairly easy to find falsifying counterexamples — it's not such an uncommon opinion.Also I believe the author of the video is clarifying in the statement you quoted that he isn't trying to take a position on the state of the industry.
People always underestimate how stable JS is. I would argue that it is more stable and backward compatible than a lot of backend languages. What is not stable in JS - is a whole ecosystem.
I've been laughed at for scripting in Java, but I have a bunch of such scripts from 15-20 years ago and guess what, they work out of the box like the first day.
You can also patch most classic .NET (4.8 and below) "binaries" in place with something like dnSpy. One example: I had to update a simple command line tool someone else wrote to poll an API that had undergone some changes. Was able to make the changes directly in dnSpy without having to even open Visual Studio. I haven't tried with any of the 5.0+ versions so I don't know if this is still the case.
Same thing with java.  Literally pick up where you left off.  The issue of not working after some time just isn't an issue.
That's how it should work. But of course last week I revisited a project I wrote in C# too, this only 3 years old, and apart from dotnet complaining about the target framework not being supported any more, I couldn't get it working again due to the libraries used.
This makes no sense. If you upgraded your libraries, thats in you to fix it tho.
> "why i moved mostly from writing node cmd tools to using bash"You literally moved from one unmaintainable mess of an ecosystem (Node), to what is arguably an even worse unmaintainable mess of an ecosystem (bash). Glad to hear it wasn't Perl though.For self-contained little tools or hobby projects that can run cross-platform, use Python. For anything beyond that - use a proper strongly typed language (C, C++, C#, Java, etc).
Only use python if you plan on compiling it with something like docker or podman to pickle your resulting stew in epoxy for all time.Otherwise you'll still be in some dependency heck as you run down why your library updated doesn't work (oh, switched to TLS encryption; that's good I guess) or you're thing uses v2 and everything now uses v3.golang, rust, at least, make a static binary out of the gate.  In 8 years it'll probably be full of hideous out-of-date code and full of security vulnerabilities, but at least you won't have to look at it and feel bad.If static binaries were good enough for Ultrix, they're good enough for you.
I've been writing tools like this in Python for a very long time and haven't run into anything close to what you're describing. However, if this happened to me and I was annoyed enough to do something about it, I would use a tool (e.g. pip-compile) that creates a requirements.txt file, which specifies all the libraries and dependency version numbers explicitly. If something broke one day, you can stick that script in a directory with a venv and just run it from there. There's no need to resort to compiled languages like Go and Rust which will very likely give you a large raft of other unrelated problems (slower development velocity, comparatively limited libraries, etc.). Going through all of that just to have a binary in hand doesn't seem remotely worth it from my perspective (YMMV).
The OCI containeristhe binary.  Docker is a tool to take any existing runtime and turn it into a static binary you can feed to any future linux(ish) kernel.I on the other hand, have had plenty of situations where some system somewhere is managed with some config management tool (such as puppet) and it is told "make this application with these dependencies" and the application, such as "manage elasticsearch index rotation" uses the system python and does pip install to install all the things.   This idiom seems fine, but ultimately ends up with a hideous mess where it worked one day and didn't work a year later, because either the system python is different or the dependencies are all messed up or the pip tool itself on the system python isn't compatible with modern package distribution.You can (correctly) say "don't do that" but the same idiom in a shell script will almost certainly work across decades regardless of if "sh" is bash or ash or ksh, to some degree of "works" (again, you can _correctly_ say that no shell script ever works correctly).
It is interesting that the data science and ML folks are willing to weather Python’s dependency mess Vs. the huge momentum Golang and (increasingly) Rust have built around their static binary philosophy.Perhaps this is the future of Kubernetes , to be the only thing brave enough to run epoxied globs of .NET, Java and Python.
Python and docker, with compose is a really good fit. Everything works, everything is boring, everything is stable all the time. And importantly, most problems are easily googled.
Just be sure to archive your artifacts.  Both the ones you make and the ones you use to build output artifact.Otherwise, your docker build tool will work today and be a screaming mess of broken dependencies tomorrow.
I think the trick is to not have any dependencies, except Python itself, when writing such command line tools. Python does have a large standard library after all. While Python itself surely could be nicer, it is still easier to maintain such a script than a script of similar size of GNU Bash code.
Bash scripts don’t break, when left unattended for months/years. Python scripts do.
It can’t break if it were never correct in the first place. Bash scripts are always chock-full of bugs, and only work when everything in its environment is the same. That folder now has two files instead of one? Now it just stops working.
In my experience, they don’t have more bugs than Python scripts. That’s assuming they’re shorter than 50 LOC. Long before my scripts reach this size I convert them straight to Go. That’s the most problem-free strategy.
Pin your versions.
Also - to make the equivalent safe bash program compared to a typical python implementation is ... a lot of work. Enough that imo the python version is worth the maintenance.
Pinning versions doesn’t help when the old version of some dependency no longer works with your new OS or hardware.I mostly only code in Python but this article really spoke to me. I have <10 personal Python scripts that I use heavily for my job, but they are such a bear to maintain.Meanwhile my two old Autohotkey scripts that I wrote 10+ years ago and rarely touch still chug along perfectly.
The recent deprecation warning message of `egrep` is a prime example that bash scripts can break (depending on stderr processing). They will definitely break once the alias is removed.
egrep has been on a deprecation path for 15 years, and the replacement is incredibly straightforward. Also, I think egrep will generally just continue to work.I'm not sure what you mean by "recent", but this is more longevity than we get in the node/JS world.I'm primarily a JS (now TS) dev, who also throws bash at things when it makes more sense, but let's not kid ourselves that it's the same.
*Statically typed, not strongly typed
In the past years Java is a strong candidate for cmd tools.Using Quarkus + Picocli + GraalVM for native compiling, gives you a standalone binary which can be used on any platform.
The python build/install/distribute situation is so bad, XKCD made fun of it years agohttps://xkcd.com/1987/
> don't need to go on a bunch of side missions every time i run npm installLol what a great way to describe what running a simple "npm install" entails.
Try doing this on a 5 year old project. You'll very likely end up in dependency hell.There is a solution though - use of nvm and .nvmrc (to control the version of node and npm that you use), and use of npm ci (which installs packages as they were at the time, rather than installing newer versions than specified in package-lock.json (because too many devs rarely ever pin versions) instead of npm install / npm i).nvm (Node Version manager):https://github.com/nvm-sh/nvmnpm ci:https://docs.npmjs.com/cli/v6/commands/npm-ci
I rarely if ever get version mismatches for a normal npm install because upgrades by default only do minors. If a package has a breaking change in a minor it's not a JS issue, it's not a npm issue, it's a "this package author made a breaking change in a minor" issue.And regarding nvm: That's obvious. This is the same for almost any runtime. If you have the wrong jdk version it doesn't work, if you have the wrong (whatever iOS uses for xcode) version it doesn't work, if you have the wrong version of gcc it doesn't work.Obviously wrong is not always the same, more up-to-date versions of gcc can compile older programs (maybe) but that's also the same for Node unless otherwise specified in the packages.
Why learn cmd and bash when you can just learn js? Easier to maintain 1 language than 1+.My software in js from 7 years ago still works.
But it's not that simple, for an example I have older personal projects as well which I'm unable to run without doing considerable changes to the code after moving to M1 chip.Just because I'm unable to run older versions of node and thus unable to run some of the dependencies and thus need to update the dependencies and then the code etcetc.Yes, I could use docker and containers... 
Yes, I could use Rosetta...But it doesn't run natively like it did before.But bash still works...
Exactly. Dependency hell is easy to avoid by avoiding dependencies. Modern JS with modules and classes is really good for simple projects, esp. prototypes that don't have to work everywhere. No framework, no special utilities that all have their quirks. And no packaging either. Much, much simpler this way.
Likewise, concurrency stops being a problem if I avoid threads and async as much as possible.I'm starting to feel old now that I can no longer pretend I've only got two threads, network and UI, where everything is fine if I wrap the network response with "do on main thread" and crashes reliably and instantly whenever I forgot.
This comment here is exactly the problem with JS people.
If you are making a big thing out of learning(!) cmd(!!!) then you shouldn't be working in software development, period.
7 years is a flex only in a JS world. As others mentioned, try 35.
My scripts in ksh from 25 years ago still work.
because js should never be the first choice in any case...
To avoid a rm -rf /  ?
Web has always been about the hot new thing. It was part of why I left-in 2001.
I left for a couple of years for Windows desktop and Android native development, turns out that the GUI civil wars at Microsoft, and the whole Java vs Kotlin vs AndroidX vs JetPack vs NDK being like a 10% project, are even worse than dealing with Web quirks.So even though I rather do native development, here we are back at the Web and distributed computing.
>the GUI civil wars at MicrosoftThe wars are done.Look at what Microsoft actually uses for GUIs, not what they recommend. All the new Microsoft apps are written in Electron.
Actually not all of them use Electron as such.Teams is thankfully now using WebView2 (less resource heavy), new Outlook is a PWA.However I do agree with the gist of your comment, it appears everyone from the GUI civil wars that doesn't want to stay until the end has jumped ship to "Azure OS", or the competition (Amazon/Google), and most UIs are Web based or the classical Win32 ones.Naturally "Azure OS" applications use the Web as UI.Only WinDev themselves seem head down on using WinUI, and still don't grasp the competition, not only the WebView2  based stuff into their turf, the other OSes that don't require dealing with COM and C++ for basic stuff like OS widgets.
> All the new Microsoft apps are written in Electron.Is this why the new calculator app takes over 5 seconds to show up on screen?
Nope, that is the UWP security container most likely.https://github.com/microsoft/calculator
Is that what causes typing "Notepad" in the search bar take 5+ seconds to show me notepad, sometimesafterit showed it just having typed "No..." before deciding it's not sure whether it wants to show me something else instead?
No idea, for me search mostly works.
The best thing about bash is portability indeed. Node requires an entire runtime, while Rust may have a problem with library versions and requires a heavy toolchain too to recompile. I use it for small CLI tools but I could not envision anything over 1k LOC in bash. I think the ideal would be a language that introduced a nicer syntax and compiled it to bash. I wonder if there's anything like that...
Why has nobody mentioned that you can (and should) just lock your dependency versions…?
Because that stop short that complain train.
nvm is my solution to thisIt isolate and pins npm installs so that the environment is the same in the future without messing up your main systemYour projects also need to consider pinning their dependencies to a specific versionOther languages/frameworks with package managers have similar concepts
> Your projects also need to consider pinning their dependencies to a specific versionAt that point, you should consider just using your version control system to handle versioning instead of trying to route around it, poorly.
As a long-time ruby user where bundler has done version pinning for decades, I think this is a core feature of any dependency management system, not some kind of "routing around it."I'm not sure what "your own version control system" means.  Checking all dependencies into (eg) git? I'm not sure how you deal with indirect/second-level dependencies, but any kind of roll your own like that to me is what I'd call "routing around" the failures of your platform dependency management system.Correct dependency pinning also allows you automated ways to upgrade dependencies, resolving requirement trees, within stated bounds specified per-dependency (like keep to same major version). It just happens when you want, not every time you install or deploy.
> I'm not sure what "your own version control system" means.Me neither.  Where did that come from?  I didn't write it.  (It's not in my comment, just yours.)
Ah apparently my brain inserted `own`, looking back you said "just using your version control system". OK, I think I'd write the rest of my comment the same still; does it mean putting all your dependencies (source/binary) in your version control (eg) git?
Yes—using your VCS/SCM to version control the source code.
hey='you can define variables' do_this='without commandline parsing' ./thing#!/bin/shhey=${hey:='default one'}do_this=${do_this:='default two'}not_that=${not_that:='because getopts is a nightmare'}echo "${hey} ${do_this} ${not_that}"
If you want to be more DRY (do not repeat yourself) with regard to the variable names you can use the `:` command inside the script (which just expands its arguments) as in: ${hey:='default one'}or even more briefly just use that `:=` {or `=`} assign if empty or unset {or assign if unset} at the first use case.Also, besides shells most prog.langs have easy ways to receive these { getenv in C, os.environ.get("do_this", "default two") in Python, etc. }.--I think what people really miss here is the (rarely used, I guess?) shell calling/invocation syntax @cduzz points out of:var1=val1 var2=val2 programwhich is notably even more terse than GNU long options:program --var1=val1 --var2=val2Also missing is a documentation standard/convention like:help= programto dump out settings possibilities and their defaults and maybe their types (integer, string, bool, etc.).  One virtue of the `:` syntax above is that it is rare enough in "ordinary shell code" that you could probably auto-generate the help from such a table at the top of the script viagrep '^: ' "$0"at least if you are willing to assume the invoker sets $0 to a full path.Soon enough you may outgrow shell programming and, if you become used to such nice conveniences and are willing to learn Nim, I might then recommend something more likehttps://github.com/c-blake/cligen
I’ve been bashing for decades and never thought of that. Thank you
You might also see ideas inhttps://news.ycombinator.com/item?id=34147636
Nim is great for this use case.
This is an article about ecosystems and package managers, not particularly about JavsScript, which is a scripting language around which one can chose to participate in ecosystems and use package managers. The distinction is not as subtle as one would think.It's the same with any program.. dependencies are future liabilities. You pay for fast development now with a future burden of upgrading and incompatibility.That's why I enjoy coming back to the software I've written with that mindset, it does not matter which language.. If I was in the supposedly wrong NIH mode when I wrote it, it still builds..
But there's something very different in the JS ecosystem that makes things worse.In the .net world, even with packages managed with Nuget, it doesn't have the same "constantly breaking" problem.For example being "stuck" on an old version of react, because dependency X version 6.x requires react < 17, but dependency X version 7 completely re-wrote their entire API and has so many breaking changes it's not reasonable to upgrade.So you're faced with either being stuck on an old react, or re-writing half your application around the new version of your dependency.In the .net world, things don't move so fast, don't break so much and it's rare that both your dependencies and frameworks all break all at the same time leaving you stranded.The .net 5 transition was the closest thing, but the .net standard pathway mitigated the worst of that, and crucially, .net framework is still well supported.Also in the JS ecosystem, it's not just your application packages but your whole build toolchain that quickly gets out of date and breaks. For example finding that you can't move to the latest version of something because it breaks something else in a "random" location.For example finding out that you when you upgrade node, suddenly node-gyp doesn't work, and this package you likely haven't previously heard of is crucial and central to your build.There's no way around this problem but to dedicate hours every month to keep everything on the bleeding edge. There's no such thing as "LTS" in javascript. Node in theory has an LTS release but it's useless as soon as libraries start requiring non-LTS releases.Bringing in librariesshouldn'tmean burdening yourself with so much future incompatibility and constant upgrade grinds that it's a significant part of every month, it they shouldn't force you to live on the bleeding edge.
Don't you find it odd that you're willing to distinguish .NET as a concept from e.g. a language like C#, but when it comes to what is, in reality, the NodeJS ecosystem that you have an issue with, you pin it broadly on what you call "javascript" (also a language)?> There's no such thing as "LTS" in javascript.In fact, there is.  The language is stable—it's at least as backwards compatible as C# (if not moreso).  There are even very stable platform APIs available outside the language core, e.g. the non-experimental stuff that the WHATWG/W3C standardizes.  What you're doing though is opting for an opinionated, incompatible, vendor-specific fork (NodeJS), then experiencing the ensuing pain that comes with that decision.Maybe if you like the stability of .NET and you find yourself having to use JS, you should rally for a JS-for-.NET cause instead of tacitly feeding the ongoing JS-with-NodeJS hegemony even though it keeps hurting you.
I refer to .net as the language a lot of the time too, they are tied even more strongly together, as described inhttps://learn.microsoft.com/en-us/dotnet/csharp/language-ref.... I'm probably just not being precise about the language.I'm happy to pin this on NodeJS but Node is the key reason why javascript is used for any non-web work at all and it's almost impossible to separate that.The javascript ecosystem and it's breakage is down to Node, but the javascript ecosystemis node. Even if you only do web work now you still need node for the build toolchain, it's essentially impossible to escape it.You can't realistically develop without it, even projects like react have given up on trying say anything but "just use create-react-app".
> the javascript ecosystemis nodeIt's not.  NodeJS is NodeJS.  JavaScript is JavaScript.The James Webb Space Telescope isn't running Node LTS or pulling in left-pad.If you want to make a lateral move and draw comparisons elsewhere: the Java ecosystem is not Sun/Oracle's mobile platform—which never took off, while Android thrives.  Languages are absolutely separable from the big loud noisemaker (and the problems they bring with them).As for build toolchains: even taking the comment that "if you only do web work now you still need node for the build toolchain" charitably, we could understand it to mean that NodeJS-based toolchains save you time, rather than that you strictlyneedthem in a literal sense.  Even that argument is dubious.  It's worth considering, if people spent half as much time working on the drudge work that these toolchains are ostensibly supposed to be saving them time on, instead of dealing with the dysfunction that comes with these tools, where might they be?  Ivan is doing a-okay with Photopea despite repudiating basically everything about NodeJS.In practice, those toolchains have proven to be a false economy for many circumstances where they end up being (mis)used.  More honestly, they're shiny distractions that people put at the forefront of their attention because that's what they like doing—and they're willing to lie to themselves by saying they're doing something essential.> You can't realistically develop without itSorry, bud, this is wildly exaggerated.  It's simple bullshit.  I won't concede to such an argument that doesn't have a firm basis in truth.Or, if you want a pithy rejoinder, here's one: "You can't realistically developwithit!"[1]Firefox is one of the most advanced early codebases that made extensive use of JS for serious use—and still more serious than many of the things that people are writing in JS today—and there was no use of NPM—because neither it nor NodeJS (nor V8!) even existed yet.1. <https://news.ycombinator.com/item?id=24495646>
But whenIsay "javascript ecosystem", I'm talking about Node, and that's clear from my writing.I don't care for pedantry about what itmightalso refer to, I'm talking about NodeJS, npm and the problems with it, and that's clear because that's also what the original article is talking about.
> when I say "javascript ecosystem", I'm talking about NodeCan you change your habits?> I'm talking about NodeJS, npm and the problems with itSo how about just saying that?> and that's clearIt's not.  A person doesn't have to go all in on Sapir–Whorf to recognize that this is fraught with peril.The original article that you fall back on for support doesn't even agree with you; the argument that the author makes (explicitly, even) is that this actuallyisa JS-and-not-just-NodeJS problem.Nor do your earlier remarks agree; you're ignoring now the pushback on your earlier remarks that escape is essentially/almost "impossible".  Feels like you're going for a motte-and-bailey here (a type of bait-and-switch argument; see <https://en.wikipedia.org/wiki/Motte-and-bailey_fallacy>).
> Don't you find it odd that you're willing to distinguish .NET as a concept from e.g. a language like C#, but when it comes to what is, in reality, the NodeJS ecosystem that you have an issue with, you pin it broadly on what you call "javascript" (also a language)?Does that matter? Both for front-end or back-end you generally use NodeJS now, if you are not using an entire other language (like WebAssembly for front-end and PHP for the back-end). Even if you get rid of javascript for the front-end, you'il still have it likely to compile or minify CSS.
> Does that matter?Well, yeah—for reasons already explained.Millions of desktops will boot into Gnome Shell today.  Millions more people, including people using Windows and Mac and not Gnome Shell, will open Firefox.  There will be no NodeJS process running in the background in order to achieve any of this, nor will there be API-compatible runtime involved.There's absolutely no reason not to say NodeJS when that's what you mean.  Thereisa problem with blanket generalizations about "javascript" that implicate other software and software developers that have absolutely nothing to do with NodeJS or the any of the NodeJS-specific problems that are well past due (read: should have been solved by now).  The world is bigger than the back-end/front-end dichotomy that webdevs spend all day thinking about.I have no idea how to even respond to your CSS comments.  Without even getting into whether it's true or not, it's just totally irrelevant.  Painfully so.  ChatGPT writes more salient responses.
What I hear you say is that some publicly available third-party libraries written for use with JS are changing very often, and introduce incompatibilities and breaking changes.And you write that some publicly available third-party libraries written for use with .NET change less often and/or do not introduce incompatibilities and breaking changes (as often).Two true statements, which are totally and entirely unrelated to the JavaScript and .net.> Bringing in libraries shouldn't mean burdening yourself with so much future incompatibility.I agree, but it does, and the more active the library, the worse.. If you don't believe me, try writing absolutely cutting edge stuff in C, using whatever the most active and hip libraries you can find..You'll have better success, not because C is a better language (though, I very much like it), but because stuff moves at a slower pace, even the hip C stuff is not _that_ hip, when you look at the amount of code contributed per unit of time, or the amount of new features implemented per release.Of course I'm being general, you can certainly find JS libraries that are extremely solid, and you can certainly find C libraries that are very fragile, but in general.. they correlate well to the popularity/activity of the language.. but not with any inherent property of the actual language.
i agree..net is a cathedral platform, well manicured by a small trusted force that tries to make eveything fit together, that works semi-cohesively, to produce a manufactured industrially syitable one-solution to everything.js is a bazaar language, that had many intertwingular existences in different places, doing different in similar things in thousands of different ways. it's innovation & history is chaotic & messy, with many onetime behemoths left by the wayside (jquery, gulp/grunt, backbone, moment, request). everything is a bit messy & organic & grown together, pieces breaking off & advancing one direction then being woven back with another library to work a third way.>There's no way around this problem but to dedicate hours every month to keep everything on the bleeding edge.i dont disagree.work has spent considerable time dragging a couple dozen old fairly complex react apps & services we inherited out from node 6, node 8 this year, freshening things up.it is however amazing how much stuff did just work. how many deps we could look through the changelog on, say, that's fine, and upgrade, and tests pass & on deployment things keep moving along. did we get bleeding edge? eh, like 50% of the time. in many cases we didnt even bother trying to get current. we checked dependabot vulnerabilities & did what we had to, stayed in the past for now. these apps were all running, live, with traffic... it's amazing how much of this messy organic tangle does work.we did run into some of the version conflicts & problems, some of the conservative concerns, the reasons for fear & trepidation you cite. it wasnt fun work. no one wanted to be here. but we got through it in quick order, and it ended up being a whole lot less pain than us engineers expected & budgeted for. we were left with the impression of ease. confidence grew.as others have tried to point out, i dont think your real complaint is with JS specifically. the organic nature of this world doesnt suit your desires. and i think that's a reasonable stance, these arent unreasonable values/complaints. but on the other hand, the organic has, i think, taken over with rightful cause. Azure OS is in huge part React, huge part JS. the techadaptsmuch faster. not being a carefully staged industrially-focused cathedral, being an organic place that values & cherishes idea & potential, has let us try a lot of things & keep exploring where real value is, and has kept leading us to better places. we understand more through the experimentalness of the process, we see such vistas that the cathedral makers could not have dreamed, find higher heights & ascend. & yes, sometimes as we rise above the clouds, we spy yet higher peaks, and we must decide whether & how long to stay where we are, or to try again, move onwards.personally this organic world has brough me great joy & a wonderful continual sense of progress. that we have kept honing ourselves, reshaping. it feels finally like we are starting to really settle down more, that we have made finer cuts at iteration. apis are much more stable. the platform has amassed a more solid core, as groups like WinterCG bless & spread more of the much developed web platform as stable trustworthy systems. React has spent years building towards Suspense & it seems uncharacteristically humble, for a framework that had iterated so much & so heavily for so long, & there's little on the radar that gives us a sense there  will be a next breathtaking new era. the organic has settled, become over time more like the cathedral you might have hoped for.
Dependencies being future liabilities is one reason why core programming skills are so important. A team with weak core programming skills will quickly make a mess of dependencies, because they will not dare to implement that left pad or that tree recursion themselves. The mess will work, but the cost will be inflicted for as long as the dependencies are in there.Of course there are some things which getting into is not so recommended, because of high initial time cost. Like writing your own web framework. Or correctly implementing data structures or difficult to understand mathematical algorithms, or cryptography stuff.
>JavsScript, which is a scripting languageIt clearly is not. Whatever it was supposed to be, or might have been in the past JS isnota scripting language.
Meh, I feel a little like this is dunking on Javascript for the sake of dunking on Javascript. Ever done the same with a PHP app? Go? Python?! They all have issues with versioning and this is why there are a good set of tools to deal with it - pyenv/nvm etc. It's like they've listed all the good reasons to use JS and then kicked it because it's cool to hate on JS.Hi, I am Darren, and I love JS - I will no longer be ashamed by it.
I can come back to a go module I write today months later and do a build. `go.mod` specifies exactly what version of what dependency I used, and `go.sum` provides the checksums. Even if the original repo was shut down, there is a good chance the `GOPROXY` I use has it cached, and failing that, if I am really worried about long time availability of dependencies I can always do a `go mod vendor` and check everything in my own repo.Heck, I think half a year ago, I unearthed a project I wrote in Go1. ... I think 6? 8?, Anywho, way before modules were introduced. All I had to do to get it to build was a `go mod init app && go mod tidy`.And all of this is baked into the official toolchain that comes with the language. So is testing, benchmarking, documentation-generation. As a bonus, the official proxy provides a handy way for package discovery, but without relying on any one centralized repository to fetch said packages.The language itself doesn't change a whole lot, and by design encourages a straightforward and to-the-point style of doing things, (at the cost of being somewhat verbose sometimes, but I think that's an acceptable tradeoff). The result (and also a big thanks to `gofmt` at this point) is a coding style that is pretty consistent between many modules written 5 years ago and projects started yesterday. The designers make sure that newer versions of Go itself don't break things, with even generics not breaking any backwards compatibility.And if I want to upgrade a dependency, there are only 2 possible outcomes: Either the go-tool can resolve the dependency graph to something that works for everything in the project, or it cannot. Either way, provided I `go mod vendor`ed, I won't end up in a situation where I just cannot build any more.
I use go a lot and also love it. I did find it odd in the early days to not have a package manager, but they seem to have mostly built on the experience of NPM and got it right.
Yeah, the initial days were indeed odd, and modules absolutely required, otherwise the ecosystem would probably be a tangle of different 3rd party solutions for vendoring and version-pinning right now. Glad they avoided that.They were building in the right direction with the idea that a world where public code repositories exist, a) doesn't need yet-another-repository for just one language, and b) should acknowledge the real world by specifying these resources directly in the code.
> They all have issues with versioningNot on this scale. Let's leave out the versions of the NodeJS for clarity's sake (nvm is not for managing packages, afaik), and focus on packages. You could argue that the complexity is because of JavaScript's popularity, but it's hard to deny that running a seemingly simple `npm install` will net you tons of dependencies, and that's typical regardless of what you're installing.
Yeah this is really the Achilles heel of the node ecosystem. It turns out having an expansive standard library is important since I'd like to think most of these issues would disappear if that were the case.
Python is worse. By far in my opinion.
Why and how?In my opinion Python modules are rarely "one function" dependencies. And while the ecosystem is certainly enormous, so is the standard library, so for many common tasks, I don't even need to `pip install` a new dependency.Yes, "virtual environments" used to be kind of messy, and the fact that there are usually 2 competing ways to install modules (via the OS pkg manager and pip) doesn't help either. But since `pyenv` and `venv` exist now, venvs are much less of a hassle than they used to be.
>Hi, I am Darren, and I love JS - I will no longer be ashamed by it.Don't make a programming language part of your identity. It's pathetic.No one is "dunking on Javascript for the sake of dunking on Javascript." PHP, Go and other languages don't have these issues, or at best don't have them at the same frequency, nor are they as catastrophic when they occur.No PHP dev ever woke up to discover the entire universe was broken because some rando who ownedthefunction that left-aligned text in terminals deleted their repo in a fit of pique. Other languages vendor dependencies by default. Other developers use libraries which contain more than a single function so their dependency trees are shallower and less brittle. Other developers are less allergic to actually writing code than Javascript developers, so less of their application is offloadedtoremote dependencies.This isn't a JS issue, it's an ecosystem and culture issue. Back in the ancient days of JQuery modules, none of these problems existed. They're the result of Javascript being co-opted by SV and corporate interests. The necessary evils of piling on complexities in order to get the language to do things it wasn't meant to do, in contexts it wasn't meant to operate in, because money.Hell, a lot of JS' problems stem from the fact that - alone among programming languages as far as i'm aware - JS development all but requires using another language entirely. No one writing Python actually uses a strictly typed "superset" of Python that compiles to Python, because they consider actually writing Python directly to be too dangerous. That would be ridiculous. Yet in JS, it's essentially mandatory.Yeah, sorry but JS is kind of a comedy of errors right now, and it's never going to get better if people refuse to see its faults.
My dude, have you lived in the tech (or otaku) community for long?Making a piece of tech (or any media) part of your identity is a tale as old as time, and arguably getting worse.I mean, you’re right, it is pathetic, and we need to collectively grow up.  But 
you might as well be saying “be a well adjusted person, eat well and exercise”.   We are so insecure and needy that we ascribe our self worth to a tech fad or piece of media or media figure.  But it’s the core problem we have in western society today: geek/otaku culture, with its highs and lows, has gone mainstream.  We are so comfortable and abundant with basic resources that we are bored and unsatisfied with our status and function in society  and desperate to fill that gap with something to geek out on.We live in a world where Lennart Poeterring gets death threads over systemd, the Golang maintainers get threats over generics, TV show runners get death threats when they change a character’s story arc.  And politically there’s lots of folks willing to eject democracy so their adopted club can rule for eternity.  Is it all for the lulz?Anyway I took this on a tangent but… really, “I can’t believe you use that programming language” has always been bad as far as I can remember (at least 35-40 years).
There's nothing wrong with making a language part of your identity but Darren is not even doing that, he simply said he loves JS.I don't identify as a Python dev and I don't even work with Python much lately, I know package management isn't great and PyPI registry suffered malicious attacks recently, but I can still say I love Python, I started with it and the syntax is enjoyable.But you are clearly making language hate part of your identity.(BTW I'd actually thank JS for TS, if they added types natively they'd probably be limited like Python's and we'd be stuck with it, but they didn't so now we have a new language with a great type system that evolved beyond JS with variations that compile into WASM and such.)
Yeesh this really kicked off but thanks for the defence. For clarity I identify as a male programmer with Lego loving tendencies. JS is simply a tool I actually mostly enjoy using. I also use a lot of other languages, but really JS is one I'm always happy to come back to!
> No PHP dev ever woke up to discover the entire universe was broken because some rando who owned the function that left-aligned text in terminals deleted their repo in a fit of pique.You act as if this is something that was forced upon you.Giving some "rando" the power to "own" a function in your app is a power that you choose to give them.If you don't want that then don't do it.Sentences like "Other languages vendor dependencies by default" are nonsense statements.  Stop saying "language" when you mean "the kind of people I do/don't have a problem with".> This isn't a JS issue, it's an ecosystem and culture issue.Right, and when people tacitly insist otherwise—by being sloppy with their words and thoughts—then it makes it harder for people to recognize the problem, see what specifically needs to be fixed, and then proceed with the "okay, let's fix it now" part.
most python modules do not have so many dependencies, and tend to have a stable api.Bugs happen but it's by no means a constant thing.
Python has a completely different issue and that is that its dependencies on c extensions makes cross platform or cross version packaging a terrible thing.This is why I get a bit puzzled when people complain about the Java build system. It's so much saner in comparison to the scripting languages, and arguably better than Go or Rust (though I'll take any of the three over Python or JS).
> Python has a completely different issue and that is that its dependencies on c extensions makes cross platform or cross version packaging a terrible thing.Well java has no way to do a unix socket unless we rely on a C extension so it's hardly better in this respect.
> I love JSThat is the problem. You love a hammer and see nails everywhere.
Well that's a judgement call I'm afraid you have wrong. JS is a great solution to some problems, as is Go, as is Rust, Ruby etc etc. I love JS for what it's good at - things like making web apps a reality, allowing a single language to be a start point for devs etc. I certainly don't use it exclusively.
I think the overlooked lesson is: the more technology you add in to your stack, the harder it is to maintain. Shallow tech stacks - using fewer tools and frameworks wherever possible - are usually a good idea to minimise your maintenance headaches.If you're making a small quick tool, vanilla JavaScript is not a bad choice. You don'thaveto use npm, TypeScript, and a bunch of frameworks. If you do anyway then sure, you can end up in a situation where 90% of your work is maintenance, but you made that tradeoff - these should be things you consciously weigh up and decide, not just do automatically.
I agree with this view. Any large, complicated project with a large number of dependencies is going to require maintenance over time, regardless of the language or package ecosystem. Keep your simple projects simple, and if you need to use dependencies to get something off the ground quickly, either be prepared to maintain it or to do some additional work to remove the need for those dependencies over time.
There's still a difference between javascript and other languages with respect to dependencies. E.g. if I open a 5yr old python project there's a fair chance all the dependencies still exist and still work with a more recent python interpreter, let alone work at all.My --limited, to be fair-- experience with npm is that you can barely look away from a project for a week or it'll have a bunch of deeply broken dependencies, requiring you to update them which then breaks other dependencies in turn.
Fred Brooks has been warning us that the key problem with software development is 'how to keep complexity at bay'. Half a century later we're still wondering why sloppy complexity management bites us in the ass later on.
My experience is pretty similar formy projectsbut I think generally we shouldn’t point too many fingers. When it comes to public projects, I’ve found a lot of trouble regardless of its JavaScript-proximity. I think we’ve been blessed by a growing ecosystem of projects that are clean to build, and eschew problematic dependencies. Try building anything Linux and C related and you’re worse than JS because now you need to modify libraries across your operating system not just NPM project.Tonight, I tried simply compiling an example super-high-profile project that recently reached 1.0 (Matter protocol impl). It took me an hour of chasing down Linux dependencies to build on my Ubuntu server, while I gave up on building on my mac altogether after comments on issues suggested sym-linking various homebrew packages around my system.We are still new at experiencing docker-packaged projects, and there’s few heavily used tools that work well. Many big companies have solved this problem internally, but not out in the wild. HN has often discussed GUIX or NIX systems, but I’ve yet to see a “real” open source project that uses anything but make/docker or language specific tools (npm, cargo, etc).
Yeah, people are jumping the horse to claim any dev environment is superior and free of issues like this. I've contributed to some open source C++ projects and a lot of js/node projects, and in my experience, every C++ project is an adventure just to get the project compiling (it can be smooth running if the maintainers have a recently-updated guide specifically for your exact OS/distro version and the right versions of all the dependencies are in your distro's package manager, but anything off of this happy path is an ordeal, especially the case where you're working on another C++ project that wants a different version of the same dependency) while nearly every js/node project was up and running after just "npm install". Sure, it can go wrong and harder than that sometimes but it's worth appreciating that the standard case is pretty good.Every project using native binary dependencies is prone to running into the kinds of dependency issues described in the OP article. I've run into similar situations with Java, PHP, and Python where there was some mismatch with a language library, a native binary, and my OS. I'm a fan of it when projects try to minimize their native binary dependencies for this kind of reason. Some js/node projects that have previously used a native binary dependency now use non-OS-specific WebAssembly binaries instead, which is great for how it removes potential issues.
My experience matches this.If there is a native dependency, then moving major node versions or moving to arm can cause difficulties or straddling the python version the gyp build system is based on.It's worlds easier than trying to insure your C/C++ build environment is prepped properly to build a binary.Updating libraries is usually not too bad, even across major versions.  But that can be a bit of a wormhole trying to get everything squared away and all versions updated.  This seems to be particularly true since all major frameworks I've used have gone from snake case deps (framework-module) to @framework/module.
Yea macOS is never a guarantee but I’m always hopeful when they include Mac instructions in the readme.I’ve found projects that use C++ or other older languages and meant for Linux still have a nightmare with building. The project I looked at had a bootstrap script, an initialization script, a pip installation, and 3+ different make-alternatives. Not uncommon even when apt works.Docker is great but it’s only as secure as Linux can be. Yea it can have outdated SSL, but it’s just as likely that the thing you need depends on a particular version. Most projects don’t get versions updated unless it’s broke.  IMO if something is a web service or generally at risk, you should not depend on the good-faith security being vended. Put it bend a secure network or proxy, Audit, etc. As the advice goes, don’t run your server on port 80 as sudo, but instead run behind NGINX.(modify for risk)
> The project I looked at had a bootstrap script, an initialization script, a pip installation, and 3+ different make-alternatives. Not uncommon even when apt works.Seems like it was created by noobs. It happens. I guess it's not packaged in a distribution for a reason. A distro maintainer would tell them to fix that crap.> but it’s just as likely that the thing you need depends on a particular versionNo it's not likely. Openssl is a shared library that you can just replace with a version that has whatever fix. Unless you do rust/golang/docker/static linking… and the standard is to dynamically link.Running vulnerable software is always a risk. You might think you secured it, but vulnerabilities can get chained.Anyway I'm sure there are crappy softwares being written in any language. But the problem with js seems to be that even a state of the art one incurs such problems continuously because all dependencies are crappy.
I experienced the same issues and to me the main culprit appears to be the dumpster fire that is the ongoing transition to ES2015 modules.Also Node v18, while full of new, important features(like the built-in test runner) feels... kinda unstable? I had to downgrade to v16 because I hadsegfaults. Also had to make it use jemalloc due to memory leak issues when it used the default allocator.I went into this platform specifically not to deal with such problems.
Just want to add that node unfortunately gives me segfaults in unexpected places too, often (seemingly randomly) during the first second of execution when I'm trying to debug it by running node under --inspect-brk...
Something is indeed off here. Even Node 0.x didn't have so many problems (granted, the debugger back then, ahem, left one wanting).
To be fair: the reference to `node-gyp` gets at a general problem with most high-level languages.  I've seen very similar issues in Python - once you start to deal with native bindings, your nice high-level language abstractions become leaky, and you can no longer guarantee that building on new hardware won't fail in mysterious ways.  (This is, incidentally, one of the benefits of VMs / containers / anything designed to remove or mitigate the "new hardware" part of that risk.)If you look deep enough, or do anything low-level enough, or need to work with high-performance native libraries enough, you will find these leaky abstractions in every high-level language.  Maybe it's at the "I want to do awesome Cormack-style invsqrt() pointer punning hacks" level, maybe it's at the "eep I'm dealing with raw binary data over a network and now the order of bits matters" level, maybe it's at the "argh I'm using a package that has native architecture-specific implementations" level.
In the early 2010s, the industry was dominated by mature and stable ecosystems, such as Python/Django and Rails. Then Node came about, and when it was stillextremelyimmature, it got a ton of attention as an army of front-end devs started to flock to it. "We are backend engineers now too!".Doesn't work that way. Node has been basically re-learning all the lessons learned a long time ago, and many lessons it didn't learn at all. The fact that the FAANG alumni then joined the orgy and reminded us that we are all lame because we really need to be doing distributed systems for everything (for the young ones - microservices), did not make things simpler.Leave a JS project unattended for a few weeks and I go back to it with a sense of dread. What horrors await me?In contrast, I dusted off an old Flask project from 8 years ago, upgraded the dependency manager, the major Python version, 2-3 hours and off I go.
This was a relatively mild but necessary rant.> re-learning all the lessons learned a long time agoBecause this is the same crew that sailed on the ship that sang the "over 30 is over the hills" song. In fact, wasn't our own /u/pg cheering this 'very wrong idea' of completely discounting experience on the side?Surprise, surprise. Experience actually matters.
But hiring college graduates is so much cheaper and they are so much easier to dazzle and don't have any outrageous demands like being able to spend time with their family. Why hire for quality when you can make it up with quantity?
> by mature and stable ecosystems, such as Python...Nothing I experienced in the JS ecosystem so far was as nearly as painful as the over a decade-long transition from python2 to python3, and now python3 has the same 'move fast and break things' mindset. It's kinda infuriating for use cases where python2 was more than good enough.
About python past mistakes and future breaking changes, I recommend you to check this talk[0] about the topic[0]https://www.youtube.com/watch?v=qC5Po77bfKI
Still to this day nothing is as painful as trying to get a pip package or ruby gem with a C dependency to build on hardware where a wheel or whatever the ruby equivalent is unlikely to exist.
There's no free lunch. JavaScript has the largest package ecosystem in the world. It's great for finding "free" UI components or server libraries for projects, but you pay for it in maintenance costs.That said, I don't think it's as bad as this article makes it out to be. There's this kind of maintenance in a traditional server-rendered Django/Rails app, too, on both ends. You can self-host your JS scripts or fetch them from a CDN instead of using Node, but they're still deps. You still have to worry about upgrading and vulnerability scanning. It's just invisible now. The onus is on you.
I've got perl web apps that haven't been touched for 15 years (aside from a single change from a flash <object> to <video> in the template) that still perform their function perfectly well
Sure - if you don't need rich UI interactivity, you can get by with a lot less. Plenty of sites don't and should.What I like about Node, though, is frameworks like Next.js that are the best of both worlds. You can do traditional server-side rendering using React components, so you can easily add as much/as little client-side JS as you need.With Next you use the same package manager for the front end and back end. And you get code sharing and access to that huge ecosystem of libraries.But needs and skillsets change the equation, definitely.
>> JavaScript is evolving too rapidly.No it's not.There's lots of dependencies and they continue to be developed.It's not too much and its not rapid.  It's just constant.
rapid is ok… constantly breaking backwards compatibility is the issue.
Build on quicksand, sink into quicksand.I may complain about Swift/iOS/macOS breaking things every year but they seem like bedrock compared to many JavaScript environments and frameworks. Come to think of it, even many Java apps seem to be built on a quicksand morass of constantly changing frameworks.But I think you can have fairly stable JavaScript if you write primarily vanilla JS and don't rely on the latest bleeding-edge features in Chrome, etc..
The only reliable solution to this that I have found is compiling an app into a docker container and ensuring my projects are able to run off a SQLite database.I then save this to my NAS.Otherwise literally everything will break.Running an app that I wrote only 3 years ago will blow up.
I don't understand: if you have fixed dependencies and the same Nodejs version, how can things break?I'm not saying it's a good thing to not update your packages but you seem to imply there's another force messing with your project?
In general it's a hassle when your processor arch, OS version, and node version starts to come into play. NPM doesn't handle this in a great way, especially with native dependencies that need to build, and rely on OS apis. NodeJS isn't particularly stable either.For example, I used to dev apps on windows, and run them on Ubuntu 16. That worked alright but required minor changes. Moving to Ubuntu 20 on my server required a couple tweaks, and then later moving to deving on Mac required more changes.Of course keeping old copied of databases is a different story but SQLite is just so convenient compared to backing up full fledged SQL dbs.These were for old finished projects I wanted to briefly spin up.
we should stop saying javascript when we mean nodejs. there are plenty of javascript ecosystems now and not all have those issues. if someone wants to use the latest experimental nodejs framework in a project sure its going to be difficult to continue a few years later, but if you want to build a sustainable long term project in javascript its simple to do. only use dependencies without binaries inside and only web standard apis no node apis and vendor/ hard pin everything you depend on. also use less dependencies 98% of what typical nodejs projects have is tech debt that is not needed.
Well js might have killed js programs. But I can go back to my python and C projects after a couple of years and rebuild them just fine.
"your new operating system"?What does this have to do with javascript? And with javascript evolving too rapidly? Software written for one OS sometimes doesn't work on another OS, or even on a new version of that OS. At least the latter is almost universally recognized as a problem of the OS, but here justifies a rant about javascript?
I agree with you. Now, thanks to JS and web browsers, anybody has access to a wide eco-system via a small interface. This is mine :http://lambdaway.free.fr/lambdawalks/with which I can play and explore lots of funny algorithms.
Tools like Babel emerged to bridge a compatibility gap between the evolving ECMAScript specification and the browser lacking behind implementing the new features. Then some "smart" people decided Babel would be a good thing to transform anything and thus React, JSX and the like were born. The problem emerged and took foot when we stopped polyfilling and transpiling the compability gap and instead built further on the powers of these tools and coupled us too tightly with them.People need to learn to build on and use the platform. Do NOT learn React, Node.js or Tailwind. Learn HTML, JS and CSS. Use these in your projects and they will work forever.The standards are backwards compatible and evergreen.  
Your walled garden withers.
> Then some "smart" people decided Babel would be a good thing to transform anything and thus React ... and the like were bornIs this a serious comment? You're playing into the typical HN bandwagon of hate on anything web related. React is a library for declarative UI and state management. It doesn't need Babel or even JSX to be used. It can be used in the browser with no build tools at all. Except no one does that, because productivity of tooling is a massive win.Your complaint about polyfills, transpiling, etc, is just a thinly veiled attack on React because you apparently have some gripe with it.
This is terrible advice, on the order of “learn assembly, not C”, or “real geeks compile their kernels with customizations”.It’s a tale as old as time:  the “smart” people are actually dumb, I am the smart one, and so I will build my own framework from the ground up of JS, HTML, CSS as part of my work.  And maybe eventually I’ll release it to the world.This is why the JS community is the way it is - lots of folks thinking they can do better than the last group.  This plays out a few times in mature language ecosystems.  Sometimes, occasionally, it’s actually true.  In the JS community there have been a LOT of new attempts with “just enough” better ideas to form a sustainable community around them.  But most of the time this is a wasteful idea: reskilling, reinvention, endless advocacy flame wars, etc.But such is the tech world, we used to see this with Operating systems in the 80s and 90s before we settled down mostly on *nix.Doing it all by yourself from base technology is fine if it’s just you and you’re the boss, but is a recipe for an unmaintainable mess that will be hell to deal with and likely thrown out once you leave whatever organization you inflicted your brilliance on.The JS community is an example of what Happens when there is no strong central body in control of core library and framework maintainability.  There are subsets that are well maintained.  Use those.
To compare plain JS and React/stuff with C and assembly, that is a bit much. The comparison of things from so fundamentally different ecosystems is not going to yield a convincing argument."Smart" people are actually dump, if they use an overblown framework for something as simple as a switch on a website and thereby destroy normal browser functionality, because most of them do not actually know how to use their hammer.So once one has carefully considered not using a full blown megabytes sized framework and simply writing a few lines of JS instead, coupled with standard conform CSS and has actually thought about what parts of a website really need to be interactive, then one can still decide point-wise / component-wise, where to use a framework.The problem in the JS community is a huge load of people, who present their specific solution as a general solution and others who trust them and add dependencies to their project. Putting something like left pad as a package shows what I am talking about. There is no need to have such a simple thing be a package and no harm in writing a single simple function, when one needs it. But in JS ecosystem there are also loads of devs who just started out developing and they are happy to choose dependency after dependency, because it means they can have it now, without having to code it up themselves, even if it should be a simple exercise. That does not lead to being very smart. Smart is, when I can avoid dependencies, due to intelligently coding simple things myself in generally reusable ways, so that it does not impact future development. But with most of the JS ecosystem mentality, people never get there.
> if they use an overblown framework for something as simple as a switch on a website and thereby destroy normal browser functionalityLikely not what you meant, but FYI there is no native "switch" control in HTML - you do need to use a CSS or JS framework if you want something like iOS switch control.  QED
Your definition of "QED" is quite a funny one.I don't need a JS framework for a thing, that has 2 states, which can be realized using 2 CSS classes and toggling between them. That's maybe a 3 liner, if at all.I am not using iOS and have no interest in it, so I have no idea what is so special about an _iOS_ switch control. Since I don't know what is that is, I also cannot really want to have it.Fairly sure that I could probably find some easy to follow tutorial on how to make something graphically resemble a switch, if a checkbox is not sufficient for whatever reason, if I look for it ... Oh I just found a website which lists 20 of them in pure CSS on the first search query I entered: "plain css js make switch"
CheckBox is a native HTML switch control.Change my mind.jpg
>  Do NOT learn React, Node.js or Tailwind. Learn HTML, JS and CSS.How exactly should I use html and css to replace nodejs?
You don't do server side code in JS and then you don't have a need for Node.js. Easy.
Learning React, Node.js, and Tailwind doesn’t mean that you’re not learning HTML, JS, or CSS…
I was going to say the same but I think you said it much more clearly than I would have. I see this meme a lot. "I hate X, don't learn X, Y is better because Y is fundamental to Z".I have not once seen these same people suggesting "Don't learn the toolkit/framework/control library for your OS, instead use raw WinAPI or X System calls and push raw pixels to build applications".Yet, they push for the same with HTML. How you arrive at the HTML is up to you. By saying, for example, don't learn React, you might as well be saying "don't do anything productively, do everything in the least maintainable and the most convoluted and unnecessary way possible, your customers and team will like that surely".
The difference is, that JS, CSD and HTML are evolving. They now offer way more than they used to. We can do so much with HTML 5 and CSS 3 already. The argument is to not use React or similar, when a simpler way using standard conform means is available.It is hard to take a comment serious which compares not using React to not being able to do anything productively. It looks like a very junior React-only dev comment.
> The argument is to not use React or similar, when a simpler way using standard conform means is available.Please show me which part of any current or future proposals show a declarative UI  + state + input + template binding mechanism which React or even something like handlebars provide.If you're going to mention three or four different API's and explaining combining them together, then you've just reinvented a worse X framework.You can't just dismiss everything as "well you can do X with the native platform" which is literally what I'd already made an analogy for.> It looks like a very junior React-only dev comment.Personal attacks, nice. If you believe I'm a junior for my comments then you are free to believe what you want, it does not change reality.
You can buzzword all day long, but that doesn't make the typical React component any more declarative than the next script. Components reyling on internal state, querying that state and then munging some JS code into some HTML-like template and mutating the state again, when a user interaction happens -- That's hardly a declarative UI. It also does not become more declarative due to using an angle bracket notation for components.One can look at some Prolog code to get an actual idea about what declarative means. In React you are not writing down constraints and logic rules, according to which React automatically figures things out. You are not working with relations, which need to be kept true. React is far from a configuration only kind of framework.To claim something like one cannot be productive without using React or similar framework is really a silly thing to claim. Most websites do not even need to use any such framework, because in their nature, they are not interactive. They show information and that is it. Then there is a set of websites, which has here and there some small interactive widget, which one could argue to use a framework for, in parts, not for the whole friggin website. This still allows for people, who merely want to retrieve the information and leave without interacting. The third and smallest category is then the set of websites, which actually need interactivity and state in the frontend everywhere, where such a framework can be justified.
> We can do so much with HTML 5 and CSS 3 already. The argument is to not use React or similar, when a simpler way using standard conform means is available.There are no simple ways to build UIs available in HTML5 and CSS3.It has neither state handling, nor reactivity, nor any APIs that don't make you tear you hair out (or build another lib/framework).It's a horrendously bad half-low-level half-high-level API with hundreds of one-off solutions and special cases that form no coherent whole.You still can't reliably animate adding to and deleting items from a list without hacks because even if you so much as look at DOM, it will re-layout and re-draw the entire document.It still has no collection of well-specified built-in controls beyond a few primitive ones.https://open-ui.org/is about twenty years too late.But sure, you can finally put items in grids now. I guess that's nice. But when you need a dialog element you need copious amounts of hacky Javascript to make it properly accessible. Go figure.
People have built "UIs" on websites for decades, without the current flavor of SPA web frameworks. It is actually very easy to put things like a navigation and forms and such things on a website. Most websites do not need more than that. They merely show some information. Maybe you can register through a form or login through a form to see some more information. Not every website needs to be a SPA. The use-case you are apparently relating to, the one of websites really needing a more complex desktop-like UI, is merely a small percentage of websites. If you find yourself building a SPA on every second project, then you are most likely just following hype.If you find yourself wanting to put dialogs on a website, consider showing information in a different way, more appropriate to the web. Work on your assumptions of how things must be done and some problems will disappear without ever having to write gnarly code.Aside from that, writing a dialog is really not that difficult. I've done that before and I didn't need any framework to do it. Just don't rely on its modality for security, obviously, because one does not rely on frontend code for security anyway. Element zapper will make short work out of any dialog, that tries to block the stuff underneath it.Ultimately the browser is not the desktop. It has a different use-case. Too many people do not understand this and try to shoehorn things into being "like on the desktop". Write desktop programs, if you want the desktop (not Electron shit ...). Write websites, if you want the web and the browser. Both have their own quirks and complications. Trying to force one into the other will only lead to more complications. Good design pays attention to the medium.
> It is actually very easy to put things like a navigation and forms and such things on a website.That's about 1% of 1% of what people want to build.> Most websites do not need more than that.That we can agree on> If you find yourself wanting to put dialogs on a website, consider showing information in a different way, more appropriate to the web.dialog is literally a web standard in the web platform you so ardently advocate for.https://developer.mozilla.org/en-US/docs/Web/HTML/Element/di...> Aside from that, writing a dialog is really not that difficult.Tell me you've never built a proper accessible dialog without telling you've never built one.> Too many people do not understand this and try to shoehorn things into being "like on the desktop".I can empathise with this sentiment because I've expressed it myself many times. However, that ship has sailed and the platform has not adjusted in the least.
Oh in theory you are correct, but in practice once people are given a hammer, everything starts to look like a nail, especially since they do not yet have the basics down well enough and it does lead to them not really learing the basics, because "it also works with React" (no matter how shitty and with how much overhead)
> The standards are backwards compatible and evergreen.They are definitely not backwards compatible. Most of the modern web will be broken on older devices. A few of the newer standards couldn't even be properly polyfilled on some older browsers.And some of them are definitely not evergreen. Marquee is the one that will definitely spring to mind. But then there was Custom Elements V0 that Youtube was rebuilt in and removed when Youtube was rebuilt in V1. And then there's the push by browsers to remove alert/prompt/confirm.> Your walled garden withers.These "walled gardens" use the platform as much as your half-baked lib/framework you inevitably end up with. Because there's nothing else to use in the browser but the platform.And the platformsucks. It offers almost zero functionality for anything beyond a static text page with a few images on it
> Most of the modern web will be broken on older devices.And the super heavy js websites will work?
Not necessarily.How old and how backward compatible are you thinking?- Symbol is 2014-2015- Map is 2014-2015- Weak* data structures and their methods span 2014-2021- WebGL 2.0 is 2017-2021- Custom Elements are 2017-2021- Chrome-only non-standards (hardware APIs and a bunch of others) are pumped out at a rate of up to 400per year- WebAssembly MVP is 2017-2018And so on. That's off the top of my head. None of them are backwards compatible. Some of them cannot be polyfilled.
This attitude usually results in a company inventing some bespoke abstraction/framework whilst saying they are following standards.
Too much churn is killing me.JavaScript is really just the tip of the iceberg or maybe the perfect embodiment of modernity.Looking at it narcissisticly, it's like some kind of divine punishment for younger me who couldn't wait for progress and innovation on basically everything.
some ways to combat this:- do you really need to upgrade?- try to reduce dependencies- freeze packages to specific versions- are you sure you need to upgrade?- if you depend on a simple package that you can't be bothered to write yourself, consider moving it into your project- try to get more control over how your project is built- try not to use dependencies that have implicit dependencies on other languages (msgpack written in c++ for example)- try to choose packages written in typescript first if you're using typescript- make sure you have a good reason to upgrade
The solution is very simple. Lock your versions in package.json. Everyone stays happy. The only thing to keep track is, is what version of NodeJS you are using. It will happily keep working for years!Do I get a super long list of deprecated and warning messages? Yes, they are also meaningless. You can ignore them and just build the feature.
This is exactly my feelings throughout this thread. We have apps in prod that haven't been touched in years that don't break and handle average to high req/s. We add a line here or there as we need to for bug fixes but we don't have any dep problems randomly breaking the app.Pin your deps and everything keeps working how you want.
I have a bit different view.If some app is not updating - there is not much use for it.Just like houses - yeah you can have 100 years old house but if you did not invest in it and expect to be just as good as new you are in world of pain.Same with cars - 10 years and you really have to change quite some parts.Applications are ideas - we expect that ideas don't "wear out" - well most of ideas wear out rather quickly and are not useful for centuries.My javascript app is not Plato "cave allegory" - but that is fine and also what makes javascript app valuable, I can throw it away and rebuild from scratch even better with low effort. Data storage or formats should be usable for at least 5-8 years. There are things that should be preserved for longer - but these are exceptions. Most stuff after 2 years is not that useful anymore.
You have low expectations; I have Racket programs that have worked for over 10 years essentially untouched.  More or less the same with Perl.  We should be aspiring to Plato's cave (while accepting that we won't reach that).
If some app is not updating - there is not much use for it.That depends entirely on the program. My CD ripper/burner is going on twenty years old and it works flawlessly. Same with my audio recorder and the sensor viewer for my phone. On the occasion I need to make a slideshow or write a document, Office 2007 works just fine with no bullshit, granted I don't view third-party files in it. ES File Explorer Pro is still by far the best Android file manager despite not being updated in three and a half years. I wouldn't be particularly upset if I had to use a version of VLC that was ten years out of date.
> My CD ripper/burner is going on twenty years old and it works flawlessly.This is probably a good example though. The state of the art in CD ripping has advanced significantly over the last 15 years. If you care about bit-perfect rips or even just reliable error correction, it would pay to know about the advances in Exact Audio Copy (Win), XLD (Mac), or Whipper (Linux).Allof these have seen releases since 2020. If you have a newer CD drive model, having an updated database in your ripping program can help you get perfect rips, as same-model drives typically have identical bit offsets. In addition, bug fixes can prevent (admittedly rare) ripping issues.
Good to know if I ever hear an error in a track I ripped. Hasn't happened in two decades so far, but you never know.
The odds of it ever being noticeable are indeed quite low.
>ES File Explorer Pro is still by far the best Android file manager despite not being updated in three and a half years.Is there something special about it? I'd typically recommend either Ghost Commander or Simple File Manager from f-droid to someone.
The way it handles separate windows and also network file shares. Even highly-acclaimed managers like Total Commander only support two windows at a time and don't really do customization. When I open ES my first window is my internal storage, swipe right for my microSD card, swipe right for my network drives, and swipe right again for another copy of my network drives. As many windows as I want, in any default configuration I want, with no screwing around with mounting or unmounting network shares. Also the built-in equivalent of SpaceSniffer is quite handy.
Updating is fine… bash for example keeps having new versions and new features.However this doesn't mean that we must fix every bash script every 6 months because of a bash update.
That's why I stick to the POSIX shell (sh)https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V...
> well most of ideas wear out rather quickly and are not useful for centuriesI'm not a religious person, but already a couple thousand years ago the bible folk rightly identified that there is nothing new under the sun. Or as BNL eloquently puts it, "it's all been done before."I don't know how we could ever quantify it or qualify it, but I would guess thatmostideas stick around.
Couple hundred years ago people were still thinking that Earth is in the center of the universe :)Ideas that survived is survivorship bias - everyday life just shifts around.
> Couple hundred years ago people were still thinking that Earth is in the center of the universe :)They were? Were they educated people or just some random people?
Well just read up:https://en.wikipedia.org/wiki/Nicolaus_CopernicusCouple hundred years ago - this was up to 600 years ago - I was not saying about 100 or 200.
Well 200 is "a couple"
Pro tip: unless it's a trivial app, and if you don't dislike "difficult" languages, use Rust for the logic. It tends to be backwards compatible and interfaces nicely with Javascript with WASM, and you can share it with other frontends like native apps.
Most of the time when JS stuff breaks, it's in your core business logic. It's some frontend dependency someone included because they didn't want to write their own date picker calendar component.
I never did understood the relaxation behind pulling new code into your project from external sources.
I don't understand the point of this article. Most Javascript "programs" (lets not glorify them) are being stripped out of prod everywhere that isn't a NodeJS shop internally (and those are being garbage collected left and right by the Covid recession).If you build your tools with somebody else's entrenched technical debt, you are now paying somebody else's debt.
The package you use for testing may cause memory leak problems. The package you use for build may cause memory leak problems. With the new version of the frontend library you use, you can completely change its architecture and decorate it with different nonsense. Welcome to the world of javascript.
As I am preparing to update a 10 year old project done in backbone/coffeescript this whole thread hits hard. Likewise a react prototype done in 2018 that is all class based that is going to be next to revive.Maybe I should just write my own framework... quick, to the name generator sites!
That is what you get for using subpar tools that are not fit for the job.
Javascript is a garbage language. Javascript on backend is the dumbest idea ever conceived in computing.
I am a ruby dev mostly but I have to work on my clients react front end a few time. While I have no idea what node-gyp really is, it has come up more often then I care to remember.
This is what I go through every time I try to run my jekyll blog locally. Just total hell.
JavaScript will always win as is most accessible to new folks.
I like JavaScript, but it's a horrible first language imo. Especially if it's being used in the browser.
Is python and pip more stable in this regard?I need a scripting language with a robust library, and I’ve seem first hand how
difficult NPM projects can become.
pypi is full of awful amateur libraries that don't work very well.Finding a good one among 20 crappy clones is a chore, and the most downloaded ones are not necessarily the best options.I personally just stick with whatever is on my distribution (debian) and very very seldom venture out to using something directly from pypi.In any case python doesn't require many libraries, so most of my projects require no more than 2 or 3 dependencies. Where js projects require 50, so the risk of issues from a dependency changing API is not as big.
JavaScript feels like IE7 all over again.
We are probably at the tipping point where the JS engine should now be part of the kernel and run in ring 0.
I see you haven't watched this talk about the history of JavaScript between 1995 and 2035 since that's exactly what happened in this future:https://www.destroyallsoftware.com/talks/the-birth-and-death...
I have! It's a very good talk. I wouldn't make any design or technology decisions based on it tho.What is clear today is that Javascript is on every computer in the world (including phones). It is now even taking over for native desktop apps and native mobile apps. At this point, including a JS engine into all the kernels for apps and browsers to use just seems prudent.
JS in kernel is a beyond idiotic idea. Why the hell would you put something like that in the kernel? Computing world has lost its mind if this can even come up as a suggestion.I just feel that 90% of people on this website are junior web devs. That must be the reason for the glorification of a POS language such as JS. Why the hell would you even want to run this garbage language on the server? Now you want it in the kernel? Insanity....
lol, are you familiar with ring 0? what about context switching and scheduler preemption? If you are, then you know they add significant overhead to IO bound applications.> Why the hell would you put something like that in the kernel?Because some ridiculously large % of all client software is written in/transpiled to JavaScript?If the JS/WASM runtime would be run with the correct sandboxing (similar to browsers like Chrome), you likely could run the entire application in ring 0 and only context switch because of scheduling preemption. Maybe even ouch the whole browser into the kernel?All runtime APIs that currently need “syscalls” would become significantly more efficient. You’d end up with an extremely performant system for running browsers and browser like apps (ie Electron).
I am familiar with ring 0. Familiar enough to understand how stupid it would be to put a browser there. You don't need that many syscalls if you know what you are doing. Obviously, JS guys don't since they argue that many syscalls are needed and it's impacting performance enough that they should move it to ring 0. Jesus H Christ ...
If that kernel is linux kernel, then linux kernel should userspace app in js kernel.
npm ci is your friend.
It's partly a solution, but doesn't help when the 'enviroment' (OS, Node, compiler toolchains used in dependencies) has moved on and is no longer compatible with the old version-pinned npm packages, the same problem also exists in other programming ecosystems (just maybe not as extremely - but I have the same bad experience each time I want to write a blog post, because Jekyll usually breaks after a macOS update).It's not Javascript or Node.js or NPM which is the problem though, but the 'culture' of offloading every little detail into its own dependency, nothing in the Javascript ecosystem technically requires this approach.
Sure, but this friend is also changing. Suddenly now it verifies peer dependencies. Oops.
"yarn set version" could become your new friend?https://yarnpkg.com/cli/set/version
It evolves too quickly for 20 years fixing fundamental issues tgat stem from the hacky origin of the language.
Just run “npm ci” next time.
I feel like many people completely forgot about how simple and fast apps can be if there aren't tons of layers put on top of one another.Like you have drupal with bunch of modules, it's slow as hell so you put redis caching. It's faster but not as fast, so you add varnish on top, so you don't even have to touch the php code unless you make a change.But then you've never solved the problem, you just hide it two layers deep.And same with javascript - 85% of sites are visit would work perfectly fine without any javascript. Loading would've been instant, and you don't even need ajax if you can spit html document fast enough - the browser makes it seamless anyways. But no, instead, we do animations and slow down the time to interaction because it's fine sitting on 1Gbit connection waiting for your slow backend part that's not cacheable.JS isn't bad, it just feels like people think it can solve anything while not seeing issues it adds.
That JavaScript for loading contents and images is probably an effect of Google's changes a few years ago where it was all about the load time of the main page.So to rise up a few steps on the Google results page, people turned to serving empty pages with a small JavaScript (which finished loading fast - so bonus points from Google) which then starts pulling in the actual content.
I was under the impression that, because Google would have to execute all of that logic in order to even get the content people are searching for -- as I can't imagine an empty page would actually rank highly for anything ;P -- that they weren't using the time of the first request but the time it took to get the content that they decided was the page.
This is a nice insight.Dear Big-G: Thanks a lot for your hard work, you've really done something.
>i feel like many people completely forgot about how simple and fast apps can beMost web apps dont have pretenses of being simple. They want to use tools that have room for growth, that have deep capabilities.And they want to use the really good tools & libraries & technologies that will be used on more complex efforts. Specializing in being lightweight, narrowing the scope of your skills & capabilities is less attractive than getting good at something that works & ideally will also be fast in all cases.I think it's good to reflect nack to 2014, when React was coming out, & think of what rapid development looked like. Hand manipulating dom trees, course grained re-rendering by setting el.innerHTML,... React and the virtual dom were a huge huge performance win. Some up-front load price, but an amazing boon to rapid rapid developmemt, grossly reducing the scope of concerns one had to think about in webdev, & massively speeding up rendering/updates at the same time.React isnt the smallest but holy shit it propelled us into a massively massively faster world. Where development is just so stinking much faster/easier, where there are so mamy less bugs & memory leaks. Thanks react.So why focus on a niche, special purpose skill set? Why go back to hard mode? Is a 30kB preact bundle actually any kind of problem? Is a 100kB react bundle really a problem?>Loading would've been instant, and you don't even need ajax if you can spit html document fast enough - the browser makes it seamless anyways. But no, instead, we do animations and slow down the time to interactionBecause it's javascript we can often run the same code on the backend, & store & cache our documents or if it's light weight enough just render it (with already started/initialized workers). Hence: server side rendering (ssr).SSR is very prevalent, actively supported out of the box in newer JS libraries/frameworks like Next. React has had support for "hydrating" a SSR page on the front end for a while, but required some investmemt & didnt just work out of the box.Im very mixed here, about performance in general. On the one hand I want us chasing technical excellence, being fast. But I also see two things, one, that waiting for a second isnt the worst. Second, a huge amount of the slowness is ads and trackers, is shitty other people prpolems that businesses just accept, and developers at a company dont get much say in. Why would we spend iterations dropping load times from 2s to 0.4s when the damned trackers are still gonna make the site take 5s to load anyways?
"Most web apps dont have pretenses of being simple. They want to use tools that have room for growth, that have deep capabilities."No, that's completely false.Most web "apps" are just text and images, and would better be thought of as documents, which after all is what the web is for. Re-inventing that out of massive piles of JS isstrictly worsethan what we already had, and in fact still have if only we would choose to use it.Yeah, sure, there are definitely real app-y things on the web, and here on HN we're biased towards those as mental reference points because they're cutting edge and exciting. But those things are emphaticallyNOT"most" of what the web is.
I suspect (from my experience developing them) that most webappsare internal business tools that are hosted inside private networks or locked down behind login forms. Most people will never interact with them. I think these sorts of tools are the ones that the previous poster was referring to. (And they are rarely so simple as just text and images.)
How is developing with react quicker than jQuery for most websites?React never made development faster.. easier to manage complex state but not faster development.
With jQuery you are working with existing state & ongoingly trying to update it. In some cases you just need to turn on and off a class, but once you start making significant modifications, things get complex. Oops, you just replaced some DOM with some other DOM that's mostly the same, but now all your event handlers are lost- so now you've got to go add yet more band-aids to re-build event handlers. There's constant inter-dependencies when you try to keep working with one piece of state.React hides all that away. The virtual-dom just works. Event handlers all get faithfully reconnected. You never end up accidentally having multiple copies of content or having deleted too much content. As opposed to the DOM's native retained mode rendering, React gives a much simpler immediate mode rendering.And it's often faster. It's easy to do too much work, to end up replacing more than you need to when you are hand-working the DOM. React's diffing algorithm is quite effective at doing just what updates actually needed be done, where-as before I as tech lead would have to go re-walk through my teammates code & tune & optimize it, fix some of the gross inefficiencies.Working the DOM used to be a complex & subtle art. A lot of simple stuff you could just do & it was ok. The API was never delightful, even with jQuery. But there was so much latent knowledge, so many particulars, so many hazards. It, in my view, made even simple things much faster to develop.
If your website isn't managing complex state then jQuery will be quicker and easier.  If you are making hundreds of dom changes react will be quicker..  but the average website isn't doing this.  There should be complexity minimum reached before react can be used.
This is a gross over-simplification of a much harder decision to make. It depends. State can be simple & small, but it can still be hard to update your page accurately & quickly without tripping on side effects. For some tasks, this isn't a risk. For others, it's a headache.There is no hard fast & easy rule to tell how problematic managing the DOM yourself will be. It's not about state size. It's about how much work you're going to have to do to maintain the dom, & the risk of one interaction jamming up something else. Knowing you can safely work the dom requires a blend of careful analysis & general intuition, to feel out where different concerns might collide, and you can be wrong. And adding just one more feature down the road can cause significant nightmares, blow up these assumptions. For someone else who comes along to do some work & who doesn't understand every assumption you've made about interactions, the risk compounds.Moving from a retained mode DOM-manipulating view of the page to a immediate mode v-dom backed view such as react can save a huge amount of trouble. That just deciding & justifying your decision that only a small tool is required is complex that I'm more in favor of using React everywhere than I was before you posted: this oversimplification & overreduction emphasizes to me how particular & careful you have to be about justifying picking a less-safe tool. Simply tallying up the state you need is far beside the point. The DOM's risk has always been more about compound interactions. If you have completely isolated things on the page that only need a couple fixed features, and you never plan to grow the capabilities, maybe conventional DOM swizzling is ok. I still find it hard to recommend.
Honestly I think a lot of what you're noticing is the product of junior frontend devs. The nice thing about HTML is that it's really hard to write code that won't load fast, but you can write SPA which load fast, you just need to be more deliberate about how you load things and what you're loading. The problem with SPAs it's easy to create huge bundles pulling in numerous large packages then loading it all in the head where it will block page render. Layer that with some poorly designed APIs and slow JS animations and you have what you're describing.I'm not saying SPAs should always be used because in most cases they shouldn't, but a well optimised SPA should in theory be quicker and provide UX improvements to the user.
> I feel like many people completely forgot about how simple and fast apps can be if there aren't tons of layers put on top of one another.There is a trend in OSS SW development to "continously improve " programs. This means that the program stays mostly the same but it gets over time a "gui improvement" which brings almost nothing new but a lot of libraries and bloat. Two programs that stroke me were Xaos ( which got a QT dependency) and Xsnow. Maybe jwz was right that every program evolves until it can send email.
Yeah, an html attribute on <head> or <body> for not having full page reload would make a big impact.
Like htmx[0]'s boost attribute?I've been building a webapp with Python/Django and HTMX, it works like a charm.[0] -https://htmx.org
Sorry, I mean it should be in html spec.
I find Hotwire/Turbo/Stimulus in Rails to be a perfect low-JS approach.
Fully agreed. Two aspects that I don't see acknowledged often enough: (1) Not everyone has fast internet. This is particularly the case in rural locations and developing nations. We're witnessing internet inequality and heavy websites are fuelling it. (2) Information transfer requiresfueland burning fuel is destroying our habitat. It might seem trivial to shave kB off download sizes, but the cumulative effect of large sites doing this should be acknowledged and encouraged.My reaction to this ridiculous situation:Use Preact instead of React -- I'm planning to switch to Svelte next -- and using minimal dependencies and writing my own minimalist implementations where feasible. I need to get better at this.Use code-splitting and lazy loading to keep gzipped download under 100k forallcontent per "page".Avoid web fonts, images, tracking, 3rd party crap, cookies, advertising, etc etc etc. I'm lucky enough to be in a position where nobody is telling me to put this stuff in.Tree-shake, minify, compress (brotli if possible). Sure, it takes processing power to decompress at the other end, but my suspicion is overall compression wins. Happy to be proven wrong.User-test everything on a throttled connection at 3G speeds. Or "poor 3G" or whatever the browser dev tools have. This is subjective, of course, but gives me a good sense of user experience.It's not a perfect recipe, but downloading megs of crap for a web page is totally unacceptable.(Obviously all the above side-steps the "no JS" perspective.)
> This is particularly the case in rural locations and developing nations.Also in a conference / the train / the beach / driving / any crowded place / in space
Yep, anything else works, they are mostly sub 10kB view lib. It's fascinating that the current situation is widely acceptable.
Data still has to get to the cache, get stored, and sent to clients. More data = more energy, cache or no.Your point about video streaming being a far larger amount of data is of course fully valid. But I was replying to a thread about JavaScript.
Solid.js may change all this.
Solid isgreat, and its focus on performance definitely helps. But for now I think a couple of other tools are better positioned here, as they already focus on shipping less JS to the client in the first place. For instance Astro (“islands architecture”/“partial hydration”; it supports Solid islands however!) and Qwik (“resumability”/on demand loading of interactive JS as it’s needed). In a lot of cases, just shipping less JS in the first place is going to perform better for resource constrained usage.Solid is currently more oriented towards fully interactive SPA use cases, but they do have partial hydration (or something like it) on the roadmap.
Dunno. But i think JS has actively harmed software development in the past 10 years. It's a bad language, designed and patched hastily that does not work well with humans nor machines. It took 10 years to allow having some form of synchronicity with promises, and that's just disguised callback hell. Callback depth is an inherent human limitation, because our working memory is very limited , so I consider JS a language that s unfit for humans and unfit for big projects.Silicon valley adopted JS probably because of ease of access to cheap developers. Pity there is not a serious competitor from another Valley because i think they could beat them with superior performance in just about anything.
I think the problem is that javascript has stopped being one language of many and has becomethelanguage.There are hundreds of thousands of developers now who only know javascript. They have no perception of the parts of javascript that are badly designed because they don't know any other language. They think that computers taking 500ms to render a webpage is just how slow computers are because that's how it is with javascript. They think desktop applications that use 400MB of memory on startup are normal.People no longer weigh up the pros and cons of javascript and decide it is the best option for a certain project. Javascript is all they know, and it shapes their entire view of programming.
Oh, come on. JavaScript doesn’t mean pages take 500ms to load. On my Node.js-powered server [1], pages take a handful of ms, and they only take that long because I’m doing a lot of sophisticated content management.JavaScript has got some rough spots, but it’s a fine language these days, with a nice multi paradigm support.[1] jamesshore.com or letscodejavascript.com — they both run on the same servers.
I'm pretty sure they're talking about client side JS bundles, not a NodeJS server that renders HTML.
Heh, good point. It’s still a silly language-wars comment, but it makes more sense.
The kinds of devs who don’t regularly learn new languages are generally the ones you don’t want to hire.
Learning new languages is a different thing than crunching into the next JavaScript fud.
The great thing about learning more languages is that you tend to gain new skills to take back to your old projects. This is especially true for languages meaningfully different than those you know.The same can be true of frameworks, databases and other tools.
I can stand yet another javascript critic(just boring nonsense) but, “cheap developers” ?! that’s unfair to the many brilliant people out there, people that build new stuff and create value making the best with what they have and mastering the art without being chic. And Callback hell it’s just an old argument that’s been solved many times even before promises
OP didn't say all JS developers are cheap. They just said there's plenty cheap JS devs around, since everybody and their dog these days are doing frontend dev. Some, like you say, are brilliant.
I have learned all the frontend frameworks (though my React is pretty shitty) and have come to the conclusion that I much prefer just rendering HTML with html/template.The thing that led me to using the SSA style initially was that it seemed easy to write a backend and then bolt on a frontend.  But there isn't actually a good transport layer for that, and the API for your web app and the API for API users usually end up being quite different.  I think that GraphQL is intending to be the transport layer that just works (and since it's a graph you can query, theoretically means you don't have to write an API for your web app, teach your web app how to incrementally request things, cache things, invalidate that cache, etc.).  I have found that ... it's not that great.  The Go libraries for a server are terrible.  There are no debugging tools.  You send gigabytes of JSON for no reason.My personal favorite API is gRPC-Web, but I guess browsers never added the hooks necessary for bidi streaming, and the "tree shaken" protos + gRPC-Web runtime are HUGE, so I've decided it's not worth being excited about anymore.  I typically stick grpc-gateway in front of my gRPC services and get normal RESTful JSON.  And then I'm at square one where there isn't any magic in React to make that particularly useful.Anyway, yeah... just printing out HTML.  Not that bad.  Use fly.io and put the server close to your user and they won't even notice that it's slightly higher latency than caching everything in your SPA.  And it sure is easy to debug when something goes wrong.
Never roll your own GraphQL server on core libraries. There are existing implementations with good practices and debugging tools.
The tricky part of edge compute though is write operation and where the data store is.
I think this is largely because people are writing JS on the frontend, and it's easier to do SSR with the code you've already got, i.e. render JS on the backend too.That said there is a movement for a more flexible style, e.g.https://htmx.org/
> I think this is largely because people are writing JS on the frontend, and it's easier to do SSR with the code you've already gotThat and those writing JS on the frontend are, among all the devs out there, those the more likely to be working on SSR pages.
Correct. Most backend engineers today do only the APIs to be consumed by the frontend.And there always was some sort of a separation in the industry: I remember when in some enterprisey places there was the strange role of "webdesigner" or some other (often incorrect) term that was half-designer half-programmer that only took care of HTML/CSS. Javascript was used very sparsely. There were several frameworks whose whole spiel was to allow people not to write HTML/CSS/JS.Anyone doing both the backend and the HTML/CSS part was considered a bit of a unicorn, even back then. For a lot of self-taught people doing "everything" was the norm, but in the industry it wasn't.Then came Bootstrap etc and sorta equalised everything. Then came Angular and React and we needed a name for people doing the HTML/CSS/JS work.When rendering on the server became a focus again, the responsibility of writing the markup once again fell on people able to do HTML/CSS. Which means frontend developers. Which means JS.
Yeah and there also just aren't any good server side component libraries as far as I can tell - everyone is still just using fairly dumb templating engines like Handlebars and the like. At least as far as I can tell.
The term "Server Side Rendering" generally refers to client-side frameworks which have been adapted to server-side.  These have been nearly entirely JavaScript for obvious reasons.Frameworks that generate HTML on the server side have been around a long time, but are mostly not considered in this category.  I would say though there are a decent number of modern ones in the "static site generator" category that exist in many languages.It makes sense to me that in the current iteration of web tech that the client code and the server code be mostly in JavaScript since it allows for a single code base between the front and backend.  There is definitely hope for other languages in this space though as WebAssembly gains more traction.As for the bundle size of an app, it's not too surprising that a bespoke app would be smaller than a modest framework.  Choosing a framework will always be a trade-off of size, complexity and whatever features the framework offers.I think wether you see it as "suck" depends on how much you love or hate JavaScript and how tolerant you are to using modestly large frameworks.  Mostly, I see the modern crop of JS frameworks as a breath of fresh air compared to what precedes them, though the complexity of what is imported when running an `npm install` is enough to give me pause and a wish for something more minimal.
It's "client-server" architecture for reasons though. Client and server mean to have completely different roles, architecture, languages. However, browsers just happened to support one language. There are also protocols between that.I don't hate javascript as I write it too, but I also write many other languages. And I also think more of the web generally.
That’s not quite the right way to put it. Client and Server have different roles, yes. That does not mean theyhave to bewritten using different languages. JavaScript on the server (in Node or Deno) is perfectly fine and scales reasonably well.If we take a step back from the most well-known client-server system (the World Wide Web) and look at other examples, we’ll find that client and server are often developed together, in a single language and similar architecture.
The point is javascript-only obsession/perspective. Javascript should be fine as well as other languages.
I am a front-end developer and a Javascript veteran. While I do hate the "hate" against JS, even I think using JS on the server for rendering to HTML is a terrible idea. It doesn't scale, it isn't natural;  it's just convenient and taxes the end users.My solution for that is to liberate UI programming out of a single language, using WASM as the abstraction layer. For more informationhttps://github.com/joelewis/kwasm
I think I get why people like it. (I am starting to like it and am falling down the NextJS Tailwind SSR rabbithole)React is a decent framework conceptually and more importantly it has become a defacto standard for UI development in JS. On top of that the sheer amount of React support in terms of components, tooling and learning resources is immense.NextJS says “use what you already know and use on the backend (React), and not only that we will make it seemless to use the exact same code to render an initial paint for time to render/seo as you do for live updates, and we will chuck in static site generation for free”.Tailwind is another thing that seems really really odd, until you use it and then it seems brilliant. In a nutshell it is css classes like “m-1” for a small margin.It would be awful for a handcrafted static site, but it works great with React because it plays well with componentizing code. If skeptical read their site where they address the obvious reasons for being skeptical.
The thing with react SSR (or SPA) is it's easier to manage layout, styles and shared components since it's all react, as opposed to html / template rendering and using react / others in places / pages where it's needed.
I love that even my email templates are now just tsx files and rendered on the server with ReactDOMServer.renderToString(). No more context switching, everything is TypeScript / React and refactoring is an absolute joy.
My vanilla JS app is way smaller than your fat app. JS doesn't automatically mean massive frameworks and libraries. Just write vanilla from-scratch JS like I do and life is fun and happy.
DOM manipulation in vanilla JS is an enormous pain in the ass. Youneeda framework, or at least something like jQuery, to be productive,
Umm no?! Maybe 20 years ago. But it's trivial today
You think? FastComments doesn't use any DOM manipulation frameworks.
The obvious reason is that Javascript is the only language that runs on most browsers (outside of Webassembly, which has its own limitations). If you want to do anything interesting on web browsers, you will have to deal with Javascript.A more interesting question is, why is Javascript the language that all browsers support? Go back 20 years, and it wasn't actually obvious that Javascript would beat out Flash, or Java applets, or even VBScript to be the main way to get interactivity on websites.
I just had a terrifying vision of the alternate universe where VBScript became the lingua franca of the web.JavaScript isn’t perfect, but standardizing on VBScript would’ve been a catastrophic mistake.
wasn’t obvious? I’m not sure, thanks god flash was killed, it was a security nightmare. java applets were a heavyweight punch in the face and vbscript… well is was vbscript. not even mentioning accessibility issues of the aforementioned. with javascript the open web won luckily for us
there is a growing reaction against the JS-everywhere situation, using hypermedia & HTML over the wire rather than JSON data APIsI am calling these applications Hypermedia Driven Applications or Hypermedia Oriented Libraries:https://htmx.org/essays/hypermedia-driven-applications/libs like unpoly, hotwire or my own htmx are all hypermedia oriented, recentering HTML and hypermedia as the core application architecture for your appsome other related essays:https://htmx.org/essays/spa-alternative/https://htmx.org/essays/a-response-to-rich-harris/the really nice thing about the hypermedia approach is that it takes pressure off adopting JS/TS on the backend, since you no longer have a massive front end codebase already in JS/TS and it can be hard to justify having two different languages, models, etc.  With hypermedia, you don't have this situation.  I jokingly call this "stack" the HOWL stack: Hypermedia On Whatever you'd Like.
To your second question about the app size vs. framework/library sizes:Frameworks and libraries provide generalised solutions to some common problems. In react and react-dom's case it's defining a ui in a declarative and more or less performant(wihtout making the dev think too much about it) way. The downside is; it includes lots of things your app doesn't need but other apps do.The alternative is to roll your own but if your solution did all the things that the X framework did; then you'd end up with a similar size/complexity. You can build the features only needed by your app; but then I can't imagine the amount of engineering hours wasted for every apps custom framework.And nowadays ~110kb is not that big of an application really. It might be really complex in terms of concepts and what it does but current day apps are a lot bigger than that in terms of size. So the size of frameworks doesn't make that much of a difference in most cases. For example the app I'm working on in my job has a total bundle size of ~15mb minified excluding any third party code. This is just the code written and being actively used by us. We don't serve it all at once and load as needed but still.
Solid.js is very small (sub 7-8kB IIRC), very similar to React.
Yes, and I think Solid and Svelte's approaches of moving complexity out of runtime and into build time will be the most popular one very soon. But this also comes with its downsides. It complicates the build process, obviously. Debugging is harder since what you code is not what is being run at all. And they usually come with some catches like "if you use this javascript thing, your reactivity will break" kinda stuff - at least for now, but I think it can and will be solved.The gist is; there are options and there are tradeoffs.
That's the only aspect of complaining. Size is one thing, it's also javascript for everything.
One of the core propositions of Javascript SSR is that you can write everything in the same way. If you have your data at compile-time, great, it can get prerendered and bundled. If not, it can be rendered on the client, the code you use it the same. You can share the logic for both, same components, same layouts, same business logic etc. You can have initial data rendered on the server and then live updates one the client side without any additional work around templating and business logic.Obviously, there are ways to write the same page and end up with a smaller bundle size, but size is only one dimension. Javascript SSR offers (arguably) less development time and less maintenance (as there's simply less code since you handle both the same way) at the expense of other things, such as bundle size etc. As with any other tradeoff, you can't only look at one parameter and say a thing is good or bad, you need to look at the whole package and figure out whether it makes sense in the given context or not.
I fully agree and would add: Component-oriented frameworks like React/Angular/Vue/… give you the ability to easily test your components individually (in the sense of unit tests or integration tests or manual tests / storybooks). Most classic templating languages for the backend don't offer anything similar and doing that would also be quite challenging: Most of the time the backend controller rendering/populating a given template is deeply entwined with business logic and database calls – good luck separating those concerns after the fact.
1. Only JS is already in the browsers. 
2. JS is simple.These are the big killer features and selling points for it's crazy adoption.But fortunately with the raise of TypeScript, which solved many of JS original traumas and made it team-scalable, it's not that of a big deal.In the end it's not about "trying-to-be-innovation", it's about money.Yes, it may be much faster and more appropriate to run some code on Go or Java. But often the difference in salaries and time to market (see selling points above) can't justify that decision.I personally witnessed the benefits of migrating from Scala to Nodejs in a big company, and I'll definitely vote for Nodejs next time in similar conditions.
It is the present. We try to maximise the features and reduce the cost. For example, no one develops apps in assembly by hand anymore, it’s not productive.130kB minified is nothing unless you make an app for people in Africa or very remote parts of the world. It is cached and is loads instantly on most connections. Check the network speeds of your users, it’s very likely more than fast enough to load a 130kB file once.https://en.m.wikipedia.org/wiki/List_of_countries_by_Interne...
Are you implying that it's okay for a web app to be unusable by people in remote areas unless it's specifically designed for them?
It’s not unusable, just a bit slow to load.
You not just count the js framework. All parts of a website contribute to the bloat. Things get exponentially slower for each thing added.I will for example "excessively" test how many images in what resolution I can get away with. Is my json to big? Can I use a custom font? Do I need to start the "infinite" scrolling fiasco? In what order are things loaded? Are we requesting a html document that when parsed has us request a js file? Is its execution delayed by the dom state? Then it parses out html? And then that html requests media that loads lazy?If I would find myself there the 130 kb (and its overhead) would persistently bother me. When I get to it it will get ripped out and replaced with inline vanilla js.It's not just that I want my application to be snappy and appear instantly. I also want to see instant results when testing it. There is no build time. It doesn't exist.
There is a javascript size usage graph yearly .. I don't have a link bookmarked but it's getting insane. Note that 130kB is without starting writing any application.
The amount of friction a designer gets for adding several multi MB images to a page, in every organization I've worked for, is very little.2 MB minified, compressed, ball of js is nothing.  I've even seen companies accidentally put their debug builds in production (>15MB js ball) with without noticing or getting complaints.I'm much more sensitive to page weight than most, and every sizable dev shop should have someone who is.  But even I realize that current business reality is it didn't matter nearly as much as sensitive tech people think.
Yes no one cares about the JavaScript bundle size until it becomes a problem.
I prefer not to create problems for myself.
Sure, but it’s more challenging to keep the bundle size very low for no reasons if you want to use modern tooling and work in a team. It’s fine for your personal hobby website, but people at work shouldn’t waste times and create problems to avoid a small and rare problem.
Rails is sort of fighting against this.  It's trying to hide or remove as much JS as it can, with http over the wire.  Still some JS, but not visible to the dev (unless they go after it)
Phoenix as well with LiveController. It’s impressive what can be built with minimal JS while being pretty responsive and snappy.
Been doing web development for 25 years, I am currently learning Rust in hope that I can compile to Web Assembly and build SPAs that way. The JavaScript ecosystem is a mess of module systems, type systems, layers upon layers of libraries and build tools and building a web app that is actually maintainable, consistent and extensible is difficult to impossible. We need better tooling than what is currently considered standard.
everything is fine. i’ve gone full spa[1]. i don’t think i could go back.my starter project is here[2]. backend is go on lambda. frontend is clojurescript with react and mui, compiled down to a single html file with js inlined, and pre-gzipped.lambda zip contains two files:- ./main- ./index.html.gzipthe backend returns the index for any route not beginning with /api/.websockets and http ferry information between frontend and backend. s3 and dynamo persist data. ops are easy. sdlc is fast.frontend runs local and instantly reloads. backend reloads in 1s. if you have bad upload bandwidth, do backend builds on an ec2 relay for $5/month! or just tolerate 10-20s backend reloads depending on your bandwidth.sure the index is a bit heavy, but if it’s not annoying to use on a phone over cellular, it’s probably fine.have most react devs seen the regeant[3] interface that clojurescript devs use with react? it’s so simple and hasn’t changed in a decade!i start all my projects this way now, and am so happy. i can’t imagine a better workflow.1.https://gocljs.nathants.com2.https://github.com/nathants/new-gocljs3.https://reagent-project.github.io/
I’m kinda done with the JS-heavy frontends. I started my career as a nodejs developer, and spent a lot of time in SPAs in the backbone/angularjs days. The current template at my work for creating a new typescript/react UI is ridiculously heavy (to me).I’m working on a new project that is using F#/Giraffe, with the Giraffe view engine. It’s using htmx to update content without a full page reload. I love it. It’s been the most fun I’ve had developing a web app in quite a while.
True, start innovation with javascript will not lead us to anywhere because the design is not going to be generic enough to form an innovative pattern that can be used everywhere. It's called "client-server" arch for reasons.
We could do client-client
Though we had that discussion recently, I will again point out that, from how I see it, the term "SSR" doesnotinclude/refer to classic server-side applications like PHP, Django, ASP, whatever. Instead, it is used specifically to refer to single-page applications, rendered on the server. Nothing else.If you search for SSR, you willnotfind PHP, Django, ASP.
Which is funny because I recall SSR was how one referred to non-SPA websites. Anyway, the new term seems to be server side generated SSG.
Yeah, that sucks. So much that there are people building tools to avoid that approach. Take a look at these:-https://htms.org-https://unpoly.com-https://hotwired.dev
I think you meanthttps://htmx.orgReading over the Hotwired homepage, I honestly thought it was a funny parody likehttp://vanilla-js.comTurns out it's an actual framework!
There’s a lot of discussion about developers and business drivers. But remember things like React and Angular hsve been around for a decade or maybe a little more.At that time flash was on the road to sunset (but still a thing - YouTube was flash then), and mobile devices were still in hyper growth mode. Browser makers (well Google and Apple) were investing alot of resources into making JavaScript more performant.In my mind, it’s a no brainer. You want to deliver rich client experiences without proprietary hooks like Flash and Silverlight. The most heavily resources engineering orgs on the planet are focused on making JS fast… the smart strategic bet bet is to bet on them!
>Is it just me that interpret this situation as "suck", or this is the futureFirst, there's room for everyone. Plenty of other trchnologies have are & will happen. But JS has by far the biggest, most boisterous & complete web ecosystem. By far. And a huge amount of the ecosystem works just as well front end, back end, and thanks to AssemblyScript, both at once (portability: a huge advantage).As for "just me" / "suck"... other people also turn up their noses. But largely these are legacy preconceptions. JS didnt used to have robust serverside stories (altough I did write some JScript a long long time ago...), didnt have fast runtimes, didnt have a package ecosystem, and so yeah JS didnt fit. But it's grown evolved & gotten fast.Much of NodeJS's history stems directly from Ryan Dahl comparing python web framework's performance,... and finding them wanting, thinking he could do better. With a performant async server, with Isaacs developing npm packages, things quikcly took off.Some poeple dont like JS the language. I have less clear ways to refute this, since it's almost entirely ill defined bias & personal opinion: you cant really argue with someome who says "i dont like bananas" & thats about as far as these discussions tend to go. JS ticks all the boxes for a great & capable way to write server side code. It's stilltheway to write front end code (although wasm Component Model (nee interface-types) is finslly happening & will make other languages much more viable).>when I look at react-dom it's 130kB minified which sounds CRAZY to meAs for react-dom, well, it's magically good stuff. It's worth it. Having immediate mode style rendering, having deep deep control over the front end, but not having to swizzle dom: it's a huge accelerant. There's preact & other "lite" takes that work similarly. I suspect react-dom might tree shake & get smaller for many deployments: bundlephobia can mever detect or understand how much code you will end up not shipping.Also, this only really should affect first load & occasional library updates. clapping:it. just. doesnt. matter.
react-dom is pretty much a sole purpose, there is no subpackage or its form of plugin. So shaking out unused functions isn't doing much since it's supposed to be * imported anyway.
Simple: ads and personal data collection. The more developers get convinced they need JavaScript everywhere, the more these companies benefit from accrued data collection opportunities.
You don’t have to like it.I do a lot of data science in C#, and absolutely loathe Python.I am not the only one who thinks that the ubiquity of Python sucks but I am certainly in the minority.I’ve stopped caring.
So do I. But ... at home for my own projects I use language and tools I like (Common Lisp, Clojure...) At work I use whatever I get paid for. I recently left Java job in favour of a Python one because they paid me more. You know, Python hackers hacked together something then left and they realized they need software engineers, not hackers.Python is not a bad language (compared to JavaScript). Python interpreter is a piece of shite and the culture and common practicies is what sucks the most. People praise NumPy, Pandas, Flask etc. because they don't know anything else. Anything better. At least they don't have to pay for this.
I dislike Python too. But I use it because I have to - a lot of the stuff at work is in Python.
For me at least its due to JavaScript having more mindshare so it’s easier to hire people to work on both the front and backend if they’re both written in JS.
Literally break the mantra "the right tools for the job". Now it's everything is a nail.
Nailed it!
I keep using JavaScript on the back-end because my projects all need rich front-ends and switching between + keeping my skills fresh in two separate languages is an awful lot of friction.I anticipate that the WASM ecosystem will mature enough that non-JS front-ends will become standard fare, and then I'll be delighted to pick a back-end language where stack traces actually include lines for code I wrote.
What did you write your SPA app in if you dont mind my asking.Web apps and "full-stack" is not my area. Based on what I have read online I was under the impression that it is all Javascript and ver had a motivation to learn it. I would love to know how to create a web app - user interface to back end server code - without node.js, React, Angular etc
All you need is a tiny view lib like lit-html/uhtml, and event dipatcher (DOM element can do that, or use bare EventTarget), now you get a MVC pattern loop; event fired -> state changed (+ optional effect) -> re-render.
I personally think the future is adding live functionality to the server, like how Phoenix does with LiveView.
The rather massive weakness of that approach is that it requires a functioning internet connection to doanything, and is badly affected by latency. If you lived on the other side of the world from the server and had a sometimes-unreliable or -unavailable internet connection, you would not sing LiveView’s praises so loudly.
How many apps have you written that should work offline? Because in my career it might have been less than 5% of projects. It's fine to optimize for the remaining 95%. My client's CRUD app doesn't need an offline mode. It would be nice, sure, for that one time the boss is using the app on a plane, but it's towards the bottom of the priority list.95% of projects, I'd pick productivity over working offline, especially these days when being truly offline is more and more rare.And lastly, even in JS, offline support is a pain in the arse, not a given. You have to design your entire app around it, it's not something you can add 2 days before shipping.
The trouble with the thin client approach is that fundamentallynocontrol is possible on the client-side. Since the connection from client to server is unreliable, this renders such pages unnecessarily fragile, considerably more fragile than traditional server-generated pages with conventional navigation by link and form. Really, I’d say that in most places where people are inclined to use the thin client approach, they’d be better served by traditional server-generated pages with no overriding of client-side routing or other such fancy scripting.Have you experienced this type of thin client when you have half a second’s latency, or a connection that keeps dropping out, or moderately high packet loss? I don’t think I’ve actually encountered a full thin client in the wild, but from my experiences with other poorly-done (verycommon) network-bound web apps in such circumstances, I can report that things areconsiderablyworse than one would expect—that half a second’s latency inexplicably leads to things taking several seconds instead of fifty milliseconds a lot of the time (though I will admit that a pure thin client is less likely to find this so); and that very brief dropout manages to lock the page up for ten or thirty seconds until it manages to (or decides to) reconnect, or just breaks your page completely so that you have to restart and lose progress.Ihaveworked on apps that work offline or partially-offline, but the problems of the thin client approach are so much more than that—which is why I didn’t use the word “offline” in my earlier comment. Prefetching. Caching accessed entities so that you can revisit them without talking to the server. The bfcache, once you’re talking about simple pages rather than apps. And various more things, some of which I spoke of in my other comment here.The thin client approach is a nice idea. It can be suitable for tightly controlled deployments. It can be suitable for averyrestricted set of apps. It can be a pragmatic choice sometimes. It will tend to be better than a badly-done client-side-rendered app. But I am convinced that it is not very often the best choice, taking into account both user and business considerations; and that for consumer systems, it’s rarely a good choice.
You should be using LiveView only for things that would require a server trip anyway. For client side interactions, use a client side JS library (like Alpine [1] if 
Phoenix.LiveView.JS [2] is not enough)[1]https://alpinejs.dev/[2]https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.htm...
The problem is that LiveView forces synchronous operation, whereas a significant fraction of things that would require a server trip anyway could actually be done asynchronously—that is, as far as the UI is concerned, they actuallydon’trequire a server trip; not immediately, anyway, and the UI should only care about the immediate.When you control server interactions on the client side, you can do things like optimistic editing, where the UI assumes the action will succeed and then does it in the background, and then handles the exceptional case where something goes wrong, most likely by returning you to a form; or things like queuing actions up when there’s no internet connection, and performing them when you get a connection again.I want to emphasise again the importance of latency. I live in Australia. Most of the web ismuchslower in Australia than it is in the USA, not because of bandwidth, but because oflatency.The LiveView approach isconvenient, but it’s technically not a good solution for most applications. It’s excellent for things like chat systems where being bound to synchronous operation and requiring a network connection to do things isn’t an issue, but I honestly don’t think it’s the best solution (technically, again; socially it may be) for much else.
I used Liveview before (on very early version), now I use PhoenixChannel and javascript, it's great balance.
Same here. Mixing ui and data logic layer was not pretty. Alpine js didn't cut it for me.
Also there is a transformation on js before handing diffs to Morphdom. There was no "replace the whole thing" without having to perform recursive diffs back then, not sure if it has now.
> The vast majority of people who use the internet don't know what JavaScript is, and especially in the US, most have no reason to really care about bundle size.It's enough for them to know thathttps://twitter.com/POTUSloads in half a minute, whilehttps://nitter.net/POTUSloads almost instantly.  Despite both being the exact same content!
I doubt that, for example, my parents would know that, or care. My wife definitely wouldn't.Honestly I use Twitter occasionally enough that I've never even considered going to Nitter.
The business reason is to simplify candidate selection to a narrow common criteria and never invest in training. Developers are typically viewed as a disloyal disposable commodity. From a business perspective developers are a cost center, not a revenue generator.Financially that reasoning makes sense but economically it’s stupid because you will end up with the same shitty uncompetitive product as everyone else. The developer counter argument is to just raise salaries, but over that past 2 years salaries have exploded and yet businesses have doubled down on this idea of prioritizing candidate selection and no training.To your point about code quality I agree. I have an OS frontend written in JavaScript that fully loads (completes page render with state restoration) in under 200ms according to Chrome’s performance tool. The code is about 340kb unminified. You won’t that with React.
> Financially that reasoning makes sense but economically it’s stupidWhat’s the distinction you’re making here? To me it looks like you’re contradicting yourself, but I’m happy to admit I might be ignorant.
They mean short term financial gains vs long term economic success
The solution is to separate creators from maintainers. You don't pay your janitors the same as your architects. The way we get there - standardization.
An interesting thought - it is so much easier to learn to contribute good code to an area you’re unfamiliar with when the codebase is already beautifully designed.It’s a teaching tool in itself. You can essentially hire a janitor and make them an architect when everything just makes sense already and guides them in the right direction.
> Developers are typically viewed as a disloyal disposable commodity [...] Financially that reasoning makes sense but economically it’s stupid because you will end up with the same shitty uncompetitive product as everyone else.Which has always been my answer to over aggressive management strategies for "replaceable devs": If your product is fundamentally software, it will be as replaceable and disposable as your developers; Show some commitment instead and you will get it in return from worthwhile devs.
I mean, you can’t close your eyes and spit anywhere on HN without someone chastising someone else for sticking with the same company for more than two years. Disposable developer culture is perpetuated by all sides.
Right but the reason for that culture is because businesses refuse to give competitive raises. I actually tried to stay with my last company but after my two year mark I was way more valuable than my current salary. I told my manager that, they agreed, said they wanted to keep me and asked for a number. I said  what would have been a 60% raise and they literally laughed in my face. So I quit and in a month I got a 100% raise. Like it’s not like I had some inflated ego, over the next 6 months my entire team except for the guy on a work visa did the same thing.
I absolutely hate it, why do that?
Moving can double or triple your paycheck overnight. If you're not learning, networking, or growing, fire your employer.
I think this behaviour can also be inline with the other side of the problem though:Employees perception of growth: it's easy to feel like you are learning more when it's something brand new because of how easy any topic is at the beginning, and you inevitably get more new things when moving; whereas pushing your existing abilities and strengths into incrementally more advanced areas is harder won and requires more fortitude. Also focus on short term financial gains over long term career growth: Although jumping ship has a tendency to force a re-align of financial reward with ability, it also resets your progress reducing your experience on long term project and denying yourself to opportunity to learn from the long term consequences of your decisions, which in turn can affect your long term prospects and financial rewards. (I am suspicious of candidates with a employment history of a series of short stints for this reason, because they did not have to live with the results of their output).It's subjective, sometimes it's truly not worth staying, sometimes it is... but I suspect many people confuse short term gains with reasons to move, when their current job may in-fact be of more mutual benefit long term.
Agree 100% though also sadly, I wonder if in practice website quality matters. Consumers are used to laggy shitty UIs and assume the problem is their 8-month old hardware.Of course eventually poor products are unusable, but I wonder if position on the barely-usable-to-snappy generates much revenue differentiation.
340kb is quite impressive for an OS, it seems browser/web has a lot of great apis that are underused.
Agreed, it is unfortunate because there is some cool prolems to solve in places where software is the cost centre but it has never been worth it. In my experience, the irony is that places where software is a cost centre often run really inefficiently from a software developmemt point of view. So it's more costly and less funded, it can be difficult to pull even the simplest projects off in that environment. I am sure there are places that run well though, you just have to have the right people up the chain.
I had seen a lot of devrels meme pre-covid, now they seem to come back.
As the client gets more computing power relative to the server, you would want to harness that. Hence more programming is moving client side and JavaScript is the dominating language / platform there.
Actually the delight of it is most of our developer tools now are powered with go-based and rust-based binaries that speed up our iteration processes. For example, esbuild, typesense, etc.
There's probably multiple factors at play, but one small factor I'd like to introduce is how there's way more tutorials for learning Javascript than say Rust.
Economical reasons come into play with software engineering.
Does that mean abstraction leak from inside out? (No, not outside in)
Easy to find javascript programmers for common tasks.
Exactly.And if onereallyneeds a slimmer version of React, there's always Preact [1] which is 3k-4k gzipped and has pretty much the same API.Of course, in real life the 130k of React is far from a problem. The React code is (more often than not) dwarfed by the application code itself.[1]http://preactjs.com
it's cheaper to run your app on the client than the server i guess.the reason why i have 3 tabs open using 3gb of ram.
Look at .Net Blazor for a non JavaScript solution.
