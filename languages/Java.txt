but java also is catching up with modern features and really is reforming.
Java has last mover advantage. It's intentionally conservative, but the features it is shooting have been used in many other languages, so it can learn from their experiences.
Kotlin on the other hand is Java's experimental younger sibling, running ahead and finding all the potholes for Java to avoid.
it's performance is not good comparing to C#, Python, JS
Hahahaha. Oh wait, you're serious, let me laugh harder.
Java runs rings around Python and JS, unless the only thing you measure is start up time. Let the JVM warm up and it delivers magic. I don't know about C#.
There’s a lot of rubbish spoken on the internet, by those who don’t know what they are talking about.
Java is a fine language, and C# is a fine language as well. C# standard library is huge, and the language is larger. But that doesn’t necessarily make it better.
Have you taken a look into the source repositories which are being use for those performance comparisons? Both Java examples are NOT Java examples they are written in Kotlin? Strange. Why not really writing Java code and why not used JDK11 etc. Or thinking about startup times taking a look at GraalVM .. ? The question is which problem I really have and needed to be solved?
but lately I have seen a lot of "hate" and many articles pointing that java is much worse than C#
They should really stick to arguments. And which arguments are used to say "much worse than C#" ? In which way?
And I understand that C# has some superior syntax and is pretty modern,
Which one? What helps a "superior" (whatever that means) syntax while binding to a particular platform.. etc.
C# and .NET Core as it is superior to anything that java has(including spring).
There are a number of other things like quarkus, micronaut etc. People are ignoring that spring, micronaut, quarkus are not part of the language those things are frameworks..
And what does "superior" really mean?
Java's optimizing compiler and GC are miles better than C#. C# GC still has stop the world pauses up to seconds long, almost unusable for anything that needs good P99 latency, like Java used to be.
The optimizing compiler is also bad compared to Java's. C# wins many microbenchmarks because it exposes lower level constructs that can be used more efficiently, but for "average" code Java is still faster.
But what really killed C# for me is utter lack of community compared to Java. With Java you can find a library for literally anything. With C# the open source community is 10% of the size if that. I used to run into trouble finding even simple things like database drivers.
I did C# for years than switched to Java and have been using it for years. I will never go back unless C# open source community grows several times its current size. It's enough of a pain to find anything that it makes it hard to build real world projects.
Java is good. It’s not perfect but performance wise it’s most definitely better than python / js etc.
Where there are issues is that lots of Java’s ecosystem have over the years relied more and more on resolving things at runtime causing slow startup times - and thus the perceived slowness of Java has less to do with the language but more about the framework you use.
Thats why I joined quarkus team as its approach of moving things to build time makes a surprisingly big difference not only in reduce memory and startup cost at runtime but also enables much faster development experience. Try use quarkus Dev mode and you'll see why :)
(Note: I'm not even including quarkus native image features just talking pure java here)
One aspect where php, python, node and the likes do "perform" better historically is the getting started experience and a more lightweight approach to do Initial exploration and builds.
For that take a look athttps://jbang.devwhich enables smilar lightweight getting started experience for java. Just one file to get started.
And yes, I'm main contributor to that project but it was made for the exact purpose of showing java most definitely can compete here.
And I understand that C# has some superior syntax and is pretty modern, but java also is catching up with modern features and really is reforming.
I think C# is way better than Java,as a language. Java has gotten a lot better, but stagnated for a long time under Sun, but has recently under Oracle been rapidly modernizing.
java is old and getting out of the market and it's performance is not good comparing to C#, Python, JS
That's not at all accurate. Especially compared to Python and JS? The JVM is one of the highest performing VMs out there, when run as a server. The JVM requires warm up time though, so startup performance is an issue, so there are some challenges in non-server situations. For example scripts, command line utilities and serverless. GraalVM is finally tackling this area in Java that has been sorely lacking, creating native images.
But, Java tooling and the Java ecosystem is way better than C#. The Microsoft dev world seems like a proprietary wasteland. Recently, things have gotten a lot better, especially as Microsoft has started embracing OSS. But C# has a long way to go to catch up to the depth and breadth of the Java ecosystem.
Oh yeah, UI is a non-starter for Java. Java has Swing and JavaFX, but the usage numbers are nothing compared to something like Microsoft's WPF.
Frankly, you are looking at it wrong. Popularity is a rough measure ofsupply. Your worth is based on the ratio ofsupplyanddemand. There are enough developer jobs for everyone in any of those languages.
There are a bunch of dimensions and knobs to turn on a resume, but if you want to make your life better by changing language, as opposed to learning more tools in the Java world, target one of the onesin the upper linewhere demand is higher than supply.
That being said, if you only know Java and C# it is far past time for you to learn more languages in addition. Its somewhat of a true-ism, but the more you know of other languages the better you will write the language you work in.
The C# vs Java feud has been going on long before C# even released.  Back then, Microsoft was working on their own Java port called J++.  Things happened between Sun and Microsoft that caused Microsoft to then abandon all the work they did on J++ and create C#.  This was a great things as it caused C# to correct some of the mistakes that still plague Java today, looking at you generics.
If you post your question in a Java reddit, you're more than likely going to get a biased opinion towards Java.  If you post it in a C# forum, then it'll more than likely be biased towards C#.
At the end of the day, they are both solid languages/technologies that have their own pros and cons.  Where Java has a much larger ecosystem, it does lack a lot in terms of language features.  C# being the exact opposite of this.
C# will, most likely, always be more modern.  Microsoft seems to be wanting C# to become the new C++.  That and Java has a 5 year start on C# so there is a lot more code written in it so they have taken a more conservative approach as to not break backwards compatibility.  Microsoft, strangely, doesn't seem to care too much.  Once they jumped to .NET Core, all full framework code bases were left behind.  Then, .NET Core 2.x changed the game again; causing you to have to re-write your .NET Core 1.x app due to incompatibility.  .NET Core 3.x had things deprecated from .NET Core 2.x that caused some re-work.  Developer, understandably, got sick of this and Microsoft made the commitment that .NET Core 3.1 would have a direct upgrade path to .NET 5 (.NET Core rebranded) but only .NET Core 3.1.  So, .NET Core has gone through a lot of growing pains lately.
As far as execution speed, it's a toss up.  One may be faster at this while the other is faster at that.  At the end of the day, neither one has an advantage to write home about.  Both, the JVM and the CLR, are impressive pieces of engineering that are actively worked on by teams trying to deliver the best performance possible.
At the end of the day, you have to pick the path best for you.  Don't buy into the hype on either side.  Know the strengths and weaknesses of each platform and see which one best suits your programming style and principals.
Some have stated that .NET lacks the ecosystem that they are accustom for getting any real world applications done.  Where that's clearly a gross exaggeration, if you're the type of developer who has a preferred suit of libraries in which you build all your applications on, then you might have an issue with C#.  I'd suggest that you look into NuGet to see if your libraries are supported/exist.
Continuing with that thought, there is a difference in the mindset from the average Java developer to the average C# developer when it comes to library usage.  From my experience, I've noticed that most Java developers won't think twice about grabbing libraries to get a task accomplished.  Where the C# developers either look for an official Microsoft library or they're okay with rolling their own.  Nothing is wrong with either approach.  Some just want to get something built and others, like myself, it's all about the journey in learning.
Also understand that you can be a person of many languages.  Who said you have to settle on one?  I actually encourage developers to learn lots of languages.  See how others solve the same types of problems.  I became a much better developer once I opened my horizons to other languages as they brought in so many different approaches and ways of thinking that I just wasn't accustomed to.
On a final note, be sure that (with whatever language you choose) there is a market in your area for it.  I like both, C# and Java, for different reasons and I use them both for different things.  I would love to do more professional Java work where I currently live however, when we moved to our new house a year ago, C# was the language I had been doing more work with so I found a C# job.  I didn't consider Java for future ventures and, turns out, this area has no Java jobs.  The area I live in is dominated by C#, sadly.  I'd love to be in an area where I could freely move between the two languages.
Edit: Tooling, I completely forgot to mention tooling.
If you go with C#, you have two options: Visual Studio and JetBrains' Rider.  Visual Studio is the go to tool for enterprises and Microsoft even gives away the Community edition for free.  JetBrains has no free option unless you're doing open source.  If you go the Visual Studio route, it's a pretty great experience.  They have an installer where you select the component that you want from Web, Desktop, Mobile, Games, etc.  You'll be up and going extremely quickly.  SQL Server with SSMS, if you decide to not use the integrated DB tool inside of Visual Studio, is a snap to install as well.  Once again, Microsoft has free version of SQL Server.  For all the negative things you can say about Microsoft, the ease of getting their tools up and running is seamless, fast, and easy.  Can't exactly say that with Java.
One of Java's pros is the ecosystem.  This includes a wide variety of frameworks.  Due to this, you'll have to do a little more in the way of setup and configuration depending on what all you're trying to do with it, what IDE you're using, etc.
When it comes to setting up the tooling, I've never found Java to be as easy as Visual Studio.  I always find myself, and others, having to take a good bit more time to setup a Java environment than a .NET one.
I don't actually think many people think Java is "extremely difficult" -- that kind of opinion is usually reserved for C or C++.
Many would argue that Java is a bit verbose, which is both good and bad. Java code tends to be longer than code written in other languages; conversely, certain types of errors cannot happen in Java due to its language design.
My dad worked/works with C and C++ still… that language has caused many a migraines as a teen lol syntax error hell.
Java is boring, verbose, boilerplate-y, and "monotone-y". This means a few things:
A lot of developers are going to hate it
Enterprise is going to love it
It's great for learning programming
It's great for many devs of many backgrounds and skill levels to contribute to and maintain.
Because of 2 and 4, getting half-decent at Java means perma-job security anywhere, anytime
FWIW, I wrote java professionally for 5 years. I don't really miss it, but I'm very, VERY grateful about how well being a professional Java developer has set me up from a career perspective. I'm also grateful knowing and understanding Java when it comes to using languages like Clojure, which I like to do on my non-professional development.
Java is not bad, but it is fussy, verbose, highly structured, and it has certain ways of doing things baked into the language itself.
It’s really great if you have a distributed team of mixed ability developers because it’s quite difficult to make a big mess. When you write Java code there’s a wealth of best practices to draw on.
Contrast with JavaScript which has very few rules and essentially lets you code how you like. It’s very easy to make a big mess in JavaScript if you don’t know what you’re doing. The upside is that you have dozens of different paradigms available to you, and we’re inventing new ones all the time.
The language you pick will depend on what you want to build and what type of person you are. When I write C I feel like a god. When I write JavaScript I feel like a pirate. When I write Java I feel like a skilled stonemason building a cathedral.
There are two types of languages: those which are hated and those which aren't used.
Are you involved in any hobby that has "sides"? DC vs Marvel. PC vs Console. Sports Team V vs Sports Team B.
That 100% exists in programming and you'll have to remember that when reading Reddit.
Another thing - perhaps worse - is that devs have a tendency to be a bit black and white and often think their opinions are closer to logical conclusions. But they're still opinions.
Having said that - I wouldn't put Java at the top of my list for people learning to code. Not because the language is harder. It still a language. But it brings along with it other things that a person learning just doesn't need to worry about.
JavaScript is often suggested because you can get started with any text editor and a browser. Python has a couple additional things but it's still very approachable.
In my experience, the best professionals - the ones who are getting promoted, working on the best projects, leading teams - are the least black and white. They might have opinions on what language is best but they're going to be far more pragmatic about picking the right language for the job.
Sometimes Java is exactly the right language for the job.
Other languages might be more concise or faster or safer or cleaner, but a lot of the time the problem is that if that "better" language is more obscure, not as widely used, and not as mature, it's not a good choice because it will be harder to find developers, harder to find good libraries to use, and harder to get help if you're stuck. The best professionals know when that's a worthwhile tradeoff, and when it's smarter to stick with a "safe" language like Java.
Also: good programmers can write Java code that's very clean, readable, and elegant. Bad programmers can make any language look ugly and hard to read.
In my experience, many subs here on Reddit where people discuss about programming and joke about it, are mostly frequented by beginners and maybe first year CS students that don't (yet) know what they're talking about but they have the urge to participate in these discussions.
People hate on every language man, drown out the noise, do what you like :)
What you're beginning programming, it's very easy to get caught up in all this language-hate, where some people just love bashing another language just people they don't like certain features of the language or because of the syntax.
Seriously though, don't listen to them. No programming language is perfect, but in the end, most languages are all capable of the same thing, creating programs. Java is perfectly fine, and is still the most used language in the world. Java rules the enterprise world, and most Android applications are written in Java (though Kotlin is certainly catching up, half of Android itself is still Java). Some people give Java sh*t because they think it's old, verbose and a lot of boilerplate code, but honestly, it gets the job done. That being said, if you are really a beginner programmer, I'd suggest starting with Python to get comfortable with programming, then move on to Java.
r/Javais for News, Technical discussions, research papers and assorted things of interest related to the Java programming language, not for help with Java programming. Such "help with programming" posts should go tor/javahelp.
We all like some good discussions, but a few topics have gotten stale. Please refrain from complaining about certain Java features (or lack thereof) or extoling other, possibly superior languages. We get it – yours is bigger than ours (language, that is).
Not that I don't have humor, or that I can't have a good laugh, but most of the "jokes" that had been posted here were extremely stale and absolutely unfunny.
Tutorials should not be posted here, they should go inr/learnjavainstead.
We do not allow surveys.
r/Javais not a job market. We do not allow job offers.
We do not allow asking for or offering pirated material.
r/Javais atechnical subreddit.
Leave political discussions out of technical discussions. If you want to discuss politics, go somewhere else.
Political comments will be removed and the poster will be banned.
Java's syntax is not as fluent as like kotlin and some never languages but other than that, it's not behind of any other language. There is nothing you can't do with Java, it might take longer to implement or syntax may not be as nice but it's more than capable for any task.
I find this kind of comparisons a way to flex for newbies.
Edit: I think there is some confusion with "there is nothing you can't do with Java" part. Yes, you can do almost anything, but it doesn't mean it should always be go-to language. No, it might perform horribly bad or exceptionally good, it depends on experience, architecture and needs and many other things. If you have to, you can do almost anything with Java, but it's not always the wise choice. I meant you can do anything with it, it's technically not behind from other languages.
i have been using java for all my dev career, and recently was working on typescript for some changes
its way too flexible, it is bound to cause issues. java being strict with types is something i like, as it keeps it structured.
It could be many things, but from my personal experience these are:
Ignorance, precisely ignorance about modern Java and its capabilities today.
Rust fanboys being Rust fanboys. The meme to re-write everything in Rust is at play here.
Parroting without thinking about what they heard/read about Java.
Java perceived "heaviness, " saying something like Java consumes/requires much more memory than other languages or Java is slow/has slow startup times. This can be true in some cases but overall with today's modern Java, a little bit of education can be avoided.
Agree. I've lost count how many times I've heard outdated (like 10+ years) or outright wrong statements about Java.
Java and its frameworks are moving on. Modern apps build with Spring are much more robust, I feel like I'm cheating. Just add a couple of dependencies (Data, Web/Webflux, actuator, swagger) add a couple lines to the config file, slam annotations on your controllers/repositories and you have a basic web app. I love it.
I think in most cases, the problem is not with performance/speed - hardware is cheap relative to developer labour. Problem is in maintenance and the growing cost of adding/changing behaviour. OOP and Java for that matter helps a lot with creating intuitive and readable code.
Some may remember back in the days before Rust when it was Ruby and Ruby on Rails that were supposedly far superior to Java.
I used to be kinda anti Java, but I realized that I was actually anti xml-described apps because of the frameworks popular at the time.
Java has actually been getting rapidly better and better.
Now has features like pattern matching, records, and sealed classes.
The var keyword is quite handy.
Virtual threads are just a game changer.
To mention just a few.
Still behind? When was it ever behind?
Different languages might be well suited to different things. Some people might not like Java because of it’s syntax and/or verbosity but that doesn’t mean it’s ‘behind’ and it frankly says more about them than it does about Java.
Most of them just studied Java 6 for the computer science class at university
Java has made decisions which definitely impact on how easy it is for them to change the language. Backwards compatibility with generics has definitely limited what can be done with it in comparison to languages which have it built in from the start. The type system is perhaps "less powerful" than Rust or Haskell - but that wasn't a design goal of the Java language.
Where Java really still beats a lot of these is the JVM model of "write once, run (almost) anywhere". Compilation speed is another massive benefit to day-to-day working on the language, compared to large Rust or C++ codebases for example.
But it shouldn't really surprise anyone that more modern languages have nicer syntactic sugar, or different standard libraries, or other concerns in general to Java. But it's not a "race". There is no finish line. There will almost certainly never be a "last" language until it'sreallythe last language and everyone is dead.
It's imho entirely dependent on which industry people work, startups are notorious for choosing new languages and frameworks while discarding proven and stable ones, often without any decent research and considerations. Rust for example was intended as memory-safe alternative to systems programming languages such a C/C++. But you're starting to see that people want to use Rust for tasks that (imho) aren't suitable such as for web development or office software.
But outside startup culture Java (and the MS counterpart) is still strong. Being a relatively conservative language with a focus on backwards compatibility does come with it's strengths and weaknesses, but backwards compatibility is (imho) what has kept Java relevant since the beginning. And Java does innovate and introduces new features, just a bit more conservatively.
Look for example at Ruby on Rails, like Rust once it was pushed as the new web framework, but it is now in decline. In the meanwhile Java is still here.
But as for missing features, backwards compatibility has kept the type erasure in place, coming from the .NET world a long time ago, true generics is the one thing I personally miss sometimes.
From a 2 year old thread asking the same question:
Java's solution to the problem of C++ allowing you to blow your foot off was to chop off your legs. Operator overloading? You might abuse it... chop. Multiple inheritance? You might abuse it... chop. Creating a new object? You'd best type the type of the object three or four times before we'll believe that you got it right. You want access to internals, subclass the compiler objects, closures, iterators, lazy evaluation, the list goes on chop chop chop
It's often hard to point to a language's philosophy because it is embodied in a long sequence of little decisions that are easy to dismiss in isolation, but that's how I see the philosophy of Java.
Of course, that didn't work, so a large aftermarket in prostheses has sprung up, and lately the language has been sort of growing some of the power features it previously rejected, although they pretty are much bolted on. Many people have even forgotten that there is a whole world full of people who don't get around in powered wheelchairs and don't need machines to help them chew, and argue passionately about how much they love their Chewing Completion and Integrated Mobility Environments and how easy it is to sort of slowly shamble up stairs on these prosthetic legs (which sounds impressive after you've spent five years in a wheelchair), endlessly haranguing those who choose to run on their own two feet about what they are missing by not getting their legs chopped off.
Read the whole thing
The ugliness of the GUI apps is the programmers' fault, by the way.  You can make some great-looking and responsive GUI apps in Java--but most people just use tools to generate their GUI code and often end up locking the primary thread as well...because they don't know what the hell they're doing.
I'm too late in the game for anyone to read this, but I'm gonna throw in my two cents anyways:
I hate Java because it's the only platform that makes sense in so many ways. Now, follow me here, Java as a platform is great because:
It has a great set of tools along with it, eclipse and the like have a huge set of integrations with the build system, your project, and java as a whole.
It's a stable, very capable platform. You can set up a massively multithreaded java server app, and the thing pretty much just runs.
The JVM with JIT is pretty much fast enough for just about anything, you're not going to get hard-realtime, but since you really can't get hard-realtime over random latency of the internet, it's not much of an issue.
Being a garbage collected language means there is a whole class of problems I can ignore, don't have to think about, and don't have to write code for. This is awesome because it lets me think about what the logic is doing without having to worry so much about these small issues.
So as a platform, Java is awesome. However, as a language, Java truly is horrible. This is why you hear so much bad stuff about it. Here are the things that annoy me the most:
It's very verbose and repetitive, this means that the smart bits of your code get drown out in the deluge of type declarations, temporary classes and factories.
Factory classes, particularly those that aren't declared static so you can just call a factory class function out of the blue.
Writing Java when coming from another high level language feels like you are stuttering, it is very repetitive.
Boilerplate. Any time I'm writing the same code again and again, it's distracting me from fixing the actual problem.
Everything is a nail. The fact that everything is a class (except for the things that aren't) will give you a rough time of things once you really start trying to be tricky. You can work around these with anonymous classes and reflection, but again, it's an extremely verbose way of doing things that adds more code which clouds the actual important code.
Java is repetitive. You keep saying the same things again and again, if your IDE can figure out the proper type definitions and arguments, you would figure the JVM could handle it.
.3. Writing Java ... is very repetitive. ... .6. Java is repetitive.
Well done.  :)
If you do programming as a hobby, you'll probably hate Java.
If you do programming as a JOB, you'll probably like it more.  Not everybody builds enterprise-scale applications as a hobby.  Java is very strong and very commonly used for back-end and middleware components for enterprise applications (Oracle Fusion, anybody?)
But as a hobby?  PHP, python, etc all are much more accessible and easy to tinker with.  Lots of people build electronic equipment as a hobby, but I don't know anybody that builds metropolitan power grids as a hobby.
Well I used to think people hated Java just because it's trendy to do so.  I'm pleasantly surprised by this thread and the intelligent responses as to why people don't like Java, sorry I doubted you programmers!
this will never be read, but oh well.
the whole reason behind the Java hate is because way back in the 1.4 JVM days, java was the language to use when you wanted to write BIG company applications. unfortunately, the 1.4 JVM was horrible when it came to speed. it was very common and fun just to sit back and watch your server die a slow death when 10 people connected to the app at once. most people i know stopped programming in java when .net hit the scene and if memory serves me correctly, .net was introduced around the same time the 1.5 JVM was coming around.
fast forward to today and the 1.6 JVM is amazing. it's fast as hell, very polished and extremely stable. however the language itself hasn't gotten the love it needed over the years and hence forth while even though the JVM is fast, programming in java is slow. because of this people have resorted to ported some of the more popular languages to java to abstract away the slowness of developing on top of the JVM. languages like ruby, python, scala and coldfusion all run on top of the jvm and make tapping into it's power painless.
so while most people will say they hate java, it's the language itself they're talking about and not the JVM.
For the most part, Java is fine.  Boring, but fine.  It doesn't have the shininess of most dynamic languages, but if you're going to be doing complicated stuff on a large team, the "excessive" verboseness of Java becomes useful.  Add to this the ease of acquiring programmers, libraries, etc., and you can see why Java is so widely used.
That said, there are still a lot of obvious flaws in Java, and Java 7 isn't looking like it plans to fix many of them.
Personally, I'd use python/c for a small or mid size project and Java for something larger.
here's an answer to your question:http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html
Although the JVM has certainly gotten to a very respectable place, Java the language suffers from being stuck in the no-mans land between the optimizer's love of low-level languages like C, and the pragmatist's desire for high-level languages like Python.
I love Java.I focused on front-end for 10 years. Starting with motools and IE6, jQuery, into React + Redux. I moved on exclusively to backend development after a few years of the latter.You couldn't pay me enough to maintain a highly available/scalable system that wasn't written in a "verbose," strongly typed and compiled language. I'm done with that pain. If you're going to pick Node, I hope you're using TypeScript. Python, no thanks.Refactoring and implementing new features in Java with IntelliJ feels like cheating, in comparison.Even Go, which I actually really like, starts to lose specificity at large scale due to its intentional terseness. I deeply dislike implied interfaces, and the error handling in a large codebase is really noisy (one of Java's main complaints), without much net benefit.There definitely was a learning curve with Java. To the untrained eye it looks very noisy and magical, but once you learn to visually parse it and understand what all the annotations do you can move very quickly with low risk.Your mileage may vary. If you can move fast without breaking things using some other technology, go for it. But I hope you're prepared for success, when 30+ devs are contributing code to your house of cards. You'll want all the natural protections you can get from your choice of stack.
As someone maintaining a hugely complex system in Python: type hints make itbearable, but notgood. A strongly typed, verbose language is an absolute, fucking, *must* for all but the simplest of systems. You can make it work if you're building web services where the type contract is in the web/RPC API (and hopefully strongly enforced), but for basically anything else, use something with a good type system.I cannot stress enough how important it is for scaling complexity.If youmustuse Python, turn on mypy with the `--strict` flag, and do it early in your project's lifecycle. Do NOT make exceptions or allow for "gradual" typing, it's monumentally more difficult to add typing after the fact than early on. Type hint as much as you can, including tests. Pytest's fixtures can be type hinted both at the `def` and with their results as function args.
Python is strongly typed, but it is notstaticallytyped. Statically typed is what you're after.
We should form a support group. Even though I'm pushing Mypy as hard as possible, there's some notable areas it can't help, like unittest.mock call assertions.
Or you could use Python with microservices that talk over a message queue instead.
I hope this is satire.
No, it's one of the fastest ways in software development you can ship software features to the customer.Scripting language, dynamic typing, microservices and a message queue is shockingly effective.There is no way to compete with that if you are using traditional development techniques.It's why we watch videos online on Youtube and not Google videos. The Google developers got beaten up by the much smaller group of Youtube Python developers.To be honest, I find it shocking that the average user on hacker news doesn't know that software development using dynamic typing is considerably faster than software development using static typing.
As of 2005/2006, you'd be right.Nowadays, the speed of development for statically typed languages is much faster, thanks to improvements in tooling. Going further, if you choose a modern language that supports type inference, static typing becomes a pure win, and in my opinion, there's no longer any good reason to use something like Python on the back end. If I had to pick a language for the situation you're describing, I might pick something like Kotlin.My background for context: in 2000-2009 or so I wrote a lot of C++ and often wrote Python bindings using Boost::Python because of how much quicker and more convenient Python was for scripting and exploratory work. I also wrote a lot of Java in that era, and Java was indeed incredibly verbose and ugly. Like C++, it imposed heavy costs for the benefits it gave you. After 2010 I worked mostly in Scala, and for a year now I've been working primarily in Python. The simplicity of working in Python still feels liberating, and doing Pandas work in Jupyter is great fun, but in most ways it feels like a relic to me now, because I can write code that looks almost as simple and reads just as easily in Scala as Python. (Sadly, I wouldn't recommend picking Scala for a tech stack in a business, because it's hard to find Scala developers who want to write stupid simple code.)
> Nowadays, the speed of development for statically typed languages is much faster, thanks to improvements in toolingWhat you static camp guys don't seem to understand is that tooling is not that important, it's just a minor multiplicator that caps out pretty fast. You can't turn nurse into a surgeon by giving her a sharper scalpel.Most engineers that had Java background I interacted with had a tendency to over-engineer. It's not because they had bad tools, it's because Java has a culture of over-engineering, which they soaked in and embraced. Tools & language are getting better - that's great. But that does not automatically fix the culture, which might take another decade or two."It is practically impossible to teach good programming to students that have had a prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of regeneration."At this point, Java is like BASIC. You can fix the language all you want, but you also need to fix the culture. It's not going to happen while most people won't even admit there is a problem.There's a reason Zen of Java is a joke:https://medium.com/@ratherabstract/the-zen-of-java-edd99991f...
We're talking about backend development, and in that domain Python has its own set of pretty awful drawbacks.Starting with needing a level of testing that would make even the most paranoid static-language devs spit their coffee out. If you haveanyuntested code and need to make changes that affect it, you are incredibly screwed. I can make sure my own code has the necessary level of testing, but when I'm at the mercy of other people's test coverage, I'd rather have the help of a compiler.The performance of tools and tests is noticeable every day. Unit tests and linting are palpable interruptions. One thing I notice constantly is the delay when asking my IDE to add imports. With Scala, I can get it done almost as fast as my eyes and brain can work. With Python, it takes a few seconds before it can offer me the right import.Speaking of performance, we were excited to discover ruff on HN a few days ago, which advertises a >100x speedup over flake8 -- it's written in Rust, flake8 is written in Python.Writing C++ and Scala, the attention paid to performance in 95%+ of the code we wrote amounted to using efficient algorithms and not making stupid mistakes. Computers are amazing these days, and if you write straightforward code with good data structures and algorithms, code on the JVM runs incredibly fast, almost always much faster than you need it to. With Python, sometimes you use the right representation and the right algorithm and the result is still disappointing, because in the absence of a JIT, good Pythonic code is a huge multiple slower than it needs to be.In many cases where performance has been disappointing, we've decided to live with the slowness, because making it faster would mean departing from the straightforward Pythonic style that gives us easy-to-read, easy-to-test code.> At this point, Java is like BASIC. You can fix the language all you want, but you also need to fix the culture. It's not going to happen while most people won't even admit there is a problem.This is one thing I agree with. Java and Scala development both have culture problems. The Java world has a disproportionate number of programmers who believe that the imperative, mutable-everything, deep inheritance hierarchies OO style of the 1990s and early 2000s is an eternal truth of software development, and programmers are either virtuous and enlightened OOP warrior-monks, or benighted stray sheep. Apparently most people whodon'tbelieve that have jumped ship to other languages, making the problem worse than ever. Scala's cultural problems have been adequately discussed here, so I won't repeat them. In my experience, the best Java code, and the best Scala code, is written by people who are deeply suspicious of the culture associated with both languages.
> If you have any untested code and need to make changes that affect it, you are incredibly screwedBut you aren't. If your software isn't landing airplanes, you shouldn't treat all bugs as critical. Build safety nets, not guard rails.Python might have 10% more non-critical bugs, but also allows you to ship 5x faster. That's a great tradeoff for vast majority of projects.> Unit tests and linting are palpable interruptions.I do believe some teams have this problem, but mine never had. To me it's a signal of many tangential issues (bloated codebases, obsession with unit testing). I don't believe it's a language-specific problem. Also, you should just lint-on-save anyway, slow linting in CI is a minor nuisance.> Speaking of performance, we were excited to discover ruff on HN a few days ago, which advertises a >100x speedup over flake8 -- it's written in Rust, flake8 is written in Python.In order to create a better flake8, you have to create flake8 first. The reason flake8 exists in the first place might be that it was easier to create in Python. First succeed, then optimize, not vise versa. Also flake8 is a CPU-intensive command line tool, not your typical environment for Python.> Apparently most people who don't believe that have jumped ship to other languages, making the problem worse than ever> In my experience, the best Java code, and the best Scala code, is written by people who are deeply suspicious of the culture associated with both languages.I believe that. I think culture will simply push good engineers out of those communities. If you have to fight both language and community, why would you stick around?
Having used both statically and dynamically typed languages, I don't think this is true at all.Most modern languages are pretty close in productivity, architecture and the way a company is organized have much more impact on productivity.In big enterprises every small change requires 3 meetings, in a startup you can just make the change.
There are studies that show it is true:https://games.greggman.com/game/dynamic-typing-static-typing...
Based on one guy who did a hobby research project based on GitHub issues?
Have you ever of this little company called Youtube?Youtube did the dynamic typing thing in Python with 20 developers and Google did the static typing thing with several hundred developers in C++ for their Google Videos.Who do you think won?https://books.google.co.uk/books?id=eulODwAAQBAJ&lpg=PA136&d...
Nice anecdote, but was it because of the language or because a small motivated team  gets much more done than a big enterprise that is bogged down in meetings?
You seem to be quite close-minded, every piece of evidence is not good enough. Are you only going be satisfied by a 20-year long peer-reviewed independent study?How about this: Python is only ~1.5 times more popular than Java, and Ruby is way below Java, and yet if you look top successful YC startups, Python has 17% of valuation, Ruby has 52% and Java is merely 1%. You can, of course, choose to interpret it in a multitude of ways, but at least one of them is that if you pick Java for your startup, you are unlikely to be successful (or, alternatively, people who are unlikely to build a successful startup are more likely to choose Java).https://charliereese.ca/y-combinator-top-50-software-startup...
You can take out the engine from a car and tape it on the top, but that construction won’t be any less complex.
> Your mileage may vary.Idk, I have written Java EE (and Jakarta EE) projects, and I found everything to be so much worse than e.g. Next.js + TypeScript. It feels like everything is broken in the Java web-dev ecosystem, except spring. I had plenty of struggles with the JPA, where some SQLite JDBC wasn't straight up working or MySQL8 was not supported. This was just to get the project running.Then, JSPs have like 300 different ways and 300 different opinions on how to do stuff. Should you do routing via XML? Should you put your routes in annotations? Or do implicit navigation in the JSPs? Managing sessions is a pain too.Setting up and deploying Java application servers in prod is way too complicated compared to Node, Deno, Python, Ruby, Whatever.> Starting with motools and IE6, jQuery, into React + ReduxAnyway, I hope you didn't have to writepurereact without any framework on top of it. I mean, the library is fine, and the React patterns mostly stay the same, but React.js is missing a lot. Personally, I wouldn't touch pure react, unless I have to write my own framework on top of it, but that hasn't been the case yet.P.S. I also had to work on JavaFX applications in the past. I used IntelliJ too, and the tooling of JavaFX is broken to the point, where you can't even use place controls in your great FXML. Which just made me think about another thing I dislike: Java's XML fetish. I don't hate the format, but knowing what XML namespace is the correct one is often beyond me.Writing new Java is probably fine, but older Java codebases are the often PITA. :(
>It feels like everything is broken in the Java web-dev ecosystem, except spring."Except Spring?" Spring IS the modern Java web-dev ecosystem.  You can't write it off as a small exception.  With Spring Boot it is very easy to get something working quickly.It sounds like you may be suffering from the Paradox of Choice when it comes to the broad Java ecosystem(s).  For new projects, just pretend nothing exists except Spring Boot and use annotation/java config for dependency management.There's obviously a lot of legacy Java out there, but it's so massively popular that there's an immense amount of greenfield development going on as well.  Don't take jobs working on Java EE stuff unless nowhere else will hire you and/or they are paying you a massive amount of money to do it.
> It sounds like you may be suffering from the Paradox of Choice when it comes to the broad Java ecosystem(s). For new projects, just pretend nothing exists except Spring Boot and use annotation/java config for dependency management.Spring Boot is passable, as long as what you are trying to do fits within what you're allowed to do and you don't have to dig into the internals too much. Regular Spring is painful, attempting to migrate a project that's been around for close to a decade from Spring to Spring Boot without a rewrite is even worse, especially if it is stuck on an older version of Spring, even worse if you need to go from JDK 8 to JDK 11+.The complexity of Spring and Spring Boot itself is pretty considerable. I wouldn't scoff at anyone using something like Dropwizard for comparatively smaller projects, as I did recently:https://blog.kronis.dev/tutorials/2-4-pidgeot-a-system-for-m...In a limited set of circumstances it can be useful to opt for something simpler, that's built on a bunch of other boring, mostly "standard" or at least idiomatic packages. Some might advocate for Quarkus, others for the likes of Vert.X - both are interesting and pretty usable, but perhaps it's a bit too early for either of those. For those interested, ktor might also be worth an exploratory look in non-prod projects (if you like Kotlin too).There is something to also be said about the likes of Ruby and Ruby on Rails, or PHP and Laravel, or .NET and ASP.NET, or maybe Python and Django - sometimes having fewer options can also make you more productive, especially if a lot of ecosystem is grown around those "main" solutions. Perhaps that's an argument in the favor of Spring Boot.
Just wanted to add that I'm currently building and shipping a 60K+ LOC product based on vert.x. I never used Spring or Spring Boot and I personally would like it to stay that way. Vert.x has been such a pleasant surprise to me: the docs are great and the community is quite active.
How's the performance and DX?
XMLs, JSPs, Java EE are relics of the old age. They were built during late 90s and early 2000s. No new projects use them. You can’t say Java is bad because of how things were 20 years ago.
Java EE is an evolving spec and includes basic things like JSON processing, REST, JMS, JPA, even the servlet API itself - these things are very popular in greenfield projects.  If you're writing a web app, you're using Java EE unless you're writing your own server.
All of the things you complained about were out of fashion before the thing you endorsed was even invented. Hardly a fair comparison.
Static types are great, but they can be quite painful in languages like Java that don't support Sum Types/Tagged Unions. I just want to represent "OR" goddammit.It should also be noted that statically typed doesn't necessarily imply verbose. Many statically typed languages support type inference which more or less gives you the best of both worlds.
Java supports sealed classes (which is close enough to sum types at least for the stuff I work on), and pattern matching over them is in preview.https://openjdk.org/jeps/409https://openjdk.org/jeps/427
They are literally sum types, with records being the corresponding product types.
You can very easily create an Or<T1, T2> class that supports the relevant features.
> Refactoring and implementing new features in Java with IntelliJ feels like cheating, in comparison.This shines especially in large monoliths. Refactoring microservice interfaces is hell (which means it's rarely done and they rot), refactoring module interfaces in a Java monolith is a breeze.Very few projects benefit from microservice architecture.
> Very few projects benefit from microservice architecture.I think the pendulum will swing in the other direction, as it usually does. The previous (NoSQL) hype burned out in about ten years, hopefully this one will go out a bit quicker.
I don't know.  NoSQL is still going strong and kinda makes sense for unstructured data.  I attended a tutorial earlier this year and the DB they wanted to put in was Mongo rather than SQLite say, even though they were storing structured data in it -- which I didn't understand.Also the problem with microservices in my mind is the tooling.  Right now microservices are deployed with k8s in docker containers which is still heavyweight for what they're supposed to be.  It could be that a language (maybe go) introduces features to allow for tooling to make easier refactoring.
It isn't just refactoring them that is hell.  Even testing things can be hell - those unit tests just became integration tests or you're rolling the dice with mocks.  If you don't get the result you expect from a service call, the lack of a single call stack you can debug up and down means tons of time wasted jumping around.They're hell for new developers coming on to a project too, since they can't just follow IDE links to trace execution paths, and too few projects implement full REST call request/response type safety for endpoints.
(just my opinion)I find java mentally exhausting. I have only ever worked with java once, and it was long ago when I just began my career over 6 years ago.Since then I mostly work with typescript and go on backend, and the languages are quite simple and strange code can be understood quickly without having to dive too much into documentation and navigating a million folders/layers of OO abstraction.I've tried getting back into java and each time I just get exhausted looking at the code.
Similar feelings towards Java. Kotlin has been a refreshing change to read by comparison at my new job. Much less exhausting.
The problem with Kotlin is that Java copies its features pretty quickly. So as time progresses, the benefit gap between the two languages diminishes, and eventually will not justify switching ecosystems. For example, Project Loom is the answer to coroutines. Sealed classes, etc. Up until recently, Kotlin was not a 1st class supported language for Bazel, gRPC, etc.
In addition to Loom being superior to async/await, Java's pattern matching is shaping up to be better than Kotlin's, and Java's string templates (https://openjdk.org/jeps/430) are also superior to Kotlin's.
Superior how?
I'm fine with Java copying features. I'm happy to use Kotlin now while it is ahead, no problem with switching back to Java once it catches up.
This approach breaks down when thinking about teams in a large organization. Language switches are a big deal.
The time for this to happen though is a long cycle though since Java holds such heavy backwards compatibility though right?
That's not necessarily due to java. I have a guy on my team (we're a java shop) with completely exhausting code. Everything is layers and miles of indirection. No one else here does that. It is admittedly more common in the java world though.
No, it is fairly common among Java devs. In fact the culture there is that way. Most happen to come from banking sector, and other deep enterprise structures where things tend to move slowly. Design Pattern abuse is super common, and is widely used as a 'smartness signalling' tool. Generally it is not that much of a problem given attrition rates in those places is low. But it does cause lots of pain for people who join the team.I was the happiest with when Python grew, not having to deal with things like 300 classes just to make a ping to some REST end point was a welcome thing.
You can issue an HTTP request in Java quite easily:https://docs.oracle.com/en/java/javase/19/docs/api/java.net....
Yeah Java people don't go the 'quite easy' way. They want some 10 indirections of builder classes to merely build the url alone. Then a factory class to create the connection etc. Then some response handlers to deal with the response. Then some dozens of classes to parse the response.By the time you work around this you are lost in the forest of classes.
Not sure why the hyperbole. It's literally one class for the client, and one for the request, probably the least you could do without things getting too hard coded.
Yep Java rocks and is well suited for larger projects. If I have a small team and need to move super fast - then I use Django. If it's > 10 devs and is going to be a large project then it's Java all the way.
> Another important factor is that the team of engineers building the first version of Picnic’s platform already had ample experience using Java and the JVM.Nine times out of ten, that's the whole story.
> Remember how Twitter had to re-platform from Ruby to Java to support its growth? Definitely not an enticing prospect, so our choice was geared towards the long run. Unlike Twitter, Picnic embraced Java from the get-go!Once again, it must be said that almost no app will ever be twitter scale. Time to market is more important than needing to do some architecture in the future. Twitter was also early in both Rails and doing globally distributed web apps, a lot of lessons have been learned since and rails itself is much better, it's been almost 12 years after all.It seems like this article could have stopped with, most Dutch developers already write Java professionally.
A competent Java programmer is not slower than a competent Python programmer. Time to market won't suffer.There is definitely a higher barrier to entry with Java, and starting new projects involves a bit more setup, but that is never the bottleneck. You start a project once. You work on it every day after that. The time it takes to set up the build system is a drop in the bucket compared to the rest of the work. Maybe it will take your company a few more hours to get to market because of that? Big deal.
> There is definitely a higher barrier to entry with JavaThis is what is missing from the conversation. Most of us Java fans have been doing Java for a while. I started in '96. We know the JVM. We grew up with Java and were exposed to various aspects of this platform for over 2+ decades. Java the language is not that hard to pick up, but the platform in its total glory is formidable to those new to the language.I myself never realized this until a few years ago when in course of quizzing a very vocal anti-Java front-end dev in a startup, he blurted "it intimidates me".And I think this is really the issue.
It does seem to me that Java's default tooling is clunky and hard to get running, which is indeed be a big barrier for new devs. The fact that after writing java for ~10 years I'd still need to google how to setup a manifest file for a basic no-frills Java CLI program is silly. I've been tuned out of the last few Java releases, so maybe they fixed that recently though?
There is no longer a JRE, you are expected to package your app into a single executable with jpackage, so no need to manually write manifest files.
It's always sad to see people in the tech industry who are opposed to learning things. Quite a lot of the anti-Java, anti-abstraction, anti-complexity crowd seem to actually just be people who are one step above a sysadmin in their mental model of programming, don't see how large-scale programming is different from imperative scripting, don't understand that complex problems sometimes require complex/systematic solutions, and resist leaving their comfort zone.There are certainly valid arguments against everything I just said, but quite often they are not the true motivation.
>>Quite a lot of the anti-Java, anti-abstraction, anti-complexity crowd seem to actually just be people who are one step above a sysadmin in their mental model of programming, don't see how large-scale programming is different from imperative scripting, don't understand that complex problems sometimes require complex/systematic solutions, and resist leaving their comfort zone.May be you are the one refusing to leave the comfort zone. Fairly large chunks of programming ecosystem has moved to Golang, Rust and even other JVM languages like Kotlin for a reason. Most Python programmers today are Java refugees too.Its just that the overall culture of Java is loaded with programmers who like to use senseless abuse of design patterns as some 'smartness signalling' mechanism. Endless layers and indirections to achieve even simplest of the tasks.Using something like Golang and Python feels instantly less stressful and liberating when you go from Java to these languages.
How can a programming language stressful or liberating at all? There is no real difference between imperative languages regarding what you can do, and minuscule one regarding how you can do them. I’ve seen hardly maintainable and understandable code in all mentioned programming languages, regardless of used framework.
I have come to form a strong opinion regarding software development people: In general we are more comfortable withoperational complexitythanconceptual complexity. (A somewhat wider sense of conceptual, to include architecture, structure, etc.)Some of us, like me and possibly you, are more comfortable with conceptual complexity but abhor operational complexity. This [division] mirrors the society at large, imo, but was masked during the early days a couple+ of decades ago when software geeks were truly geeks. That subset of demographics never was upset by complexity per se, onlyun-necessarycomplexity was a cause for getting upset. The general demographics is bothered by complexity, period.Companion theory partly based on this opinion is that as the community grew by orders of magnitude from say late '80s to '10, it began to more closely resemble the general population. So the degeneration of keep it simple, stupid (KISS) to mean keep it stupid and simple is an economic and social phenomena.We are workers in a field with an arts and craft mentality on the production side and global industrial demand on the consumer side. The factory worker plugin iPhones together is not asked to think conceptually. The factory worker making software widgets in some IT department however has to come up with an ad-hoc 'assembly-line' with his or her teammates. Of course they are going to poo poo conceptual complexity. What does it bring to the table for them or the production line?In contrast, learning (or copy/pasting) n chants for m different infra-beasts to get your widget online seems far more reasonable and far more bangs for mental bucks.
I don't want to start a flame war, but I don't think there are "pro-complexity" and "anti-complexity" sides in programming debates, but really different views on where that complexity should be placed. Is a complex language unnecessary and design patterns are enough, or are design patterns symptoms of a language that's not powerful enough? I hope nobody is adding complexity for its own sake, at least.
Many design patterns became obsolete for most languages because they added new features, java not being an exception.
You sound very condescending. How do you know you are not the one staying in the comfort zone?
IntelliJ comes with a step by step GUI to set up Spring Boot for you with all kinds of bells and whistles, with the choice between Gradle or Maven for your build chain (last time I checked, maybe they're moving away from Maven at this point). You follow the steps and get going. You can set up a project as fast as the time it takes to Google the exact name of that npm/pypi package.Sure, you'll want to check your settings before pushing your first code to prod, but the same is very much true for any other "default" deployment.The same is very much true for other "boring" platforms as well, such as dotnet these days. Getting started is quick and easy.Java will have a significantly longer setup process if you decide to throw out all the work that's been done for you and implement your own boutique web server and routing system, but that's not a realistic scenario for most companies.I imagine most of the Java horror stories people recall come from the days where there were no good Java libraries and everyone was reinventing the wheel. Sometimes there are weird dependencies that stop being maintained and rather than fix the problem, companies opt to stick to ancient versions of Java and the JVM, but that's not really a Java problem either, that's a supply chain issue.I don't understand what the higher barrier to entry is supposed to be like in practice. If you know the basics of backend development in any language, you can get started. Learning to place annotations on top of endpoints is a five minute tutorial process, not dissimilar from how setting up routes in any other language takes reading a page or two to get right.The only barrier to entry I can think of is that you probably want the full version of IDEA which costs money, though you can use all of its features for free by sticking to the EAP release if you're tight on money.
> I imagine most of the Java horror stories people recall come from the days where there were no good Java libraries and everyone was reinventing the wheel.My memory of java is from about 2007 and I had a pretty negative memory of it. I recently joined a company that primarily does java development and it's amazing what 15 years of progress can do. It's night and day. Using IntelliJ instead of eclipse alone is a big jump.The thing is, as a C#/.NET dev, those tools weren't that great 15 years ago, either. But I'd been keeping up with the progress in that ecosystem, using it day to day, so it's easy to forget.
> A competent Java programmer is not slower than a competent Python programmer. Time to market won't suffer.A fast horse is not slower than a fast car.Languages and ecosystems shape how people think. For example, you will find that Java and Python programmers haveverydifferent values and principles. Given same options, they will make extremely different choices. Clearly this is going to have at least some effect on time to market.I found Java to be a land of overengineering, verbosity, and anti-patterns. The infamous "Hammer Factories" [1] post screams Java to me.[1]https://www.danstroot.com/posts/2018-10-03-hammer-factories
> A competent Java programmer is not slower than a competent Python programmer. Time to market won't suffer.Really, really doubt this. 100%. Not blaming the developer, surely, but even modern java is more complicated than running something in node.js> The time it takes to set up the build system is a drop in the bucket compared to the rest of the workIt's not just a one-off, Maven will make your development slower every day of the week. Every build, every unit test run, etc
In what way? Sure, gradle can build faster, but the amount ofcompilationtime the frontend need that barely does anything is orders of magnitude more than any maven run.
> It takes 2.5x time to develop a program in Java rather than Python. It's been measured.I thought it is 2.54 times faster. Python to Java is inch to cm.
Do you have a link to the study making those (very hard to believe) claims?
Why exactly do you think the claim is hard to believe?People use scripting languages like Python due to faster development times.
They certainly don't use them for resulting code performance :pYoutube vs Google Videos:https://books.google.co.uk/books?id=eulODwAAQBAJ&lpg=PA136&d...Youtube's 20 developers using Python were able to out compete Google's several hundred developers using a more traditional language.Here's a study for you:https://games.greggman.com/game/dynamic-typing-static-typing...
Because nothing in Python is magic. There isn’t a single language feature in Python that somehow magically makes you more productive. All of the Python language features are also present in other languages.And productivity to me is not how fast I can bang out a solution to a small problem. I can do that in many languages no problem. Productivity to me is being able to effectively maintain very large (million+ lines) code bases. Not having types is a productivity killer in that scenario. And Python being a slow languages (when not calling C libraries) makes it even worse.But hey if you feel more productive using Python that’s great! More power to you.
People generally do interviews in Python if given the choice. Coding in Python being quicker is well known in the community.For why Python is more productive:Dictionaries (maps), sets, (generic) lists, tuples are first class citizens of the language with simple syntax.Typing is dynamic, which means generics, abstract base classes, interfaces and tons of typical boilerplate code, which you would use in Java, are simply speaking omitted entirely.Extensive library, which is easy to access by pip.It would be very weird indeed for a developer not to be more productive in Python than say Java.It should be fairly obvious why the hundreds of Google engineers were run into the ground by a small team of Python developers.
Nothing you mention is unique to Python. C# (for example) has all of that. And no there is no agreement in “the community”. Just look at the very long dynamic vs. static typing discussions we have all the time on HN.And if you think that typing a few fewer characters will make you more productive then we clearly don’t agree on what it means to be productive. Programming is not about typing fast :)And pick any two random developers using the same programming language and you will probably find that they vary dramatically in productivity.And please don’t worship Google developers like they are made of magic fairy dust. I have worked with people who ended up joining Google and they were OK but not great developers.So no it is very far from being obvious.
Getting rid of 60% of the code, generally speaking is a productivity boost.
It's a bit more significant than a "few characters".I'm pretty sure that developing with scripting languages is significantly faster than regular programming languages :pAre you actually trying to argue against that?Not sure why you think I was worshipping them?
Several hundred developers being knocked out by 20 developers is an impressive feat.
> Dictionaries (maps), sets, (generic) lists...Youdoknow that Java has had those for decades, right?
Honestly the biggest reason we had to re-platform to the JVM was latency (fail whale was a 5s timeout) and not growth. Ruby was just too slow for all the stuff we wanted it to do. It ended up being 10x fewer servers AND 10x lower latency.
I feel like this is a pretty important comment that busts a popular myth about Twitter and Ruby.  The notion that Ruby was a poor choice even for a young Twitter that hadn't hit scale makes Ruby (or at least, late 00s/early 10s Ruby) look even worse than it already does.
That said: time to market with java is also quite nice and one selling point for it.
Java was designed to, and still delivers, rapid development.Is it possible for java developers to entangle their work through poor choices such that development becomes slow?  Absolutely; the java ecosystem has accumulated a number of such tar pits.  Competent java developers avoid these.Unfortunately incompetent java developers abound.  The world is full of java developers that haven't learned anything new since Java 6 appeared 16 years ago.The above argument is also used by C++ advocates; C++ is great if you know what you're doing and apply the solutions provided in modern iterations.  Ironic since java was Sun's 'fix' for C++.  Given the rapid rise of competitors to C++ I believe that argument isn't working terribly well.
I think people confuse "I don't personally know Java" with "Java has a slow time to market." Sure, for people that don't know Java,learningJava to that level is definitely going to cost you time.
I've worked with plenty of languages [1] since 2001 when I entered the job market . Recently I've been doing coding interviews for developers for aJavashop who theoretically knew Java.  Itpainsme to see what they need to do to implement what I ask them (simple tic-tac-toe game) using Java.   Something that in  Ruby would be:  puts(row.join('|')), in Python would be: print('|'.join(row))  in JavaScript would be console.log(row.join('|'))   in Java requires either a StringBuilder monster or a third party library [2] to make it bearable.And like that, there are other crazy things that make me glad I don't have to write Java anymore (I worked 4 years with it in total in the early 2000s).[1] (VB6, VB.net, C#, Java, PHP, ActionScript3, C++, JavaScript, TypeScript Python, Ruby, 8086 asm, top of my head).[2]https://stackoverflow.com/questions/6622974/convert-string-t...StringUtils or TextUtils
String has had a static join method since Java 8 which was released almost 10 years ago. Your example would just be String.join("|", row).
Right? I mean I think what GP is saying that they aren't qualified to interview Java programmers? Hasn't used it since 2010??? Yet they had the hubris to think that they were qualified, and used the interviewees lack of knowledge to confirm his priors about Java?
2004 Java is a little different from 2022 Java....
I have mentored coworkers who didn’t know Java on how to use Java at work. I would definitely rather hand a random person Java to learn for work than others.
True enough.  But Java (and other options) have changed in the meantime too.  Are the productivity arguments equally true today as they were when Twitter decided on Rails?
I haven't kept up with Rails or Java for a couple of years, but Rails has always been laser focused on rapid feature delivery. If I knew up front I'd end up with twitter I might not start with Rails, but I wouldn't choose Java either. The truth is, there are a lot of good options today and hiring will be a consideration. I think the big negative for Java there is that almost every dev sort of knows it, so the signal to noise ratio there isn't very good.
Java has been improving pretty fast and is starting to close the gap in spots where it's been seen weaker to Go etc. 
Fact still remains that it has excellent lib ecosystem, tooling, observability and large code bases with multiple teams are much easier managed in static languages. 
At this point most of the downsides are from legacy frameworks. A modern framework + Kotlin is very productive.
Isn't Kotlin slow to compile though? I created a simple hello world Kotlin multiplatform website the other day and it took like 30 seconds to recompile any time I changed anything.
Havent used multi-platform. We use it for Android and Server, seems ok
Really interested what you mean by Java having gaps compared to Golang. You can basically write Golang like code in Java, just leave out any useful language features and you've got it.
I have used both professionaly and am not a fan of either. (I really like typed and compiled languages, so those are not my issues with them).
Co-routines .. that's a useful pattern Go did out of the box. 
Fast startup .. important for containers and auto-scalingCo-routines have been in Kotlin for a while, got added to Java (Project loom) recently. Same for startup time. Native image support in Project Leyden
For fast startup, look at GraalVM/native-image which compiles Java to native code and works very well.Downsides are that highly dynamic and reflection-happy Java code bases/libs won't run OOTB, that using profile-guided optimization (for achieving or surpassing HotSpot perfornance levels) requires a commercial EE license from Oracle (about 300-400 bucks per seat last I checked, not required for mere development until used in prod or at customer sites, and bundled with commercial JRE/JDK subscription since about a year), that even with EE your garbage collector choices are limited, and the somewhat overwhelming number of optimization flags to pass to native-image, not unlike earlier JVM runtime arg excesses.
Although note that using PGO with Go isn't really common either. Actually, JVM languages and JS are amongst the very few that use PGO regularly as setting it up and using it with AOT compiled toolchains takes more work.
Java starts very quickly (like a second). If it doesn't, that's typically down to pulling in slow libraries. Spring Boot in particular is awful for start time, can add like 30 seconds to start time.
Coroutines are coming soon, project loom.
Can you list a few modern frameworks? Just curious, I was using Play a few years ago but that was Scala.
Quarkus and Micronaut. Spring replacements almost. Backed by commercial companies and strong dev teamsSuper light frameworks, more http focused, Kotor and JavelinSpring itself had a major overhaul recently
Plenty of rationalization of how java (the language) is "subjective for developers" in terms of productivity and happiness. From a non-engineer view though, let's be real : nobody ever got fired for picking java. 
This was just a decision made in favor of managers over the poor engineers that will have to deal with maintaining a large Java code base over time.
As an engineer, Java would be one of the languages I would choose for maintaining a large codebase over time. It is far better for that than most other popular languages.
If that is because of static types then I might agree with you, however once Spring and other reflection-heavy frameworks are added to the mix then I'm not so sure. Java's biggest problem is not the boilerplate, but the culture of over-engineering.
Luckily, the culture of over-engineering has shifted significantly thanks to modern approaches for designing Java-based systems.The "Triple Crown" of Java frameworks, namely Spring Boot, Quarkus, and Micronaut, but also with the influence of smaller contenders (Dropwizard, Javalin, SparkJava, and a few others) have helped developers focus on business code rather 'design patterns' because these frameworks have embedded a lot of the "over-engineered" concepts into their 'opinionated' approaches.Developers are no longer thinking too much about layers, and just writing components by following the guidelines and best practices of these frameworks. The final result is pretty similar among all of them, especially for microservices.
I like the sounds of that but I would definitely note that this requires _significant_ technical leadership. If you try to hire Java developers, 95% of the resumes you're going to get are people who learned Spring the bad way and have very little experience shipping efficient or reliable code.
Can I ask what you mean by learning Spring the bad way? I'm new to the industry and starting a Java role in Jan.
The general problem I’ve seen is complexity and action at a distance - basically many things where anyone trying to figure out how it works or make changes has to understand a lot of code in multiple places.A mundane version of this problem is dependency management: every Spring app I know is constantly patching CVEs, almost always in optional code for features they aren’t even using, and sometimes upgrades are not trivial because you have to push around a lot of framework code. Node is similar but at least the tools are better.None of that is specific to Spring, and I’m sure someone will pop up to say that’s doing it wrong but it’s been 100% of the work I’ve seen from multiple contractor teams so perhaps the way to characterize it is that the community doesn’t have enough culture of pushing back against support burden or complexity.
In my long time java shop we're doing pretty much the opposite - using less frameworks and libraries to minimize time spent on constant upgrades to the frameworks and their myriad dependencies for exposed vulnerabilities.
These things are changing - Quarkus and Micronaut are gaining a lot of popularity, and both use compile-time DI, not reflection, and Quarkus in particular is designed to target GraalVM, and Graal does not like reflection at all.Spring is the fucking devil though.
Agreed.  Even if we buy into the argument that Java is just wordy and slow to work with, once we're doing with long-lived code that needs maintenance, that's less of a concern than code that's hard to decipher, so the trade-off seems like a good one.
Yep. The wordy nature of Java is just giving you more info to work with when you dive into code you haven't seen before. Java is also a lot less wordy than it used to be, and if you use the right tooling you don't need to actually type everything by hand anyway.What matters most for maintaining large codebases that a lot of people work on is the type system and the tooling. A large ecosystem of good tooling exists for working with Java, and it is empowered by the static type system to do some very impressive things. Some of the .net stuff is probably close to that with Visual Studio and the ecosystem around it. Everything else is pretty far behind, including Python and Ruby and Go.I know people who work on a massive Java codebase that is almost 20 years old and has over 1000 people currently working on it -- and thousands more have passed through that codebase in prior years. It's not a lot of fun. But if it was a Python codebase, it would actually be impossible.
The type system isn’t impressive. You can find usages and thereby get navigation and refactoring via excellent Java-centric IDEs. But it seems like that’s it(?). On the other hand you have to constantly exercise your code because of lurking NPEs. Although hopefully we can get good annotations through third-party tooling (Facebook’s looks good).
I do like Kotlin's nullable types for that reason alone. At least Java has far better NPE messages now.https://www.baeldung.com/java-14-nullpointerexception
That's a lot on its own, and being able to understand the argument and return types solely by signature is a big productivity boost compared to environments where that isn't possible.
Java can be hard to decipher in its own way. Mostly because of a culture of favoring just-in-case indirections, a propensity towards making deep call stacks as the codebase evolves (maybe because IDEs make that navigation tolerable, although it never makes it easy to see the whole context), and pretty imperative constructs outside of streams and lambdas.But on the whole Java is not bad. I think it’s perfectly OK. I am more afraid of Java culture.
I disagree that it's a tradeoff, because those two are orthogonal. Java is often hard to decipher because there are many things that can happen dynamically outside the visible code path that affect execution logic, like annotation processing, classloading, dynamic bytecode manipulation, AOP, dynamic proxies, reflection, etc.
Most of those strategies are equally popular in Ruby but without the guardrails that at least make them cumbersome enough to make you think "is this really how I want to approach this?"  The pitch for Ruby has always been productivity because it's terser so I'm trying to be charitable here and grant them their greenfield case.
In my experience (and our experience at TransFICC building middleware for financial trading systems, which is extremely throughput and latency sensitive), Java is the fastest language to work with simply because the tooling support is second to none.
I never understand java hate. The hate seems isomorphic to: "i hate types and i dont use a real ide"
Have you compared and contrasted Java and C# (especially with regards to let's say larger frameworks)?Both of those put a strong emphasis on types, but only one of those (it's Java) is the sort of language that really attracts developers that love types like AbstractWidgetBoundaryFactoryWrapperFactory.I can definitely understand the "Citizen Kane" effect of looking at a modern Java framework and going "yeah looks just like any other language, except with types and IDE support". Java didn't get there from nowhere. It got there after 20 years of being overly verbose and frustrating to work with.
Then haven’t seen some old .NET codebases. Both languages around the high of OOP-hype made similar monstrosities, but neither does it anymore.
https://steve-yegge.blogspot.com/2006/03/execution-in-kingdo...
My only real gripe with the language is JRE versioning and updating and that's the only legitimate complaint I've seen from others. It seems that you can sidestep that issue by baking in the JRE to your executable.Honestly, I think the only reason C# is winning at all right now is because MS controls Windows and can silently keep .NET infrastructure up to date all the time. There must surely be a parallel universe where Oracle created their own OS where they enjoy the same benefits as MS.
Search for the memo where google employees were saying, "we the developers of google are losing to Youtube, as Youtube engineers use Python and we use Java. And iteration in Java is slower than Python." That's before google purchased youtube.Edit : Python. The point remains the same.Link :https://news.ycombinator.com/item?id=16674628
YouTube was based on Python from the very beginning.  And since then has migrated more and more pieces to Golang.  PHP was never a major component of their stack, if it was ever used at all.Search for the memo where Twitter migrated to the JVM.  That one actually did happen.
The link from your linked page states that Google were using C++, not Java. Which is correct. I was there. Writing web servers in C++ is a good idea if your web server is 1% HTML rendering/UI and 99% complex algorithms over large binary data structures i.e. a search engine. It's not so great if your web server is 95% UI.
Found the memo, reads Java.Link :The source :https://twitter.com/TechEmails/status/1433837480449613839/ph...Discussed on HN, 2021https://news.ycombinator.com/item?id=28424339
Are you reading these links carefully enough? The first link you posted was talking about Google's use of C++, but you presented it as an argument against Java and in favour of PHP (which YouTube weren't using). This second source also doesn't say Java vs Python was the problem. They say:"We're constrained on UI/Java development resources", "we have 1.5 engineers working on UI things and that is slowing us down" and "I think if we had one more good Java/UI engineer we'd be kicking butt vs YouTube".So the problem was a lack of people ("resources") assigned to the UI side, i.e. too much of their headcount is being consumed by the C++ infrastructure leaving very little time for UI-centric work like social features. Google Video's problem is stated here to be toolittleJava development, not too much.As someone who was there at the time and who read the internal post-mortem written by the Video team, Google Video vs YouTube wasn't primarily about implementation language. It was pretty much as the emails you cite say:"They're cranking interesting features a lot faster than we are, but don't likely have a backend that will scale or a plan to make money. We, otoh, have these"The YouTube guys did the now classic VC play of focusing on growth hacking without any idea of how to pay for it all beyond being acquired. At the time Google bought them the site was close to total collapse; the project to stop it running out of bandwidth was literally called BandAid. The Google Video team was also small but focused more on stable and scalable infrastructure, and product-wise they'd been chasing professional content as they couldn't see any obvious path to monetizing hobbyist produced video. In turn that pushed them away from the Flash plugin towards a more HD video oriented custom plugin, which hurt adoption. These were the wrong calls clearly, but, YouTube didn't really have a plan either. In the end both sides needed each other. One of the first things that was done after the acquisition was start moving core YT functions like  video and thumbnail serving off Python and onto the Google C++/Java infrastructure. The web server UI on the other hand remained in Python for a long time so their (social) feature throughput wouldn't be disrupted. I think that codebase did eventually stop scaling and got rewritten, but my memory starts to fail there and I can't quite recall what the state was back when I left.
Youtube was first written in PHP.> Before Google acquired Youtube, the majority of the code was initially written in PHP, but there were many restrictions and clutters in PHP at the time, so after acquiring Youtube by Google, they moved to Python as one of the core parts of its backend programming.Python started after google's acquisition. It's not that youtube was "never written in PHP".https://ourtechroom.com/tech/technologies-programming-langua...
Rate of iteration changes with the size of the codebase, and not in PHP's favor...
And yet, YouTube rewrote their stack in C++.
The more common and recent hate I hear is that so much has been layered on top of it that it's difficult to manage or really understand what's happening in the code. Mentioned in other comments, but things like loads of annotations, Spring abstractions, and so on.
Recently coming from a Python/Flask codebase to a Java/Spring codebase, I would say that the amount of "magic" is not all that different.It's just that with Spring, I can go to an extremely well-written user manual, or to StackOverflow and get my questions answered.  With the Python/Flask codebase, I had to splunk my way through all the layers of random libraries the original developers slapped together, in an attempt to reproduce something resembling out-of-the-box Spring.I suspect that those original developers had fun making all of those custom choices back in the beginning.  I don't know for sure though, since of course they've all left the company since then.  The company chose to migrate because it wasn't maintainable once that tribal knowledge left.
That sounds more like a microframework vs a kitchen sink opinionated framework issue though than a language issue. eg Flask is a DIY collection of libraries with your own architecture vs say Rails or Django where you have 95% of those decisions made for you and baked in.I'm sure there are Flask style frameworks in Java land too. And there was a port of Spring for Python a while back too :)
Exactly this.Had to stand-up a server in Java recently.At some point I realized I was doing more programming via XML files and Spring decorators than via actual Java code. Mostly because Java itself isn't a great abstraction for a CRUD server.
If you did it recently, you should not have needed XML. Even a decade ago, XML-based configuration was on its way out. The transition from Spring to Spring Boot enabled us to use regular code to configure our injectors, for example.I haven't touched XML for nearly a decade as a full-time Java developer.
I've only ever developed Java at places that had their own infrastructure for everything, so this question may sound uninformed, but isn't Maven still the de-facto package manager used for most Java applications and isn't Maven configured with XML?
Well, while maven be a bit bigger, gradle has plenty of users as well, which uses groovy or kotlin for configuration.
Yes Maven uses XML.
Yes it's using XML for all the wrong reasons - as a config and even scripting format (hello ant plugin) when XML is for markup/text. Fscking Maven doesn't even allow basic XML/SGML features such as entities/text macros. And yes Maven's pom.xml is used for package metadata on maven-central and elsewhere even if you don't use Maven directly.BUT I have to say, every project using gradle as alternative so far has receded into bizarre ad-hoc deployment scripting. Maybe that's just because gradle can do stuff that was hidden away in jenkins build files, but still ...
Most of the pieces we were using allowed for configuration via XML or code.Predictably, the team therefore used both.
XML is pretty rare in Java code written this side of 2010. Not that it doesn't exist, but the whole spring mess is not something you really have to touch to set something up in Java.I usually enjoy Spark[1] for bootstrapping a simple REST-like interface. There are other options, but in general, you don't really need glue-languages at all if you stray away from old-fashioned EE-style frameworks.[1]https://sparkjava.com/
Yikes! You can't attack someone like this on HN, regardless of how wrong they are or you feel they are. Obviously it's completely against the site guidelines.If you'd please reviewhttps://news.ycombinator.com/newsguidelines.htmland stick to the rules when posting here, we'd appreciate it.
I can only tell you my own lived experience, and that was it.It is possible there's a better way to do these things my team was unaware of (I was aping an existing server and replacing its RPC handlers with our own, not starting from scratch), but yep. XML and I can't be arsed to remember if they call their @-forms "decorators" or "annotations" because I use too many languages that have some variant of them to keep track.Point is, I wrote more of both than actual Java, and the annotations make debugging much harder than slapping a tracing debugger on.ETA I think the peer comments and this one underestimate the stickiness of methodologies in old languages. The fact that there are better ways to do it now is irrelevant... Because there was a previous best practice that is no longer a best practice, that best practice lives forever in the code bases and shared knowledge passed by peer review of existing institutions. Hell, I can go to my bookshelf and pull down two Java tutorials that show how to do an RPC server with Spring and XML... Once it's committed to paper, it lives forever. One can make the assertion that a team should be constantly developing their process, but management is a lot more comfortable with standing up a new server that looks exactly like the old one than with trying a new methodology that is unproven at this company. If for no other reason than so we don't have multiple ways to approach debugging servers depending on what team set it up.
Has those people have any understanding of what is their computer? It is layers upon layers of abstractions, plenty in hardware and even more in software. In fact, the only tool we have to actually solve complex problems is (good) abstractions. So those haters should probably find better arguments.
Large codebases in dynamic languages are the pits. Determining if some bit of code is used and how is a probabilistic exercise. Eventually you learn to give up or YOLO and see what happens.
Everyone always says that's fine if you have tests, but that's never actually true.
If I write the tests, maybe. Some tests make refactoring even harder. If I couldn't already refactor my own code we're also in pretty bad trouble. If I've written more than 10% of the tests overall, things have already gone badly.
And so we have a chicken and egg problem.Thanks to verbosity, Java creates the very problem that it tries to help with.Did you need to have that many programmers and that much code?  Who knows.  But once you have it, continuing with Java makes sense.
Verbosity is not a problem. The problem is being able to navigate and understand a large codebase. Terseness and dynamic typing are the enemy of that goal.
Attempts I've seen to quantify it have found that you hit a productivity peak in a team of 5-8 people.  Then you need to add processes to avoid n^2 communication overhead.  You don't get back to the same productivity until you have a team of 20-25 people.If you've never worked on a small team, the productivity difference from staying small may not sink in.  But they are real and large.  And companies should not lightly cross that threshold.I agree with you that, on a large team and in a large organization, terseness and dynamic typing are bad.  But I don't agree that verbosity is not a problem.  It absolutely is.  It makes you have to go to large teams sooner.
Why is that verbosity never mentioned as a negative for Go, when in fact, Go is more verbose than Java?Also, I really have a hard time believing that java would be significantly longer than any other mainstream language, it is at most longer by a small constant amount.
> Why is that verbosity never mentioned as a negative for GoIt is, all the time. For some random examples:https://news.ycombinator.com/item?id=27175184https://news.ycombinator.com/item?id=8893204https://news.ycombinator.com/item?id=19354659https://news.ycombinator.com/item?id=33942901
Modern Java isn't remotely as verbose at scale. The language is very different and the API+3rd party support is so vast you can usually build huge things with very little code.
20 years ago, the rule was that Java took an average of 10x as much code to say the same thing as a scripting language did.In all the time since I keep hearing "modern Java this" and "modern Java that".  But every time I venture into some Java, well, my limited experiences haven't fit what I was told about "modern Java".Maybe I just haven't encountered modern Java?As for the API+3rd party support argument, the productivity of third party libraries has been used as an argument for ages.  I remember when it was being made about Perl with CPAN.  My experience of it has always been that libraries make a great start to the extent you have a common problem.  Which is wonderful for demos.  But once you're in the weeds, you still have to write lots of code.  Maybe there isn't a library for your unique needs.  Maybe the standard library has bugs.  Maybe you wrote code because there wasn't a library but now there is.No matter how it comes about, you wind up writing code.
20x was always an exaggeration. It counted class boilerplate and compared stuff like hello world which was always "decorated". As scale that overhead gets minimized. Java will always be a bit more verbose than some other languages. It's strict. By definition that's more verbose. It also forces declarations (e.g. public). Again, a choice to keep things clear.But that's not the code that takes time to write or read. In that department Java isn't more verbose in a significant amount. If you're the type of person that gets upset that every line ends with a semicolon or that we need to repeat the word public for many methods. Then sure. Java is verbose.Looking at the body of a Java method I don't see something I can significantly cut down with TypeScript or Python.
> Maybe I just haven't encountered modern Java?even modern Java 18 codebases with exclusive use of records instead of classes, and with enabled enhanced support for instance pattern-matching instead of old-school conditional blocks and switches, are still significantly more verbose than Scala codebases, especially if the latter use `cats` or `scalaz` for all traversal/mapping/folding logic. Java developers would just manually encode all these patterns into series of nested loops by hand by default every time, because the required tooling as well as the compiler help to aid that tooling is not available in the language.
Mapping/folding is possible with plain old java streams. So while scala can be smaller, the difference is not too significant in my opinion.
refactor tools for Java is just so much better than what you can do in a plain text editor or if the language does not have type annotations.
It's the (static) types, not the type annotations that matters in IDEs these days. Even in Java there are (very limited) situations where you can omit the type and the compiler infers it. And the ide handles it just fine. And in, say, Scala, which has more inference, the ide works fine (albeit not as well as Java but that's more down to maturity).
>This was just a decision made in favor of managers over the poor engineers that will have to deal with maintaining a large Java code base over time.What's wrong with maintaining large Java code bases? Say what you want, but the language is built for that.The worst code-bases I've seen tend to come from dynamic languages. Try to maintain hundreds of thousands of lines of python or ruby code over several years, and see how fun that is.>From a non-engineer view though, let's be real : nobody ever got fired for picking java.No. That's not a correct framing. Java is one of the few languages that able to strike a great balance between performance, development productivity, 'debuggability", cross-platform support (i.e. works just as well under Windows as Linux), language safety, and library and framework ecosystem. Honestly, it's hard to come up with a use-case where Java isn't a natural right answer.
I disagree. The alternative is some rockstar developer saying "let's pick Elm!" or "let's pick Elixir!" and then leaving the company after a few months. I'd take Java (or C#) over several other languages in a heartbeat. I'll leave the more esoteric stuff for the weekend, thanks.
I picked Elm once and I managed to convince my boss to let me got rid of it 6 months+ before I left. Turned out it's a good move! (well.. a not that bad move)
Most of the flak that java gets is from people who have never used/maintained java codebase. I moved from java to python and I actually miss java. It’s much easier to navigate and refactor java code. Yeah, you can write code faster in loosely typed languages like python, but maintaining it is a different story.
At my workplace I would pick Java 8/10 times. I would only pick something else when Java is really not an option (e.g. Scala/Python for Apache Spark, Typescript for CDK).Maintaining a larga Java code base is very easy (I think much easier than e.g. Python).
The tooling is awesome, there are countless libraries, last but not least Java is the easiest to hire for.
I think nobody fires developers who pick a language the boss or whoever in power doesn't like. And the boss would just say: NO.
Java seems to be getting a lot of flak. I would very much prefer to maintain a large Java code base over large JS, Python, Ruby code base hands down. Trust me, you don't want to be in a position to maintain a 100KLOC mess of an app written in JS by long goners.
> Sadly there’s very little evidence supporting productivity differences between programming languages, especially in bigger real-world contexts.Only because it's almost impossible to quantify and is so contextual. However there is a good reason why Java is getting many extra language features from functional programming, e.g. streams, records, "sealed classes", pattern matching. Yes, productivity. Personally I am far more productive in OCaml, Haskell and Rust than Java; and that's after spending many years getting a lot of Java experience. But these are not necessarily good choices for the risk averse, which really comes down to the real reason why you chose Java.
Streams are not a language feature, they only depend on generics and lambdas. There are surprisingly expressive FP libs available for Java written with only existing tools (vavr for example).Also, Java deliberately move slowly, it is a huge benefit for the platform as it can better avoid potentially vain features that would have to be maintained forever even if they are not popular. Algebraic datatypes debuted many many decades ago, yet they only become sort of mainstream in the last couple of years.
Both lambdas and generics did not ship with Java originally. Yes Java moves slowly, but it would move even more slowly if they waited for published studies proving the productivity gains of these features.
The whole article could have just been this:> Another important factor is that the team of engineers building the first version of Picnic’s platform already had ample experience using Java and the JVM.And the author of the blog post is a book author on the language and Java Champion, so uhh, yeah, it would be very weird not to go with Java in this case.
I've always found these types of articles annoying. Pick the language that you know and can hire for cheaply. The end.If your product or service is a success you can completely rewrite your app and change your entire stack.
> Pick the language that you know and can hire for cheaply.That's exactly what they did.> Go make your thing already.This article is about a company founded in 2015 that now has a 300-person technical team.  They already made their thing and this post is a retrospective looking back at that experience.
> Please don't comment on whether someone read an articleThat's fair.  I've updated my comment to remove that bit.
> and can hire for cheaplyUnless you're writing things in C or brainfuck, you shouldn't "hire for" language experience.
I feel like they wanted to make this article because of the bad rap that Java gets in the developer world compared to some “trendier” languages. The article was advocating for the exact approach that you say should be followed when picking a language.
I suppose - every article I've read in this vein always has the same conclusion - use what you know, and everything else is just a rationalization. What would be more interesting is the opposite.
While there are things I wish it did better for the sort of stuff I use it for (foreign memory API can't arrive fast enough), Java is a pretty solid pick.It's boring and unsurprising to a fault, which is a great selling point if you want to build something of nontrivial size and scope.Another strength is that it has a large well rounded standard library and a large set of mature libraries you can pull in when needs must. Not quite as batteries included as python, but not far off.The tooling is best in class, the available IDEs are great, debuggers and profilers are ridiculously powerful even at face value, and that's not going into the iceberg of weird shit you can do, like you can attach a debugger to live production process like no big deal.There are pitfalls when it comes to frameworks. Like both Spring and Spring Boot are quagmires that tank your performance. Like whatever velocity you gain from starting off with those is lost waiting 90 seconds for the planets to align every time you want to run your unit tests.
Have you got a chance to read "Java Puzzlers: Traps, Pitfalls, and Corner Cases"?
Java is a very surprising language with a lot of strange corner cases (a lot of them related to reified generics and wrapper types).There is also a lot of magic going on in JVM e.g. there is one optimization that causes stack trace to be omitted if the exception is thrown from a given place a lot of times. Beginners then see an exception without a stack trace and are stuck. SO rel:https://stackoverflow.com/a/3010106/1779504Spring can be a source of confusing problems when defining beans (especially when you have to use Qualifier's). Most of the juniors that I had a change to work with had very hard time getting used to Spring bean model. And I am not mentioning here strange Spring Proxy behaviour that can defy even programmers with 10+ years of exp
Yeah. Generics is arguably Java's weakest point. They're an afterthought in the language's design and should in general probably be avoided in all but the most trivial cases. A lot of problems go away if you stop trying to make Java into Haskell or C++ and just avoid the feature unless absolutely necessary, which you rarely do.That said, I did once sorta port a somewhat tortured definition of Haskell's parser monads to Java's type system for an event at work, mostly as a joke. Like it'sdoable. Wouldn't want to maintain that code, but it's doable.In general I don't think "does it confuse beginners" is a great metric for what makes a good programming language. You'll be able to find a beginner who is confused by almost anything. Beginners are hopefully not the same people who will write or maintain the code.
While it is surely an afterthought, it is imo very well executed knowing that — while you can’t have proper Monads, quite a lot can be accomplished, just have a look at some FP libs written in Java.
I have read that book, and while it is a great read, it rarely employs realistic code you would run into (will you really cast some number literal multiple times and try to guess the resulting value in actual prod code? And things like that)I have yet to be bitten by this stack trace behavior, thanks for the heads up, but I think every platform has its idiosyncrasies. I would still not change it for UBs everywhere :DAnd I really don’t think that the spring model is all that difficult, we just have plenty of bad developers and not enough focus on proper education of juniors (often done by “senior”, bad devs)
> I have read that book, and while it is a great read, it rarely employs realistic code you would run into (will you really cast some number literal multiple times and try to guess the resulting value in actual prod code? And things like that)There is some admittedly unintuitive behavior when it comes to type conversions, especially in bitwise operations. Like this is just nasty:long f(int a, byte b) {
        long ret = 0;
        ret |= b;
        ret |= (long) a << 8;
        return ret;
    }

    System.out.println(Long.toHexString(f(100, (byte) 64))); // 0x6440
    System.out.println(Long.toHexString(f(100, (byte) 129))); // 0xffffffffffffff81

    // you need to do 

    long f(int a, byte b) {
        long ret = 0;
        ret |= Byte.toUnsignedLong(b);
        ret |= Integer.toUnsignedLong(a) << 8;
        return ret;
    }
The problem is that in Java byte is _signed_ type. So `(byte) 129` is the actual source of the problem, the number is simply out of range (-128 to 127). Since there is no byte literal and numbers by default are integers you always have to cast when calling a function with byte parameter. There is simply no distinction between safe and unsafe cast...
The correct language to chose as a start up is one that your team has expertise in and allows you to move with speed. It seems silly to over optimize for future "re-architecting"
This is interesting because there's so much negativity towards Java, particularly new projects. But Java continues as an enterprise-class language, just as C++ does.
When we started our company 9 years ago (after many years as a freelancer in bloated Java-based enterprise projects), I had only one condition: no Java! With 2022 Java, I definitely would not have asked for that.
> In retrospect, it seems that Scala’s popularity has peaked, and we’re happy that we chose the Java programming language.This doesn't sound like a thorough assessment of Java alternatives one would normally expect from an engineering team. There's hardly any technical reason to choose Java in favour of Scala3 today, except one: the team's lack of Functional Programming expertise. Otherwise, choosing Scala for JVM would almost certainly result in better quality software in terms of safety and internal components design suited for long-term maintenance.
>There's hardly any technical reason to choose Java in favour of Scala3 today, except one: the team's lack of Functional Programming expertise.I disagree about your premise at multiple points, but I want to focus on just one point - In my experience, Functional Programming is a large enough of a technical reason to not choose Scala in a company of a reasonable size. It's actually such a big reason that it deserves more than as an afterthought as you have it written.I worked in Scala for 10 years. Not only was it difficult finding seasoned Scala devs, but also we often had to compromise by hiring Java devs and training them on Scala. Time and time again, functional programming was always the most difficult hump for them to grasp and it took experienced devs forever to learn the language and a new paradigm at the same time. Sure, you could hire someone who knew functional programming already and came from a background writing Haskell, but they were rare and usually commanded exorbitant salaries that made sure they were never in the equation to begin with.Not to mention, you better have a disciplined team with strict linting rules and styleguides, otherwise your devs will go off the rails using Scala in ways that the team isn't prepared to learn. Or if you have Java-trained-Scala devs, they might revert to their old OOP ways.Because of that, it actually causes more problems, resulting in worse quality software and worse deliveries overall.It's too much of a risk, really. Especially when Java is not really a terrible choice in a large enough organization - same huge JVM ecosystem, large pool of devs, mature toolset, etc..
> I disagree about your premise at multiple points, but I want to focus on just one point - In my experience, Functional Programming is a large enough of a technical reason to not choose Scala in a company of a reasonable size.You say you disagree with my premise, yet you seem to be confirming the point I made. Your arguments revolve around difficulties with finding devs for a team and with training them to actually understand FP at a level that would allow them to untangle their algorithmic thinking from OOP. It's exactly what I said about the only proper reason to choose Java over Scala: team's lack of FP expertise. Other than that, my point still holds: type algebra and explicit nulls opt-in bring better quality software overall. And it does require FP expertise, not just awareness or vague familiarity with.> otherwise your devs will go off the rails using Scala in ways that the team isn't prepared to learnThis also contributes to my initial point. But I'd like to know what are your examples of off-the-rails, as I've been to situations where a couple of folded traversals had been called similarly "too much" in a Scala codebase, but for someone writing Haskell it was just a regular application of a familiar pattern.> Sure, you could hire someone who knew functional programming already and came from a background writing Haskell, but they were rare and usually commanded exorbitant salaries that made sure they were never in the equation to begin with.This is a specific argument that could be made within your organisation. I don't know your budgets and the requested salaries by respective candidates, and you didn't clarify the level of expertise your teams were looking for, so I can't make an informed judgement about the merits of this argument and to what extent it could be applied onto the tech stack in general. I've been doing FP for a meaningful amount of time, mostly in Haskell, and the common theme over all these years has always been a visible shortage of FP positions compared to the number of capable candidates willing to compromise on their salary in exchange for an opportunity to use Haskell at their workplace. Many of them were instead compromising on Haskell in exchange for a regular Java-grade salary for writing Scala. And I've never heard of people commanding better salaries just for the fact of being able to write Scala instead of Java. Usually it was due to additional set of skills, like strong algorithmic training or extra years of business domain expertise, and these traits bring additional value to organisations, if they are able to utilize them within their teams.> Especially when Java is not really a terrible choice in a large enough organizationIt certainly isn't terrible, but it also is neither safer nor more productive. For a developer who has a good command of both paradigms, Scala would be a better choice on JVM.
Interesting that the choice was vs other JVM languages, and vs Scala specifically. The starting point to align tech choices with "realities of the hiring market" does make Java come out as the obvious choice then. But of course lots of companies hire developers for learning ability and the expecatation that they pick up the used language on the job, which also selects for other desireable qualities... no right or wrong answers here of course.
> In fact, we did migrate from Java to Kotlin: only not for our backend codebases, but for our Android app.good call. that's where it belongs.
I don't like Java although I have to use it at my current job. There is simply no other alternative that is both widely known and supported (think a lot of programmers and a lot of libraries). I see only 2 other candidates C# & Go, switching to either of them means significant effort and temporary performance drop for the entire company.Java is a very backward language, at my current job we use Lombok to generate boilerplate code. Lombok itself is a compiler hack, I don't like it. Why is that Java 17 records does not have supports for builders or for "withers" (point.withX(3)), C# & Scala offer both of those things. This makes records unusable for most of my use cases.The other hard miss is lack of named parameters. This either makes code very verbose or less readable.And my last complain is about lack of support around Futures/async/await. Yes there will be project loom, maybe even in next JVM release but currently we don't have it and a lot of libraries will need at least a year to support it. So instead of await's I have to manually compose CompletableFutures into spaghetti like code. I really hate this. We propose to our architect to use Project Reactor but the idea was discarded (after all Reactive Programming is not very popular among "commodity" programmers).If I had to start a company now I would probably also pick Java (or Go), my main points would be:
- Free compiler and IDE
- Good library support for wide range of use cases
- Programmers available on the market (Java) or willing to learn (Go)
- Good build system, static analysis tools, best practices, learning materials & stack overflow
- Language is battle tested (sorry Haskell, Ocaml & Lisp)Yeah this reduces it to Java for JVM, C# for .NET, Go if you are adventurous. If someone pick something more ambitious like Scala 3 or Rust I would gladly join that company, but if it was my own I would not risk it.
> Language is battle tested (sorry Haskell, Ocaml & Lisp)do you mean battle-tested by yourself? Otherwise it's kind of FUD opinion, as Haskell is battle-tested across industries in quality-demanding domains[1], and I'm sure the other two have similar lists of industrial application.[1]https://www.reddit.com/r/haskell/comments/6p2x0p/list_of_com...
I would add nodejs/Typescript as a mature option by now. Also, for web apps, using only one programming language sounds like a net positive for me.
I'd argue that Java/C# with Typescript is still a reasonable mix to maintain, they're not entirely foreign.
Most of your complaints are resolved by Kotlin, which can be mixed and matched with a Java codebase on a file level.
What about C#? Have you guys considered the .net framework?
A shout out to Orleanshttps://learn.microsoft.com/en-us/dotnet/orleans/
I am mainly a dotnet developer but even I think that if you already have a team full of Java developers there is little to gain from switching to C#. Just the effort of learning a completely new set of libraries and frameworks would give me pause.
C# seems to be the pick for those programmed in microsoft ecosystem in the past, it's not attractive for beginners or non-microsoft-ecosystem developers per se, esp in this cloud and internet era.
I’m dumbfounded that anyone would believe that C# is not attractive for cloud development - Microsoft’s platform or otherwise. C# is a fantastic language and dotnet is a great, modern platform. IMO c# is a tad more beginner friendly than Java.
Also any time I have to use Java I'm always trying to use LINQ before I remember that's a C# feature. C# is really solid, especially .NET Core 3.1 and later.
Same for me. I use LINQ extensively and can't imagine without it.
* This other JVM language has it too.  Groovy is not Java.Java does "have it," as in Java has streams.  It's pretty crappy compared to Linq due to language limitations but it's a lot better than nothing.
> [streams are] pretty crappy compared to LinqI think that's unfair to the Streams API.  It wasn't intended to solve the same problem as Linq and the problem it does solve it does very well.  Streams transform collections.  Streams API statements are usually elegant and the party piece of Streams is concurrency with parallelStream(), which will distribute stream operations across threads safely and transparently.Perhaps java should have a Linq equivalent, but the fact that the Streams API isn't that isn't actually a knock on Streams.  In the meantime there is JOOQ and others that deliver elegant query syntax with compile time type safety.
This sounds like a pretty serious misunderstanding of what LINQ is.  LINQ is a general query capability of which there are multiple providers - one of them is for SQL, which may be what you are thinking LINQ is, but another is for in-memory enumerables ("LINQ to Objects").  LINQ to Objects and Java Streams actually are intended to solve the exact same problem.If you think Streams API statements are elegant compared to LINQ, I again don't think you are familiar with LINQ.  C# has language features Java does not have which usually makes LINQ much more succinct.  For example, imagine a list of order items where each item has a double "Price" property.  If you want to sum the price of all the items, here's how you'd do it in C# vs Java:C#: 
double sum = items.Sum(item => item.Price);Java:
double sum = items.stream().mapToDouble(Item::getPrice).sum();Java lacks extension methods, so stream() must first be called to get at any stream methods.  Worse, Java has generic type erasure, so I have to to call "mapToDouble" to get this hacky concoction called a "DoubleStream" which actually has the sum method.Not the end of the world, for sure, but definitely crappy compared to LINQ.  There are lots of other irritating problems, such as Stream itself not being enumerable and the need for calling collect with a Collector.
Does it have the List.Where().Select() syntax instead of the select n from list where syntax? All of the examples on that page seem to be the latter.
Read the authors argument why they don't use Kotlin, a better language is not always nicer, especially when you risk being left behind. That is the reason why   I don't touch C#.Java has a massive community and a community that shares knowledge. This is what makes Java the greatest tool for any business.
> it's not attractive for beginners or non-microsoft-ecosystem developers per se, esp in this cloud and internet eraSpoken like its 2002!
Couple jobs ago worked a startup that was a hoard of Java developers from Cars.com. Pretty much their defining factor around why they picked Java since it was the team they could build to get the company off the ground. Undervalued factor considering what teams you can build early on and the skills they possess.
Author credentials: Java ChampionI mean, it's perfectly fine to pick language you're most familiar with, but maybe let's not pretend you're not biased? I wouldn't want to work for a leader that is full of BS.
Thanks, I guess? FYI, I joined Picnic in 2019, long after this choice had been (independently) made.
I'm confused. You wrote an article about how somebody else chose Java, but you're using the term "we", but it doesn't include you?The article unquestionably leaves the impression that you were there when the choice was made.
Not that complicated, really. I'm part of Picnic now for quite a while. That's the 'we'. Of course I've discussed the origin story as used in the post at length with my close colleagues who were there from the beginning. Also, I'm very much part of the current choice not to migrate to e.g. Kotlin based on such discussions. So yes, this isourstory which we want to share widely. It comes up every now and then, so now we have something to point people to. Didn't expect this to get picked up by HN, though!
Is it true that Java isn't slower than Python/Ruby/.Net? What are the fast ORMs and MVC frameworks for it that let you build a web app quickly the way ROR / Django / whatever .net people use?
Python and Ruby are probably the slowest commonly used languages, they are on the order of 10x slower than comparable C code. Comparatively Java/JS/.NET sits around 1-2x C speed, with .NET exposing some lower level details allowing manually fine tuning the performance, while Java has hands down the best GC implementations out of these 3. So one can’t objectively order them, for CRUD apps all 5 are great, and I think that there are very very few areas where C#/Java is not a good choice for performance reasons and you have to go lower level to C/C++/Rust.
I am starting to check this ecosystem but Spring Boot for the MVC framework is the ref. Used by so many big and small startup. I know a famous fintech using it too. Netflix etc also... Then JPA as the ORM and Hibernate. For the migration Flyway or liquidbase.And then everything in Spring and stuff you can plug from the ecosystem.
You may find this product interesting:https://stratoflow.com/
Grails
Java17 is fast... _very_ fast. CDI is a the killer framework.
Personally I like Java a lot.  I like Python for rapid prototyping and particularly code where numpy and scikit-learn can do the hard work.  PyPi helps w/ branchy semantic web workloads but for things like that (say something likehttps://github.com/srdc/ontmalizerthat really works which I've had on the agenda for the last year) I'd pick Java.I’ve worked for numerous companies including startups that used Java or JVM languages like Scala.
What do you recommend to switch from Python to Java or JVM based languages like Scala? I have developer experience with personal projects, but I can't seem to get shortlisted to any of the bigger companies which use them.
If you're looking at startups and the typical SV / YC crowd, maybe not. Looking more broadly, 100% yes, Java is being used for new projects. At my $DAYJOB employer new projects get launched using Java all the time. Not interested in saying who that is, but we're a Fortune 100 public company (not a "tech company" though).
Decades of work by lot of smart people has gone into the JVM, so there is still benefits to be had in using it.
Java is still ok. A lot of people use it. It's a good ecosystem and well hung technology, the tooling is very good.However, I think Java is not very popular because of Oracle and the licensing. There is no good reason to avoid it technology-wise but it has kind of a bad smell.Another reason could be that more and more modern languages are trying to prevent using a VM and are designed as or transition into a compiled language offering "best" performance by having native binaries without too many dependencies.The last reason I can think of is productiveness / complexity and elegance. Java just does not feel very elegant or easy to learn with its enterprise background. Too many products / libraries / technologies for beginners. Because of it's strictly object oriented design you have to write much code to achieve the same thing you can do in a few lines or even one line in other languages (even when you are using modern Java features). Kotlin comes in handy here, but still feels a bit clunky from time to time.I would still use it, if it is the right tool for the job... or even if I didn't have skills in another language and wanted to get things done. Still it may be a good idea to check out other languages to learn something new. Python is good for AI stuff, Go was very productive. TypeScript is... well a "better" JavaScript with interesting concepts. Currently I'm learning Dart / Flutter, because C# failed hard while building my first little audio player app :-)
why did C# fail for your app?
C# still has a lot of problems regarding cross platform development.The Microsoft Framework (MAUI) is... let's say it has some obvious problems that probably will never get fixed. Community Frameworks like Avalonia UI are better, but not there yet.To sum it up:- App sizes are huge (>70MB)
  - App Performance is meh
  - Important libraries are either missing, not cross platform or outdated
  - Hardware access is not good enough (camera, gyroscope, audio, bluetooth)
  - Cross Platform Deployment is too complicated
  - There is even more I can't remember right nowAll of that is not the case for flutter... it worked out pretty well until today.
Python and esp Django are great for rapid prototypes but larger projects I find the performance and structure of Java easier for a large team. Maybe things get a lot better in the future as type hints get more widely used with Python?My company does Python for ETL/data but Java for everything else
How do you measure that? Do you include only companies with _no_ experience in a particular language before starting a new project using that language?  Companies usually continues the language they have an experience with.Except some areas where you don't have much flexibility. Like for AI you chose Python even if you have no experience. Or for a website, you don't have much choices and have to use TS/JS even if you don't like them.
I launched a startup with Java/Spring Boot on the backend. Tons of developers already know this stack, no headaches, everything works. ChatGPT is also an expert in mainstream Java technologies. Using a bleeding edge framework like the newest next.js has major gaps in ChatGPT
Is that a comparison that makes sense?
I’m using Java in a new-ish project of mine. It’s not glamorous, but there is a library for everything which is nice. I also have the most experience with it (Clojure coming second), so that lets me focus on building rather than learning a new tool.
Here’s my pitch:https://cdaringe.github.io/programming-language-selector/
Not to be that guy, but why does it seem like Rust is so high for everything and Python is crazy low?I don't have a stake for either languages, but when I select a web server with only Developer UX, Hiring, and Ecosystem selected (as in no performance or correctness) Rust is at 0.87 and Python is at 0.12?I think if you told someone "I need a webserver in a language with a great ecosystem, easy to hire for, and performance doesn't matter" most people would think of Python. At the very least, nobody would think of Rust.
No matter what I try, I can't get python to reach the top. :DI like the website. It shows rust for a lot of options go as close to next best.
These days you gain very little (performance, devX, complexity etc.), but pay too much (overengineering mentality, "best" practices and traditions, tons of legacy etc.) in comparison to other tools.
If you include Android apps in the category of "new projects," then new projects using Java and Kotlin are being launched all the time, including by companies that were not previously using Java.
OP did ask for Kotlin, so I guess it counts. Because I don't think people really start any new code using Java itself. Kotlin is the officially supported language. And there's just significant tangible benefits of using Kotlin over Java (e.g. Compose).
Yup, it's boring and works :)
lots of java being used at mature banks & successful fintechs
Code is code bro. Just use what you like.
love this response :)
yes, absolutely
Maybe my favorite feature in this release:https://openjdk.org/jeps/463Finally solves the inscrutable Hello World program!Yes, it's just ergonomics for early beginners.  But could be the difference in whether or not someone new to programming sticks with Java or not.
C#'s got even better version of this feature since Nov 2021. Hello world is just a true one-liner.https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals...
I really disliked this the first time I saw it. I was like "WTF is this?"I can only think the reason why they did this was to compete with python, as our scripting languages that do not require a main/Main entry point.Personally, it just feels wrong for compiled-based languages.I think they could improve on C# with their namespace. Rather, for example, a typical C# file looking like:-using EFG;
  namespace ABC
  {
    public class XYZ
    {
     
    }
  }They could just :-using EFG;
  using namespace ABC;
  public class XYZ
  {
    
  }Pretty much taken from the C++ way.. but it saves on space availability.
The second option is what C# defaults to since a few versions ago.
Correct -- was added since .net 6, I believe.
Namespace declarations have been a thing in C# for a while
Yep. Point is it should have been added since Framework 4.
I 1000% agree. Though, a favorite early programming memory of mine was when static methods finally clicked and I went back and looked at all that boilerplate that meant nothing to me and it all became crystal clear what it meant and why it had to be like that.
This reminds me of when I finally understood why returning 0 from a function named main made sense.
And why array indices start at 0 instead of 1, in many, though not all, programming languages.
https://en.m.wikipedia.org/wiki/Zero-based_numbering
Actually a nice feature.This solves the public static void main string args issue.Still if I need JVM then Scala or Kotlin are still preferable over Java.Obligatory Java for the Haters in 100 Seconds:https://www.youtube.com/watch?v=m4-HM_sCvtQ
> Still if I need JVM then Scala or Kotlin are still preferable over Java.That's so 2010. I would avoid Scala like plague. It is a soup of all features imagined and some more. Java is difficult for novice. With Scala even experienced senior devs can look into a snippet and be befuddled. It is designed by academicians who thought clever looking choice is better.
About a decade ago, some Scala library authors thinking that "everything is better as a DSL" gave Scala a reputation for being a hieroglyphics soup, but that cannot be farther from the truth today. It's a really nice language to learn and to use, and the only one in my experience that I would want to take with me to scale from a quick dozen-liner script bash-style to a highly concurrent, highly available server application, from native to jvm to JS.And the foothold in academics has some practical perks, too, like a sound type system (DOT calculus), compatibility guarantees at a theoretical level (TASTy), and what's cooking in the area of capture checking might be a general solution to many of the industry's biggest challenges (e.g. colorless asynchronous programming, safe errors, safe resource management, ... Think of Rust's borrow checker as a special case of this, and the consequences for scala-native as a systems programming platform).
> It is designed by academicians who thought clever looking choice is better.That's just not true. That's the typelevel ecosystem. The official Scala toolkit mostly includes haoyi libraries which is pretty much Python like Scala.
I've never seen a java codebase I thought couldn't be better in kotlin
For reading it, I believe that. For authoring it, yikes it is slow. I'd guess due to all the implicit and implied and coercion and ... and ... and. Now I'm cognizant that I'm running my mouth without trying it on 1.9.x and a similarly recent IJ so maybe it got infinitely better, but my life experience with languages is that they only getmorefancy swooshings not QoL improvements due to Moore's Law and yearly refresh cyclesI was/am always glad to pay that tax because non-null-by-default and thevastly superiorval/var keyword pairs are totally worth it but it for sure is not a drop-in replacement in team environments. I am already constantly battling the vscoders (to say nothing of vimers) whining that "IJ is too slow for my eeee-leeeet typin'"
Definitely also for writing it.
I really dislike this feature.It's better to just say "we will come to this concept later", rather than make a fake syntax that does this (taken from the JEP) behind the scenes:new Object() {
    // the implicit class's body
}.main();It adds more confusion, as you are left explaining that you could not really run an instance method without instantiating the class -- it was just something fake for beginners.
I agree. Coming from NodeJS I appreciate how explicit Java is.
The complexity is there either way, but in Java it's right up front where I can see it, not hidden away under layers of abstraction for a supposedly better DX.
The thought process leading up to this workhttps://openjdk.org/projects/amber/design-notes/on-ramp
My first Java programming course went over in detail about that piece of code and in a couple of hours taught me a lot of important Java concepts right away. Consider me not enthused about it.
Simple code like that kept pulling me back to the JSL 1.0 spec time and time again as my understanding deepened, much like the old singleton pattern debates of old.
This is nice for beginners, but the confusion is only postponed, because then you'd have to learn why you need to write a class as a container for static methods and that these methods must be static. So, the Java developers created another special case in the language.Compare that with Kotlin where you have top-level functions, so that `main` is just like any other function.
They almost caught up with C#, which ditched requisite class declarations years ago. Although C# went one step further and allowed top-level code outside of methods, so that hello world is now:Console.WriteLine("Hello, world!")
You can write write code outside of methods in a Java class, called an initializer block:class MyClass {
    {
      System.out.println("Hello World!");
    }
  }This will run when an object of the class is instantiated. So not useful for the case in question (you could get rid of the class declaration but would presumably still need a main method).(It's also pretty poor style, but occasionally useful in a pinch, like when instantiating an anonymous inner class, which has no constructors that take arguments)
It has been a few years, but top-level statements in C# are still a fairly recent thing (C# 9 in 2020).
That sounds a lot like Top-level Statements in the .Net world. Personally I don’t use that feature because I’m old and get confused if things are magic but can certainly see the benefit for the newer devs.
I’m also a somewhat old school C# dev and the main reason I don’t use top level statements is that they only work in a single file of an application, so that single file is different from every other file in your solution.It’s okay if you’re only writing a single file, and it really seems intended for beginners or micro applications, but for those of us writing anything besides the most trivial, it’s merely “cute” and just adds inconsistency.
Yeah, no doubt inspired by the .NET feature.  I use it all the time for throwaway console apps.
This is exactly what I've been calling the "public static void main problem" for years (and an illustration of why I thought something like BASIC or Python should be everyone's first programming language). Neat to see the Java team come up with a solution for it. But "public static void main" runs deeper, and has to do with immediacy: shortening the time between the programmer giving instructions to the computer and seeing the results of those instructions being executed. It makes the smallest possible Java program greatly simpler and absent unusual comments that beginning programmers might struggle with; but there's the issue of thecompilationstep as well! If they make Java REPL-driven they might well have a winner!
Java has had the ability to run a single code file directly by running `java <path-to-file.java>` since Java 11 -https://openjdk.org/jeps/330. And it's had a Java REPL since Java 9.
Good that they got rid of the class/public static void/string[] Args boilerplate, but if they just went one step forward and declared implicit main function as top-level scope of a file, we could've got to a Python level of tersity. Just imagine!System.out.println("Hello world!");
To bethatguy, notquitea python level of tersity!
Well, if they added System.out in the default context, it could've been justprintln("Hello world!")I think that's as far as you can go.
# Python 3p = print # the print() function# Now we can do:p("Hello world")# endlessly, in this file.Shorter by 17-odd characters than the above Java version.
I really doubt that. Java is complicated enough that it's not beginner friendly even if you don't have to write the class to put main into.Given these are still methods of classes this JEP seems pointless to me. Not having to write class x {} isn't a great time saver.
Maybe in another ten years they'll remove System.out.println and allow for a simple println to be used.Or maybe we'll all move to Kotlin by then.
You can statically import System.out if you are so inclined.
You can but for a new user that is even more of a barrier than writing out System.out.println
this will probably show up in java 23, ctrl + f "simpleio"https://openjdk.org/jeps/8323335
And create the Kotlin Virtual Machine, with a Kotlin based ecosystem?
With respect, not hostile to beginners but adding complexity to the build to support this kind of implicit sugar, when beginners are 100% going to be using AI to write code and answer questions- seems like not the right tradeoff in 2024.
Well, they reduced a few lines of boilerplate for hello world Java program, while adding many many paragraphs of text to explain it. ;)
love this!
Groovy itself is a bad Groovy.
Raises handHere! I have to work with Spock on a Java codebase and I think groovy sucks ;-)
Yeah I use Spock and Groovy all the time, good god does it suck big ones.
I hate to be "that guy" but ...raises hand.Spock isalsoa DSL disaster that's trying to be ScalaTest (https://www.scalatest.org/user_guide/property_based_testing) but in a  dynamic language. Every time I use it I have to re-learn the syntax. (I have the same issue with Gradle, so maybe it's just-me?)
My problem with gradle is I never use it enough to get familiar with it, once the problem is solved I promptly forget everything.
It's the perfect example of a bad DSL.A "DSL" like SQL that you use hundreds of times a year you'll learn the model of.A DSL like groovy that you use once for project setup (and for that you'll one-off it likely and stackoverflow the rest of the question) is not. And it isn't really natural, it's a bunch of arcane steps that at the end might superficially look a bit consistent, but still really isn't.Groovy really needs an autocompleter or a generator. Or, well, as you say, you stackoverflow for everything outside the very vanilla basics of it.But good luck getting the right version match to the syntax you need. Christ.
Having types in Gradle by using the Kotlin DSL, with IntelliJ auto-complete, solves ~80% of that pain.
How so? I don't think there are many good things to say about Groovy, but I generally agree with most new features introduced to Java. What do you think Groovy does better?
- String interpolation- triple-quote strings / blocks- minimal class boilerplate (this posting)- closures (Java closures are worse IMO)- usable hashbang for UNIX- I think java has strings in switch now, don't they? Do they have expressions?WAIT, does Java STILL force you to write getter/setters?
features that make strings easier to use are bad in my opinion. the number one problem in java is people circumventing the type system with strings.switch on strings is there, as are switch expressions.records now removes the need for getters in immutable contexts.
But Java has all those features...?
You can be really productive, expressive and performant in Groovy. So much of the language still works well with @CompileStatic and doesn’t require dynamic typing. Writing clear code that has decent refactoring support in IntelliJ.Don’t forget traits! When are we getting traits in Java? Probably never.Optional semicolons and parentheses to cut the line noise and enable internal DSLs.Though Java has improved implicit typing with `var` and now we have reasonable lambdas, Java is still not a high-level language, but maybe it is now medium-high.
> Oops, sorry those are features java "stole" from groovy.Well, yeah?  Java's explicit strategy for the last few decades is to let other languages experiment, then implement the ideas that worked out once the dust has settled.
Hashbang aside this is a solid description of a base feature set of C# :D
A form of string interpolation is in this release.
It isn't a "Sexy" PL change, but a full foreign function interface will be a huge change. In my experience, relying on the old java JNI based libraries seems to be one of the biggest things that break in upgrades. So I am hoping this will reduce the maintenance burden of Java.
Boring changes like these are what keeps Java interesting.New and shiny syntax sugar becomes stale real quick.
As a modern language Java is still quite feature deficient. But you can use compiler plugins like the manifold project[1] to level up.1.https://github.com/manifold-systems/manifold
I see Manifold as a huge leap past previous tools Immutables or Lombok. I understand there's a use case where you want to add these language features to an existing code base. But for the most part if you want the language features on the JVM, you should probably just use Scala. That gives you a set of established patterns, best practices, libraries, and a community of users.If you want type safe SQL in particular, you can pry JOOQ out of my cold dead hands.
> just use ScalaScala is a dying language, anyone boarding that ship is making a mistake. Anyhow, I prefer Java supplemented with powerful features Scala doesn't have, such as type-safe SQL.> If you want type safe SQL in particular, you can pry JOOQ out of my cold dead hands.Jooq isn't bad, but it's not SQL, it's Java trying to be SQL. Manifold lets you write type-safe, native _SQL_ of any complexity directly in your code.
I have never seen anyone use manifold. Are you saying that I should use something like that in a serious production environment over Scala, that is a huge language with people that actually know it?Especially that you call it a dying language, when it just got reborn, and better than ever with Scala 3.
> Jooq isn't bad, but it's not SQL, it's Java trying to be SQL.Can you elaborate on this? I have been using JOOQ for years (with Kotlin), and I have never had any issues with it "trying to be SQL".
once you write jvm language you can't really be dying language. how can yoy die if you can use all jvm tech stack. Its just all about syntax. You can write powerful state of the art software even in brainfuck as long as it compiles to jvm bytecode
> powerful features Scala doesn't have, such as type-safe SQL.What? This site is getting worse by the day.
I'm not 100% sold. I like some of it's features (e.g. the mentioned typed SQL safety) but adding all of it seems super heavy-weight. Lombok took a good time to become widely accepted and I don't think this will ever appeal to more than just a niche audience.At the very least, I prefer not to have any surprises in my codebase because it looks like Java but isn't quite so really.
> I'm not 100% sold.The vast majority of people that use it aren't, but that's a feature :)Manifold isn't an all-or-nothing proposition. It's architecture is modularized so that you can select the parts you want à la carte as separate dependencies in your build.> At the very least, I prefer not to have any surprises in my codebaseBut manifold surprises are pleasant ones :)  As with any library or framework, it's a design decision: does it provide enough productivity and opportunities to offset its presence in your project? It's not a panacea.
> Manifold isn't an all-or-nothing proposition. It's architecture is modularized so that you can select the parts you want à la carte as separate dependencies in your build.Oh that's neat! Didn't sound like it when I was skimming over it. I'll keep it in head next time a pet project comes along :-)
Manifold isn't Java.
Linkable featureshttps://openjdk.org/projects/jdk/22/For me personally the most interesting one is JEP461 (Stream Gatherers)https://openjdk.org/jeps/461This will allow addition of interesting stream operations.
This is indeed nice. However, static extension methods would have made this feature simpler (and more generic).
And would also make code harder to read. I was always reluctant to use those in Scala because of this.
Although I like Kotlin better, I'm really impressed how Oracle continues to improve Java. Some developers think Java is an old, cumbersome language, but it is indeed such a productive language and ecosystem with outstanding quality! Java has quite good support for functional programming, concise and immutable structs (called "records"), pattern matching, string templating, virtual threads, structured concurrency (preview for now), a vast ecosystem with outstanding quality, world class documentation, a fast and robust runtime and so on.Even after nearly 30 years, Java is still a good choice to start something new (e.g. a startup).
It is very trendy to hate java. Which is actually a good thing, because it means I get to continue to enjoy working with java alongside sensible professional developers, who quitely get on with writing excellent code and creating industry leading systems with java. Less competition for the roles and I don't have to work with fanboy types.
Foreign Function Interface is one of the key advantages what C# had over Java (e.g. against huge APIs like Android or macOS). I am really curious how this JEP turns out.
Small correction: FFI in Android land is abysmal, to get decent performance when accessing all kinds of system APIs you almost always end up having to write helpers in Java, to try to alleviate the pain of JNI as much as possible (it is still significant).Interop with iOS OTOH is a breeze, some of the APIs may require newer Swift Library Evolution ABI (direct calls to Swift exprots, without going through C/objC) but .NET is getting it in .NET 9 (the first and only platform to have it at the moment of release).
Calling Android "Java" has always been a stretch. Not only has Android never been compatible with any version of Java, the divergence between Android and Java is only growing. JDK 22 is Java; Android is Android.
That is true, for all intents and purposes however the glue code to (insufficiently) reduce marshalling and FFI overhead is written in Java the language, even if it does not use OpenJDK.
Okay, but we're not talking about OpenJDK but about Java, a specification -- not an implementation like the OpenJDK JDK -- that Android has never conformed to and from which it is only growing further apart. I.e. the OpenJDK JDK is an implementation of Java; Android is not (there certainly may besomeJava code that happens to behave the same way on Android, but it is not, and has never been, the case for Java code generally). The relationship between Java and Android is similar to that between Linux and Unix -- lots of intended similarities, but there shouldn't be an expectation that a new Linux feature appears in, say, AIX or vice-versa.
At least they were forced to accept how much Android ecosystem depends on Java and now Java 17 LTS is the latest supported version, minus the stuff they never supported like Swing and Java 2D.
I started to tinker with this new API last week. I definitely think it's a lot better than needing to self compile a lot of the bindings yourself which will certainly bring more from the community into the feature than were here before.That said, you really need to write a bunch of boiler-plate to implement  useful things in java-like paradigms in the library today. Just as an example, I wrote up a sane windows _getcwd() stub and it's like 30 lines to implement  correctly (properly freeing the buffer when I'm down with it)My pet project is to see if I can write automatic stubs around calls based on published API info and sources, so that at least some of that platform binding lift isn't just for those with non-trivial  knowledge of C. Well, that's the hope anyways.
I've been quite keen on the new FFI too - apologies if this is old news, but have you tried the [0] jextract stuff for some of the boilerplate gubbins?[0]:https://github.com/openjdk/jextract
No! Thanks for the callout! That would certainly help on my path. My main goal was to insulate calls to avoid overly complicated reference counting when integrating large native surfaces into as Java program, but certainly an important aspect is getting the function signatures to target in the first place. I threw something bad together to work sort of like this (testing using proton), but I'm more than happy to bin it for something that just-works.
Have you looked at Microsoft's Win32 API metadata package [0]? They're using it to generate C# and Rust bindings, and other people have targeted other languages.[0]https://github.com/microsoft/win32metadata
The FFI is also an artifact of CLR type system and the ability of have proper stack value based types.
Not just value types, but also:1. Pointers to the same (and not just references to objects).2. Unions (via explicit-layout structs)3. Function pointers.4. C-style varargs.To be fair, not all of these have been exposed in C# historically even though CLR had them all along. Most notably, unmanaged function pointers took over 20 years. And since most people look at CLR through the prism of C#, they aren't necessarily aware of these features.Still, one way or the other, we're at the point where pretty much any C program can be transpiled to C# in a one-to-one mapping of almost every construct (setjmp/longjmp has to be emulated with exceptions), and a very similar performance profile of the resulting code.
Honorable but important mentions:5. Stackalloc (C alloca), fixed buffers in structs and inline arrays6. ref T and Span<T>, which act just like &mut T and &mut [T] in Rust (with the same syntax). They are used in both advanced and most basic APIs alike to provide zero-cost wrapping and/or slicing of arbitrary memory (managed heap, stack, NativeMemory.Alloc'd)e.g. You can receive byte* and length from FFI and construct a (ReadOnly)Span<byte> from them. That span then can be passed to almost every method that used to work with arrays only during .NET Framework days.
Indeed.
The CLR from its inception implemented a lot of features for helping native inter-op. I would guess that msft did make the effort simply because of their large legacy c/c++/win32 code base.It's a shame really that msft stewardship of the .net/clr was so lacking. Of all the modern virtual machine clr us pretty much up there
The goal wasn't so much native interop as being the universal VM for different languages. Specifically, they had an explicit requirement that pure CLR bytecode should be a valid compilation target for C++ (among other things - such as what would eventually become F#, hence why CLR also has explicit tailcalls, for example). But, of course, when you have all the necessary abstractions, that also allows for easy interop with the world outside the VM.It's too bad that this vision was never fully realized - in part, because .NET was not open enough originally, but also because of internal divisions in Microsoft itself. If it did, we could have had the equivalent of both LLVM and WebAssembly much, much earlier.
The internal divisions had more a play into this than anything else, Windows could have evolved into something like Android or Inferno, but that isn't something that those on Sinofsky's team would accept.Also why we got WinRT being like .NET, but with COM and C++, with .NET Native being a complete difference compiler toolchain, as he got hold of the Windows reigns.
Because it was yet another all-in, where all future Microsoft software was going to be .NET based, but WinDev/Office never played ball.We just have to go back in time and see all those Visual Studio.NET shows on surviving documents, or how Ext-VOS (what became .NET) was being done at MSR.We could have had something like Android, Inferno/Limbo in terms of .NET usage across the Windows layers, but it always bumps into the love for COM and C++, which incendently is how many Longhorn ideas were remade in Vista and continues to this day, using COM instead of .NET.
Sadly records are not value types, maybe Java will do this better, but I doubt it. Valhalla is probably years away.
They will eventually bring value types to Java with Project Valhalla.
I wonder how long it will take. We’ve been waiting for ten years already.
One design iteration already has a working, implemented branch available, it’s just one of the hardest designs to get right, to remain backwards compatible, to have it work nice with generics and all the other features, etc.So once they actually settle on a design (which they seem to have closed on quite a lot in the last couple of years), it might not take that long to happen.
Looks like we may see a first preview in Java 23, i.e. already this year.
Noting that Valhalla value types are about guaranteeing object value identity with memory layout and/or flattening  supposedly deriving from that.
Modeling unmanaged sequence of bytes within the type system (like receiving a typed buffer from un managed code) might still be challenging
For anyone reading, here's a link to the page with detail on this project:https://openjdk.org/jeps/454
It's definitely exciting and a big step forward from JNI/JNA.However, I am a little concerned about the heavy emphasis on library unloading in the JEP. Unloading is famously fraught and unsafe for wide swaths of common libraries ... or maybe I'm overfitting due to recent trauma[1] and everything will be fine.1.https://gist.github.com/thomcc/8c4a8003cf1a282949a539e899cb4...
It worked great for me. I had long wanted to rewrite a Python lib in Kotlin, since the Python part of the lib is slow, and it does not support multi-threading.But the ugliness of JNI stopped me. Then I tried FFI in Java 21, with jextract it was amazing.I wasn't aware of FFI at first, but the finalized version of virtual threads made me check the Java release notes.
It's kind of startling to see how many places still use Java 8, estimated at ~1/3 of projects according to a survey i just googled. And something like half that still use java 11.
8 reached EOL in the last year or two. I think 11 is still under LTS.Part of the problem is the changes made between 8 and 17 could be incredibly disruptive depending on your libraries.If they had stuck to not using sun.* stuff you were pretty safe, but a few very popular things did.Then somewhere in there a lot of the common server stuff moved from javax.* over to jakarta.*.Both were needed and very good, but could turn into dependency nightmares. So depending on your app/stack it wasn’t an easy transition.17 is fantastic though, especially coming from 8. I’m excited about what’s already in 21 (latest LTS) and coming in the next LTS after that.
> 8 reached EOL in the last year or twoJava 8 is still under Extended Support until 2030 (and indefinite sustaining support). Java 11 left Premier Support September 2023."Java SE 8 has gone through the End of Public Updates process for legacy releases.  Oracle will continue to provide free public updates and auto updates of Java SE 8 indefinitely for Personal, Development and other Users via java.com".https://www.oracle.com/java/technologies/java-se-support-roa...
Oh that’s right. My company didn’t want to pay the insane Oracle fees to keep getting support. I think it wasn’t even a discussion once the saw the number, but that’s basically a rumor.So we have to stick to OpenJDK which means 8 doesn’t receive security updates and is untenable.
Seems like willful incompetence on the company’s part.Just for note, JDK 8 came from the same time as WindowsXP. Sure, the attack surface is different, but if they have no plans on moving forward and doesn’t even want to pay for support, then frankly fck them. Then they just surprise pikachu when a bunch of their user data leaks.
That seems oddly hostile.We moved to the latest LTS. Continuing to use an old version with no security updates would be moronic. Of course we didn’t do that.All I was saying was sticking with 8 wasn’t tenable for financial reasons.
Err,what? Windows XP wasEOLeda month before JDK 8 was released.
Oracle JDK support is not the same as OpenJDK support (for both better and worse).
Wasn't the whole point of Java never releasing a 2.0 that there would never be breaking changes? Seems like something went very very wrong with Java if the state they are in is that the language refuses to make breaking changes and the developers refuse to take up the supposedly non breaking updates due to breaking changes based on the comments I'm seeing here. So the language never improves as much as it can and the developers never update anyway making the whole point of non-breaking changes moot.
Java 8 allows access to unsafe methods, which despite being meant for internal JDK use only, have been widely used in external projects. Newer Java versions do not permit the use of unsafe except for the JDK itself.It wasn't ever part of the public API that's promised to never break, and JDK developers were annoyed that it being used meant Java got perceived as unstable, and it's gone in more recent versions.
I thought the issue was not Unsafe methods (which are only just now starting to be marked for removal) but rather various bytecode weaving libraries like javassist. As the JDKs progressively enforce bytecode verification more strictly these libraries sometimes run afoul of the new restrictions. (I speak from a little experience here, managed a somewhat involved upgrade path from 7 to 8 way back in the day which had this issue.)
I haven’t ever seen this mentioned. The real culprit was libraries that go into jdk internals when they shouldn’t have so end user applications couldn’t upgrade until those libraries upgraded.
That's probably another factor, and these two aren't the only ones.
Huh, but I'm using Unsafe in JDK 21?
There are barely any breaking changes, I could still run a graphical application written by a prof in early 2000s, served on his website as a jar. No other language comes remotely as close to this level of stability.As for the changes in 8->9, there was a stagnation period in the last year of Sun, and many people overfitted their libs to 8, by e.g. making use of internal APIs made accessible through reflection. This was never a good idea, and all that is happening now is that you have to explicitly state at invocation what kinds of non-future-proof modules you make use of, so that you are made aware of what could potentially change, plus it disincentivizes libraries from accessing these non-public APIs.
I'm dragging my new company's codebases from 8 to 17 from soup to nuts. It's not always just about the language update, but all the old legacy crust that accumulated since java 8 that prevented anyone else to do it. My PRs are terrible and necessary.
Wait until you hear about COBOL still being used.Snark aside, the problem with Java in the enterprise is that Oracle provides support for mind-bogglingly ancient versions (if you're willing to pay them). This disincentivizes companies from upgrading, ends up frustrating their developers, and has probably contributed to the negative reputation that Java has in some corner of the net.I get that tracking the current version isn't feasible for most companies, especially if software isn't their core business. The Java folks do their best to make upgrades painless, but the longer you wait, the more painful it gets.
> Java keeps chasing mistakes like green threadsIf by green threads you mean virtual threads in JDK 21 could you please elaborate why they are a mistake? I'm not a Java developer but from what I see new concurrency model allows to write much more efficient network software - OS threads are expensive (in terms of RAM/CPU) and to handle many thousands of network connections (C10k problem) you have to either throw a lot of hardware or use NIO (New/Non-blocking I/O) which is hard to code.One of reasons why Go become popular - gorutines look like normal threads (relatively easy to code) but more efficient.
There were already "user-mode" implementations of asynchronicity on the JVM for years (like Monix, cats-effect, Pekko (fka Akka), etc).Loom has a worse API, is hidden from the user (what's preemptible and what will cause OS thread starvation? who knows!), and effectively ends up infecting the whole JVM with its complexity.Go shares most of those downsides, but as a greenfield project (..heh) there's at least the expectation that all libraries play nice with their scheduler. They also try to hide FFI starvation by effectively running each FFI call in a dedicated OS thread[0].There's also gevent/greenlet, which tries to bolt "colourless" M:N scheduling onto Python. It hasn't exactly taken the Python world by storm either, despite beingfarolder than their native asyncio support.Overall, I'd consider all three implementations of the approach to be dead on arrival.[0]: Seehttps://stackoverflow.com/a/28356944, it's a bit obfuscated but the overall effect is the same
User-mode implementations are very easy to get wrong (you might accidentally call a blocking operation where you shouldn’t), and have indecipherable stack traces. How is Loom’s API bad? It literally reuses basically everything you know about Threads, seamlessly.Also, Java has the luxury that almost no code makes use of FFI, so their impact is minimal.
Kilim was the first for Java iirc.Interesting point regarding scheduler and the interruptibility of FFI calls. Just thinking about it I don't see how thiscanbe addressed. So definitely interested in learning here: what is the remedy to your criticism here beyond "document behavior"?
> Kilim was the first for Java iirc.No, the JDK had builtin green-threads behind a command line flag around Java 1.1 on Solaris.
fibers, not threads (regardless of color). "loom" ..
> Go shares most of those downsidesDoes it? Preemptability is pretty robustly solved in Go. While it's sometimes less efficient than I'd like, it's a far cry from the initial draft of virtual threads in java where a misplaced "synchronized" could sneakily starve entire executors. Even with CGo pinning (which, as you indicate, is rare due to the bulk of pure-Go libraries) I'm having trouble thinking of reasonable situations where full starvation or deadlock occurs rather than (admittedly unpleasant!) latency and queueing.That said, Loom is quite new and deliberately iterative in approach, and the Java core folks are quite skilled, so I do expect to see substantial improvements in behavior and issue-detection tooling here over the coming years.> I'd consider all three implementations of the approach to be dead on arrivalI'd argue that eventlet/greenlet failed for different reasons than the concurrency model or starvation risk (the monkeypatching approach just can't sustainably work in an ecosystem as big and native-code-dependent as Python's), hence Python's falling back to traditional async/await cooperative concurrency.The Rust folks are struggling with the same choices here as well, further constrained by their requirements of a GC-less runtime with near-zero-overhead C FFI, which precludes them from using Go's approach. There was some great discussion of that here:https://news.ycombinator.com/item?id=39242962
If you consider Go to be "dead on arrival", I don't know what world you're living in.
And the rationale for it being dead is… ffi? Something that 99% of all apps don’t use.
you didn't like java generics? why?
Examples [1] of these features.[1]:https://www.happycoders.eu/java/java-22-features/
Now this may seem like a silly question, but if I only want to run Java apps on macOS, what should I install from MacPorts? Searching for "JRE" gives no results. Searching for OpenJDK gives various options including:- OpenJDK21:https://ports.macports.org/port/openjdk21/details/, 
- openjdk21-zulu:https://ports.macports.org/port/openjdk21-zulu/details/- openjdk21-oracle:https://ports.macports.org/port/openjdk21-oracle/details/each of them havingso many variants(see the links). What variant needs to be installed to just run a Java app?
Usually Java apps come with Java these days, like how there's no independent way to run Electron apps, it just comes with the download of the app itself. There are tools that make it easy like jpackage and (toots my own horn)https://www.hydraulic.devIf you want to just quickly run a fat jar then any will work. "openjdk21" is fine. The Zulu variant comes with JavaFX which simplifies things if your app needs that.
For sure, Java developers need to use a tool like yours to distribute their app. My experience with some Java applications was that running it triggered an attempt to download (I assume) the JRE, which I cancelled as I didn't know the source of download and didn't want it to download some PUA or malware. (I remember JRE for windows used to bundle some browser toolbar on windows). Hence my attemt to install it myself beforehand. But, since Oracle has stopped distributing latest JRE through Java.com for macOS, I looked for it in MacPorts. And it is really confusing - for example, if you look at the OpenJDK-Zulu port that you recommended -https://ports.macports.org/port/openjdk21-zulu/details/- it has 4 variants:1. Applets ( Advertise the JVM capability "Applets".)2.BundledApp ( Advertise the JVM capability "BundledApp". This is required by some java-based app bundles to recognize and use the JVM.)3. JNI ( Advertise the JVM capability "JNI". This is required by some java-based app bundles to recognize and use the JVM.)4. WebStart ( Advertise the JVM capability "WebStart".)- what the heck? I think I am better off without Java. :)
That's a MacPorts thing, I've not seen that before and the Zulu download doesn't seem to have that. And zulu goes in for variants more than most distributors do.
My personal go-to for mac is the Liberica JDK from Bellsoft.
Sweet, G1 keeps getting better for free. Time to cut a new build tag for this.
Interesting to see the developments on the String Templates API using the STR and fmt template processors.
It gets interesting:https://mail.openjdk.org/pipermail/amber-spec-experts/2024-M...
> concrete syntax TBB (to be bikeshod)TIL the past participle of 'bikeshed' is 'bikeshod'.  Tremendous.
I'm really happy they are reconsidering the syntax. Thanks for the link
It sound like they're only reconsidering the prefix, not the backslashes, or am I misreading it?So we're not getting"hello $name"but rather thanSTR."hello \{name}"they're now considering$"hello \{name}".
I like the backslashes. It’s one character to do escaping
“Vector API (Seventh Incubator)”Seven iterations?  What is going on with vectors in Java?
"Vector API" is universal api for SIMD. It will probably remain in incubator until valhalla delivers value types.
Is there a timeline on Valhalla? I only loosely follow the Java ecosystem these days, but Valhalla is of particular interest to my performance-oriented mind.
I follow up on valhalla every now and then. It looks few more releases away, probably not before next LTS.That being said, the amount of rigor with which the JDK devs test their experiments is really something to witness. Its equivalent to old school MS with painstaking maintenance at backwards compatibility, all the while moving the wheel of progress.Every single change so far has been planned with a decade of advanced planning because that's just how this ecosystem roles.
My understanding is it depends on Valhalla (value classes) and they basically keep updating it as that project changes.
The Foreign Memory API is in the works since 2014. They are just very diligent and careful.
Yeah, given the amount of legacy infra built on Java. They don't have the luxury to move fast and break things.
They said it is waiting for some feature from project Valhalla. Not sure which one though
There are ad-hoc hacks in the JDK to avoid allocation for vectors; once we get some Valhalla features, vectors could be represented as plain value objects.
If you're interested, there already is a somewhat similar language that offers first-class support for these.
It will go on until 'value classes' are incorporated in Java
Unrelated to Java, but it’s so refreshing to see a simple HTML page for once
To me the question "Why would I use X over Y?" in programming space is a bit redundant. Why would I use Kotlin over Closure? Why would I use Groovy over Scala?Even only considering JVM languages you run in to way too many options for the question in itself to be worth your time as a serious discussion.IMO - use whatever you and your team like best and that suits your needs. Java is great for hiring new devs and is arguably the most well established in an enterprise settings.If you want an actual answer: Personal preference.
Kotlin is a guest language, doesn't have nothing to call their own as platform.
Android?
Android OS layer has zero Kotlin, and Google had to backtrack on their decision to let Java languish, as the Android ecosystem started to lose out on Java ecosystem, thus ART is now updatable via Play Store since Android 12, and Java 17 LTS is the latest supported version.Kotlin is only used on Jetpack Compose and a couple of AndroidX libraries, that you have to ship alongside the application. And as alternative to Groovy on Gradle build scripts.I expect this year's GDC to announce Java 21 LTS support.
Interesting, I don't develop for Android so I don't know the details in this space. Surprising to learn that the Android OS layer is 100% Java. In terms of a platform, I was more referring to the mass adoption of Kotlin for Android app development. 95% of the top 1,000 Android apps are written in Kotlin and adoption overall is > 50% according to their overview pagehttps://kotlinlang.org/docs/android-overview.htmlIMO those numbers create a lot of staying power for the language.
> Android OS layer is 100% JavaMore like 70%, the remaining 30% are split between Linux kernel (C), Treble drivers written in C++ (Java is also supported), SQLlite (C), and naturally Skia, ART are written in C++. With a couple of newer drivers like the Bluetooth stack, adopting Rust.However zero Kotlin.Naturally Kotlin has such an adoption on userspace, Jetpack Compose the new UI framework is written in Kotlin, so already adopting that jumps up the adotption numbers.It is like measuring Swift adoption by the use of SwiftUI, even if the business logic is still written in Objective-C.I do agree that Google being Kotlin's godfather, pushing it for new projects, does create a lot of staying power.However it is also the reason why on JVM, it is only yet another guest language, as there is no one telling Java developers they should not write Java to use framework XYZ.All those that tried, Grails, Spark, Akka,... eventually lose adoption speed, and got replaced by Java alternatives.Which Google had to accept, Kotlin's value without the breath of Java written libraries isn't that great any longer, and they aren't going to rewrite the whole Maven Central into Kotlin, as the Java community moves beyond Java 8.
You still need the JVM to run Kotlin. Also performance.
Some of the time. On Android and with Kotlin Native you don't. (IIRC there may also be a browser target?)
The downvotes are unfortunate. To clarify I wasn't trying to start a flame war.I was hoping someone would answer with concrete technical tradeoffs and comparisons e.g. compile times, null safety, common footguns, personal experiences, etc.I was recently asked for a comparison between Kotlin and modern Java by a team that's considering a migration of their legacy Java service. I haven't kept up with Java's changes, so didn't have an offhand unbiased comparison to share.I've worked on backend Kotlin and Java codebases for the last five years and have introduced Kotlin to dozens of teams across my company. Nobody I've introduced Kotlin to has ever ended up preferring Java or switching back to it. There's been initial skepticism at first (reasonable), but after working in Kotlin for a week or two, I've seen even the staunchest Java devs proclaim they're never going back.To the point on personal preference, I think it's a factor but I don't think it's _the answer_. It's a blanket statement that ignores important details. Languages have different affordances, features, paradigms, and patterns that lead you to develop and think in different ways. Some differences like null safe types are obvious improvements for a large codebase with many contributors. The feature catches real bugs and makes the system easier to build and maintain.I think there's a lot of warranted skepticism of JVM languages that aren't Java, but something about Kotlin feels very different. For comparison, I've worked with Scala (Spark) and played around with Clojure in my free time.I'm not sure what feels so much better compared to other JVM languages, but if I had to guess I'd say it's an emergent quality from a few things JetBrains has done really well. In particular:- The 100% Java interop claim is real. I've only had minor hiccups with Lombok
- The ability to incrementally adopt Kotlin in an existing Java codebase
- The IDE support in IntelliJ IDEA is unbelievable. The suggested refactorings subtly teach you the language
- Null safety lets you focus on domain modeling and business logic instead of error handling and validation
- Kotlin's backwards compatibility. New versions never seem to break anything. And they even provide refactoring actions in IntelliJ to automatically update deprecated usages
- Very few significant paradigm shifts. Kotlin doesn't force you to totally change your Java code to fit a functional style or anything like that. It just tries to make safer code easier to write
- The political stability and longevity gained from Android's blessing as a first-class language makes Kotlin feel like more than just another JVM language. There's Kotlin running on billions of devices. That's a pretty big ship to turn around, sink, or replaceTo summarize, Kotlin just feels like the elephant in the room. Aside from low-level changes like new FFI possibilities and GC improvements, it's not clear to me what value Java upgrades add in comparison to Kotlin—especially in regards to new language features and syntax.Anyways, hopefully this followup post starts a more fruitful discussion. I asked this question in earnest based on my personal experiences and observations. If you haven't tried Kotlin yet, I'd suggest cracking open an IntelliJ scratch file and test driving it yourself.
I doubt Oracle would fix it, as this is definitely a kernel bug that breaks userspace. It is part of the POSIX spec what the JVM relies on, and MacOS is supposedly POSIX-compliant. So it should be Apple that fixed their bug.
I'm not sure whether Java is in decline, but it's a clunky language that I wasn't sorry to leave behind after moving on from my previous job.  The only people I've met first-hand who love Java have been using it for years & program primarily in Java.Sure, JDK 21 adds support for some much-needed quality of life features: sequenced collections, records, switch pattern matching, code snippets.  But all of these features have been supported for YEARS in other languages that I've enjoyed: C#, Kotlin, Python.  Java doesn't have anything as slick as LINQ (C#) or list interpretations (Python) for succinct map-reducing objects; Stream API is what you're forced to use, and it's clunky by comparison.
Yes, I see no new interesting projects for years started in Java. I've been working with Java for a long time. At first it outperformed C++ in ease of development. Large enterprises created software of humongous complexity with that but Docker emerged and Java fell out of favour as it's startup slow and it couldn't never fullfill low-latency needs with its GC magic. And eventually, it fell in a trap of any long-living tech - it became complex, with snobbish communities, no easy way to adapt to new realities, though it tries but it fails: failed to integrate itself with browsers, failed with computing graphics, failed with scientific libraries, low-latency servers and now it starts to lose ground in general computing. The only argument in its defense is that it's widespread - well, yes, but it's a miserable argument for a prefessional.
I develop almost exlusively in Java and as a language it still works extremely well for our use case, and is only improving.We write financial trading systems which require lowish latency (but not truly low latency) with rock solid stability, monitoring, tooling, etc.We actually write idiotmatic Java in the sense we don't actually use object pooling etc. We have five 9s latency at below 500 micros. Which people in the industy will know is very much not low latency HFT style, but is enough for our competitive edge. And as I said, we can achieve this while still relying on idiomatic Java, which means we spend most of our time writing feature code rather than fighting the language. And by idiomatic Java I mean the right style for the right part of the code. We mostly write data oriented code, which low touch records/pojos and business logic outside of objects, but there are cases where we're more traditional OO style.I have ex-colleagues who have moved elsewhere who use non-idiomatic java to achieve < 5 micros fastpath. That was several years ago, they may have improved that into the nanos now.The online programming sub-culture loves to hate Java, because humans love being part of a fashionable in-group, and it is extremely fashionable to hate Java. Luckily, very smart people don't care about that nonsense and I get to work with a lot of those people.Summary: I don't know if the stats show Java is in decline, but I doubt it. I still get many high salary job pitches from headhunters monthly.
In my view, Java is still the best choice for building any relatively complex web/sass application. For some reason people negatively associate it with "enterprise" software. Enterprise software tends to be very complicated and Java was likely chosen because it is/was the best option at the time. And I'm sure people had bad experiences that they blamed the language for because the problem they were trying to solve was very complex and the leads/architects made poor decisions.I'm using Java with Quarkus for an enterprise app for the past 2 years as the project lead and I couldn't be any happier with my decision. We're upgrading to Java 21 in a week or two. The code we're producing is some of the most boring/straightforward code I've seen in a long time. Nearly all of our time is spent solving the business problem and the language never gets in the way. The dev experience is outstanding. With Quarkus we get nearly instant hot reloading. IntelliJ provides industry leading IDE. Oracle keeps releasing major enhancements to usability. Excellent ecosystem, testing frameworks, etc. It's hard to find any faults really. Yeah NULL is allowed in the language, but I cannot remember the last time we had a NPE.
The rapid change in Python is an indication that programming is different, rather than Java per se. Python, Java, and C all serve radically different programming niche.The increase in Python tells you that its niche is increasing. It is, among other things, the language of data science and machine learning, which has a huge upswing lately. But that doesn't affect the absolute number of Java or C projects or jobs. It just tells you that a new thing is appearing.If there is a chance in Java's utility, you see it more in C++ and C#, which occupy more similar niches. It's notable that C# is picking up; that's a trend that might be worth noting. And it's a bit puzzling that Java should fall below C++, and I suspect it has more to do with the vagaries of the metric.But Java is for general-purpose programming, and that niche doesn't seem to be going away any time soon. If you want to get into data science, then by all means go learn Python. But that's less about picking up a new tool set as a change in careers.
For anyone else who is curious, here are the Tiobe Language Index rankings for October 2023 (https://www.tiobe.com/tiobe-index/):#01 Python
#02 C
#03 C++
#04 Java
#05 C#
#06 JavaScript
#07 Visual Basic
#08 PHP
#09 SQL
#10 Assembly LanguageIMO the fact that Visual Basic is in the Tiobe Top 10 at all is kinda sus, so it's probably worth also taking a look at the Stack Overflow 2023 Developer Survey results (https://survey.stackoverflow.co/2023/#professional-developer...):#01 JavaScript
#02 HTML/CSS
#03 Python
#04 SQL
#05 TypeScript
#06 Bash/Shell (all shells)
#07 Java
#08 C#
#09 C++
#10 C
Oracle stuff didn't help.  It's initial appeal was that it ran everywhere.  Now all languages do.  So people who just want to code something quickly w/o worries for security, etc. use Js/Node for web stuff and Python for pretty much everything else.  For people really concerned about speed and security C/C++ is the 'real' programmer's tool of choice.  Java code gets very ugly, very quickly and code reuse, one of the big promises, just never took off.  So Java is kind of purposeless.  Pick a task and there is something better and easier to use than Java.
I gotta disagree with thesuperbigfrog in some aspects. In the corporate world, Java is still very much alive. Not just on legacy software, but there is a lot of new software being developed in Java. Specially with the advent of the cloud native frameworks like Quarkus and Micronaut.Indeed it's not fancy as "new" techs like Go or Rust and I agree it's ckuncky and verbose, but there are plenty new features and applications for modern Java.
>> Is Java in decline?Yes.Take a look at the graph:https://www.tiobe.com/tiobe-index/java/Java's original strengths were:1) "write once, run anywhere": a huge improvement over the platform-dependent C / C++ that was widely used at the time,2) easier to learn and safe replacement over C++ for many problem domains:  finding / growing good C++ talent has always been a challenge3) large, powerful standard library and massive third-party ecosystem:  it made development rapid and much more like building with Legos than rolling your own libraries like many C / C++ shops didJava's killer use case became backend and middle-tier enterprise software.Today Java's strengths are less relevant:1) You can "write once, run anywhere" with containers, Go (easier deployments over Java, lower resource usage compared to Java, easier to learn than Java), or Rust (easier deployments over Java, far lower resource usage compared to Java, harder to learn than Java, more performant than Java).2)  Java never fully displaced C++ for high-performance domains.  Go and Rust are solid competitors to both Java and C++ depending on the problem domain.3)  Go and Rust both have wide adoption and third-party ecosystems that compete against Java's ecosystem.I say this as someone who wrote Java enterprise software for many years.  I don't hate Java.  It has been very useful and paid my bills for years.Java is not going away.  There is FAR too much software written in Java and enterprises will keep on maintaining legacy software until they choose not to.  Java 8 will probably go on for decades as long as someone keeps patching it and selling support.  Java will slowly become another COBOL.>> Was it caused by all that Oracle bullshit in recent years?Partially.Breaking changes in how the JDK / JRE worked between Java 8 and Java 9 were a contributing factor.Oracle's licensing changes caused many enterprises to flee to alternative OpenJDK distributions, effectively causing some mindset fragmentation and encouraged enterprises and developers to look at alternatives.
There are alternatives such as Rust for some of the error-elimination cases that Java was covering.I'm still using Java and improvements in it continue, and like COBOL it won't die completely, but there is a good argument for looking elsewhere for new projects especially long-lived infrastructure.
NoItIsNotInDeclineDueToItBeingAbleToBeWrittenOnceAndBeingAbleToRunEverywhere
Decline? IT runs on java 8 with trillions of code
The biggest feature in Java 21 is the release of Virtual Threads:https://openjdk.org/jeps/444For some reason, this is missing from the article. If there was any feature that would sway existing Golang developers to switch to Java, it would be this. It would perhaps also convince the haters of the reactive-style concurrency patterns.
I don't think any existing Go developer is going back to Java.I worked with Java for 10 years and switched to Go and I will never go back.This is mostly because applications and libraries are so hard to reason about and understand due to inheritance, packaging, OOP, build tools ect compared to Go.Go is simple. It's easy to understand, read, and maintain. The packaging is like how you would package files on your computer in single folders. The tooling is built into the language. You don't need a IDE like IntelliJ just to make it feel reasonable to work with.Maybe all of this has changed, but most of the libraries I see in Java today still look like this.
> This is mostly because applications and libraries are so hard to reason about and understand due to inheritance, packaging, OOP, build tools ect compared to Go.You are just at the early phase of the project.> Go is simple. It's easy to understand, read, and maintainMy opinion is that Go istoosimple, to the point that it hinders understanding and readability. 4 nested loops with random mutability is much worse than a clear Stream api "pipeline". The 31st if err check will not be actually handling the underlying problem, while you can't forget about Exceptions -- even if they do bubble up to the main app, you will clearly get an actionable stacktrace.> The tooling is built into the languageThis has benefits, I will give you that. At the same time, I think all these new build tools are anemic and can't be used for anything more complex than interacting with the same language's standard dependencies. Gradle is not sexy, but is actually capable of doing any kind of build.
Im convinced Go is just an incomplete language masquerading as a simple one.
Go is a complete and simple language, and this is a fairly objective claim.Unless by "incomplete" you mean itcouldhave more features. But C++ and Rust (and Java) have been piling on features for years, with no signs that they will ever slow down or stop, proving that they're also "incomplete" by this definition. IMO this is really just a result of there being too many cooks in the kitchen, and a lack of leadership committed to saying "no" to feature requests.This is also why using Rust or C++ requires every organization to agree on a subset of the language they will utilize. Rust isn't as far along this path, but it's heading in the same direction as C++.But with Go, every organization can use the complete language. That's how simple it is.Go has been used by many organizations to build stable, large, and scalable systems that have been operating successfully in production for many years now. That's how complete it is.
I wonder if replacing the type system in Go with the one in Rust and adding native Actor model support would be doable. Or if GC and compile time would regress too much. Modern languages without good sum types just seems like such a lost opportunity to me.
What would be the point? Why stick with Go if you want so deep-reaching changes?
That what I often wonder, if one is going to start using a new language why go? Rust at least it gave one memory safety and not having to use GC make it more stable usage of resource as the discord article have already pointed out. Seem like go is just google's .NET, every big corp need to have their own language.
>>You are just at the early phase of the project.Nah.99% of the code written out there doesn't need layers of indirection, responsibility tossing around, Code splitting across classes, design patterns, inheritance and the class jungle that is common in Java.Rise of languages like Go is simply majority of the people realising when they want X, they are better of writing just X. You don't have to write a generic version of X that needs to work in a dozen situations. This is for a simple reason. Most of the times, there are no dozen situations. Most, not all the times.Most of the code I write, doesn't change all that much. If you are writing code that needs to run for decades in an industry where grifting and job hunting is a daily affair you are doing it wrong.
> Most of the times, there are no dozen situations.After 20 years of building all sorts of software, I know that this a fact, but the challenge is to make others aware of it.
> You are just at the early phase of the project.Lately, I am seeing very few codebases getting supported more than 3 years in companies offering software products. Every 2-4 years services are getting rewritten, what's the point of having tool intended for 15 years, when services are deprecated in 4 years
It would be good for my job if learned go, but I've been having a hard time because it's just so boring.
You're doing it wrong if you think programming for work is about the code being a means of expressing your inner soul. The most successful professional programmers derive their enjoyment from achieving business objectives, like making products that users love and improve the world.If you want to express your soul in your code, do that on the weekend using whatever language you want. Trying to mix these motivations is a recipe for disaster.
> The most successful professional programmers derive their enjoyment from achieving business objectives, like making products that users love and improve the world.Successful by what metric? Achieving business objectives? I don't necessarily disagree with the point, but this seems like a truism.
Or a tautology. No true professional programmer would derive more enjoyment from beauty than from making his boss happy.
I have too much skepticism of "businesses objectives" to be especially interested in success. I want something that'll bend my mind.
Honestly, just find yourself a project and just Go for it (sorry for the pun).The syntax is easy enough you can start coding just after having looked at basic examples.Personally I actually like Go because it's so boring.I tend to see languages more like tools rather than valuable knowledge I must learn, so a simple yet powerful enough language is a perfect fit for me.
I did. Did Go professionally for ~5 years and went to JVM.Go is easy, but it's surface level easy. Building and maintaining large applications in Go if you don't have a huge team is a giant pain.JVM (especially paired with Kotlin) for me atleast has meant regaining the expressivity I was missing from Ruby and Python when I moved to Go whilst retaining (well actually usually beating) it on performance and scalability.I lost absolutely nothing to go to JVM but gained so many things.
I’ve got to disagree with this strongly. I built and operated the same large system in both languages (acquisition forced me to rewrite) and both the dev and operating cost of the JVM was much higher.Go is a high velocity language. Code reviews on language/style issues are non existent, it’s GC is blazing fast (not our experience with JVM) and it’s really easy to read. I’ve watched many new engineers ramp up on both systems, as both operated side by side for a while, Go was inevitably faster for engineers.What made maintaining Go hard for you?
The main pain-points in a large org at least:Lack of a "default" stack for nearly anything. The stdlib is great but the ecosystem isn't. Which web framework? Does it come with a logger? If not which logger? Do the third party libraries I want to use work with my logger/have a mechanism to provide one via an interface or am I shit out of luck? This goes for so many more things though, cache libraries, data structures (because Go stdlib collections are a joke). Contrast to Java here you have a relatively minimal set of very long-lived deps for all of these "basic" things. Ecosystems like Spring, the slf4 facade, Apache etc provide the foundation that most Java programs sit on and that has no alternative in Go land.Go module transition was also hot garbage. It's better after sure but going through it was worse than Java 8-9 or to Java 11+ both of which were "difficult" transitions for Java but vastly less disruptive for me personally at least.
Then take all of this stuff and multiply it by the number of teams you have if you don't have a central team doing library choices and laying down architecture guidelines - which we eventually got but not before all the Go codebases had turned into by and large unmaintainable messes.IMO Go is high velocity only in the simplest sense, it's very easy to pump out shit tons of code. With a big team of mediocre developers this is even more true. The problems all come later. Big change in requirements? Good luck with that.
Had a team try to go crazy functional with Go and now they have immutable data everywhere and allocations are completely destroying the throughput of the Go GC? Good luck fixing that. etc.The velocity eventually moves from it's strength to it's achilles heel once the codebases are big and bad they are really hard to fix.I get that most of these problems are "big company" problems and maybe in smaller teams with a stronger hiring bar you won't run into these or maybe not at the same severity but they severely impacted my view of how well the language scales to large teams and codebases.
Teasing this apart I see a few things: a) logging, b) modules rollout and c) missing frameworks.I’ve never had a logging issue in large systems. Explicit error return (as you know,  on every function) allows you to log in your code, not lean on only libraries that support your interface.Modules rollout was part of growing up. But, you won’t get Go 1->2 upgrade issues as we have 100% backward compatibility on version upgrades. Moving to the latest version of Go is trivial and simply unlocks new features.Too many allocations for Go is going to be too many allocations for JVM too. This seems like an  problem isolated to that team.I’ve done Go at both a three engineer startup and at Google and I can’t help but notice none of these are really the type of problem that crop up later.
Good to hear logging has gotten better.Though I still don't see a standard web stack. "stdlib is enough" is only true for people that don't need their hand held and/or can organise good standards across teams.If it was just me or people I know are good writing the software that works. At Google it probably works because of aforementioned hiring bar. At the average large-ish company? Not something I like leaving to chance because I have usually ended up disappointed.
> Too many allocations for Go is going to be too many allocations for JVM tooNo, Go’s GC is a toy compared to the JVM’s. It is lowerish in latency by actually stopping the application threads when under high contention.Java doesn’t slow down the allocation rate, it tries to keep up with the churn.
Even it's latency is outclassed by ZGC and Shanandoah.The GC monoculture is great from a simplicity and out of the box experience but there is a very good reason to a) want multiple different GCs tuned for different workload types and b) have competition so that the best designs can be found rather than having to fight to be the only implementation.
Huh, Go also does not allocate ten times more more memory like Java. So even if Go's GC is 1/10th performant as Java (and it isn't) it will be equally better Go applications.Java's GCimprovementis relentless because Java's applications are relentless in memory allocation.Being on endless Java memory/perf issue prod calls I can say Java GC improvement, performance tuning is cottage industry in itself. Meanwhile end users keep suffering but at least Java devs get to tune GC to their heart's content.
I’d love to see you elaborate on this. Anecdotally, my experience was the exact opposite. Is there some documentation making this point?In the course of optimizing I came to know the various JVM GC algos (concurrent mark/sweep, parallel old, etc) by the corresponding memory graph alone. I never, ever had to debug similar latency in the Go stack.
>> (concurrent mark/sweep, parallel old, etc)Both of those are only picked for low sized heaps with few cores, probably within a container. Were these micro services?G1 is the default for larger heaps and multiple cores, and ZGC and Shenandoah (low latency GCs) have to be manually turned on AFAIK.OP said:>Java doesn’t slow down the allocation rate, it tries to keep up with the churn.This is incorrect. ZGC will block a thread when it cannot give a thread any memory, because it can't collect and free memory at the pace needed. Google "allocation stall" for this. ZGC can achieve very low latencies akin to Go's GC, I don't know if the throughput is higher or not. Multiple cores and some GiB of heap space is when ZGC will shine.
No web framework, the standard library is enough. log/slog is in the standard library now, and is compatible with zap, which seems to work with everything.>IMO Go is high velocity only in the simplest sense, it's very easy to pump out shit tons of code. With a big team of mediocre developers this is even more true. The problems all come later. Big change in requirements? Good luck with that. Had a team try to go crazy functional with Go and now they have immutable data everywhere and allocations are completely destroying the throughput of the Go GC? Good luck fixing that. etc.I doublt things would go better for teams trying to go full OO in haskell, or full functional in Java.
The stdlib really isn't enough unless you want num_teams x session handling implementations etc.> I doublt things would go better for teams trying to go full OO in haskell, or full functional in Java.That is the beauty of Java, no one does this.They don't feel like they need, should or will get approval to.Go is pretty much the wild west because "the std lib is enough" attitude permeates everything. Build your own datastructures, build your own anything really.I can understand why many people find that attractive and hate Java as a result, sometimes Java feels more like Lego and less like programming but it does create predictable reliably constructed software that is generally easy to clean up even if it's done a bit poorly.Which is something I value because I often end up in the code janitor role and/or being air-dropped in to get a project back on schedule or drastically cut down the defects etc.
> JVM (especially paired with Kotlin)I agree the Go lang compiler/runtime needs "a Kotlin", with more null-safey build in, proper sum types, a std lib that makes heavy use of null-safety and sum types, better story for polymorphism, better ergonomics for writing stream pipelines, and additional compilation targets (like JS, WASM). This all while proving stellar interop with all Go code, obviously.Kotlin is quite a sweet deal.
Curious to understand what you are suggesting here. What’s a better story for polymorphism than duck typing? What would (better?) null-safety look like in Go?
I'm saying that we need an XYZ to Go what Kotlin is to Java. The I name some ways that Kotlin improved upon Java that Go would also benefit from.> What’s a better story for polymorphism than duck typing?Something that give compiletime guarantees and has not runtime overhead.> What would (better?) null-safety look like in Go?https://kotlinlang.org/docs/java-to-kotlin-nullability-guide...
Going on 12 years with Go and agree with everything.
Go's major selling point to me is that you can ship one binary, nothing beats that.Python, Node, Java all have to pre-install lots of dependencies before you can use them, fine for developers, not so great if you want to distribute software for people who are not software savvy, who typically just wants to download one file, install and start using it.c and c++ can also do one executable, but, it is not as portable as Golang, and not as static-link friendly as Golang.
>  Go's major selling point to me is that you can ship one binary, nothing beats that.You can ship one compiled binary in Java too if you want it.https://www.graalvm.org/22.0/reference-manual/native-image/> Go is simple. It's easy to understand, read, and maintainGo involves alotof code repetition which makes it difficult to human-scan and maintain. Worked on both large scale Go and Java projects and I found Java projects easier and more comfortable to maintain. Had to pay a lot more attention to Go. Go iseasierto write though thanks to its well-designed and extensive standard library which is possibly the best in the world, but the maintenance angle still tilts to Java. There are also more Gotchas in Go compared to Java.
I’m neither a Golang nor a Java developer per se, but I touch source from both as an SRE. I find it weird to see so many comments saying Go is verbose and Java is not. I found the opposite to be true. To do every little thing, the Java code has a ton of abstraction, and the actual implementation of anything is so far removed from the place where it is used that it gives me such a headache to touch anything without wondering “whatever else would break if I change this behavior?!”However, the Go code bases I’ve encountered have been less abstract and to the point(even if it means repetition of some little things). I also found it to be free of boilerplate except for the if err != nil part.I guess those that have spent decades in such abstractions must have learnt a skill to navigate such a spaghetti. But, I still hate it every time.
Quite a bit depends on how the codebase has been written and what era are you looking. Before Java 8/9 or after it. Java code written in the recent era is pretty lean and mean.No matter the amount of abstraction though, one rarely runs into the sort of issues in Java that Go code tend to run into frequently - causing multi-million dollar mistakes frequently even for experienced Go programmers. For loop semanticshttps://bugzilla.mozilla.org/show_bug.cgi?id=1619047, Unintended variable shadowing, common mistakes in slice appends/copies, slices and memory leaks, defers inside loops, nil interface vs nil, panics in go-routines. There are loads of bugs in OSS projects wrt to these usually repeated again and again.Go is very simple to learn andveryhard to master writing bug-free code. Looking forward to seeing how languages like Rust perform if/when adopted by enterprise.
> You can ship one compiled binary in JavaEven if you’re shipping a jar. You can ship one artifact by using jlink or you ship the runtime in the docker image.This has been a solved issue for ages.
> not so great if you want to distribute software for people who are not software savvy, who typically just wants to download one file, install and start using it.i think it's a flaw that wasn't considered properly in the standard java toolchain to not produce an embedded java runtime into a final packaged artifact that is self-executable.You end up with third party tooling like:https://www.ej-technologies.com/resources/install4j/help/doc...(andhttps://launch4j.sourceforge.net/too).If oracle bundled this tool into the JDK, it would've not been an issue at all.
It has existed for 20 years, and already started with Sun.Having AOT compilers as commercial offerings, was seen as one way to capture value in the Java market, in a culture where most compilers were still commercial, GCC being the exception.
>It has existed for 20 years, and already started with Sun.In an anemic way, with mostly third party offerings few people know or care about, and various degrees of pain and shortcoming to their use. It should be a first class feature, and as simple to use as is in Go (including for cross compiling).In general, if something exists in "some form" for 30+ years in a language, and only a handful of people use it, whereas in another it's used all the time and people from other languages are jealous of how well it works, then the formers "some form" is not a good one.
Regardless, it exists.
There is jpackage and jlink, which don't do single files but make single directory apps.These days there's also GraalVM native image which does produce Go-like results. But with everyone using Docker on the server anyway it doesn't matter anymore. People who talk about single binaries are confusing to me. What are you doing where shipping one file is so much simpler than shipping a container?
> What are you doing where shipping one file is so much simpler than shipping a container?Desktop applications.Java would be a more popular desktop application platform if it weren't for the difficulty in this area (which, to be fair, isn't the only difficulty - cross platform is difficult inherently).
it's pretty hard for average Joe to install a docker engine before he can pull and run dockers, plus docker is not that great for cross platform desktop GUIs.
> everyone using DockerNot really.
That wasn't a flaw. It was a "feature". Can yo you think of a way to increase market awareness of Java other than putting an icon on every computer in the world saying "Your Java needs to be updated" every two weeks?
jpackage and jlink are shipped in the jdk.
Fully compiled languages have another huge advantage.
If you write a tool in Python and targeted say Python 3.10 then people using Phython 3.9 might not be able to use it. So, you really can't use latest and greatest features of Python 3.11 or 3.12.
However, with Go, you can build your tool in Go 1.21 or whatever, and the user does not even need a Go toolchain on their machine.I was planning to write a small side-project to generate GitHub Actions boilerplate. And this time, I intentionally chose Go for that exact reason.https://github.com/ashishb/gabo
Unless dynamic linking is used, or OS APIs change between version, or specific OS files change location.
Go binaries are traditionally statically compiled.
Hence my 2nd and 3rd points.Also DNS uses dynamic linking unless configured otherwise, while being OS specific, then that are the libraries that rely on cgo.
Yeah, you can list 100 such cases.Let me tell you the most common scenario.
I have a fairly popular FOSS CLI tool written in Python.
I cannot use the features from the latest version of Python or else I will alienate ~50% of the userbase.
This problem does not exist with Rust or Go.This problem would have existed for Java on Android except Google took the burden of "desugaring" the Java 17 code -> Java 8 compatible bytecode for the old devices.
Google dug their own grave here, Java is as backwardsand forwardcompatible as it gets.
You cannot run Java 17 code on a Java 8 runtime without "desugaring."
I never see Dart talked about in these contexts but just to highlight a few things.1. Compiles to native code with a single and very reasonable sized binary on pretty much any platform.2. Compile to WASM (coming this year) if that’s your thing.3. Excellent concurrency support with lightweight and simple mental models4. Variables are not nullable by default thus simplifying tedious checking in your codebase.5. Syntactically it’s the best parts of Java and JavaScript combined without all the foot guns and verbosity.6. Full support for both OOP and functional code styles7. Existing interop support with C, C++, Rust, Java and JavaScript and in the future WASI.8. Fully static / compile time metaprogramming capabilities coming this year.9. Also have maybe one of the best teams working on it that I’ve ever seen in an open source project anywhere. They put in a stupid amount of detail and care to try and keep everything pointing in the right direction at a macro level and have really strong levels of transparency around how the language is developedhttps://github.com/dart-lang/languageHonestly I think it’s critically under-rated and under-used. Most of its common criticisms I see about it are many years out of date.
Combining the best parts of Java and JavaScript isn't exactly something to boast about. Dart lives and dies with the Flutter framework. Other than that it's not doing anything special. Not terrible but also not a significant improvement.
I mean you’ve taken my point, cut it in half to remove the relevant context and are now arguing against a point you’ve made up as some kind of gotcha… I don’t know what you want me to say to that.Same with your second point. I made a big point to explicitly say I think that right now Dart is very underused and has a huge potential outside of Flutter. Quoting that back to me as though it was something I hadn’t considered is equally as confusing.
I'm with you, I think that Dart is very sensible and very underappreciated language. But he does have a point in saying that currently Dart is tied to Flutter. Google is presenting Dart as a language that you write Flutter with, not as a separate entity. I'd much prefer if Google would present Flutter as a GUI framework for Dart, but alas. Perception is everything. As much as I'd love to start my next project in Dart I probably won't because I can't be sure that Dart won't end up in Google's graveyard in next couple of years whereas I'm pretty sure that Go won't.
I support that. I tried Flutter a few years ago, and I liked Dart and the Flutter way of defining the UI (compared to the old xml stuff in Android).Then I moved to Kotlin + Jetpack Compose, and I don't see the point of Dart anymore.
You say Dart is underused, but why build something new with Dart when you could do the same thing with a better language? The only reason to use it is Flutter.
Familiarity comes to mind.
Dart has developed into a nice direction with sound null-safety, extension functions, sealed classes and compilation to native&wasm. (The libaries weren't very mature when I used Dart, not sure if that changed.)
I'd pick Kotlin because I'm familiar with it, but if mdhb is familar with Dart, maybe from his work with flutter, maybe from a time where you'd mostly use Dart to compile it to js, then go for it.
Dart is a nice enough language to earn my thumbs up. (not that that would be important to anyone.)
Performance matters. Dart isn't even in the same league.And its null handling and checking is the worst.I absolutely hate it.
Java over Dart any day.
Dart has excellent null handling[0] so I am not sure if you're perhaps talking of another language? It has had this since release 3.0, if I recall, and has been out for quite a while.https://dart.dev/null-safety
What specifically about the null checking are you talking about?I’ve never heard this criticism before and have no idea what you’re even referring to here but I am genuinely curious..
you still need wrap in Dart's runtime though, just like Rust, it's possible to pull in the libraries, it's just not static-link "friendly".
Since Java 9, developers can use jlink to provide a pre-packaged runtime environment bundled with the application.  It's not static-link friendly or a single executable, but it does not require the user to pre-install anything or pull dependencies at runtime.
You mentioned "distribute software" but did not consider Electron for Node.You can make an Electron app with JavaScript and ship the binary (or installer) on any platform. It's not a single executable file, but the user experience is the same.I don't think there's an equivalent in Go that allows you build a desktop app like that (with frontend and backend both written in Go)?
You can do that with Java too. The JDK has jpackage, but if you want something better than I'm willing to sell that to you (or give it for free, if you're open source):https://conveyor.hydraulic.dev/It can be used to ship servers, we use it that way for our own servers. It sets up systemd so you don't need to use Docker. But where it shines is desktop apps.Windows users get a little 400kb EXE that installs/updates your app and then immediately starts it without user interaction required, so it's effectively a single EXE. Mac users get a bundle. Linux, well, Linux users get a deb that sets up the app+its apt repo, or a tarball. Maybe in future a FlatPak or Snap or something else.It knows how to bundle and minimize a JDK along with your app as part of the release process. Works great for desktop apps.It's for Electron too, same deal, easier than Forge in my humble and very biased opinion.
Java GUI is less appealing though
That was true in 2005. Modern Java UI can look pretty great. Two examples:1. Start IntelliJ and check it out. It's Swing but it feels modern and fresh.2. Go tohttps://www.jfx-central.com/... JavaFX was introduced years ago to add far better support for modern visuals. JFX Central is a website written with JavaFX itself - it runs server side and streams drawing instructions to the client (implemented using a mix of divs, svg tags and css). You can do this because JavaFX implements the CSS2 drawing model. The website looks modern, like any slick website would today, but you can also download and run it locally. It uses Conveyor to do that in fact. The desktop version looks exactly the same as the web version.
how is jfx-central different fromhttps://openjfx.io?
Different websites run by different people, I think. The former is more of a news site.But yeah, arguably they should be unified.
but it would still be bettter and more performant than electron based apps.a little memory heavy, but no more than electron apps while being less janky
For me I use neither, I actually picked wxWidgets after all those desktop GUI troubles over the years, not ideal, but it's the best I found for myself.
> You mentioned "distribute software" but did not consider Electron for Node.Sorry for the snark, but users will undoubtedly be very grateful to them for not considering Electron.
I'm not so sure if the users of VS Code, Discord, Slack, etc would agree.Yes it's bulky and sometimes slow, but it offers a lot of features and allow developers to ship features and updates really fast, while only needing one codebase for all platform.
I'm a user of VS Code and Slack and I'd be very happy if they didn't use Electron.>Yes it's bulky and sometimes slow, but it offers a lot of features and allow developers to ship features and updates really fast, while only needing one codebase for all platform.Like Slack having 1000x the memory and CPU use for 1/10th of the features a 200K app like ICQ used to have 25 years ago?
I feel vscode is quite good at hiding the fact it's not native, and felt quite snappy when I used it. Slack on the other hand feels painful slow and heavy (and very sensitive to network events like change of network or short disconnections, while native apps are generally much better add handling such glitches for some reasons)
I can't see users caring about it all being one single codebase and I don't think that they should. Every cross-platform development tool like this means awkward, non-native UIs. Maybe there's something to new feature development. But, I suspect the big players could be a little less profitable and deliver a better experience for their end users.I've used Electron as a developer, too. While it may have been fast & easy at one time, I think that argument is losing merit. Electron had a lot of security holes and patching them has made common tasks harder. Security with Electron is a problem in general given its massive surface area.Users definitely notice the performance issues. It's certainly not just devs complaining about abstract issues. Yes, people use these tools, but that's mostly out of necessity, not preference. Moreover, big players like VS Code have had to write swathes of the app in C++ for performance reasons.I look forward to a return to optimizing for the user, not developer velocity. There will likely always be attempts at cross-platform toolkits and there may be a good solution in that space. I hope Electron isn't the best we can do.
> Security with Electron is a problem in general given its massive surface area.I'm new to Electron development. I've read the docs recommending hardened runtime. Would it be sufficient for security? Can you give examples of such security issues?
Here I was referring specifically to pulling in a web browser as a dependency. Chrome pumps out security releases regularly for all sorts of issues. If you're essentially making Chromium the core of your application, you inherit those security issues (setting aside the fact it may happen in code paths you don't use). And, consequently, you need to keep up on updating Electron and distributing new builds to your end users, even if you haven't made any code changes.I'm not suggesting every Electron app is a giant bag of vulnerabilities, just that you have a lot more to keep on than you would writing with GTK or UIKit. And, since everything is bundled with the application, you can't rely on OS updates to fix things for you. You need to cut a new release and distribute it.If you follow the Electron recommendations on security you'll be on the right path. You'll just find common tasks have become harder than they were back when Electron was attracting people with its ease-of-use. I found trying to do type-safe IPC to be an exercise in frustration. If you read the old docs, tutorials, or books, you'll find IPC used to be considerably more free-wheeling. Locking it down is the right trade-off, I think. But there's been an accumulation of many small changes like that. As a result, I don't think the framework is nearly as easy to work with as when Slack or VS Code adopted it.
Thank you for your response. I have previously dealt with IPC for a different project and it was painful indeed.But I found out that there is this new Preload module in electron that lets you use Node.js very easily via normal export and import. I'm using a popular starter template and it works great so far.
Haven't used VScode, but Slack absolutely sucks IMO (on Linux). I don't even want to install Discord, I use it from the website (but I'm pretty sure the Electron app would be similar to the Slack one).> Yes it's bulky and sometimes slow, but it offers a lot of features and allow developers to ship features and updates really fast, while only needing one codebase for all platform.So you are saying that it is bad for the user (bulky and slow), but good for the developer productivity. I really don't see how the users could like the fact that the developers are being more productive while making a worse app.
Using Discord for voice comms in CSGO on Ryzen 3600x w/ 32GB RAM had noticeable impact on my framerate, big enough that I refused to use for this purpose. No impact using Teamspeak. Both in Windows.
The best cross platform desktop GUI is Qt.
Isn't it just LGPL? Why is that a "mess"?
I'm not a lawyer, I wish it's as simple as "it's just LGPL", it's not.Otherwise Qt has already conquered the desktop GUI world, it did not for a reason: the license mess.
It did conquer (-ish) the desktop GUI world, for a while: quite a lot of software was written in it.And then Electron happened.
> And then Electron happened.Which is worse for users, but better for developer productivity (probably nicer for developers too: C++ is not exactly fun).I am still hoping that JVM Desktop apps come back at some point, maybe with Kotlin Multiplatform?
You can easily pack every single class file and resource into one single .jar if you desire to do so, no external dependency apart from JRE itself. Oh and of course no installation necessary, just put it anywhere with read access, all works.At least in the past you could also make a single .exe out of it via 3rd party if you wanted, but I didnt use that for 20+ years so maybe its not valid anymore.
You just add the -static argument, if you want a fully static executable that can run on any linux distro: ‘g++ -o main main.cpp -static’You can even go above and beyond with cosmopolitan libc v2, which makes c/c++ build-once run-anywhere:https://github.com/jart/cosmopolitan/releases/tag/2.0There seems to be some work getting cosmopolitan libc support in Go, but it is not ready like it is for c/c++:https://github.com/golang/go/issues/51900Edit: There can be some problems with using static, if you are using your system package manager for library dependencies. I would recommend compiling dependencies from source using CMake and FetchContent, this has solved pretty much all problems I have had with c++ dependency management.
If you want to distribute app to non tech people you do it via browser ;)
there are many apps that are not suited for a browser :(, on some embedded devices with a touch screen, it does not even have a browser and no internet connection either.
From my POV that is bad example, for those embedded apps you have technical personnel installing and configuring those. Non-technical users don't have any means to install/modify whatever is there.
> Go's major selling point to me is that you can ship one binary, nothing beats that.Are .war files no longer a thing? ;)
Shipping one binary to install on a users machine has been solved by jlink and jpackage for ages.
How do you distribute a Go library? How do you distribute a Go library that has dependencies?
I'm not sure if your question is rhetorical, but Go doesn't have the concept of compiled library that you can link to another binary.So in Go you make available the library's source code, and the end-user will download it at build time, or vendor it in the source tree.
Which is a non starter for businesses that don't ship source code.
Businesses that want to sell libraries without a source code license can ship APIs.
Not sure I understand what you mean here. How do I ship the API of my library without shipping the library?
Sure, if they don't care about performance.
https://pkg.go.dev/plugin
Not only it doesn't work in all platforms, it uses a bare bones C API with unsafe code, and it hasn't been removed yet due to backwards compatibility, as Russ Cox already expressed his opinion that plugin was a mistake from his point of view.
> Plugins are currently supported only on Linux, FreeBSD, and macOS, making them unsuitable for applications intended to be portable.uh-huhbut, in all seriousness: I wonder why that is? I struggle to think of atechnicalreason that go would be unable to load and invoke a .dll even if one had to name it .sohttps://github.com/golang/go/blob/go1.21.1/src/plugin/plugin...
Right, so it feels like Go hasn't solved this problem. It just completely ignores it.
I suggest reading about GraalVM...
> Go is simple. It's easy to understand, read, and maintain.Matter of taste I guess, to me Go code looks ugly, it's too verbose with all that error handling every other line which hurts readability. 
Also the docs are often so cryptic and unhelpful, one needs to rely on examples elsewhere. I do use it though, when I need something fast in a single binary.
My main pet peeve with Golang is to use single letter or very short abbreviations when naming variables. The Golang documentation recommends what is considered a bad practice by most programmers communities.
Yes, short abbreviations are brutal in long sprawling code contexts.  Write in a compact, functional, and readily unit testable coding style, and those tiny variables reduce your cognitive load and bring great clarity.  Use comments and/or docstrings to provide context for compact parameters and local variables once, rather than implicitly documenting with every usage.
>Use comments and/or docstrings to provide context for compact parameters and local variables once, rather than implicitly documenting with every usage.Context that isn't documented with every usage is context you need to remember. Trade off, but I'd much rather not have to remember multiple contexts for the same name every few hundred lines.
Are you specifically referring to method function receiver type annotations? 
Those are often left shorthand but shouldn't exist out of the type definition file anyway eh?
I’m referring to this guideline:> Variable names in Go should be short rather than long. This is especially true for local variables with limited scope. Prefer c to lineCount. Prefer i to sliceIndex.https://github.com/golang/go/wiki/CodeReviewComments#variabl...
One of those is not like the other...lineCount is literally perfect meanwhile sliceIndex could be anything.
Exception handling and generics are missing key pieces from go. But adding them will make go look like java.I just wish java would add null safety in the type system in a first citizen way.For enterprise use java has no competitors. You have c# which is microsoft trying to estabilish nash equilibrium fu*ing the developers. I am a bit worried about ever increasing complexity and a steep learning curve, but seems like this is a problem on all fronts.
Java is an inferior language to C#. To get a superior language you would likely have to go for Kotlin. There is no comparison, because Java gets features today that C# had for years. Not even mentioning having to retrofit green threads because adopting async/await (used by TS, Rust, Swift and other languages) is impossible at this point.
C# does not have virtual threads. What C# has is async/await. Which was nice for its time, but at the same time it's an error prone design, as computations should never start async by accident, blocking should be the default. C# also has no useful interruption model. Java's interruption model is error prone, but at least you can work with it.Async/await also splits the standard library and the ecosystem in 2 (blocking vs non-blocking, or blue vs red), and it can't automatically update the behavior of old code.The introduction of virtual threads in Java also works well with "structured concurrency", as seen with Kotlin's Coroutines. Kotlin's approach to concurrency is also superior to that of C#, actually. But what's interesting about Java is that its evolution is often one that involves runtime changes, lifting all boats. Java engineers preferred pushing more changes in the runtime, and somewhat ironically, the JVM ended up being the true multi-language runtime.Java is a good case study of how languages should evolve. It has extreme backwards compatibility, and features being pushed are assessed for how they impact the whole ecosystem, including libraries or languages not in Oracle's control. Project Loom was developed in the open, compared to what Microsoft usually does.
Do give async/await in C# a try, it has all the structured concurrency features other languages have to invent APIs and special syntax for :)(if you want to take a look at good structured concurrency, you might be interested in Swift implementation)
I worked with C# professionally.The async/await syntax works with the language's other statements, but for a long time it had gotchas. It doesn't qualify as "structured concurrency", and it has the aforementioned issues — it's (accidentally) error-prone, it splits the ecosystem in two, and has no interruption model.I am not familiar with Swift, but I think you can hardly beat Kotlin's implementation. This is a good introduction from Kotlin's lead:https://www.youtube.com/watch?v=Mj5P47F6nJg
What do you mean by "it splits the ecosystem in two"? I never observed such split, certain methods intentionally offer sync and async variants.Interruption is achieved through cancellation tokens and has to be handled by consuming methods. There is no way around it because interrupting execution at an arbitrary point would lead to all kinds of issues regardless of the language (unless it implements some form of transaction abstraction and rollbacks all uncommitted changes).
Those "cancellation tokens" from C# are a band-aid.In Java, you don't need to initialize those "tokens" manually, because the interruption signal is baked into Threads. Moreover, a lot of the standard library cooperates with Java's interruption, which is why you see plenty of methods throwing `InterruptedException`; and it's also reflected in types such as `CancellableFuture` or the `Flow.Subscription` (reactive streams). Of course, user-level code that isn't well-behaved, can end up catching InterruptedException, or resetting the interruption signal, without actually interrupting. This makes Java's interruption model somewhat error-prone, but it's workable, and at least it's baked in.Note that interruptions could also be preemptive, as you don't necessarily need cooperation. If you think of the call-stack, or flatMap/SelectMany in reactive APIs, the compiled code could check the interruption flag automatically and interrupt the call chain.And resource leaks aren't necessarily a problem, if the interruption protocol is well-thought-out. In Java, try/finally still works in the presence of interruption, since at worst you get an `InterruptedException`. It's not ideal because you can interrupt the interruption process, and in truth the ideal would be for interruption to be its own communication channel, complementing that of exceptions. But it's totally doable, and here I am familiar with several libraries from Scala's ecosystem, namely Cats-Effect, Monix, and ZIO that show it (with limitations imposed by the runtime).Either way, what C# provides is basically next to nothing. In fairness, some C# libraries tried fixing it, such as Rx.NET, but it's not enough. And the aggregate result in the .NET ecosystem is that interruption is not something people design for. Like what to interrupt a network socket? This ends up being a setting, presented as a timeout in case of inactivity, as a configuration of the connection, instead of a higher-level generic function that can be applied on the consumer side. And the probability for resource leaks goes up actually, because in the presence of concurrent races, you really need interruption.
https://journal.stuffwithstuff.com/2015/02/01/what-color-is-...
Except when there is only one version and someone has to write the transition code.
> regardless of the languageThat’s a choice, but it is unfortunate for the programmer. The truly right way to do it all is like Erlang does - where all processes are cancellable and nothing bad happens.
There shouldn't be a reason for a managed language to introduce function coloring. It's horrible.
But async/awaitisspecial syntax. I agree it's a nice improvement over using Task APIs directly.
And don't forget to bookmark David Fowler guidelines to avoid all the gotchas that everyone falls into while using async/await.
This one?https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/b...
Java, prints 1:Set<File> s = new HashSet<File>();

    s.add( new File( "c:/temp" ) );
    s.add( new File( "c:/temp" ) );

    System.out.println( s.size() );C#, prints 2:ISet<FileInfo> s = new HashSet<FileInfo>();

    s.Add( new FileInfo( "c:/temp" ) );
    s.Add( new FileInfo( "c:/temp" ) );

    Console.WriteLine( s.Count );C#, test fails:string path = "/tmp/filename.txt";
    FileInfo f = new FileInfo( path );

    File.CreateText( path ).Dispose();
    Assert.True( f.Exists );

    f.Delete();
    Assert.False( f.Exists );https://en.wikipedia.org/wiki/Principle_of_least_astonishmen...Languages have their strengths and weaknesses.
FilInfo doesn’t override Equal operator in C#. HashSet will use it for comparison and those are two different object references so idk what the confusion is here.
A set is a collection of objects in which order has no significance, and multiplicity is generally also ignored. Observing the code alone, it isn't obvious that two FileInfo instances having the same path are themselves not equal. As has been mentioned elsewhere, FileInfo should not be hashable to prevent declaring it as a Set, avoiding the situation entirely.C# isn't flawless. Java isn't flawless.
You can’t decide language superiority by the number of features. While C# indeed has many cool features, I do think it has already went into C++ territory where all the different, independently cool features have very non-trivial interactions that make it very hard to reason about.Also, async-await is not a good thing — virtual threads are superior in every way in case of a managed language.
This is code with async/await:async fn read_file(filename):
    f = await os.open(filename)
    let data = f.read()
    await f.close()
    return datathis is equivalent code with green threads:fn read_file(filename):
    f = os.open(filename)
    let data = f.read()
    f.close()
    return dataAs you can see, async/await is pure syntactic noise, it doesn't convey any important meaning.
Async enables clear contract for a type that represents a delayed result.Better implementations offer eager execution and allow to easily interleave multiple concurrent futures/tasks, like C#. Green threads on the other hand are a workaround to deal with blocking for the most trivial case of cooperative multi-tasking, offering little beyond that.
> Async enables clear contract for a type that represents a delayed result.It's not really a type, otherwise it would be something like Future<T> in Java and plenty other languages. It is usually implemented as a transformation to a state machine.Also, Loom is M:N and calling them green threads doesn't give you the whole picture at all. Not exactly sure what you mean by easily interleave -- functionality wise the two is more or less equivalent. You just get to keep your simpler mental model (and tooling) with virtual threads.
with green threads, every result is "delayed" and available exactly when you want it (i.e. as indicated by naive reading of the control flow in code)> eager execution, interleave multiple concurrent tasksgreen threads give you that for free> deal with blockingblocking is an implementation detail; both async/await and green threads can be implemented on top of either traditional blocking IO, or callback/non-blocking IOI'd be even happier to discuss concrete code blocks / examples, that's where the superiority of green threads truly shines
Because they were created to manually run multiple threads on one physical thread, which is the kind of decoupling that a VM/OS is supposed to do for you.
Obligatorily reference:https://journal.stuffwithstuff.com/2015/02/01/what-color-is-...
Read David Fowler's guidelines.
Do you have link to any specific article of his (on virtual threads vs async)?
Here,https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/b...https://github.com/dotnet/runtimelab/issues/2398
C# is turning into C++, sadly.It appears every six months there must be new language features being added.The last one, for declaring fixed size arrays in structs, with an annotation instead of proper grammar change is getting ridiculous.
F# is far superior to C# as a language. If you are going to jump to the .NET runtime that's the tool to go for.
apples and oranges
C# is a better language, but the JVM is a significantly better ecosystem. Java will always be behind (and type erasure for generics is annoying enough as someone who started in C# that I don't think it will ever catch up) but between hotspot and being the preferred language of 2/3rds of the clouds I think it clearly wins.
Type erasure is why there's such a rich ecosystem of 3rd party languages that run on the jvm.
Meaning that it would be harder for those languages on the clr because of generics? Would typing all generics as Object not be essentially equivalent?
type erasure for generics is annoyingI too have spent significant time programming in both C# and Java.  This complaint about type erasure in Java: When does it affect your daily life?  There are so many craft workarounds available now that it hardly comes up anymore.Also, would your opinion of Javasignificantlychange if type erasure was removed or never existed?
I have much more experience in C# then Java FWIW, so you're welcome to take my opinions with a grain of salt.
I've had a couple of really annoying errors with Beam serializers that took me way longer to debug then I thought was worthwhile.I think it is a worse choice, it's too ingrained in the language and ecosystem to change. That and a couple of other nits would likely make me pick Java over C# or Go if I was starting a new project going forward.
Sorry you’re down voted. Closure might not be what the author is looking for.There are a lot of languages you can use with the JVM, Closure is one of them, Groovy, Scala and Kotlin are some more. Kotlin is gaining a lot of traction, especially since it’s backed by JetBrains.
Clojure*
Java 21 doesn't retrofit green threads though. Quasar [0] is a library that implemented fibers for Java and the main developer pron has joined the OpenJDK development team. All that was necessary for first party support is to make the JDK libraries yield when blocking.Adopting async isn't impossible at all, there is very little demand for it.[0]https://docs.paralleluniverse.co/quasar/
Async/await is an inferior product compared to threads, for so many reasons (function coloring and meaningful stack traces come to my mind). 
Keeping the same interface as native thread, plus structured concurrency, are best of breed.Many uncancellable threads + mutability + goroutine panic kill it all are serious issues for golang.
> I just wish java would add null safety in the type system in a first citizen wayWith valhalla (value types), it might just come!
Afaik, no language as great of exceptional handling as Java.
I prefer Go but I have to admit, Java's checked exception handling is amazing.
That is an extremely debatable topic. Which is why kotlin completely ignores checked exceptions.Frankly, Id rather have a result and optional/nullable type like in rust/kotlin than deal with exceptions in any capacity.
Kotlin’s decision to make every exception runtime is the main reason I don’t use Kotlin. It’s especially baffling that they realized the issue with implicit nullability and got rid of it (though not with Java methods, which opens another can of worms), then went and intoduced implicit “exceptionality”.The correct way to deal with Java’s checked exceptions would have been introducing a Result type, or, preferably, type algebra, like in TypeScript, so something like:fun openFile(fileName: String): File | FileNotFoundException {…}Then you could handle it similarly to null:val content: String | FileNotFoundException = openFile(“myfile.txt”).?read()
  …then you have to do a check before you use content as a String…orval content: String = openFile(“myfile.txt”)?.read() ?: “File not found”(There could also be other possible ways of handling the exception, like return on exception, jump to a handling block, and so on.)In fact, null should be treated as an exceptional value the same way all exceptions should be.
This would be my preference. I like `Either`or some other container type, but a simple union that makes exceptions explicit works also.
Checked exceptions are gross, they get in the way when you're prototyping, and you end up just ignoring them anyway (since you're prototyping)
The ergonomics of checked exceptions may be debatable but compared to golangs explicit error handling at essentially each function call is definitely worse.
Yeah, I've got a lot of Java experience and a wee bit of Go language experience and I agree with you. I like Go in almost every way except for it's error handling. It's just wrong to have to check every goddam function one by one
I guess that's the reason why most Java programs I use cannot do proper user-facing error messages. Because it is so easy to just ignore error handling. The exception will be caught by the top-level, right? This is how almost every Java cli tool prints a stacktrace on even most trivial user errors like file not found.Having to deal with errors and forcing the developer to do proper error handling is a good thing.
I don't mind Go's errors.
I do mind the complete lack of hierarchy in that.
Java's exceptions are hierarchical.
I can create an exception that specializes from `IOException` and that I feel is really powerful.
Go added this half-baked and much later.
So, most FOSS libraries don't support it yet.
Both Java checked and unchecked exceptions are inferior to signaling errors by return values like Go/Rust/Haskell do.Exceptions are not composable, cannot be generic, and it is not visible in the source code which lines can throw, so every line is a potential branching point.
I don't think the jury will ever return on this topic.
Go has had generics for more than a year now
I agree, Go has had generics for a little while (of course they are different from Java's generics because Go's type system is different from Java's type system) and I don't think the parent comment writer was aware of that.
Not even in the same league as Java.
What is “enterprise” use? Plenty of enterprises use Go.
By enterprise I mean a lot of features related to data consistency, scalability and integrations.I do not know about go ecosystem, but java and spring have mature solutions that cover the most advanced use cases.
Kubernetes is what I would call very advanced use case.But that's the thing with Java, yes there are libraries for everything and one could see that as a problem actually.Spring was mentioned before, but it's the perfect example of an overengineered/ heavy library that does a lot of black magic.
Java is strange because it can be both verbose and magical at the same time.Just the other day I ran across an issue where spring was wiring things up correctly on Linux but not Windows.
I too dislike dependency injection frameworks.  I try to always wire manually myself.  I'm tired of debugging old SpringFramework apps where changing the JVM by a patch level or changing one JAR dependency breaks the wiring.  I have seen it too many times to count.
Originally prototyped in Java, rewritten in Go when a couple of advocates joined the team.
If all you have is spring boot, everything looks like a spring boot problem.
Plus Spring is honestly quite badly programmed.The pagination object is bulky and unnecessarily complex, where a simple offset/limit is enough (and a nextUrl for cursor-based access).When we looked into cluster locks, they’re not even released if one node goes down. I mean, who would need a lock implementation that just stores a line in a DB? And the doc doesn’t even warn about it.Apache contributors were much better-skilled.
Apache contributors were much better-skilled.That is quite a broad statement.  Two negative points about Apache Java libraries I can think of: The original "lang" libraries have not aged well at all.  Also: The HTTP client libs are a fiasco.  Very challenging APIs and weak documentation.
Not really. Software first enterprises do. But most enterprises that have a non-software focus generally prefer languages that have been around for a while and are known by lots of people.
I’ve written go code for large corporates in Australia who absolutely did not have a tech or software focus. One was a notoriously bureaucratic company which used to be a government owned enterprise. For the niches it fills well, it’s become almost ubiquitous.With regard to this:> But most enterprises that have a non-software focus generally prefer languages that have been around for a while and are known by lots of people.I know developers who work for large blue chip financial sector and other traditional sectors. They’re on the same React/Vue/Webpack/whatever treadmill as all the frontend devs devs working at web dev agencies. And they’re often compiling it down from TypeScript, which has not been around for a very long while at all and is not known by lots of people (relative to the size of the JS community.Swinging a bit of Go for a service in an environment like that isn’t really that hard.
By enterprise he means non-webshit industry.
The programmers don't make that call. The CTO does, so they can hire anyone.
This is definitely one of those. “Tell me you don’t know .NET with out telling me you don’t know .NET” moments.
> Exception handling and generics are missing key pieces from go. But adding them will make go look like java.You know that Go has generics since a couple of years now?
Coming from Spring Boot with it's 17+ level deep abstractions to Go / gin-gonic was such a breath of fresh air!
With the little difference that spring boot offers you 99% of your needs, both to fetch the data from (sql, nosql, you-name-it), and to offer your interface out (web, rest), and programming style (syncronous, asyncronous), and observability, ....while for go you'll find yourself deep in the mud of choosing what 3rd part library to use for logging and how to make it work with the rest of custom stuff you have to write
it's kinda funny to me when people with latest macbooks, loaded with actually useful but comically expensive programs, open up goland that itself has a shit ton of features, to write some error handling in go
I went the other way as I was sick of all the repetition in Go. Spring boot/JPA data repositories save so much SQL, and spring boot automatically marshals to and from JSON, form data, etc. It means you can just work on the meaningful business logic. Add on Lombok and there's even less to maintain.
Go is Java 1.0, nowadays 1.5, as they thankfully finally at least added some support for generics.I am not touching Go, other than on the projects I have some customer or higher up telling me to do so.
Go gives you the illusion of simplicity because it gets rid of guard rails and error checking. If you remove all error checking, of course your code is going to look a lot simpler. It's also going to be a lot more wrong and crashy.Wait until your code base grows, your team grows to >10 developers, and you will understand what I mean.Java (and preferably Kotlin) are a lot more serious about making sure your code is robust before it compiles.
Wait, are you implying Go doesn't have error checking? In what way? It has famously verbose error semantics.
It's verbose yes, but also more error prone.
No exhaustive enum checks.No Option type, so you can still use results of a function if it returns an error.
well...https://github.com/search?q=%22f%2C+_+%3A%3D+%22+language%3A...98k results...
I've heard this argument before, and I point out Kubernetes to them. Is that code base complex enough, because it's pure Go doing just fine and runs on plenty of systems?
You can point to a complex project in any language, and that would prove nothing.
I mean, that’s pretty much go’s first complex application that was specifically written with that, so don’t think it is a good example.
> Java (and preferably Kotlin) are a lot more serious about making sure your code is robust before it compiles.You are making great points for Rust, Ocaml and Haskell.
There isn't all that many plus in their type systems that is not expressible in Java. OCaml and Haskell has Monads, sure. There is Scala for that on the JVM.
> There isn't all that many plus in their type systems that is not expressible in Java.Thanks to Turing, anything that is Turing-complete can duplicate any other thing that is Turing-complete. So, yes, you can do all of Haskell's types in Java. That is not a flex.The flex is doing them in a non-horrific way.
The kind of Turing completeness certain type systems have is useless beside academic curiosity -  look at the vavr library, that’s what I’m talking about. You can have plenty Haskell types without any hacks, except for Monads in Java.
> vavr - turns java™ upside down"turn X upside down" are different words for "use X contrary to its original intention and design".You will find very few people willing to let go what people undestand as Java so as to be able to do Haskell-in-Java.
It’s goddamn immutable collections and Optionals, not brain surgery come on.It’s not like Java hasn’t been going in the same direction, see records, sum types, pattern matching.
Yes, it's goddamn immutable collections and Optionals.People still hate it because it's immutable, therefore you can't do hashmap.add(), and it's hard because they can't randomly return nulls, and it's slow because the hashmap now takes o(log n) always instead of o(1) sometimes and o(n) other times.People hate it because it's different to the Java they learnt 20 years ago, that they claim is exactly the same as today.
Is it possible to express Rust enums (tagged unions) and especially the option type in Java? Ofcourse.
But the power of good type system doesn't come from the factifyou can express something, but rather how seamlessly it is integrated in to the language.
Rust has sum types named wrongly as enums, which java also has as sealed interfaces. The option type is just one example for a sum type,  which is as easy to express in Java assealed interface Option<T> permits Some<T>, None<T> {
    record Some<T>(T value) {}
    record None<T>() {}
  }Sure, you have written 3 words more than Rust, and?
Go has made many decisions that i'm not happy about.If they did one thing exactly right on the language level, it's the [lack of] OOP: interfaces in their implementations, and no inheritance, overridden methods, covariance / contravariance games, etc.You can of course write in Java in that style: only extend interfaces, never inherit classes. But many libraries, including the standard library, actively refuse to cooperate.
And yet even after writing Go for 5+ years I still have to Google for what actually implements Reader so I can read a file, etc.
Do you mean overloaded methods? You can "override" methods in Go in the sense that if you have an embedded struct you can provide your own implementation in your struct to use instead
Go also sucks. It's so easy to leak threads.
I never understood some of the objections to inheritance. It always made it easier for me to reason about the code, not harder.
Some people are aware about various concepts/paradigms and are able to put each to good use where appropriate.Other follow fashion and if some dick looking for fame declares A as obsolete and B as the new and shiny one (to be replaced soon anyways) then the lemmings would follow and sing the gospel.
This is correct. It is about culture too. Java is the kind of language that attracts some mediocre programmers who produce mediocre code based on the wrong ideas of object oriented programming. of course, there are great Java programmers. It is just that a better programming language would help average programmers like us to achieve more
That escalated quickly. There are good and less good people everywhere and using language X does not automatically tell anything about you.If anything I think the cases where you can use Go successfully are only o fraction of the cases where you can use Java successfully. It's not necessarily Java itself but the ubiquity of the JVM and its ecosystem (see Kotlin, see Scala as examplea that have leveraged this ecosystem successfully)
So the ideal blub language will be whatever language is too new to really be the legacy thing with tons of black magic you just have to know, but also too old to include tons of new ideas in language design the programmer has to grapple with.Old languages force you to understand really core issues because the stack is 1m+ lines of code and you need an operating model for all that magic.New languages do the same thing, but it's because half the really good stuff is <experimental>Python and JS are in the current sweetspot, go is up next, and after that, Rust.
>  the cases where you can use Go successfully are only o fraction of the cases where you can use Java successfullycould you elaborate why do you think so, and maybe give examples of cases where Go can't compete with Java?..
Libraries for application programming, last time I used Go nothing came close to the Java PDF creation libs for example.
Imho Go is really good for self contained micro-services. The way Go does binaries and the cross-compilation part are great.Otoh, Java has a huge ecosystem. Huge. This plus dependency managemnt make it the first choice in most cases. Not even going to go into the massive innertia given that Java has been around for decades (who is going to rewrite everything in go?)Today most of the time I pick Kotlin which is sort of whatbJava could have been (or maybe will become) with proper investment and care.
Let's not forget who golang was made for:"The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. - Rob Pike
You're entitled to your opinion. I guess I must be a mediocre programmer then. (Don't forget that 90% of developers thinks of themselves as above average.) But if Java can evolve, why wouldn't its practitioners?
In the past, when java was dominant and most popular language - sure.Today though, with languages like js being the most popular one, I would be surprised if inflow of mediocre developers into Java world would be even the same, not to mention higher, then with those more popular languages (Go included)
This generalisation is easy to explain.  On the server-side, Java "won" the enterprise battle.  In the last 20 years, big corporates re-wrote their server-side C/C++ stack in pure Java (and thick desktop clients in C#).  It is so much easier to maintain than C/C++.  As a result, they can hire mediocre Java developers tomaintaintheir "new" legacy services.who produce mediocre code based on the wrong ideas of object oriented programmingThis overlooks this history of OOP.  Each decade, lots of new ideas have emerged so that skilled programmers continue to use the same languages (Java, C#, C++, C), but changehowthey use them.  C++ in 1996?  Let's fight about diamond inheritance!  C++ in 2006?  C++ in 2016?  C++ in 2026?  Repeat for all four languages that I mentioned.  The story will look similar.  Anyone good writing new code in these four languages isn't using many levels of inheritance.  It is gone.  Sure, itexistsin the language for historical reasons, but it is hardly used in new code.  "Prefer composition over inheritance."
And some people for no fucking reason think that they're smarter than everyone else and are qualified to tell others how they should go about they business.
>  attracts some mediocre programmers who produce mediocre codeThat will be reality for most companies, no matter the language. And if Java projects still got delivered in such conditions - it might also be a mediocre language but it is also just good enough.
Yeah that's not going to be too popular but Java in particular has a tech culture problem. It's way more common to find overengineering and overabstractions in Java projects than any other language.The language itself might be fine but I'll never touch it because of that.
Despite the fact that this is a claim with no basis in reality, what you are saying is that people who don't understand the core concepts the language is built on write bad code...Isn't that true for every language?
This is also the killer argument for going Python, by the way. Go is going to be much faster, of course, but you can still scale quite well with just going Python. And sometimes / most often you don't need scale.
I use Go and Java every day, and Java is way more enjoyable to use
Lol...you use the language most appropriate for the given situation. What's appropriate in the browser....hmmm. Can't slam your foot down on that one.
> The packaging is like how you would package files on your computer in single foldersHow does that vary from Java?
Java 21 has me anticipating the next JRuby release because of Virtual Threads. Charles Nutter gave a talk about JRuby in August where he showed a demo of the impact on Ruby fibers and it’s pretty significant.There’s a lot that I really like about the JVM and it’s tooling, I just don’t like writing Java code anymore. JRuby kinda gives the best of both worlds.Here’s the talk. Virtual thread demo is around the 45 minute mark.https://youtu.be/pzm6I4liJlg?si=GtxQ4MThEaNDfC67
I loved this. Is there any post comparing Ruby performance with JRuby?
There are lots. Usually these days, also comparing with TruffleRuby, which also runs on the JVM.This one is a couple years old now but you get the idea:https://eregon.me/blog/2022/01/06/benchmarking-cruby-mjit-yj...I don't know where to find more up to date benchmarks.
How does jruby relate to truffleruby?
He actually talks about that during the video as well. Short answer is “it depends”.IIRC Truffle is dramatically faster in some benchmarks but slower in others. And there are some usability aspects of the language that are negatively impacted.
I think he shows the performance of running JRuby on top of GraalVM. GraalVM uses Graal (the JIT compiler) in place of C2 (the JIT from HotSpot).But TruffleRuby is something different. It is another Ruby implementation (just like JRuby is a Ruby implementation) using the Truffle framework. And Truffle framework requires to be run on GraalVM.
Wondering if anyone is using JRuby on Rails in production.
He listed off a bunch during the talk.
>  If there was any feature that would sway existing Golang developers to switch to Java, it would be this.Not sure about this, but a trajectory question: why does the Go community have so few concurrent containers but Java community does? I mean, even `sync.Map` is specialized for two specific use cases instead of like Java's ConcurrentMap that is of general purpose. And In Java there are concurrent sets, queues, barriers, phasers, fork-join pools, and etc. I'd assume that even with Go's go routines, we can find great use of such containers, right? At least fork-join is not that trivial to implement. And using mutex everywhere seems just so... low level.I understand that there are 3rd-party implementations, but concurrency is so tricky to get right that I would be really hesitant to adopt a 3rd-party package, unless it is as mature as Java's JCTools or Google Guava, both of which are also backed by a large number of users and developers.
Because the predominant patterns are to do concurrency with message passing, so having multiple goroutines trying to mutate the same container is the exceptional case (though as you say, mutexes are the answer when needed). Another reason is containers are embedded features not stdlib, which has huge implications to how willing someone is to go against the grain, for better and worse.
Ironically, golang does not have constructs to build immutable types to pass them around, while Java does (records).
Yet another reason is that you really want generics for container types and Go's generics are relatively new
What concurrent data structures that Google Guava offer than the standard library does not?
`Executor.newVirtualThreadPerTaskExecutor` versus `go` really gets to the heart of why I think that Go developers aren't going to be switching.edit: Sorry, it's actually:try (var executor = 
        Executors.newVirtualThreadPerTaskExecutor()) {
       executor.submit(...)
    )instead of `go`
You’re likely to need a lot of boilerplate that “go” statement won’t generate: pass and wait for completed results, report errors, timeouts, cancellation, bounded parallelism, pushback, service monitoring.
My comment is perhaps too glib. I'm not trying to say that Go is better, I frankly like Java more. I only mean that if I'm in a Go mindset and I read the linked document on virtual threads, and I see that code example, I'm going to close the tab.
Starting a virtual thread in Java isn't that clumsy:Thread.ofVirtual().start(() -> System.out.println("Hello"))
The go example is missing the channels, select, wait group, context, cancellationDoesn’t sound like a fair comparison thou the Java version is missing things
> The go example is missing the channels, select, wait group, context, cancellationThe Java version would require all of those in the exact same way though.
Java has structured concurrency in the works, which will not be much more verbose, unlike golang.
If you want to use that with more concise syntax, there is Kotlin for that. In which case abstracting that is one line of code tucked away in a utility file:fun <T> go(body: ExecutorService.() -> T): T =
        Executors
            .newVirtualThreadPerTaskExecutor()
            .use(body)Now you can write:val result = go {
       val result1 = submit { slowOp() }
       val result2 = submit { blockingOp() }
       result1.get() + result2.get()
    }or words to that effect. You can also reduce it a lot in Java too, as mentioned by another commenter.class Shortcuts {
        static <R> R go(Function<ExecutorService, R> task) throws RuntimeException {
            try (....) { return task.apply(service) }
        }
    }and then you can write:var result = go(service -> {
        var result1 = service.submit(() -> slowOp());
        var result2 = service.submit(() -> blockingOp());
        result1.get() + result2.get();
    });using static imports.Now if you're making a cultural point then sure, Java APIs tend to be named quite explicitly. It has advantages when searching or auto-completing, and it's easy to wrap with aliases if you want to abstract a boilerplate pattern away.
Wrap it in class Go { static void go(…) } and it will look better with “import static”
I assume `Go` would have to be Closeable and you'd still need the try-with-resources, right?
You don'tneeda try-with-resources, you can manually call close if you want, or has to work in a non-lexical scope.But you often want the concurrently running threads to return some results, that try-with-resources is part of the structured concurrency that helps you with closing off a branching point, similarly to how we use while loops instead of gotos. `go` in itself corresponds to `goto` basically, with many of the same negatives.
So basically executor.submit(). And you still have a language that is significantlylessverbose than go, objectively.
Yes, if you ignore more than half of the code it's quite concise.
How many thread pools do you want to use? You only need that once.
go will always lose vs java when it comes to code verbosity
Extend that to a full function and the Go code will be 2x more verbose than Java with all the `if err != nil` stuff.
Java 21 also previews structured concurrency (https://openjdk.org/jeps/453), which uses the virtual thread implementation. It seems really nice, at least from reading the examples, and removes a number of pain points when dealing with thread-based concurrency.
> The biggest feature in Java 21 is the release of Virtual ThreadsIs there a good honest writeup on why is this interesting? Very curious.The earliest JVMs had this, green threads. Performance was terrible so it was eventually dropped.Iwantto fully utilize every CPU and every core I have, why do I want green/virtual threads again?
The JVM automagically swaps out blocking network calls executing in a virtual thread to a non-blocking implementation, so potentially many other requests can be served in the same time.So you get the benefit of async frameworks, with none of the negatives: the blocking model is trivial to reason about, read, maintain, and works perfectly with tooling (you won’t get an exception in some WhateveScheduler, but at the exact line where it actually happened. Also, can step through with a debugger).
Thanks. Any good books that cover the current java performance landscape but is grounded in the history of what came before?I used to be heavily involved in java-based server performance and scalability work back in the 90s and 00s but have been working on other things the last decade. But it would be fun to learn more about where things stand.
> I want to fully utilize every CPU and every core I have, why do I want green/virtual threads again?If your task is CPU bound, then virtual threads don't gain you anything.On the other hand, if your task is IO bound, e.g. for a webserver, virtual threads make it trivial to spin up a new thread per request, for massive workloads.https://en.m.wikipedia.org/wiki/C10k_problem
It's not the same. The earliest JVMs weren't really thread safe at all but machines were single core so it didn't matter, you could just cooperatively multi-task.Later HotSpot became thread safe (and fast - a rare achievement), so started using real OS threads so it could go multi-core.Virtual threads are M:N threading. There are multiple native threads so you can exploit all the cores, and also user-space runtime managed stacks so you can pack way more threads into a process.
> The earliest JVMs weren't really thread safe at all but machines were single core so it didn't matter, you could just cooperatively multi-task.In the 90s we didn't have multiple cores but we had multiple CPUs. I started using java in '96 on a 2 CPU SPARC and the lack of real thread support was limiting. When green threads was dropped in favor of real (OS) thread support there was much rejoicing. I worked primarily in server performance back in those days.> Virtual threads are M:N threading.Solaris had M:N threads early on but it also was dropped.
For me, it's the difference between code structure and resource usage.Green threads are for a cleaner code structure. async/await comes quite close, but requires function coloring, creating high coupling. The threads have to have low overhead, so that I don't have to think about whether I should create a new one or not.Kernel threads are for parallelism and scaling across cores.
From my vantage as a Clojurist, virtual threads on the JVM seem to have very minimal benefits.  All I can think of at the moment, is that we could have thread-safe JDBC connectors:https://medium.com/oracledevs/introduction-to-oracle-jdbc-21...
I mean couldn’t you have the performance equivalent of core.async’s go except with the ability to take across cross function boundaries? That seems pretty huge.
I don't think Golang devs are waiting to switch to Java if only making a lot of threads was easier.Honestly, its way too early. Virtual Threads will need a a "killer app" (in this case a killer framework) to pull in devs.
Like Helidon Nima, Micronaut, Quarkus or recently, Spring?
I haven't really used or heard of the others but Spring was already quite good and you really didn't need to think about threads very much.  This might help some benchmarks but, again, who is pining for "Spring but with more threads?"I'm thinking something that would be a clear differentiater such as a multithreaded GUI framework.
The great thing about virtual threads is they're basically a drop in replacement for threads.
For cases that are IO bound yes. Threads still have their place (another thing that golang doesn't have).
Go almost instant build time is a huge productivity boost when compared to Java. You get both the solidity of a typed language, and the development speed of interpreted languages (py, js).
Java's build times are very fast. Java's buildtoolsare anything but. And I'm surprised no one is doing anything about it.
That's because everybody is busy shipping full web browsers with a hard-coded website inside and calling that an "app".
Gradle, when the daemon is runnning is very fast, people just often fck up their build scripts to include config-time run functionality, which is just all around a stupid thing to do.It only ever runs tasks that actually have to be run, has integration with javac, can work in parallel, and even has cross-company build caches if needed.Also don't forget that Java can do hot reloads with the debugger, or with tools like JRebel. Certain frameworks support it 100% and it will be much much faster than whatever go does.
I've never seen Gradle run fast, even with the daemon running. Gradle itself can take multiple seconds to startup. God knows what it's doing.
Gradle is steaming pile of garbage. But since the zoomers are allergic to XML, Maven (actually fast) is slowly dying.
We are in the process of switching to Gradle at work and I'm not sure I like it. I used Gradle when building some OSS projects, but my experience wasn't that great.
Just make sure that whoever writes the majority of the build file actually understands gradle, at least its fundamentals. It really is not hard, and afterwards it is a really great tool that can significantly improve compile/CI times.
The tool whose main purpose is to build stuff should not demand "understand gradle at least fundamentals so that afterwards you can probable possibly improve times".Why isn't it fast out of the box? Why does the simple "provide a list of deps, provide a list of paths, build" take so darn long? Because Gradle is a great tool or something?Don't forget that it's also already at version 8, where each change is mostly incompatible, bizarre and inexplicable breakages between versions, often due to meaningless option renames. Imagine if they spent all that effort on actually making it a great tool.
Gradle is much faster than maven as it can properly parallelize the workloads. Sure, it won’t be visible on a hello world, though.
I've never seen gradle be faster than Maven. I have no idea what purose its daemon serves or its promise to "parallelize workloads". Which workloads? Its purpose is to build the project, fast. It spends about a magnitude of time more just trying to start up, even with daemon running.
There seems to be some disagreement to your statement.  Can you provide some concrete examples?
https://gradlehero.com/maven-vs-gradle-comparison/
Has never been the case in my many years of using it. Hundreds of MB permanent RAM usage for the daemon (which it wouldn’t require if it was properly designed), everything taking well above 10s. None of this has ever been an issue with Maven.
You can disable the daemon in gradle if you don’t want it.
Gradle is anything but fast
If you are leveraging Maven, use mvnd during development:https://github.com/apache/maven-mvnd
If you avoid pre-Java 11 modules in Apache Maven, it is very fast to build.  Plus, IntelliJ is auto-magically incremental build.  Can you give some specific examples where Java build tools are slow?  Most Java developers spend their whole day in an IDE that is doing incremental build, jumping in and out of a debugger to fix bugs or broken unit tests.
Maven is okay-ish, Gradle is an abomination. Incremental compilation doesn't always work, and the fact that the build tools often spends a magnitude or more time just starting up than actually doing useful work is inexcusable.
I once posted an Ask HN: what are your build times. A golang developer stated their 25 million line project compiles in less than half a second. If that is really the case, I must say, this is very impressive and potentially a reason to switch from other languages.
I work on a product written in Go which is considerably smaller than 25 million lines and our compile times are... really... really long. I really don't believe that claim at all. 
If it's true, I would love to see how it's done because that is SOOO far away from my daily experience.
I was skeptical as well. Thanks for providing feedback. I suspect the way they were counting lines was wrong as 25M lines is a very large project in its own right.
Isn't this an exaggeration ? I have a 100k line go project and it takes several seconds to compile. No idea how a 25m line project compiles inless than half a second.
Java compiles very fast especially with a running gradle daemon, definitely on comparable levels. It also supports hot reloads to a degree.Also, was that a clean build?
I wonder what will happen with these patterns now. They seem to have been invented to work around the problems with regular threads. Will new patterns emerge, or will the reactive patterns be ported to run on virtual threads?
The reactive patterns are now obsolete and will die. And good riddens I say.
I wonder: are virtual thread at the JVM level? If so, would Kotlin (and other JVM languages) be able to leverage virtual threads to improve (e.g. produce more optimal JVM bytecode) for their async functionality?
It is a JVM level feature but the Scala guys at ZIO are not that excited about it IIRC.
That is true, but there are many who have discussed that. I wanted to bring some attention to the new syntactic changes Java brings that can help with implementing better logic.
It depends what one needs.
VT are nice, but I don't use  threads much, so it is a cool feature I won't use.For me bigger feature is pattern matching for switch and records.
No thank you.  There is limited time in the day and go fills my needs.Go, Rust, Ruby.  These three cover all cases.
Add Python to that list (for the ecosystem) and JS (for front end web dev)
Will that also make existing Sway developers go?
The title of the blog post is IMO a poor choice. The (hidden) subtitle of the post is "Algebraic data types in Java" which is much more descriptive of the content. A better title would have been "Algebraic data types in Java 21".Perhaps because of the title, many/most of the comments here are off-topic. I was hoping to see more discussion about algebraic data types, strengths and weaknesses of the Java implementation, technical comparisons to other languages, etc.
Yes, I'm also not really sure I want to see algebraic types in Java even though I would prefer if a language that focused on algebraic types was more popular.All the existing Java code doesn't go away, so is it really going to be nicer to have code like this mixed randomly into that?
Of all the features most Java devs (and ex-Java devs) desire, algebraic types are near the bottom.How about intersection and union types? (NO, sealed classes are not a substitute for unions).But, yeah, in my view JDK 21 is a a disappointment. I rarely want pattern matching, but I would like properties please and records are nice, but actual tuples are more useful. Etc.
I would love a union type in Java, but I still enjoy the language, community and especially development experience.  I wouldn't recommend it for everything, but it's sturdy by design and enjoyable for when it fits.
I'd love if interfaces worked as in typescript.As long as the object signature matches the interface as parameter then you can use it.
Check out project manifold, it’s a compiler plugin for Java. Among other amazing features it adds structural typing [1], which is essentially interfaces typescript interfaces.1.https://github.com/manifold-systems/manifold/tree/master/man...
Well hopefully it won't be mixed in _randomly_.I have some use cases in mind and think it will be very helpful. I have been converting a 10+ year-old code base to modern, functional-style Java and believe that sealed types and pattern matching will help us further simplify our code and eliminate more usages of nullable values.A challenge for us will be that we need the core library to stay on JDK 8 for a while. But, in general, I am finding that you can implement a JDK 8 library that works well with newer JDKs if you are careful (and willing to write more verbose code using the older syntax/libraries to support the newer paradigms)
I did title it that way at first but ended up changing it at the last second, ended up shunting it off course.
It's a great post. Thank you for writing it!
thankyoufor giving it a read!
The "Sealed classes" feature, as described here, just feels all wrong to me.They are saying that if you have a (normal) interface, anyone can create a new class implementing it. So if you doif (x instanceof Foo) {
        ...
    } else if (x instanceof Bar) {
        ...
    } ...then your code will break at runtime if someone adds a new class, as that code won't expect it. So the article is saying the solution is to use the new "sealed" interfaces feature, so nobody can create any new classes implementing that interface, and your "if" statement will not break.Surely object-oriented programming already thought about that and already solved that? (I know object-oriented programming is out of vogue at the moment, but Javaisan object-oriented language.)The solution there is to add a method to the interface, and all your classes implement that. Then rather than having a massive if/switch statement with all the options, you call the method.That is better than preventing people from extending your code, itallowsthem to extend your code. They just have to implement the method. And the compiler will force them to do that, so they can't even accidentally forget.The example given of color spaces (RGB, CMYK etc.) is a great example. I can absolutely imagine writing code which uses color spaces, but then some user or client having a need to use a weird obscure color space I haven't thought of. I wouldn't want to restrict my code to saying "these are the color spaces I support, due to this massive if/switch statement listing them all, the code is written in such a way that you can't extend it".
> The solution there is to add a method to the interface, and all your classes implement that.What if you don't know all methods that you will need in advance?That is the problem and this problem is solved by sealed classes. However, by doing so they introduce a new problem: what if you need more extending classes and you don't know all of them in advance? Which raises the question: is there a way to achieve both?This problem is called expression problem. [1]There are (statically typed) languages that are able to solve the expression problem, Java is one of them [2]. However, unfortunately the way to do that in Java is (still) very complex and unergonomic, hence rarely used. Languages like Haskell or, if you want to stay in the JVM world, Scala do much better here.[1]https://en.wikipedia.org/wiki/Expression_problem[2]https://koerbitz.me/posts/Solving-the-Expression-Problem-in-...
The solution with sealed classes also allows anyone to extend the code, but in a different dimension than the solution with an interface method.The solution with interface method and virtual call is very inflexible when you want to add new operations instead of adding new classes. If you want to just add one new operation, then you have to go to all the implementations and add new methods. And you possibly break the implementations you don't have access to. And all those methods must be defined in a single class, even if they are unrelated to each other. This seriously degrades code readability (and performance as well - those vcalls are not free either).The sealed class extends much better in this case. You just add a new switch in one place and done. No breaking of backwards compatibility.This is the famous expression problem.https://pkolaczk.github.io/in-defense-of-switch/
> If you want to just add one new operation, then you have to go to all the implementations and add new methods.not necessarily, if you have extension methods (kotlin, swift) you have the option to extend the interface and only override the specific implementation when needed
I understand what you're recommending, and I've seen Bob Martin talk about it extensively (polymorphic dispatch instead of instanceof), but it's something I disagree with.To do this kind of polymorphic dispatch, objects have to deal with multiple concernswithin themselves.In a video game, a Car might have .render(), .collide(), .playSound().  Later on you can add a Dog, which also has those three methods, and youdon't need to edit/recompile the Renderer, the PhysicsEngine, and the SoundEngine.  And other programmers can add additional entities like this without introducing bugs into my precious code!  What's there not to love?Well, now both my Car and my Dog need to know about graphics, physics, and sound.  And these entities don't exist in isolation.  Cars and Dogs need to be rendered in the right order (maybe occluding one another).  They'll definitely need to check for collisions with each other.  And (something which has actually happened to me in a Game Jam) my sound guy is going to need to step into all my objects to add their sound behaviours.I would much rather work in the Physics.collideAll() method, and have it special-case (using instanceof) when I'm thinking about physics, and work in the Graphics.renderAll() method when I'm thinking about graphics.A more common example I see in day-to-day backend Java web dev: when I'm sitting in the (REST) Controller deciding how to convert my Java objects into HTTP responses, I much prefer it if I can consider them all in one method, and map out {instanceof Forbidden} to 403, {instanceof NotFound} to 404, etc., rather than putting getCode() (and other REST-specific stuff) into the Java classes themselves.
The OO solution is to have a PhysicalObject class that dog and car both inherit from (or use via composition).
Then there's even more scattering around of the logic.Good way:PhysicsEngine {
    List<Entities> entities;
    doCollisions() {
      // Logic involving instanceof
    }
  }Bad way:PhysicsEngine {
    List<Entities> entities;
    doCollisions() {
      // Delegate to whomever.
      entities.forEach(e -> e.collide());
    }
  }

  Dog {
    collide() {
      // What the hell can I do here?
      // I don't know about the rest of the world
    }
  }

  Car {
    collide() {
      // What the hell can I do here?
      // I don't know about the rest of the world
    }
  }Worse way:PhysicsEngine {
    List<Entities> entities;
    doCollisions() {
      // Delegate to whomever.
      entities.forEach(e -> e.collide());
    }
  }

  Dog : PhysicalObject {
    collide() {
      super.collide();
    }
  }

  Car : PhysicalObject {
    collide() {
      super.collide();
    }
  }

  PhysicalObject  {
    collide() {
      // Not only do I not know about the rest of the world
      // I don't even know how *I* collide, because what am I?
    }
  }
It doesn't always make sense to allow extending -- String is `final` for a reason (and one might even argue that final should be the default, and one should explicitly mark with `open` classes that can be subclassed).The stereotypical FP example for sum types are a List -- there you only have an Element<T>(T head, List<T> tail) and a Nil(). There is no point extending it, it would, in fact, result in incorrect code in conjunction with all the functions that operate on Lists.Also, the Visitor pattern, which is analogous to pattern matching is very verbose and depends on a hack with the usual method dispatch semantics of Java. I do think that pattern matching is several times more readable here.
In a world of untrusted code and SecurityManagers, it was critical that strings be immutable so a data race couldn’t bypass a policy decision. The JVM doesn’t have immutable arrays, so string methods carefully protected the embedded array from tampering, and couldn’t be overridden.Most classes don’t have this problem. The original authors of a class don’t know what I’m trying to do, and they don’t bear consequences if I (a consenting adult) get it wrong.
There are valid use cases for that.Consider a security interface of some sort, e.g. such that validates a security token.With a normal interface, it is easy to implement it and ignore the token (allow all), siphon off the token, add a backdoor, etc. If a class doing that is somehow injected where a security check is done, it can compromise security.Now with a sealed interface, there cannot be new, unanointed implementations. If you get an object that claims to implement that interface, it's guaranteed to be one if the a real, vetted implementation that does the actual security check, not anything else. You've just got rid from a whole class of security bugs and exploits.
Nice article as someone familiar with sum types but not sum types in Java.I don't know if sum types alone are enough to get me to like Java, pervasive nullability is still around and even rears its head multiple times in this article.
Nullable is a huge issue in Java, but annotation-based nullability frameworks are both effective and pervasive in the ecosystem (and almost mandatory, IMO).I'm really excited abouthttps://jspecify.dev/, which is an effort by Google, Meta, Microsoft, etc to standardize annotations, starting with @Nullable.
This can never be as effective as changing the default reference type to be not nullable, which would break backwards compatibility, so you can never really relax.I know Kotlin is basically supposed to be that, it has a lot of other stuff though, and I haven't used it much.
That's basically what c# has done. But it's implemented as a warning which can be upgraded to an error. I think it might even be an error by default in new projects now.
Holy shit, how didn't I know they'd taken it this far? This is great!https://learn.microsoft.com/en-us/dotnet/csharp/nullable-ref...They actually fixed the billion dollar mistake...
They didn't. A proper fix would require getting rid of null altogether in favor of ADTs or something similar. I work with C# daily and nulls can still slip through the cracks, although it's definitely better than @NotNull and friends.I haven't worked with Kotlin in a while, but IIRC their non-nullable references actually do include runtime checks, so you cannot simply assign null to a non-nullable and have it pass at runtime like you can (easily) do in C#.
they won’t change the default reference type to non null. might take a few years but you can see their planned syntax here:https://openjdk.org/jeps/401
I hope they succeed. So many people have tried.
Not having nulls is easy.Persuading Java devs not to use nulls is hard.
I was just writing about nullability annotations!https://news.ycombinator.com/item?id=37534184
Nullable annotations don’t work with well with generics, or at least those tools I use.
With valhalla, we will have explicit nullability as well, so that problem will also be handled.
It's also not expression orientated yet.
Fortunately switch has now an expression variant. But I would die for an if-else expression (very subjective, but I would prefer a more verbose if-else to ternaries), and especially a try-catch expression!
> Why do we call them product types anyway?Answer in the piece is not wrong, but put more intuitively and succinctly: the total number of possible value (inhabitants) in a product type is the product of the quantity of inhabitants of the constituent types.Replace the “product”s with “sum”s and it works too.Interestingly, the total number of unique functions (judged only in terms of input and output) from a -> b can be found by exponentiation, (inhabitants of b) ^ (inhabitants of a).
>Answer in the piece is not wrong, but put more intuitively and succinctly: the total number of possible value (inhabitants) in a product type is the product of the quantity of inhabitants of the constituent types.More intuitively and succintly: product type is equivalent to a cartesian product of sets
Maps (and lists) are other examples of exponential types. Intuitively this should make sense that these are the same as functions because any pure function could be (theoretically) replaced with a map lookup of pre-computed values. In this context, list is a special map where the keys are integers.Writing it out mathematically, given a List of Bool, the left-hand side is the number of elements and the right-hand side is the total possibilities.- 0 : 1- 1 : 2- 2 : 4- 3 : 8- 4 : 16- 5 : 32and so on
Ill add that in, somehow forgot about that golden bit of info
I can't wait 'til Project Valhalla is complete and Java finally gets value types. Then with sum types, value types and goroutines it'll be one of the nicest languages out there.
java was never really a bad language.the people were. if not massive over-engineering. too many abstract concepts that make it hard to grasp a codebase.code voodoo - in the form of reverse GOTO statement i.e annotationsDI frameworks .what needs fixing is not the language but the ecosystem. there needs to be a "reformation" movement within the java ecosystem.yeah people migrating to kotlin or clojure or scala isn't enough.
100% agree. You can create a HammerFactoryFactory to churn out HammerFactories in any language. But the ecosystem in Java (and C# is similar imo) promotes and encourages this type of problem solving.The one thing Java really does need is free standing (or namespaced) functions though. Sometimes I don’t want a class, what’s wrong with a function in a module or namespace in that case?
A class is a module/namespace. You can make a class just to have functions in it.
It’s not though. In lots of languages a namespace can span multiple files, whereas a class must be declared in a single file[0][1]. Modules can usually contain a collection of functions and classes. And namespaces can also contain multiple classes/structure/functions and sometimes modules depending on the language[2].[0]:https://www.typescriptlang.org/docs/handbook/namespaces-and-...[1]:https://learn.microsoft.com/en-us/cpp/cpp/namespaces-cpp?vie...[2]:https://learn.microsoft.com/en-us/dotnet/fsharp/language-ref...
The author cites this to justify the need for Records:> Most Java objects set every field to be private and make all fields accessible only through accessor methods for reading and writing.> Unfortunately, there are no language enforced conventions for defining accessors; you could give the getter for foo the name getBar, and it’ll still work fine, except for the fact that it would confuse anybody trying to access bar and not `foo'.Scala supports pattern matching on objects implementing the `unapply` method.Is this considered harmful? Why didn’t Java follow this route?
it's a matter of standardisation again. Java's standard is like C++; ponderous. The record pattern jep indicates in final footnotes that something like unapply may be in the works, so all hope is not lost.
Java was always a great language. It's the enterprisy ecosystem that make me want to throw up. To implement a line of logic, I have seen dozen classes and interfaces.
道生一，一生二，二生三，三生萬物。萬物負陰而抱陽，沖氣以為和。The Function gives birth to the Unit type. The Unit type gives birth to the Boolean. The Boolean gives birth to the Value type. The Value type gives birth to the Top type. Each Top type contains 0s and 1s, thereby bringing harmony to the computation.
Golang is simple, smart and opinionated subset of Java/C#.Everything moves slowly in corporate world. It will take another at least 2-3 years for large community of Java ecosystem and average devs to adopt Java 21 and capabilities.
Go is just a dumb subset hyped up as simple, but it is useless and slowly it will have to introduce all the remaining pieces in some ugly way as they didn’t plan with them ahead of time - see generics.
That is exactly what I used to think when I started with it. But I changed my opinion after 6 months with Go and eco-system. It's not ugly, it's different and much more concise.
It is more verbose than java by all objective counts.
I think there may be a “Penny wise but pound foolish” thing going on in your analysis.
Is there any widespread concern over lack of unsigned int native types?
Not really. With valhalla they can be user-implemented efficiently, although without syntactic sugar like +.
Does that mean addition would look likeUint32 a,b,c;
  c = a.plus(b);in what you describe, once project valhalla is complete?
Well, that will be available as a basically zero-cost abstraction. But I haven’t seen more specific mention of it in the mailing lists/design proposals - they definitely didn’t want to add a new primitive type, but perhaps if they manage to heal this rift between objects and primitives and it will only be add syntax-level complexity, they might go for it.
the argument for Java seems to be that it's gradually gaining features we already have in Scala, Kotlin, OCAML, F#, etc... so why not use the languages that have those features today?
Inertia. There are still a ton of Java shops out there, and many of them will not switch even partially to another language anytime soon. The hope is that these orgs might find it easier to upgrade to Java 21+ than to learn and start using Kotlin/Scala/etc. I fully expect I might find myself working at such an org again, and when I do I’ll be grateful for newer Java features.Signed, a dev who would never willingly choose Java over Kotlin for anything ever again.
One thing about "gradually gaining features" is that the Java language architects do a very good job with backward-compatibility. This means that your application/library will be easier to migrate to newer versions of the language and you will continue to have a large number of 3rd-party libraries available. The Scala community is currently migrating to Scala 3 and many libraries have not been ported (Scala experts correct me if I'm wrong.) Kotlin also seems to be less stable at the API level than Java (but I may be wrong here, Kotlin experts please correct me.)This backward-compatibility does comes with costs (e.g. non-reified generics)Also, if you're a library developer and you want to create a JVM library that can be used by Scala, Kotlin, etc. developing in Java is often the best choice. For one thing it avoids any dependencies on the standard libraries of those other languages.Disclaimer: I like Kotlin and Scala, but mostly use Java.
Because Java will still exist in 5 years
I hate Java because the docker containers based on it take too much RAM. The smallest Spring JAR takes about 70-120 MB for a single container!
Hate spring instead ;)
My favorite go feature (not exclusive to go) is `implicit` interface. Once I drank from that cup there is no going back!
What a weird title change.
did that to make it a bit clearer what I was really optimistic about, but I unfortunately can't edit the hn post itself.
Does it add value types?
Thatll probably come in about a year or so going by the pace of valhalla's completion.
Is there an Ocaml vatiant for the JVM (similar to F# for dotnet)?
I know of Scala for an FP variant but nothing that's ML-like specifically.
Well, one could argue thay Scala is a ML for JVM with Java syntax
I just found this:https://flix.dev/
You could say Kotlin to some extent..
Yeah, it has nice funcional capabilities and libraries (like Arrow[0]).[0]:https://arrow-kt.io
any advice on a book/tut to learn "modern" java?
Manning's Modern Java in Action is outstanding. It assumes you already know basic Java.https://www.manning.com/books/modern-java-in-action
both suggestions here are for books that cover java 8. how is it possible that java 8 is modern relative to java 21?
Modern Java in Action (the 2nd edition of Java 9 in Action) covers Java 11 and contains a final chapter that talks about "future Java" features -- many of which are now implemented.It's a great book for Java programmers who want to make the jump to functional-style programming. If that's the transition one is hoping to make, then I would definitely recommend the book.
And I would recommend "The Well-Grounded Java Developer" (2nd edition) to those who have mastered the functional-style Java of "Modern Java in Action". It covers JDK 17 (and beyond) and also has a a polyglot JVM focus with coverage of Kotlin and Clojure.https://www.manning.com/books/the-well-grounded-java-develop...
Core Java for the Impatient (3rd) is less than a year old and updated for Java 17.
excellent - thanks
... and I agree that there is a need for a Java 21+ book which includes discussion of algebraic data types, pattern matching etc.
Core Java for the Impatient by Horstmann.
In other news, we have an upgrade path at work to go from Java 8 to Java 11 pretty soon.
We (finally) upgraded last year from 8 to 17. Lots of nice things, I’m so glad we were finally able to. But it was a big project due to some dependencies and how some things were done internally.I can’t wait for 21, but I’m not sure when we’ll switch. At least it will be trivial compared to leaving 8.
do/i/still/need/to/create/sub/directories/for/the/things/i/want/namespace?
Only if you're using vim like someone from the 70s, otherwise any sane IDE handles those things for youBut, yes, namespaces are still mapped to paths, it's not like they rewrote the JVM to use blockchain or something
>Only if you're using vim like someone from the 70s, otherwise any sane IDE handles those things for youI don't think that's quite it when Ruby is also from the 90s and figured out not to tie namespace resolution to the directory tree
I am not sure why this is a problem. Looking at the organization of the resources directory of every project I've ever worked on, I am not sure I want more opportunity for physical and logical concepts to unnecessarily diverge.
I mean, its the same idea as custom path config in TypeScript
Let's not hold ruby up as a poster child for modularity.
Yeah I really like my IDE doing stuff in the background without me knowing shit about it.
Yeah, I do like my IDE doing the tedious work for me. It's also really nice to unzip any JAR I need to troubleshoot and know exactly where to navigate to find exactly the file with the code I need.I like Golang a lot but the standardisation and verbosity in Java-land has some benefits after you get used to it enough to learn to ignore the boilerplate, it's pretty good to have some kind of consistency enforced by the VM when working in large codebases.
Yes some C# codebases end up with wildly inconsistent namespacing as you can do anything you like
I don't understand how it is doing stuff in the background.You literally ask it to move some class and then it does it. And it's very obvious what it's doing.
Then you’d be thrilled to hear about all the stuff your NVME drivers are doing in the background without you knowing shit about it. Or maybe you prefer to engrave your ones and zeroes in stone by hand?Abstractions exist for a reason. In Java, that abstraction is coding in classes and packages, not files of text.
better_than_having_just_a_single_file_that_have_lots_of_functions_without_namespacing
Or import ../../../../../asd
Yes/you/do/but/the/ide/does/it/for/you/so...
The/ide/giveths/the/ide/takeths/all/this/could/be/easier/and/you/know/it.
Yeah, just like Python, Ruby, JavaScript.
Ruby modules aren't tied to the file system
True, but they are loaded by path.
We made the jump from 8 to 17 this year! Some of our developers of course still write 1.6 level code, of course
Going from 11 to 21 is a lot easier.
Depends- one of the hardest parts of the 11-20 upgrade for us was that cms gc was removed.If you run a bunch of different microservices with distinct allocation profiles, all with high allocation pressure and performance constraints, and you've accomplished this w/ the help of a very fine-tuned CMS setup, migrating that over to G1/ZGC is non-trivial
Java sort of suck for microservices (microservices suck on their own) as it has relatively high bootstrap cost.High allocation rate feels weird with micro services - I suppose that depends a lot on the coding style. G1GC is meant for generally large setups, with several cores at least. E.g. the default setup of 2048 areas on 2GB heap means, allocations over 1MB require special care.
If you GraalVM Native Image or one of the frameworks based on it then bootstrap cost disappears:https://quarkus.io
GraalVm is great, it made our Spring REST API app go from 10+ seconds to 0.5 seconds on startup (not to mention the lower mem and cpu requirements).Except… when we try to build it with Jenkins on a Kubernetes cluster, this happens:https://github.com/oracle/graal/issues/7182
I can't help but think if you're teetering on a knife's edge, only holding on thanks to hyper tuned GC params, then you should take a step back and consider getting out of that predicament.
Is that what happened at your company?
Yup. We've clearly benefitted- G1 and generational ZGC have large advantages over CMS- but it's a lot of experimentation and trial-and-error to get there, whereas other deprecations/removals are usually easier to resolve.
Isn't the default config correct for pretty much all workloads, unless you haveveryspecial requirements? Like, at most one should just change the target max pause time in case of G1, depending on whether they prefer better throughput at the price of worse latency, or the reverse.
What were the backward incompatibilities preventing that move? I thought Java was pretty backward compatible, but I've heard this a lot.
It's more likely that there's some dependency that is not easy to upgrade, because the upgrade also includes api changes (from the dependency, not from the jdk).Compound this with multiple dependencies that exhibit this issue. If you have a "legacy" application that does not require active development, there's zero business incentive to invest into the upgrade. Unless you could prove value in having the upgrade, it just doesn't get prioritized.
Java has in recent times actuallyremovedsome apis from the standard library, and made some inaccessible (undocumented internal apis especially) so any advanced frameworks that use them would have been affected.
7 -> 8, but JBOSS 6 is a pain to migrate away from.
8 to 17 for us
Try with 8 --> 11 first then 11 --> 17
we are going ahead to 17. too much resources spent to do an intermediate step
Sad this gets to front page while a blog post which documents that .NET 8 has 200 A4 pages worth of performance improvements gets absolutely ignored.C# keeps being the language people are looking for but don't know about.
It's because C# only "recently" became cross platform in a reasonable way.Hard to overstate the mindshare that it lost for that
And it's still not as cross-platform as Java is, or pretty much all other tech stacks. FreeBSD and commercial UNIXen are not supported at all. If you prefer to develop on macOS or Linux (hi there), you don't get access to many Windows-only tools (mostly for debugging and performance measurement). Microsoft only cares about other operating systems to inasmuch as you can host the resulting application there, but really expects you to develop on Windows. Which makes sense... forthem.
For Linux and macOS you can use Rider and CLI tooling (as expected for most other langs), VS Code is up there but obviously does not come with profiling or advanced debugging tools.The bias does exist but it's going away, especially that now a lot of developers are moving over to M-series macs.
Since it is a Java thread, I’m gonna mention that ecosystem-wise, the JVM is just much much bigger and of higher quality - you very often see copied JVM packages in C# with much less features, less stability, and often even being paid.With that said, it is a cool language and platform, that is indeed underhyped.
Groovy is... not Java.
I think it is, just as Gradle is Java. Groovy is a superset of Java, and makes some parts of Java development better. I for example write many tests with Groovy or implement DSLs for my clients with Groovy.
I've written in C#.  It's Java.  If they're not the same language to you, you need to learn more languages.
Its a good language, but the corporate sponsor and community is suspect. Microsoft has a long history of user hostile actions. The types of companies that use C# often treat SWE as second class. Learning and using C# limits career options to low salary, high stress jobs.
I'm going to vouch for this comment but not because it is correct but rather it presents good opportunity to address the concern.C# and .NET are most heavily invested in by Microsoft which owns and steers its development, that is true. It is also true that JVM world sees investment from multiple MSFT-sized corporations.And yet, despite the above, it keeps moving forward and outperforming Java on user experience, performance and features despite being worked on by much smaller teams. I think it stands on its own as a measure of a well-made technology.In addition, you can look at source code and contribute yourself, 90% of what makes .NET run is below. Almost all development happens in the open:https://github.com/dotnet/runtime
    https://github.com/dotnet/installer
    https://github.com/dotnet/roslyn
    https://github.com/dotnet/aspnetcoreCould Microsoft do a better job at making it even more community-facing and attempting to make the .NET foundation as a sole owner and steering committee of the language itself? Sure. But it's not that bad either today. Quick reminder - Oracle is not exactly a saint, perhaps even worse (MSFT has never gotten into any litigation even remotely related to .NET or C#).As for career opportunities, as other commenters would note, this is highly specific to a region and does not translate globally. Again, we are discussing the "how good the language/platform is" first and foremost. I don't see startups adopting Go because of the market or trusting Google not to rug pull them...so perhaps we can do a better job so the next language of choice they pick is C#, which has much higher ROI in the hands of the good developers (for example, it can be very easy to adopt as a second language if you are well versed in Rust).
I don't have as much experience or knowledge as others in this thread, but just taking the opportunity to chime in that C# is a great language, and pretty pleasant to work with. And it was a language to which I was introduced as a 24 year old at a venture-backed startup, not at like Boeing or the company Dilbert works at or something.It has features like LINQ. It has routinely had a lot of good updates, new features always coming out, increases in performance, etc. The primary thing lacking has been good support for developing and deploying on Linux, and a couple other devops-related things. It's a shame to see that holding it back, but at least MSFT actually opened up Linux support at all (nobody thought they would).
Seehttps://isdotnetopen.com/for why people think .NET has openness issues
Microsoft uses C# internally and has a vested interest in making it better for all of its own developers, as well as making it good to increase industry adoption so it has a larger pool of skilled developers to hire from. Your arguments about who backs the language don't hold water.
Does it have a vested interest to make everything work cross-platform?
Well, Linux has won the cloud meaning it is and will be a primary target for .NET.I'm not sure what vested interest MSFT had in some of the changes introduced for iOS in .NET 8, but now it can be targeted with NativeAOT too, so there is clear investment and dev effort both from community contributors and MSFT employees to support various platforms.Somewhat arbitrary example, there is also a project to support RISC-V (https://github.com/dotnet/runtime/issues/84834).
For both reasons mentioned above, yes. Even internally, many teams in Microsoft are shipping containers on Linux for prod services.Azure is also the big moneymaker, so these days they want all their technologies to have Linux support since that's the dominant cloud OS.
Both are horrible languages and while Java libraries are abundant, most are horribly over-engineered, archaic stuff from the 2000s, where everything was about forcing OOP on every problem. Log4j executed code from an ldap server. Insane.
We live in bubbles.In my limited 6 years of professional experience as a software engineer, I have never met a single person who writes C# or .NET.
Second this. But here in hacker news, C# is hated for no reason, just the old Microsoft mantra and NET Framework
> C# keeps being the language people are looking for but don't know about.Every time I point out about C# most programmers are saying about evil Microsoft and being locked in the ecosystem. Most programmers I've met do not even know that .NET Core is MIT open-source and runs on any device.I really wish C# would be more widely used because it is amazing, and for sure 10 times better then Java.
It’s because C# is only really nice on the surface. As soon as you actually do something with it that takes it beyond its cozy CRUD, it becomes such a nuisance to work with.We have an ODATA client that we build our selves to use in our React frontend. Now, this would obviously not have been something we also used on the backend if we knew what we know now, but it’s the perfect example to illustrate my decades of experience with C#. We had the client because we use a lot of Office365 and BC36 APIs and they are ODATA, and since we had the client we figured we might as well use ODATA on our internal APIs. Which was all well and good until we tried mixing EntityFramework, ASP versioning and ODATA together. These are all Microsoft packages mind you, and they just don’t work together. They each use the Model builder magic that C# comes with, but they each use it differently enough that things become a nightmare. Which basically sums up why C# has been a terrible language for its entire existence.If you never get to those breaking points, then C# is fine. But when you use it for what you’d assume it was intended for, well… At least the ODATA experience sort of triggered my C# PTSD from back when I wrote an admin system to maintain all the thousands of school printers and computers in a municipality, which was hefty Active Directy work and an absolute nightmare to the point where I literally had to either extend or rewrite half the Microsoft packages because they either weren’t finished or outright terrible (again likely because they weren’t finished). Similar to how the ODATA, ASP versioning and EntiryFramework packages aren’t really finished right now. I mean, I can look at the road map for EF and see some of our issues as planned fixes on who knows when. Anyway, since those days more than a decade ago, it’s become obvious that if you want to do anything AD related then you need to use PowerShell and not C#, really, C# doesn’t even run in Azure runbooks and Python does so it’s obvious that Microsoft themselves don’t really use a whole lot of C# for that part of IT operations internally. And I think it’s frankly the same with a lot of things. The ODATA package seems to fall in that same “not used by Microsoft” box. Because it appears to be some sort of “fork” that’s mostly maintained by a single employee in China.So yes, if you just use regular ASP and EF without versioning or ODATA to do very standard CRUD monolith APIs it’s a language that’s both fast and productive. Sure you’ll still need to do all sorts of silly things with your Azure DevOps pipelines to get EF migrations for Microsoft’s own SQL server to work, but hey, you can. But if you’re actually going to be doing things that takes it beyond it’s “basics” then no, C# is really not the language people are looking for but don’t know about.I’m also partly in the “Java is sort of 10 years late with 21” club, but it’s not like anyone has switched away from Java in those 10 years, and really, it’s not like it was a fun experience to go through the .Net -> .Net Core -> .Net, .Net Standard and .Net Core -> .Net years, so maybe Java did it right?
Your issue seems to be with packages provided by Microsoft, not C# language itself. Model builder magic is part of those packages, not C# language. These types of libraries often make simple things quick and easy, but complex things (or just simple customization) much harder or even impossible.
I've seen this response before, but why on earth would we be using C# if not for its included batteries? I can't imagine a world where we would have chosen C# to write an API unless there were some specific benefits, and while I may be wrong to assume this, I don't think I've ever met someone who would. Not so much because there is anything wrong with C# or .Net for that matter, it's okish, it's just well... Honestly, writing C# is a lot like writing typescript with bad linting rules, at least to me. It's not that bad, but it's also not something I'd ever really want to do.
I agree with you that the choice of language should not be based solely on the language itself, but also on the ecosystem it provides for the task you need to complete.I was just pointing out that your critique was about the included batteries, not the language. Every language has some bad libraries in its ecosystem.
The point I was trying to make was that C# has nothing but bad libraries in it's ecosystem. I've worked with quite a lot of languages and I've never experienced anything like it. Well, obviously Node has an "interesting" environment, but the flip-side is that it's very easy to work with what isn't there. C#'s libraries are like half-charged batteries that you won't realize are only half-charged until it's too late.
Are you feigning ignorance about why people don’t like Microsoft?We all know C# exists
The problems with Java can't be fixed by adding new things, you can't undo decades of ecosystem development, training, and ideology built on top of the idea that inheritance is really good idea and belongs everywhere.edit: I will say that as a Java developer I am grateful every day for the improvements to the language. Java is a very impressive language and I have a lot of respect for the people working on it.
I rarely see inheritance used in practice in java code bases. Except where I would use a union type or sealed class in other languages anyways. I don't feel what youre describing is a real issue.
You must be really lucky then. In my previous job, inheritance and abstract classes were everywhere. Coupled with dependency injection frameworks that "worked like magic", it was really hard to follow the code inside that big, monolithic app. It made me never want to work with Java ever again.
I've never been a big fan of dependency injection.  It solves a problem with unit testing in Java, sure, but the reality is that Java could have done some nifty things to help alleviate that as well.
Agreed. Java injection frameworks are opaque and accomplish what they need to with overly powerful mechanisms because of the nature of the language. You don't see that sort of nonsense in python.
Wtf, so what do you think Django is?
I'm curious to understand what dependency injection is in Django that you're referring to?I know pytest does DI with fixtures, and trying to figure out what you're pulling into a test can be difficult.
In django you're importing a default cache, a default storage etc, and write your code to the interface. In settings.py you wire it all up. It's basically the same, for testing you would have to mock the import or provide some implementation.
technically that's not dependency injection, but a global service locator.
Yeah I agree on that here.The user doesn't write DI code for Django Class Based views.  E.g. the view  doesn't accept a Database upon instantiation.
Nothing to do with the nature of the language, but with the nature of the program.If you're writing a few line script, you don't need a DI container. Once your program gets large, it becomes extremely messy without one. It's no surprise projects like [1] exist.[1]https://github.com/ets-labs/python-dependency-injector
That DI library is not pythonic at all.There's nothing wrong with this at all, say:class MyClass:

        def __init__(self, my_dep1=None):
             if my_dep1 is None:
                 self.my_dep1 = get_my_dep1()  # Or potentially raise
             else:
                 self.my_dep1 = my_dep1

             [...]Then to test:def test_my_class(): 
        mocked_dep1 = MagicMock()
        my_class = MyClass(my_dep1=mocked_dep1)
        [...]
And if you want to configure the scope of `my_dep1` (singleton, transient, etc.)? What about nested dependencies? etc.
Why do I care about any of that while writing python?  Those seem like artifacts of a Java based DI system.
It's a reality of any non-trivial program, regardless of the language.
No.  Some languages don't require you to play cat and mouse games to get around artificial limitations put there by the language designers.There was a talk at PyCon a while back about that patterns commonly used in Java were non-existent in Python.
If that’s the only thing it’s used for in the project, then you are most likely good with Autowired (in Sping) or something similar.Any complicated DI solution must have a reason for it being there and I’ve seen too many projects complicating themselves on buzzwords like DI or MSOA without really needing either that much
Sounds like you’re confusing DI with DI containers.
I've seen the same craziness with NodeJS, and very simple Java services with minimal inheritance.
Inheritance used to be extremely common, look at AWT/Swing - however more or less it finished there, e.g. more than 20y back.There are still lots of folks who love 'protected' and deep hierarchies, of course. There is stuff like spring that uses way too many interfaces with a single implementation, doing something a bit off the regular road ends up implementing tons of the said interfaces anew.However the 'hate' part is mostly the internet (well esp. Hacker news)warrior topic
Great to hear. I used to program java in 2010 and inheritance  was still beeing heavily used back then. But things change, if both the lang and the main community has change to focus more on simplicity its def worth looking at again.  
Coroutines and pattern matching is really good features
Contrast that, I've seen numerous Java codebases, young and old, and inheritance is very much one of the core ways that people program.I strongly suspect that in a few cases some Java devs using net new systems and avoiding common frameworks will perhaps be able to avoid lots of inheritance but I find it insane to say that that's common or even easy.
Inheritance is heavily used in Java in 2023, at least in projects I’ve had to look at.
> I rarely see inheritance used in practice in java code bases.That seems absurd to me and I have a hard time understanding it, honestly.
> I rarely see inheritance used in practice in java code bases.Without some specific call-out, it can be assumed that this is a very niche viewpoint that has no bearing on modern development.The vast majority of projects use inheritance, today.Does it use Spring? extends SpringBootServletInitializerMeaningful responses using values from a request? extends OncePerRequestFilterFormatting exception handling responses on web requests? extends ResponseEntityExceptionHandlerThen there's all the interfaces you have to satisfy, because it's all tied into the standard library and popular libraries.
You need to inherit to create anything that is a class. But the focus is on composition. You inherit from useful classes so you can build the solution using composition.I don’t like modern Java because there’s too much non-Java magic code. Layers of stuff that “helps” but removes me from the language. Entire programs written in config and special text wrapping classes and methods. How it works requires understanding multiple intersecting languages that happen to be strung together in .java files.Edit: when something is in config it’s not checked at compilation. Every environment from dev to prod can have its own config so when you compile in dev you don’t know what’ll happen in prod. I know: let’s add more tools and layers.
> You need to inherit to create anything that is a classThat's true of the Java compiler, for which the documentation is strewn around the intenet...but an example is here:https://medium.com/javarevisited/compiler-generated-classes-...The Java syntax doe not require extending Object explicitly.eg This is a valid, useless, class:public class App {}> I don’t like modern Java because there’s too much non-Java magic codeIt seems like this is the common path for popular languages. They develop their own library-backed DSL's for the most common use cases, which are often little more than macros (@data @getter, @notnull, etc). I am biased by what I've seen in the last 30 years though.
The OP/GP wasn't really complaining about inheritance, despite the fact that this is what they wrote.The OP is complaining about the difficulty of the API because it is _exposed_ through inheritance.The complaint about `SpringBootServletInitializer`, for example, is exactly this. There's nothing wrong with inheritance. In fact, SpringBootServletInitializer is exactly what you want to use inheritance for - because you need to build your app using the servlet api.There are http servers that aren't servlet api, such ashttps://vertx.io/docs/vertx-web/java/#_re_cap_on_vert_x_core..., which uses little to no inheritance (since the api surface is smaller).
Having a single level of inheritance (especially if it's an interface) is not a problem at all. Having deep inheritance trees can be a code smell.
While you have to extend some things in Spring, yes, the whole point of the DI in spring is so that you can often compose instead of extend.
If you type everything with interfaces in your codebase, you are much less tied to inheritance. In fact, everyone could be written to be composed.However Java doesn’t support type union so you can get into some ugly and verbose situations but the JVM doesn’t really check type so this is more a compile-time issue and could be fixed in a future Java language revision.
>However Java doesn’t support type union so you can get into some ugly and verbose situationsIsn't the "sealed interface" described in the OP blog post a type union? Or you mean anonymous unions?
Definitely referring to anonymous unions too. Without them, there’s still friction sometimes which makes union types unnatural.I haven’t written Java in a while and I can’t remember if you could sometimes fake a type union using a generic type on a method, but if you can, it’s definitely super ugly and would raise eyebrows during any code review.
Anonymous unions are a relatively rare feature; Rust and Haskell don't have them, for instance.
Sorry, what? Is not java toghether with Ruby maybe the most hardcore OOP enthusiasts that uses inheritance for "most stuff".Has the java culture move so far the last decade ?
Effective Java, written by Joshua Bloch, and first published in 2001, had a very influential section called Favor composition over inheritance:https://books.google.co.nz/books?id=Ra9QAAAAMAAJ&q=inheritan...Why do you think DI is so prevalent in Java codebases? It's a great way of simplifying composition.
>had a very influential section called Favor composition over inheritanceThe GoF book (Design Patterns) had the same, somewhere early, like in the Introduction, in 1994:https://en.m.wikipedia.org/wiki/Design_Patterns
I’ve been writing OOP code and reading about it for a decade or two, and inheritance was identified as problematic pretty quickly. The problem today, imo, is more underuse now.
>inheritance was identified as problematic pretty quicklyExactly what I referred to here:https://news.ycombinator.com/item?id=37539443
Yeah, it’s a bit like how the school version of lisp makes people think real lisp code bases are all lists and recursion.
Funnily enough, it actually started from C++. And, Java is so large that it is simply meaningless to talk about a unified style -- sure, some Java EE behemoth will continue to run on a complicated Application Server for decades still, churning on its workload, but so will someone write a Micronaut microservice, or something for robotics, and these will all have distinct styles.With that said, even the Java EE/Spring complicated word has been moving towards a less inheritance-based future.
Even in Ruby, IME,deepinheritance is fairly uncommon.Wideinheritance through mixins is common, though.
HtmlElement. AST. Socket. Stream. Window. Closable. Runnable.
Examples of classes where inheritance is indispensable. I cannot imagine what kind of programming you are doing where that pattern never comes up.
There is nothing wrong with inheritance. But sure, there is usually something wrong with deep inheritance or using it, where better solutions exist.
No, there's a lot wrong with inheritance. It leads to all sorts of issues and while theoretically one can keep the tree 1 level deep, in practice it's too tempting to expand the hierarchy.This is one of Java's big issues. The other is reference equality as a default, pretty horrible. Records help but records are also limited in when they can be used.
"in practice it's too tempting to expand the hierarchy."Not anymore, if you got stuck, by doing that once too often. But 2-3 levels can be allright as well. It depends, what you are doing amd with whom.
> No, there's a lot wrong with inheritance.No, there is a lot wrong withbad code. No need to blame the language or any programming concept.Note that I say that for all programming languages, not just Java.
That's a difference between a dangerously unsafe tool and a good tool. By unsafe I mean providing enough of footguns to shoot yourself in the foot. Java has a community of people that indulge in teaching about inheritance as the first thing after classes in their "OOP" lessons. This ingrains the habit in beginners.
> By unsafe I mean providing enough of footguns to shoot yourself in the foot.Just to play on the comparison: would you say that a gun is a "dangerously unsafe tool"? I would tend to think that guns have been very well optimized over time, and I don't know of a gun design that prevents me from shooting myself in the foot. Actually that would be a limitation of the gun.But we all agree that people who use guns need to learn how to use them properly. Why doesn't this apply to programming languages? How did we as an industry end up in a place where it's considered the norm that developers don't really know what they are doing and need some kind of child safety in order to not hurt themselves?
Yes, guns are dangerously unsafe, they're designed to cause harm. It's hard to reconcile that goal with the need for safety. That said, guns do have safeties - guarded trigger, safety switch, drop safety, etc. [1].The general principle is to design in as much safety as possible without compromising the intended purpose of the tool too much. The degree to which this is possible varies. Inherently complex and/or dangerous tools like guns, cars and aeroplanes require significant training before safe operation is possible. Most tools however can be made perfectly safe to use for anyone without any special training. Like plugs and outlets [2].Programming languages are no different. The history of PL design is defined by the ever increasing restrictions placed on what languages let programmers do in the pursuit of safety & correctness.But really, we humans, especially programmers, have no clue what we're doing and need all the help we can get.[1]:https://en.wikipedia.org/wiki/Safety_(firearms)[2]:https://youtu.be/139Q61ty4C0?t=42,https://youtu.be/139Q61ty4C0?t=105,https://youtu.be/139Q61ty4C0?t=205
It seems you conflate the tool and the education about the tool?Why is Java itself bad, because some people (maybe) teach it wrong?Also inheritance as a first lesson with OOP is not bad either, if the follow up is sound. But as far as I know, the concept composition > inheritance was already taught 15 years ago.
If we look at other modern programming languages, some don't even have inheritance. Lets take Rust for example. The language from the get go avoids the trap of deep inheritance hierarchies, by ... not having classes and inheritance! Instead it has structs and traits you can implement for the structs. Behavior separated from structure. They learned from the mistakes or design flaws of the past. Sure, Rust is not perfect, but this aspect about it I really appreciate. I am sure though, that someone somewhere will implement something resembling inheritance and create footguns anew.Lets compare with Java. Java has forced everyone for decades to shoehorn everything into classes (sometimes an enum, sometimes an abstract class, whatever). Last time I checked it was still impossible to simply open a file, put a function (!) inside and be done. No, Java forces you to wrap that into a class or similar construct, as if a function in itself was not enough and not self-sufficient. There is a whole mindset behind this, that seems to come from an ideological "everything must be a class, because then I can instantiate and then I haz objects and can call methods". Other languages don't need classes to have objects.Decades fast-forward. Java learns, that lambda expressions are a nice idea. Java will offer structs. Java learns, that lightweight processes are very neat to have. And despite all that, the old footguns still remain and could only be undone at significant cost, because of backward compatibility. This is where programming language design sins really rear their head. PHP suffers from the same problem. Horrible standard library, but cannot be fixed, unless you break backward compatibility.On one hand you can state, that it is all on the programming, who is "holding it wrong" or needs more education. On the other hand, the programmer can choose a better designed tool, that doesn't cut their fingers every time they try to use it. Just because it is possible to do a good job with Java, that does not mean, that Java is a good tool for the job. It means you can only let the most experienced people work with the tool, instead of what we have now, every Billy knowing Java, writing classes and getting a kick out of inheriting from a super class.Good teaching will avoid weighing things one should avoid disproportional. There is no good reason to teach inheritance early on. It should be a thing taught on the side, something one quickly glances at and says: "Yeah, that also exists, but lets not get into that much, as we will not need it much ..."But in Java you probably can't avoid it for long, because you will want to make use of some library sooner or later and library authors might force you to make some class inheriting from their library's class, define a behavior and pass that in. But often that is not enough ... No no no, you need to pass in a factory for classes, that implement an interface, and their methods will implement the actual thing. I have seen this recently for logic of checking, whether a password is valid/acceptable. Why the heck do I need to implement a factory for that, when the actual task is simplest logic, checking whether the password has all required kinds of characters in it?Usually this is completely overblown, because you want to pass in some behavior, that could be expressed as a simple function. I shouldn't need to create some brimborium. All I should be required to do should be to implement the logic in a function and pass that as an argument to the library.The existing ecosystem forces its "OOP" on you. If you are not willing to throw out decades of ecosystem, which actually is the main advantage of the JVM, then you will need to deal with the cruft that has been created before.
Ok, you don't have to convince me that Java has many problems, as I intentionally avoided Java for some of those reasons for the last 15 years. But thanks for reminding me of some of them ..But the concept of inheritance I like. And I use it succesful allmost daily. And like I said, I am aware of how you can use it in the wrong way. And my code surely is not perfect either, but the flaws I have, do not come from inheritance. Those parts are actually very clear, solid and stable. And still flexible.And Rust is trendy I know. I have never used so far, so it was news to me, that they don't even have inheritance, but to convince me, that Rust has the superior concept, I would like to see it to be used as widely as inheritance languages first.
[..] a programming language designer should be responsible for the mistakes that are made by the programmers using the language.It's very easy to persuade the customers of your language that everything that goes wrong is their fault and not yours. I rejected that...- Tony Hoare
I feel like it often goes in the other extreme: "if a 2 years old cannot use it, it's too hard".I am fine with requiring that professionals know their tools, even if I'm well aware that this is not the norm.
Love it, and love using plain ol' functions for it
Inheritance is not necessary for code reuse.All you really need for that is named procedures. A way to combine modules and different files certainly helps too.Type hierarchies can even hinder code reuse, because you can’t just pick the stuff you actually need.
That question seems blatantly disingenuous.
Composition > inheritance.
Please ELI5 what is wrong with inheritance and/or how Java have it wrong. Do we need to go back to a new object oriented undegraduate course? Genuinely asking.
"Prefer composition over inheritance" is actually a well-known mantra and appears in, for example, the Design Patterns book from 1994, which is basically the OOP bible. And this iswithinthe OOP bubble, you won't even find inheritance outside of it.https://en.wikipedia.org/wiki/Design_PatternsDon't take undergraduate OOP courses seriously.
> a well-known mantrawhich isn't an explanation, but just the same as the OOP mantra that was taught in undergraduate courses.
One reason is the unstable base class phenomenon. A some changes in the base class require you to constantly change all your derived classes.
"What OOP users claim" ->https://i.imgur.com/KrZVDsP.png
Inheritance is fine. It helps to avoid code duplication for logic that requires encapsulated data (private, protected fields).The problem is what if you have a class that needs to derive behavior that's in two (or more) classes? Multi-inheritance is terrible because it becomes a nightmare of which class overrides which.If there's a shallow level of inheritance (1-2 levels deep), then there's nothing wrong with it. Things like composition for most use cases has been common advice since forever.What happened with java was that there was a massive movement for enterprise code that way over-complicated everything based on ideas that didn't pan out. There were all these auxiliary patterns, and ideas that people had to learn to be onboarded onto projects, and so many people poorly understood them that it led to even more spaghetti code, too many people that developed using dogma instead of common sense.
With compositions A uses B but B can never use A.
With inheritance Child can use the Parent, but Parent will also call the Child 
 (virtual methods) which in turn can call the Parent again etc.., so the code can become difficult to follow. It can become very complicated with multiple inheritance and multiple levels.
Such code would be difficult to follow regardless of whether you use inheritance or not. Sometimes, two pieces of code developed independently just need to interact very closely with each other.Remember that OOP and inheritance to some extent came out of the need to develop GUI systems. Inheritance is still heavily used in GUI toolkits because it's a good fit for that problem space. You have graphs of objects that need to be treated at different levels of abstraction, and controls often need to customize (override) or implement some behavior that shouldn't itself be a part of the public API.Attempts to get rid of inheritance and OOP in UIs end up looking like Compose or React. I found very quickly when working with these that pure composition just wasn't sufficient and these approaches have their own issues; problems that OOP trivially solves become difficult to impossible to solve cleanly without it.
I've certainly done that in the past, but not since I changed jobs ... 7 years ago. Probably not for several years before then.
> you build a classification of all life and it is built upon the idea that everything "is a" plant or animalWith all due respect, this and similar examples are just plain wrong, and I really can't take anyone seriously when that example is used. The point of programming, and its abstractions is to help youcomplete a task, and make the implementation maintainable and easy to reason about. I think grabbing the "is a" part is fundamentally bad -- there is no point in creating a taxonomy in and of itself, this is no database for that data. Inheritance sometimesisthe correct abstraction and while it is definitely overused, when it's correctly applied there isn't really another abstraction that would fit better. E.g. see a graphics library's Node class as the stereotypical correct application.
I think your post can be broken down into two main points.1. That my point is bad for some reason2. That inheritance is sometimes a great toolWe agree on (2). Inheritance is pretty amazing, even if I think that it's ultimately a terrible feature to build so ingrained into a language and to expand in power to such a degree.As for (1), I don't really get your point. Abstractions help you complete a task - ok. Abstractions are to help you reason about stuff - ok. Something about "is a" being bad? None of that really explains why my example demonstrates the problems you run into when you try to build a classification of values using inheritance. But I also said that I wasn't going to really try to explain much, it's been written about plenty.
> This is not a fun situation to deal with and inheritance makes it a lot harder because the "is a" relationship is driving a ton of your logic.Judicious OOP design allows others to change behavior based upon needs that perhaps the original coder never thought of.I would not call most Java OOP design judicious.  The control in Java is owned by the library writers and the language devs -- not the people using it.
What is a language with judicious oop design? Asking to know
I tend to be fond of Python OOP styles.
This problem is partly a type system limitation however.In a more flexible type system with union types and other magical features, your example problem would be less of an issue.However Java has an extremely limited type system so there is no middle ground between composition and inheritance. Once you choose one way, there is no “middle step” to migrate over.
Union types are very rare (scala, typescript are the notable ones I can think of that implement it), most other languages only have sum types (which includes java as well, see sealed interface/classes), where you have to create each unique set of types you want to use separately, wrapping each option into a marker type basically.
In cases of refactoring, inheritance seriously sucks.But it is quite advantageous when, as you say, your model is well thought out and stable.
If you want to see how codebases work without inheritance in practice, I suggest checking out Go, which features polymorphism through interfaces, but not full-fledged inheritance
Prefer composition over inheritance has been a common mantra for at least a decade, if not more. Maybe you should undergo the last decade of development and training.There will always be shitty devs, and since java is one of the biggest languages, it definitely has more than some ultra niche academic language no one uses. I don't think it is the fault of the language though, or if that somehow were a reason to choose a different language. Should a decent BMW driver sell their car, because plenty assholes buy that car also?
Just because everyone has been saying "composition over inheritance" doesn't mean that that's how things get done. Jump into any Java codebase and you're 99% likely to see inheritance used as one of the primary abstraction mechanisms.> Should a decent BMW driver sell their car, because plenty assholes buy that car also?A better analogy would be "Should you drive on the street where all of the shitty drivers do donuts and street races?"
> Prefer composition over inheritance has been a common mantra for at least a decade, if not more. Maybe you should undergo the last decade of development and training.What are some other well known mantras?  The null reference is a billion dollar mistake?  Minimise mutability?Maybe the language designers and library writers could catch up too.
Records and value/primitive classes are immutable, not to mentionhttps://openjdk.org/jeps/401
Inheritanceisa useful feature, using bad abstractions is a user error.Nulls are an error in that no language feature solves them (though third-party tooling does), so far at least.
Yeah, I think this is the part that gets me. To be fair, I thinkwell designedJava is flexible in exactly the right ways for an enterprise development. The trouble is that enterprises don't typically pay well enough to get people who arereallygood and thepopularways of building Java applications are not great.
> ideology built on top of the idea that inheritance is really good idea and belongs everywhere.Those are two different ideas.
I used the word "and" to indicate that, yes.
I think a comma would make it less ambiguous.Starting that single though with "The" indicates to me that you don't think those are two different ideas.Compare:the idea that inheritance is really good idea and belongs everywhere.With:the idea that inheritance is really good idea. and belongs everywhere.
I think that would actually be an erroneous comma?
> This set of changes allows Java to express one of the foundations of functional programming that the language never could before - Algebraic data types, along with idiomatic ways of using them.And here I thought the foundation of functional programming wasfunctions, which Java still doesn't have.Seriously, functional programming is about functions, not types.
> functional programming is about functionsdifferent people mean different things when referring to functional programming.Some people believe that functional programming are using higher-order functions like `map`, `reduce`, `forEach`, etc, which takes a function as a parameter, instead of doing imperative loops.Some people, in addition to above, believe that functional programming is about creating functions that take a certain 'shaped' parameters, to allow for automatic checking.And lastly, the "real" functional programmers are people who believe in referential transparency in your functional program.
How is Math::sqrt not a function in Java? Sure, it’s called a static method and it lives in a class - but is it meaningfully different from the same being a function in a Math namespace in say, C++? You can static import it even and use it as a function. This is just needless hair splitting imo.
> And here I thought the foundation of functional programming was functions, which Java still doesn't have.> Seriously, functional programming is about functions, not types.Well it does have methods and it does have "Functions" (not to mention "Bifunctions", whatever those are).  And there's certainly nonsense around exceptions and referring to outer variables.  And no currying.But if I understand you correctly, you real complaint is about not having effect-free functions, right?  But then it becomes about the type system again, because that would be the mechanism to prevent effects.
Can you convince me to use Java? I’ve never used it (only C++, Python, CL) but it feels bloated and dirty.
None of the memory problems of C++, the speed of C++ most of the time. Thousands of high quality libraries, a JVM that is a marvel of engineering after 20 years, tooling for development, monitoring and introspection of exceptional quality. Many of the internal tools at the largest Cloud developed in Java. Most enterprise level software. NASA extensive use of Java. A team behind the development who has stunning common sense in resisting the latest fads. Support for IEEE 754 that took years. AOT compilation...The infra behind most internet banking sites out there. Use in high speed trading.What else do you want from the ecosystem?
What would be a modern IDE for Java?I remember programming Java in Eclipse. And it was powerful for the time, but everytime I read bloated, I automatically think Eclipse since then..
https://www.jetbrains.com/idea/
and also FOSS (Apache 2):https://github.com/JetBrains/intellij-community(as well as PyCharm found in the "python" subdirectory)
IntelliJ is very good.
Eclipse has seen vast development in the last few years and is fast and easy to use these days.
Another rather new option is VSCode + the Java plugin
>” None of the memory problems of C++”I’m sorry, I’m calling BS here. You can still leak memory in Java.
You can leak memory in any language. That’s an impossible bar. The problems op is referring to is obviously about memory safety.Java obviously isn’t thread safe like Rust is, but it’s typically safer than C++ on that front too.
Rust isn’t thread safe either. It’s borrow checker will attempt to correct you but you can still run Rust unsafely.
As I understand it Rust's unsafe is designed so you can encapsulate unsafety behind a safe interface.It's up to the programmer to verify the safety of code using unsafe. But it they do so correctly then you can rely on the borrow checker to verify that everything else is safe.This means that when you run into a thread safety bug in Rust code you should only have to look at the unsafe blocks to find the culprit.
With that said, I think it is important to mention that if you go off the safe path in rust and you do hit such a bug, your current execution is no longer trustable, it could have corrupted the heap, introduce UB, and die with a segfault, etc.In java, race conditions can enter illegal application state, but their scope is much more limited. NPEs are 100% safely handled, etc. you can only get off the safe road with using Unsafe unsafe, and manipulating the JVM’s inner state which is not even allowed by default. Depending on application, this difference may matter a lot!
There are two kinds of leaks IMO. The one where your algorithm allocates gigabytes needlessly (and cannot be avoided by language design) and more insidious stuff like having to unsubscribe from an event handler for your object to be dereferenced.
Shitty code is shit in any language. What's your point?
Isn't that true in any language that lets you allocate memory?
var list = [];while (true) {
  list.add(1);
}Here you are, which language won't leak memory here?Also, which language will let you connect to a prod instance without a performance hit to get some stats on the heap and its allocated objects? Hell, you can even list every instance of a type as I've recently learned.
>var list = [];> while (true) { list.add(1); }idk, I don't think endlessly growing memory usage is really what aleakis, a leak is really when you have no way of accessing the allocated memory to free it (ex. dropping the last remaining pointer to a `alloc`'d block in C) or the opposite in garbage collected languages: accidentally holding onto a strong reference to objects that should be freed.
> the opposite in garbage collected languages: accidentally holding onto a strong reference to objects that should be freedSo basically what I gave an easy example of. Sure, it won’t look like this in practice, you probably accidentally keep adding to a list, or a cache, but basically this is what happens. The former kind of leak can’t happen with tracing GCs.
You can. But you have to try rather hard.
> Every time I see something like this I roll my eyes... C++ doesn't have any "memory problems".You can choose which report you would prefer: Microsoft's, Google's 65%, ... I'm sure they just hired bad developers that don't understand pointers.Sure, human problem, but if no human can use the tool correctly, then surely there is some problem  with it. And no, that doesn't mean that memory unsafe languages don't have a place, but we really should have a very good reason for going down that road.
I understand pointers, yet I can’t be trusted never to make a mistake with them. “Each mistake will go uncaught and become an unpredictable catastrophe” is a language problem when your target audience is made of meat.
"But that's because the human's dumb, not a language problem."If everything is the programmer's fault for being dumb, then Brainfuck is an excellent system language.
> C++ doesn't have any "memory problems"Well, every time I see someone claim this, I roll my eyes.
It must be hard being perfect. The rest of us will keep looking for solutions for mortals.
I’m a fan, long time fan, but I can honestly say that I feel Java is one of the most pragmatic development systems on the planet.It can do most anything. It can do it most anywhere. And you can code in it using several different paradigms.It’s easy to install, it’s easy to be instal several versions, the footprint, by today’s standards, is not enormous.It’s easy to deploy, especially server side. While you can certainly do all of that modern stuff with containers and what not, it’s not really necessary for Java. Drag and drop a JDK install, anywhere. Plonk your Java server code, anywhere, and point it at your JDK, and. . .that’s it! Fire it up. The JDK is remarkably light on dependencies.And since most Java apps are “pure Java”, the apps rarely have a dependency outside of the JDK. And since Java apps routinely bundle their Java dependencies, the apps don’t stomp on each other either. Even SQLite bundles it’s binaries in the Java Jar file. So wherever that jar goes (again, and typically bundled with your app), SQLite goes. No floating dependencies.Desktop bundling requires a bit of search engine research, but it’s doable. And the runtimes can dwarf something like Electron installs.As a language is Java ELEGANT? Not particularly. It has its own elegance in some areas but that can break down or get overrun in others.But, boy howdy, it sure is practical. The ecosystem is so huge. It compiles really fast. I marvel at the stories folks tell about their dev cycles in other languages. How do they get anything done, besides sword fighting?I love Java, but I’m very comfortable in it. But the Maven based dependency system works, it’s huge, it makes use and reuse simple. The IDEs are powerful and mature.And, finally, Java’s not dead. Hardly. Oracle has been a surprisingly good steward (with warts, as always). The language has been on a rocket of development and shows no sign of slowing down. Server side is still very hot with all the frameworks and all the different approaches. Things like GraalVM taking the JVM in a whole new direction.And, yea, that. I’ve only been talking Java the language, not the JVM itself per se. That’s a whole other thread.
Throughput in Java can be quite high, and latency can be quite low. You still occasionally get latency spikes from the GC, but these days that's not so bad. (If you areextremelylatency sensitive, stick to C++).Dependency injection frameworks are your bread-and-butter in server-side Java, and some can take a while to grok, but Java can be very productive after the chosen framework "clicks" for you. Typically, this means you'll be writing constructors or factory classes that construct your dependencies per request. The way you wire your factories into the system differs by framework, but it often involves using Java's annotation syntax.Not having to worry about memory management is a huge win for productivity over C++. Likewise, constructors in Java are much more sane than in C++.Classical object-oriented programming is intuitive, and Java tends towards the "one obvious way to do something" paradigm. I find it pretty easy to hop into legacy code bases, if I already know the framework being used. The collections API in the standard library is one of the best classical OO APIs out there.The JVM provides great visibility into the performance of your system. A lot of instrumentation comes "for free".I'm not sure where you get the "dirty" and "bloated" feeling from. By any definition I can think of for those words, Python would be in the same bucket.
>  Java can be very productive after the chosen framework "clicks" for you.you can chose to not use DI frameworks at all..
DI buys you maintainability.Without DI, there's too much flexibility in how objects get constructed. If you want to add new functionality to a legacy code base, it can be difficult to track down the different integration points and slow to plumb through your dependencies. These projects can turn into spaghetti very quickly.DI solves this with a simple recipe: define your functionality, define your dependencies, wire it up to the injector.The pattern is useful in all OO languages, Python and C++ included.
the problem is that those DI frameworks are all adding substantial amount of complexity and brain load.I started using just static factories in my code, and abandoned all those DI and it works well enough.
> I started using just static factories in my code, and abandoned all those DI and it works well enough.i have done this as well (though not in java), it makes knowing what gets initialized how and where much easier and faster to debug
Yes, I agree that Python can feel “dirty”, although not necessarily “bloated.”
urllib... getopts...There's as much useless junk in Python's standard library as there is in Java's.
What's dirty is trying to get a python project reliably running on all dev computers. Pyenv, venv, wheels, suddenly you need a complete rust or c toolchain etc. With java I haven't had those kind of issues the last decade, it just works. With python it's still a big hassle and everything breaks every update.
To be fair, getting all those scientific library binaries compiled and installed was a huge pain even before python came around. Python's toolchain made it better, but only marginally in some cases.
Sadly this isn't just the case for scientific Python. E.g. some widely-used web library (I forget which) recently switched to using a Rust implementation of TLS, and suddenly you needed a working Rust tool chain available to install it. This caused a lot of grief.I love Python, and I've been experimenting with Rust and enjoying it so far, but this situation could have been better handled, I think.I agree 100% about scientific Python though. It's a whole new level of horrible when it comes to dependency management.
Java itself is a nice language that can be lean and mean but has long been culturally bloated by early tooling and conventions. Since Java 8 (~10 years) the tide has reversed and it now mostly accepted to write terse code that is to the point.The language gets updated regularly and is managed very competently. Although it may seem to trail on some aspects vs other langs, it benefits from second mover advantage - new features are done right, for the right reasons.Any Java code ever written is essentially eternal, both in text and compiled bytecode form. Compiler and VM compatibility guarantees are unmatched. You can stumble upon 20 year old code and just use it.The platform is mature and robust. The JVM itself is a marvel of engineering.The ecosystem is extremely rich. There isn't a problem that wasn't addressed by a library or a stack overflow question.The tooling is unequalled. IDEs can reliably perform large code transformations because there is no preprocessor or macros and the type system is relatively sane.If you know Java you'll never be out of a job.
Bloat is a meaningless word. One person's bloat is another's essential.
How could you possibly like C++ but feel thatJavais bloated?Like I academically understand disliking Java but this just makes no sense.
I think people are understanding 'bloated' differently.I agree C++ is bloated in a 'just make it a setting' / 'add this feature' / 'kitchen sink' sort of way.I agree Java is bloated in a boilerplate, empty directories, maybe except for another directory, 'oh god the boilerplate' sort of way.
> I agree C++ is bloated in a 'just make it a setting' / 'add this feature' / 'kitchen sink' sort of way.Interesting.  Can you expand on this, explain more?  I honestly don't know what you mean or are referring to -- and I'm a heavy modern c++ advocate -- but suspect if I did it might expand my mindset/viewpoint a bit. :)
Honestly I haven't actually used it since C++14 was new, but it's a common complaint IME that each 'edition' (as Rust would call it, I don't know remember the term, standard?) adds too much, there's too many ways of doing things, variations of pointers, boost, and so on.I think a lot of people wish it had stayed at say C++7, a mature C superset, but that's enough now. I probably should have said 'I understand' rather than 'I agree' - I don't feel strongly, I don't use either of them.
Ohhh, I get what you mean now, thank you!  I understand (and mildly disagree).  :)Yeah, C++ is a living language, I can respectfully see that bothering some people.  I viewed c++98->c++11 as essentially a new language with c++14 and c++17 being "bug fixes" for the "new language" that is c++11.  But certainly, it can require more learning about every decade now.
I think of Java as more bloated than C++ at runtime - with C++ I can make smaller executables that start up faster, use less memory, etc.But if you are talking about the source code itself, then things are quite different.
???I'll answer your question with a question:  Have you seenhttps://github.com/EnterpriseQualityCoding/FizzBuzzEnterpris...?   :)I'm guess that to those of us who remember when Java came out, "FizzBuzz: EE" is what we think of when we think of Java. :PIn Java I have to type a bazillion characters to get anything done!  And make all these useless directories and files and InterfaceClassFactoryProtocolStreamingSerializer BS. And worry about how that executes.C++?  No bloat*, just speed*Yes, there's some _optional_ bloat.  But compared to Java? no contest.
> In Java I have toYou have to do literally none of these things to write working Java.
When java came out? So mid 90s c++ vs mid 90s java?
I mean...Java is run through a VM while C++ is compiled to native code.I can see that being used as a reasonable argument for bloat.
> run through a VMThis is just incorrect use/understanding of Java’s execution model. It does have a runtime, but it is definitely not a VirtualBox VM.
What are you talking about? No one brought machine/platform virtualization into this conversation other than you.The bytecode interpreter for Java (and other similar languages) isliterallycalled a Virtual Machine, due to the way it functions:https://en.m.wikipedia.org/wiki/Java_virtual_machineIt would seemyourunderstanding of the Java execution model is flawed.
C++ allows for much more terse code than java when you do small projects. It is popular in competitive programming for that reason, not just because it runs fast but also because it is really fast to write algorithms in it.
You don’t have to use Java. All the languages you’ve mentioned are fine. If you think that using Java to solve a particular problem is a good idea, then you should definitely use Java.
What feels bloated and dirty?Because there is plenty of bloated and dirty stuff in C++ and Python too.
What convinced me to consider Java just recently is GraalVM. I don't know about the "dirty" part, but at least GraalVM might solve the "bloated" part. Compiling to native standalone executables makes a big difference to what Java is traditionally known for (portable bytecode but requiring the JVM). Been using C++ and C# for a long time now, and my pet peeves with these languages were also only just addressed relatively recently (C++ getting modules and native AOT for C#). Java being able to get natively compiled makes it worth considering among these. Now, for me, it's a matter of what other frameworks/libraries available for the respective languages would get the job done while I only have to rewrite little to switch among them if I try my best to stay within their syntax overlap.
I work on a Python codebase now after years of JVM and here's what I miss, static typing taken as read.* Threads that can use more than one core.* The best approach to package management I've ever seen, no-one worries about typosquatting or "someone already registered all the cool crate names" because every package has at least two coördinates - a group id based on a DNS entry you must be able to prove you have access to, then the package name. So I can publish my malicious package gauva, but as I can't register it with the group id "com.google.guava" or even "com.google.gauva", no-one is going to mistakenly use my package.* No fucking dance of the C libs. Or Rust these days. I want to use a Python package that wraps a C lib, but there's no binary wheel built for my version of Python and/or platform arch, so build from source it is. Which I'll figure out when pip install -r breaks, and then I get to a) apt-get/brew/etc. install the lib and/or headers b) install any compiler toolchain needed buy not yet present c) export compiler flags and header locations d) all of the above,  and then run my pip install again. Until the next library breaks.* Intersection types for generic bounds. I don't need it that often but when I do, I really miss being to say that for `def foo(ex: T) -> Z`, T must implement interfaces A and B.* Logging. Occasional horrible security holes aside, Java's logging story is one of the best I've ever worked with, compared to it, Go's sucks, Python sucks  more, like how you can't set your preferred timestamp format AND include millis without writing a custom formatter (seriously, go look at the source code of logging.Formatter.formatTime...)* JMX and MBeans. Having detailed VM performance metrics and the ability to change exposed values or execute an exposed method at runtime built into the VM is amazing. Want to have a quick look at what's happening with the GC? JConsole in. Want to set one logger in particular to DEBUG to see what's going on in prod without having to restart anything? JConsole or jmxterm and away you go. Want to experiment with your batching parameters under prod load to find the sweet spot for throughput? Expose them via an MBean.* No need for pyenv, virtualenv, etc. Although being fair, if you're working with different incompatible JDK versions, you'll usually end up using SDKMan like Python uses pyenv, and Maven needs a little bit of additional configuration to locate your toolchains, but Gradle is smarter about finding your available JDKs.* Libraries with type signatures, makes for far easier code reading, and if you pass **kwargs 5 levels down, I hate you. Yes you, sentry-sdk...* Libraries with correct type signatures, looking at you confluent-kafka, either publish type stubs to typeshed, or update your goddamn doc-string type hints so my IDE doesn't think that confluent_kafka.Message.value() is missing a parameter.* The ecosystem. I really really really miss the ecosystem of JVM FOSS packages.* The speed, in general.I'm sure there's more, but these are the pain points I've been having of late.
Id rather say use kotlin. It comes with a better type system with explicit nullable types, proper closures, and syntactic sugar to easily enavle beneficial programming patterns.Nd it is very compatible with Java itself, interop is dead simple
Finally Java catching up with some basic features that Scala has for 10 years or so. Hoping that more good stuff from Scala will get into Java soon, maybe at some point I can try to use Java again. :-)
Big firms I have worked at still using Java 8.Dead.
We have an app that also needs to be able to run on Android, so we are held back by the shitty Java Google implements for Android.
You can use [limited] Java 17 with Google's Android.
The compiler converts Java 17 -> Java 8 bytecode.
I agree that many companies are “stuck” (through their own choice really)… but at least Java is moving now.In many ways Java’s boringness is a feature that keeps it easily maintainable, at a low - easily recruitable - skill level.
At least you can now run Minecraft 1.7.10 on Java 17 -https://github.com/GTNewHorizons/lwjgl3ify
What a marvel of engineering.
A lot of Apache projects still use Java 8 :(
Has anyone used virtual threads?  I tried to migrate my app over to VT's and kept experiencing random deadlocks and I couldn't figure out what was causing them.  I tried moving all the synchronized blocks to reentrant locks, but that didn't work.  I also tried turning on the TV debugging system properties, but none of them printed the problem.
As someone writing code on Java since v1.0 and making tech strategy decisions on the C-level, I consider myself sane and experienced enough to say that Java is something that will do the job well and can be the primary choice for startups and new projects. Kotlin as a platform is not mature enough to deserve the same qualification.
> Kotlin as a platform is not mature enough to deserve the same qualification.
 With
(1) a lot of Java backend projects migrating to Kotlin (let's be negative and assume 20%); (2) all of Android running Kotlin, which is around 80% of the world's mobile phones; (3) the world's best IDE authors building features and improving Kotlin; (4) the language being almost 13 years old at this point; and (5) Kotlin being 100% compatible with Java in both directions,
I wonder what additional maturity would you be looking for. Can you point to a specific problem?I mean, of course, Java has been here since forever and we've made careers out of programming for JVM. I'm wondering if you are referring to a specific maturity issue, or just want to highlight that Java was here for longer... if it's the latter, I don't think it can be a valid argument against Kotlin or in favor of Java.
Hard agree on the maturity, it's clear this person has literally just decided that Kotlin is immature despite it flying in the face of all facts
The job of software engineers is to translate a business domain into software.Different languages are better or worse at modeling different domains of problems.I have seen the same problem solved in different languages take 2-3x the amount of work and have a large difference in ongoing maintenance costs.Java's reliance on traditional OO means that only a small subset of business domains naturally map to the language's constructs. People get good at modeling problems in Java, but that doesn't mean Java is the right language to model all problems in.A problem that is best represented as stateless functions processing data is a miserable fit for Java, a problem that is best represented as thousands of threads going off to do independent work and then unifying results, is a bad fit for Java.Sure Java can be used, and I'm sure as an experienced Java developer you instantly thought of how to model those problems in Java, but experienced users of languages that map naturally to those problem domains don't have to think of how to translate to their chosen programming language, because the language is a natural fit for that particular problem domain.As a trivial example, I once saw Java used to parse a raw binary stream that had a lot of unsigned ints in it. Miserable usage of Java, tons of wasted space. In a language like C/C++, or even C#, it was possible to just directly map a structure onto the raw byte stream, but for Java they had to read each unsigned 32bit INT into a 64bit INT to ensure no overflow.Horrible mismatch, lots of unnecessary allocations, ugly code, wrong tool for the job!
> Java's reliance on traditional OO means that only a small subset of business domains naturally map to the language's constructs.In my career I worked on a really wide range of business domains and have not even noticed the problems you are talking about.The problem of mapping certain  types like unsigned int that you mentioned is rather rare integration scenario. There’s not that many domains where numbers with the most significant bit are important, but MAX+1 size numbers are not.
> In my career I worked on a really wide range of business domains and have not even noticed the problems you are talking about.How many other programming paradigms have you explored in depth and built solutions with?Back when I did OO in Java and C# I didn't think twice about it, converting things to an OO paradigm was second nature, but once I stepped outside my comfort zone and learned of other modeling techniques, I realized that I had been jumping through extra hoops to get to where I wanted.
> I have seen the same problem solved in different languages take 2-3x the amount of work and have a large difference in ongoing maintenance costsI am sure none of this experiences were basis for an objective experience, there are too many variables. But surely, there are (very few) problems that doesn’t fit Java too well, though it is not an OOP-only language, it is a multi-paradigm one, with many FP concepts seeping into it.E.g. for some ultra low-lat audio processing I wouldn’t choose it, your binary stream processing may be another good example, though it depends on a bunch of factors and in many cases java is more than fine for that as well.
> reliance on traditional OO means that only a small subset of business domains naturally map to the language's constructsYou don't have to stick to OO constructs. Java has functional programming support and pattern matching.> best represented as thousands of threads going off to do independent work and then unifying resultsJava has had executor support for a long time now. And if you're talking about IO bound tasks, Java has virtual threads now.> parse a raw binary stream that had a lot of unsigned intsJava has `Integer.parseUnsignedInt()` and other similar operations.
I'm sure you have done great work in Java, as have many of us, and for many of those years, Java really was the best tool for many jobs. But that was then, now is now.I'm not saying Java doesn't work, even for greenfield projects today. It works fine. But me and many others also think it's not enough for something to merely work, especially not when there are other much better and more modern tools. (which Java is demonstrably playing catch-up with)You and every other C or higher level exec need to get a grip, get with the times and realize that continuing to insist on Java is only going to make (or, by now, keep, more like) your organization stale and attract more and more mediocre engineers for every year that passes. I know because I've worked with the kind of engineers who are still doing Java + Spring like it's still the 90s, and they're not the ones you want on your projects. The best talent don't even want to consider working with Java if they can help it.
> especially not when there are other much better and more modern tools. (which Java is demonstrably playing catch-up with)Which modern tools do you have in mind here?Java does indeed playing catch up with new features. That's inevitable for a language came out 30 years ago. OTOTH many other languages are still behind Java in terms of the runtime environment and the ecosystem. You should pick what works for you, not to go with the trend.> The best talent don't even want to consider working with Java if they can help it.I think you seriously overestimate how talent those devs are if language is the deciding factor of what they choose to work on.
> Which modern tools do you have in mind here?We're talking about Kotlin here (there are many contexts where neither Kotlin nor Java is the correct tool, but for pretty much any use case where Java is an option, Kotlin is going to be a better one)> not to go with the trendI'm so sick of this argument, it presupposes that Java is the default and anything else by definition is just a trend. Kotlin is not a trend, Kotlin is not a fad. Stop begging the question.> I think you seriously overestimate how talent those devs are if language is the deciding factor of what they choose to work on.Ok, and I think you seriously overestimate the willingness of people who have given Kotlin a serious try and seen first hand how much it offers over Java to go back to working for a Java-heavy shop if they can help it.
> OTOTH many other languages are still behind Java in terms of the runtime environment and the ecosystem.Ecosystem doesn't matter except at the long tail. I've never needed a library that didn't exist for NodeJS, until I started doing LLM work.Now 80% of LLM libraries exist for NodeJS, 100% of LLM stuff has a Python library, and Java libraries are incredibly rare.Want an ORM solution? Java has you covered.
To build a good product you don’t need a kid with Hollywood star complex, for whom the choice of programming language or tools matters that much.If Java repels such self-proclaimed “best talent”, good, because the team will be healthier without them. There’s enough engineers willing to learn and write a good code on Java to solve a business or an user problem, and they are absolutely not mediocre. There’s even no such thing as a scale on which you could put an engineer to measure some “greatness”. Every person is unique and has talents that may be useful in different types of projects.
> To build a good product you don’t need a kid with Hollywood star complexAgree 100%.> for whom the choice of programming language or tools matters that muchProgramming languages do matter. Serious, mature professionals critically evaluate and compare tools and pick the best one for the job. Kotlin is a) not some fad b) objectively better than Java for pretty much every imaginable use case. Kotlin avoids entire categories of Java defectshttps://proandroiddev.com/kotlin-avoids-entire-categories-of...Me and others who advocate for more modern tools are not self proclaimed wannabe rockstar devs who are only interested in the latest fad. Ultraconservative diehards who refuse to learn anything new since the 90s are the ones who need a reality check, not us.
As a mature professional who stopped counting learned programming languages and frameworks long ago (I’m familiar with Kotlin too), I can tell you that Java is a modern tool by all measures. It may lack some features of other languages and platforms, but it is not features what defines relevance for modern applications. Your advocacy is important, we of course need progress and testing new concepts. Yet what ultimately matters is business value and user experience. Java is pretty good in delivering it and many professionals choose it for that reason, leaving new stuff to pet projects at home. It is not diehard conservatism that lets us make this choice, but a mere pragmatism. For me it is not obvious that Kotlin is better. There are risks associated with less mature platform that already costed one of my teams  a couple of wasted sprints. Productivity and quality impact isn’t really noticeable (the biggest factor in those two measures is always communication, not tools).
> it is not features what defines relevance for modern applicationswhat? zero-effort null safety out of the box alone is immeasurably valuable> leaving new stuff to pet projects at home... risks associated with less mature platformI'm so sick of this argument, it presupposes that Java is the default and anything else by definition is just new, a trend, a fad. Kotlin is none of those things and you know it. Stop begging the question.> For me it is not obvious that Kotlin is better.I mean, if you can familiarize yourself with things likehttps://proandroiddev.com/kotlin-avoids-entire-categories-of...and still conclude there are no obvious benefits then I don't know what to tell you, it's clear nothing is going to convince you
That feeling is mutual. I very much prefer boring Java or .NET developers who are all supposedly stuck in the 90s to hipsters chasing after the latest JS fad of the week.
Me too! But you're building a strawman. Kotlin isn't a JS fad. It's been around for many years, is the default language for Android platform and the de facto standard IDE for Java, backed and used by Google, JetBrains and many many others. But sure, everything that isn't what you've been doing since the 90s is a fad.
>  I've worked with the kind of engineers who are still doing Java + Spring like it's still the 90s, and they're not the ones you want on your projectsAnd I've worked with programmers who use the latest fad of the day (golang, etc) and they're not the ones you want to have on your projects.>  The best talent don't even want to consider working with Java if they can help it.Not in my experience.
Every single person who's arguing against Kotlin in this thread is resorting to the argument that it's the latest fad of the day. It's not.
I was mainly arguing against golang. As for Kotlin, given the incredible work that has been done in Java recently, the argument is that there isn't much reason to switch over anymore, due the introduction of more moving parts into the project (another dependency, compiler, room for issues, etc.) and the fact that Java ended up with the superior approach (better/fully fledged pattern matching, virtual threads, programmable string templates, etc.).
If I look at the job market in my area it’s dominated by Java. There are a lot of .Net jobs as well but they are typically at companies you really don’t want to work for, so it’s basically so much easier for you to find a nice job if you’re into Java.I’m not, mind you, but maybe 21 will actually change that. I guess it’ll depend more on the tooling than anything else. Because the things I dislike the most about current world Java is that it’s very dependent on 3rd party “addons” to become a nice working experience. Like, you’ll probably want to use Quarkus if you’re doing anything enterprise related, but then you’re putting yourself at the mercy of Big Blue. I’m not sure that Java21 will change that, if it will then it’ll probably be a world where Java dominates even harder than it already does.
> the sane members of the Java community have long since moved on from Java, and they're not coming backWe wish!  We're stuck in the Java job market, reading Java praise pieces like this... Oh boy!  Java's getting structs?
How long until we get continuations in Java? Maybe another 10y? How long until we get TCO? Lets say 20y?And in the end it will still not feel clean or as neat as other languages, that had this stuff for multiple decades.
Hopefully never. There's a reason no primarily functional language ever became mainstream. The "elegant code" they allow is never as lovely as the zealots imagine
None of those are a necessity, and they can be easily implemented in an additional layer (e.g. annotation processor if you really wanted to).
No language features above machine code are a "necessity". Java is not a "necessity". "OOP" is not a "necessity" either. Why don't we all work in C? Or maybe all in assembly language? Yet most of us are glad we can work at a higher level. Probably no single language feature is a "necessity", yet when they come together they make for higher level languages and elegant expression.
Let's not forget that the JVM still does not have reasonable generics & value types.  The .NET CLR introduced this in 2005, bettering the JVM.  Java was in a sleepy slow release mode back then.   We've been waiting 18 years for value types and proper generics - Valhalla has been just about ready for a very long time.  Some of us moved on a long time ago.Agree that Kotlin is a bright spot in terms JVM languages.  For my taste has adopted some of the best concept of Scala, but without the burgeoning complexity.
C# def brought a lot to the table vs Java but I feel like it has also kind of stagnated and not realized the potential of F#. Scala likewise is very powerful but def overly complicated and difficult. Kotlin + Arrow hits the sweet spot, at least for me.
As a Kotlin dev you should still be excited by virtual threads in Java 21. You'll never have to use coroutines again.
I'm very curious to see how this works out in the Kotlin ecosystem, given the amount of async code out there (and the associated function coloring issues).
You can easily combine the two, just use a virtual thread and when you hit a `suspend` function use `runBlocking` to get rid of the suspension.
> Also the null thing hasn’t been an issue for over 10 years.I don't think I've ever seen a Java codebase that doesn't experience NPEs in prod, and that includes modern greenfield ones that make use of all the tools to combat it.> Just use null annotations and both your static checker and your IDE will catch every NPE.Yeah, or just catch it in code review, or just xyz...Or, just switch to a compiler that doesn't allow it in the first place, out of the box?
> I don't think I've ever seen a Java codebase that doesn't experience NPEs in prodFrankly, the last NPE I saw in production was many many years ago.
same, Kotlin doesn't compile if you try to deference null pointers
Having worked extensively in Java, Node, and Python, I’ll take the JVM ecosystem absolutely any day of the week.Me and my catheter will be over here delivering actual software while you figure out how React 32 broke your transcompiler.
No idea why you are comparing Java, which is BE, to React, which is FE.I think I will check Java once they finally make coroutines… I mean “virtual threads” a stable feature. That actually looks exciting… being able to parallelize almost like in Go 5 years ago.
>finally make coroutines… I mean “virtual threads” a stable featureDon't you mean fibers? Anyway, I'm pretty sure it's targeted to JDK21.
Fibers are now called virtual threads
Except I’m over here serving 10x the traffic with 10x less cloud spend on CPU and Memory for hosts.
In what language would that marvel be? I give you the less memory....
Go has goroutines which have better cpu and memory than threads which are commonly used in java.Java is now catching up with go and adding virtual threads which in september 2023 will have the same ease of use as go had in … 2007?But as I wrote above, it migh really get me to check java again.
Well is it correct that until 1.14 (so 2020) Go used cooperative scheduling? Because 
Java Threads, (before the new virtual threads) are preempted by the OS...Go was launched in 2009? Who is doing the catching up?
Maybe you should upgrade from Java 1.4...
It’s almost like there is even a CS law for this exact scenario.. but Java 8willbe around and will still work 10 years from now, plus it is not an insurmountable task to bump it up to the latest version at all. Tell me literally any platform that has a better backwards compatibility story, because honest to God there is simply absolutely none.
Java 8 will be out of support in 7 years. It might seem like a lot but for enterprise systems it's nothing.
Which gives you a lifetime support of 16 years for a single version, with an absolutely sane and doable upgrade path.
C++. And it’s hated for the same reasons.
Do you feel good about yourself, talking down on people that made a perfectly valid choice by developing software in Java?Let's look at the alternatives you mentioned: Rust and Golang. Java compared to Golang is a much more expressive language. Java compared to Rust is a much easier language because you have a garbage collector for the majority of the cases you don't need the manual memory controls that Rust offers you.
In other words, Java is a perfectly valid alternative to both Golang and Rust with its own tradeoffs.You try to paint a picture of Java not being cool but at the same time I see "modern" companies that are held in high esteem for their engineering prowess using Java to do incredible thing (e.g. Netflix and Google)
Google invented Go.Netflix uses Java and Rust and Go.Twitter used to use Scala.GitHub uses Ruby on Rails.EpicGames uses C++.Instagram uses Python.Everybody uses something.Now, if you have building on top of your organizations previous 10 years of engineering, you’re probably going to be writing Java and it’s probably going to be complicated. I’ve been there. I wrote Java for 15 years. I won’t anymore. I’m in love with the simplicity and speed of Golang. I’m in love with the robustness and correctness of Rust. I’m in love withdocker pull scratch:latestand putting your binary inside to run on an empty metal container. No need to waste 250MB of ram on a JVM. Use nano size instances and it’s just as fast as c5’s (async based workloads).
> Google invented Go.A handful of people at google invented golang is the more correct thing to say.Yet, google continues to use Java at a much much bigger scale than golang.golang is simplistic, not simple. Once you work on large golang code bases you'll see the challenges and messes it causes.
I work on really large go codebases
You're trying to make the point that the only companies using Java are doing so because of legacy. That is demonstrably untrue. Netflix and Google have had ample time and capacity to replace Java, yet they didn't.As any good engineer, people working at those companies recognize that Java, Golang, Rust etc. are all tools and these tools have their place in different scenarios.I used to be like you, but my personal "anti-language" was PHP. I would talk down on organizations using PHP and I would take them less seriously as engineers. But I have come to see that they too are using a language (PHP in this case) as a tool to build a business. And it serves those orgs well apparently.Don't get me wrong, Java would not be my first choice in many cases. At the company I'm working for, we only use Golang and Python in the backend and Typescript in the frontend. That doesn't mean that I cannot recognize the value the Java can bring and the niche it occupies.I'm actually pretty amazed by how far Java has come as a language. 10 years ago, I thought Java was going to be replaced by the likes of Kotlin or even Scala. But Java has pretty much caught up in terms of features and ergonomics compared to the Kotlin and occupies a comfortable spot now as being an expressive and productive language without bringing the learning curve and footguns of Scala.
Manual memory controls?  What are those?  Rust does not have "manual memory controls".  You write the code so that the borrow checker does not complain.  End of story.
Those are pedantic semantics. I assume you know what I mean. But I'll explain it to you: with Rust you are in control of how memory is managed. Indeed through the borrow checker.
So which is the real programming language one should use in the God's year, 2023? (Will it change in 4 months also?)> virtual threads but you still have threadpools and os threadsAs opposed to what, quantum entanglement threads?> No one really enjoys debugging your call stacksFrankly, debugging has probably the very best tooling around the JVM -- so, what exactly is your chosen favorite that would be supposedly better? Or is objective reality not hyped anymore?
Yeah, I dislike Java more than most but picking on its debugging story is laughable: it’s tooling around that is excellent
I just picked up Java (via Kotlin) for the first time in four years, during which I've been doing Rails dev. I needed an AWS Lambda for zipping files into and out of S3. I banged my head against broken/unsuitable Node packages for doing so before finally giving up, since it is the lingua franca of Lambda.I was able to rewrite and deploy the function in Kotlin in two days' time. It was easy to set up and run, and worked literally first compile and run - a benefit of static types.Now, would I recommend it to anyone who is unfamiliar with the JVM ecosystem? That's a harder sell. But the stability of the ecosystem and a modern set of saner tools and libraries have made it much better to work in; I'd even call it pleasant.
AWS Lambda is the once place where you should never use Java. You have specific thresholds for how fast your function responds, jvm prevents that and requires more memory.AWS Lambda’s documentation shows how to accept a Request and send a response. You don’t need a package for that. For making zips from s3, again, AWS’s sdk. It’s one of the most commonly asked questions on SO. Here’s one implementation for you that could have saved you days:https://stackoverflow.com/questions/38633577/create-a-zip-fi...
Trust me, I looked up dozens of references. All would mysteriously halt after several files - known issues with how the Archiver library works, and none with any kind of fix, basically a data race within the library itself. Node's streams and promises are far too complex for far too little added benefit, and leads to broken concurrency in a multitude of libraries, and I'd had enough.As for startup time - the latency isn't that important and would be an order of magnitude less than the ZIP construction, so the JVM warmup delay is actually just fine. The cost will be slightly higher, but it's not an operation I expect to run with high regularity - it's only on-demand for a reasonably small userbase.As for complexity - which I am able to weigh due to the above constraints - Java's streams are not only simpler in design, but vastly more stable, and far more straightforward to glue together, and with highly stable implementations of ZIP stream wrappers and output-input pipes. A couple of additional stream wrappers for chunking into multipart upload segments and forwarding streams (introduced in JVM 9 when I'm on 8), and I was ready to go.All that to say: don't create universal rules, though I agree that all of what you mention are good rules of thumb for certain. My given constraints work just fine with Java, here.
A minimal Java app can easily start up in 0.1 seconds, which might just as well be good enough, but if not, there is also GraalVM that can output a native binary.
Wouldn't you have a lot of warm starts with that many invocations?
At that point, why lambda?
Exactly what is enterprise? I think Java has a role to play in most professional settings, even if the company is quite small. It is not a sports car but I see it more as a truck or a cargo ship. Vehicles that underpin the world economy, but that only few think of as fun or exciting. Not pretty or nice to look at, but reliable work horses.
Yeah, sure the thing that runs the whole of Apple, Alibaba infrastructure, many part of Google, most of that "cloud" infra is a wagoneer..
Such as...?
> No one really enjoys debugging your call stacksOf all the things to criticize about Java, this IMO is not one! A Java call stack is a joy compared to just about anything but Python.
It's not so bad. I might be an old masochist with Stockholm syndrome, but every language has its own special flavor of barely tolerable bullshit.
There is some truth to this.  Every language I used had severe drawbacks.  At this point, it's choosing the lesser of the evils.
so, which lang would you use personally?> you still have threadpools and os threads.why this is a bad thing exactly?
Golang or Rust. If it’s a web service or microservice: Golang hands down. If it’s a desktop software or game engine, rust. If you just want to typescript your way to success, deno and vite.
If you’re too introverted for Rust, Zig.Java, whether it be spring, micronauts, jee, whatever, is wasting CPU and Memory in the cloud costing you and/or your enterprise money.
> Golanggolang is probably a good contender for business logic code where Java is widely used, but I feel ecosystem (libs, integrations) is not comparable to Java, so you take some risks while choosing golang.
And it is much more verbose, it is not even comparable in observability and on real world big applications (especially enterprise) you can't get away with value types and slowing down the threads to let the GC keep up with them -- Java definitely shines in these kind of conditions (GC-wise the only competition Java has is different Java GCs, really).
> you can't get away with value types and slowing down the threads to let the GC keep up with themI am not Go expert, but to me this is Go's big advantage: you can chose you want to have object GC controlled or be on stack and copied everywhere. 
GC controlled objects add lots of overhead, because malloc is expensive, and require lots of memory per object to track state and synchronize between thread, and that's why JVM tries to adapt something similar:https://openjdk.org/jeps/8277163
Sure, value types are a good thing, but they are no panacea in and of itself.Also, any non-toy GC won't be using malloc, e.g. in Java's case allocating objects is barely more expensive than allocating them on the stack: they use a so-called thread-local allocation buffer, which can be used to allocate new objects in, without expensive synchronization, and the GC can quickly scan it, moving still alive objects out of it, and clearing the buffer.
>  they use a so-called thread-local allocation buffer, which can be used to allocate new objects in, without expensive synchronization, and the GC can quickly scan it, moving still alive objects out of ityeah, all these logics still have significant overhead, especially memory wise, it is hard to reason when JVM decides to kick that or another optimization or not kick anything at all.With value objects you have full control and bare-metal-native performance without compromises.
> you have full control and bare-metal-native performance without compromises.Not even you believe that, right? Especially with regards to Go.. Go is closer to JS than to Rust/C++.
as soon as you copy your struct by value around, it is easy task for escape analysis to decide to put struct on stack.also, golang has arena API now, and it also makes heap allocations super cheap if you manage to integrate it into app life cycle.
Golang doesn't have copy elison unlike C++ so in principle you need to leverage the heap escape anyways.Golang's arenas were an experiment that hasalreadybeen ditched by the maintainer as un-feasible.
> Golang doesn't have copy elison unlike C++ so in principle you need to leverage the heap escape anyways.I mean you can pass structs by ref or value around, which makes direct impact will they be on stack or heap.> Golang's arenas were an experiment that has already been ditched by the maintainer as un-feasible.Thank you, good to know, looks like big pros in favor of rust as lang for my next project.
I have not used Go generics, but it's viability as a business logic language would  depend on that.
Wait, what?Generic programming is a perfectly valid style, but are you saying it's essential to implement business logic?Because, like, the last 3 languages that got adopted as the default business logic language didn't have them (Java pre 1.5, C, and Cobol).
It is not essential, but without it, it is much more cumbersome. I programmed it with Java so I know it can be done but I would not choose a language without it if I could.
It is absolutely necessary nowadays, yes. Our applications are often more complex than what people did in Java 1.5, Cobol, or C, and definitely need to be developed at a faster pace.
and during last 20 years consensus has converged to the view point that generics are essential.
Huh. Guess I'm heterodox, then.I mean, don't get me wrong. It's quite useful once in a while, especially when working with containers, but I don't think of it as essential.But I'm fine with it as long as people don't overdo it.
Rolling your own containers really really sucks. Sucks enough to the point that it is essential, in my books.
Maybe I should be more clear.This thread was in the context of go generics, which generally means go 1.18, when user defined generics were added to the language. Go always had support for a minimal number of containers, I've never rolled my own when working in the language.Go had special compiler support for slices, maps, and channels before then, and they got used as the default containers for everything.Using those was annoying when you needed to do the same thing to, say, a slice of strings and a slice of ints, but if you aren't using a generic heavy style, it actually comes up surprisingly rarely. And, if I'm being honest, I'd consider most of the uses of generics I've seen the average enterprise dev use to be mistakes.
they have generics now, but there are other conceptual shifts:- no inheritance- error codes with explicit handling everywhere
no inheritance but thereareinterfaces to be able to provide alternate implementations. Similar to traits in Rust. If it quacks like a duck, has feathers like a duck, swims like a duck…Go just assumes if you satisfy the interface, you’re good.
maybe, it is just some effort for someone who coded in classic OO for last 20 years to wrap head around this new concept fast and judge if it will satisfy all/most use cases.
Yes those are also drawbacks
golang is a simplistic language which lacks the modeling capability of Java, so it won't do well in large business code.
TIL that projects like terraform are - apparently - not "large business code".
You can write basically anything in any Turing complete language, doesn't mean it's a good idea.
This ... is how you make engineering choices?
At work, I have a different context. What is the common denominator of what people know. Personally, the “write once, run everywhere” notion of Java has been replicated with much more productive languages.
Sounds like you're talking about a pop band, not a tool.
Call me back once golang is going to have anything close to visualvm and remote profiling capabilities.Is golang still using mark and sweep gc?
I agree, Java is wordy, ritualistic, and prone to overcomplication. Build/run/write loops are slow and painful, and frameworks and toolkits try to do so much that they inevitably get in the way.
Not by that much... the problem is Java's build systems. Theyre what complicate and slow down java development 90% of the time.
Can this fkin FUD finally die? Java is pretty much the safest bet on a longevity, stability, risk aversion spectrum. Also, Oracle just has a particularly bad PR, but it is not at all worse than any other similarly sized company.
Oracle has definjtely done bad things; mismanagement of java is not one of them. They got a pile of crap and turned it into something competent.
I am wondering if Oracle is really playing significant role in Java evolution, they have some open process with many other companies contributing.
They are responsible for like 95+% of all OpenJDK commits.
> The biggest problem with Java is... the walled garden, the snob society, the elitist, exclusive culture.No idea how you have managed to come to such a conclusion, or what kind of experienced you might have had.  I have been part of some of the core JSR/groups, as rather independent/unaffiliated (not oracle/google/hp/ibm/twitter) - there was no gate keeping, elitism or anything alike.I'd consider mailing lists extremely professional, respectful, even nice.
Agreed, I have never seen a pattern of elitist behavior unique to the Java ecosystem.There are always people like that when groups get big enough.The thing I love about the JVM ecosystem is the engineering culture. The quality of the platform and most libraries is very high, and well designed.I don't love the Java language, but it can get the job done.
Rudeness scales mostly with the size of the community. If you go to something like Nim you will immediately find them way more nice than Go, just from this.
Java? Elitist...?Maybeit's true for Haskell or Rust. But Java?
Imo problem with Java is... JVM because it's quite a resource intensive application itself, memory usage is orders of time magnitude worse than most of the language I've used.
Interesting. A Spring Boot webapp (with the runtime dependency injection framework, etc. etc.) serving some static content and exposing some REST endpoints works fine with 32 MB RAM. Is it really orders of magnitude more than other languages, e.g. will a Go-based webapp consume less than 300 kBytes of RAM?
I do believe that number will go down in the coming releases; things like valhalla will allow us to pack data representations much more efficiently after all. the only things that really benefit from object identity are behaviors, not data.
That's almost always a consequence of poor engineering. You need to consider the runtime when developing any program. With Java, that runtime is more than just your CPU and OS, it's the JVM too.
Forgot that our computers were so resource constrained these days...
